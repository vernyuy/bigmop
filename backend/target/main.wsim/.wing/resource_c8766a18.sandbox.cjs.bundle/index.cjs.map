{"version":3,"sources":["../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/tokens.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/target-sim/tokens.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/dependency.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/private/stack-trace.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/private/uniqueid.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/construct.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/lib/metadata.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/errors.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/package.json","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/constants.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/codegen/code.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/codegen/scope.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/codegen/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/util.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/names.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/errors.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/validate/boolSchema.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/rules.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/validate/applicability.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/validate/dataType.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/validate/defaults.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/code.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/validate/keyword.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/validate/subschema.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/fast-deep-equal/index.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/json-schema-traverse/index.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/resolve.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/validate/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/runtime/validation_error.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/ref_error.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/compile/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/dist/refs/data.json","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/schemes/urn-uuid.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/schemes/urn.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/schemes/mailto.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/schemes/wss.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/schemes/ws.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/schemes/https.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/schemes/http.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/uri.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/node_modules/punycode/punycode.es6.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/regexps-iri.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/regexps-uri.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/uri-js/src/util.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/runtime/uri.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/core.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/core/id.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/core/ref.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/core/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/runtime/ucs2length.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/limitLength.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/pattern.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/required.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/limitItems.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/runtime/equal.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/const.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/enum.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/validation/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/items.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/items2020.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/contains.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/properties.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/not.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/allOf.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/if.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/applicator/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/format/format.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/format/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/metadata.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/draft7.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/discriminator/types.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/vocabularies/discriminator/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/dist/refs/json-schema-draft-07.json","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/ajv/lib/ajv.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/toml/lib/parser.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/toml/lib/compiler.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/toml/index.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/identity.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/visit.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/doc/directives.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/doc/anchors.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/doc/applyReviver.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/toJS.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/Node.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/Alias.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/Scalar.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/doc/createNode.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/Collection.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/stringify/stringifyComment.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/stringify/foldFlowLines.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/stringify/stringifyString.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/stringify/stringify.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/stringify/stringifyPair.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/log.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/addPairToJSMap.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/Pair.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/stringify/stringifyCollection.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/YAMLMap.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/common/map.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/nodes/YAMLSeq.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/common/seq.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/common/string.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/common/null.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/core/bool.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/stringify/stringifyNumber.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/core/float.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/core/int.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/core/schema.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/json/schema.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/yaml-1.1/binary.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/yaml-1.1/pairs.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/yaml-1.1/omap.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/yaml-1.1/bool.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/yaml-1.1/float.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/yaml-1.1/int.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/yaml-1.1/set.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/yaml-1.1/schema.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/tags.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/schema/Schema.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/stringify/stringifyDocument.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/doc/Document.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/errors.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/resolve-props.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/util-contains-newline.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/util-flow-indent-check.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/util-map-includes.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/resolve-block-map.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/resolve-block-seq.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/resolve-end.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/resolve-flow-collection.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/compose-collection.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/resolve-block-scalar.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/resolve-flow-scalar.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/compose-scalar.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/util-empty-scalar-position.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/compose-node.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/compose-doc.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/compose/composer.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/parse/cst-scalar.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/parse/cst-stringify.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/parse/cst-visit.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/parse/cst.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/parse/lexer.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/parse/line-counter.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/parse/parser.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/public-api.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/yaml/dist/index.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/platform/util.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/array.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/json_schema.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/bool.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/lifting.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/types.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/shared/misc.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/inflight.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/datetime.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/duration.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/generics.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/json.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/map.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/connections.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/node.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/number.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/regex.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/resource.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/set.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/string.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/struct.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/test.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/api.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/topic.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/bucket.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/counter.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/domain.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/endpoint.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/shared/resource-names.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/function.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/on-deploy.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/queue.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/node_modules/cron-validator/src/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/schedule.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/secret.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/service.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/website.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/cloud/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/test-runner.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/platform/parameter-registrar.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/lib/platform/platform.js","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/platform/platform-manager.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/platform/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/app.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/attributes.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/dependency.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/ui/base.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/ui/colors.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/tree.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/index.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/target-sim/resource.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/target-sim/util.ts","../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/target-sim/counter.inflight.ts","../resource_c8766a18.sandbox.cjs"],"sourcesContent":["import { IInflightHost } from \"../std\";\n/**\n * Represents values that can only be resolved after the app is synthesized.\n * Tokens values are captured as environment variable, and resolved through the compilation target token mechanism.\n */\nexport interface ITokenResolver {\n  /**\n   * Returns true is the given value is a token.\n   */\n  isToken(value: any): boolean;\n\n  /**\n   * \"Lifts\" a value into an inflight context.\n   */\n  lift(value: any): string;\n\n  /**\n   * Lifts the given token to the host.\n   */\n  onLiftValue(host: IInflightHost, value: any): void;\n}\n\n/**\n * Global registry of available token resolvers.\n */\nconst _resolvers: ITokenResolver[] = [];\n\n/**\n * Creates a valid environment variable name from the given token.\n */\nexport function tokenEnvName(value: string): string {\n  return `WING_TOKEN_${value\n    .replace(/([^a-zA-Z0-9]+)/g, \"_\")\n    .replace(/_+$/, \"\")\n    .replace(/^_+/, \"\")\n    .toUpperCase()}`;\n}\n\n/**\n * Globally registers a new token resolver\n */\nexport function registerTokenResolver(resolver: ITokenResolver) {\n  _resolvers.push(resolver);\n}\n\n/**\n * Find the first token resolver that considers the given value a token (or containing token(s)).\n */\nexport function getTokenResolver(value: any): ITokenResolver | undefined {\n  return _resolvers.find((r) => r.isToken(value));\n}\n","import { ITokenResolver, tokenEnvName } from \"../core/tokens\";\nimport { IInflightHost, IResource } from \"../std\";\n\n/**\n * Produce a token that will be replaced with the handle of a resource\n * when the simulator is started. This can be inserted to an environment variable\n * so that the real value can be used by an inflight function.\n */\nexport function simulatorHandleToken(resource: IResource): string {\n  return simulatorAttrToken(resource, \"handle\");\n}\n\n/**\n * Produce a token that will be replaced with a deploy-time resource attribute\n * when the simulator is started.\n */\nexport function simulatorAttrToken(\n  resource: IResource,\n  attrName: string\n): string {\n  return `\\${wsim#${resource.node.path}#attrs.${attrName}}`;\n}\n\n/**\n * Regular expression that matches a simulator token. This is a sequence of\n * characters that can appear in the middle of any string in the following format:\n *\n * ${wsim#path/to/resource#property.path}\n */\nexport const SIMULATOR_TOKEN_REGEX = /\\$\\{wsim#[^#\\{\\}]+#[a-zA-Z0-9_\\-\\/\\.]+\\}/;\n\n/**\n * The same as SIMULATOR_TOKEN_REGEX, but it must match the entire string.\n */\nexport const SIMULATOR_TOKEN_REGEX_FULL = new RegExp(\n  `^${SIMULATOR_TOKEN_REGEX.source}$`\n);\n\n/**\n * Returns true is the given value is a Simulator token.\n */\nexport function isSimulatorToken(value: string) {\n  return SIMULATOR_TOKEN_REGEX.test(value);\n}\n\n/**\n * Represents values that can only be resolved after the app is synthesized.\n * Tokens values are captured as environment variable, and resolved through the compilation target token mechanism.\n */\nexport class SimTokens implements ITokenResolver {\n  /**\n   * Returns true is the given value is a Simulator token.\n   */\n  public isToken(value: any): boolean {\n    if (typeof value === \"string\") {\n      return isSimulatorToken(value);\n    }\n\n    return false;\n  }\n\n  /**\n   * Lifts a value into an inflight context.\n   */\n  public lift(value: any): string {\n    switch (typeof value) {\n      case \"string\":\n        return `process.env[${JSON.stringify(tokenEnvName(value))}]`;\n      default:\n        throw new Error(`Unsupported token type`);\n    }\n  }\n\n  /**\n   * Lifts the given token to the host.\n   */\n  public onLiftValue(host: IInflightHost, value: any) {\n    switch (typeof value) {\n      case \"string\":\n        const envName = tokenEnvName(value);\n        host.addEnvironment(envName, value);\n        break;\n      default:\n        throw new Error(`Unable to lift token ${value}`);\n    }\n  }\n}\n","import { IConstruct } from './construct';\n\n/**\n * Trait marker for classes that can be depended upon\n *\n * The presence of this interface indicates that an object has\n * an `IDependable` implementation.\n *\n * This interface can be used to take an (ordering) dependency on a set of\n * constructs. An ordering dependency implies that the resources represented by\n * those constructs are deployed before the resources depending ON them are\n * deployed.\n */\nexport interface IDependable {\n  // Empty, this interface is a trait marker\n}\n\n/**\n * A set of constructs to be used as a dependable\n *\n * This class can be used when a set of constructs which are disjoint in the\n * construct tree needs to be combined to be used as a single dependable.\n *\n * @experimental\n */\nexport class DependencyGroup implements IDependable {\n  private readonly _deps = new Array<IDependable>();\n\n  constructor(...deps: IDependable[]) {\n    const self = this;\n\n    Dependable.implement(this, {\n      get dependencyRoots() {\n        const result = new Array<IConstruct>();\n        for (const d of self._deps) {\n          result.push(...Dependable.of(d).dependencyRoots);\n        }\n        return result;\n      },\n    });\n\n    this.add(...deps);\n  }\n\n  /**\n   * Add a construct to the dependency roots\n   */\n  public add(...scopes: IDependable[]) {\n    this._deps.push(...scopes);\n  }\n}\n\nconst DEPENDABLE_SYMBOL = Symbol.for('@aws-cdk/core.DependableTrait');\n\n/**\n * Trait for IDependable\n *\n * Traits are interfaces that are privately implemented by objects. Instead of\n * showing up in the public interface of a class, they need to be queried\n * explicitly. This is used to implement certain framework features that are\n * not intended to be used by Construct consumers, and so should be hidden\n * from accidental use.\n *\n * @example\n *\n * // Usage\n * const roots = Dependable.of(construct).dependencyRoots;\n *\n * // Definition\n * Dependable.implement(construct, {\n *       dependencyRoots: [construct],\n * });\n *\n * @experimental\n */\nexport abstract class Dependable {\n  /**\n   * Turn any object into an IDependable.\n   */\n  public static implement(instance: IDependable, trait: Dependable) {\n    // I would also like to reference classes (to cut down on the list of objects\n    // we need to manage), but we can't do that either since jsii doesn't have the\n    // concept of a class reference.\n    (instance as any)[DEPENDABLE_SYMBOL] = trait;\n  }\n\n  /**\n   * Return the matching Dependable for the given class instance.\n   */\n  public static of(instance: IDependable): Dependable {\n    const ret = (instance as any)[DEPENDABLE_SYMBOL];\n    if (!ret) {\n      throw new Error(`${instance} does not implement IDependable. Use \"Dependable.implement()\" to implement`);\n    }\n    return ret;\n  }\n\n  /**\n   * Return the matching Dependable for the given class instance.\n   * @deprecated use `of`\n   */\n  public static get(instance: IDependable): Dependable {\n    return this.of(instance);\n  }\n\n  /**\n   * The set of constructs that form the root of this dependable\n   *\n   * All resources under all returned constructs are included in the ordering\n   * dependency.\n   */\n  public abstract readonly dependencyRoots: IConstruct[];\n}\n","// tslint:disable-next-line:ban-types\nexport function captureStackTrace(below?: Function): string[] {\n  below = below || captureStackTrace; // hide myself if nothing else\n  const object = { stack: '' };\n  const previousLimit = Error.stackTraceLimit;\n  try {\n    Error.stackTraceLimit = Number.MAX_SAFE_INTEGER;\n    Error.captureStackTrace(object, below);\n  } finally {\n    Error.stackTraceLimit = previousLimit;\n  }\n  if (!object.stack) {\n    return [];\n  }\n  return object.stack.split('\\n').slice(1).map(s => s.replace(/^\\s*at\\s+/, ''));\n}\n","import * as crypto from 'crypto';\n\n/**\n * Resources with this ID are complete hidden from the logical ID calculation.\n */\nconst HIDDEN_ID = 'Default';\n\n/**\n * Calculates the construct uid based on path components.\n *\n * Components named `Default` (case sensitive) are excluded from uid calculation\n * to allow tree refactorings.\n *\n * @param components path components\n */\nexport function addressOf(components: string[]) {\n  const hash = crypto.createHash('sha1');\n  for (const c of components) {\n    // skip components called \"Default\" to enable refactorings\n    if (c === HIDDEN_ID) { continue; }\n\n    hash.update(c);\n    hash.update('\\n');\n  }\n\n  // prefix with \"c8\" so to ensure it starts with non-digit.\n  return 'c8' + hash.digest('hex');\n}\n","import { Dependable, IDependable } from './dependency';\nimport { MetadataEntry } from './metadata';\nimport { captureStackTrace } from './private/stack-trace';\nimport { addressOf } from './private/uniqueid';\n\nconst CONSTRUCT_SYM = Symbol.for('constructs.Construct');\n\n/**\n * Represents a construct.\n */\nexport interface IConstruct extends IDependable {\n  /**\n   * The tree node.\n   */\n  readonly node: Node;\n}\n\n/**\n * Represents the construct node in the scope tree.\n */\nexport class Node {\n  /**\n   * Separator used to delimit construct path components.\n   */\n  public static readonly PATH_SEP = '/';\n\n  /**\n   * Returns the node associated with a construct.\n   * @param construct the construct\n   *\n   * @deprecated use `construct.node` instead\n   */\n  public static of(construct: IConstruct): Node {\n    return construct.node;\n  }\n\n  /**\n   * Returns the scope in which this construct is defined.\n   *\n   * The value is `undefined` at the root of the construct scope tree.\n   */\n  public readonly scope?: IConstruct;\n\n  /**\n   * The id of this construct within the current scope.\n   *\n   * This is a scope-unique id. To obtain an app-unique id for this construct, use `addr`.\n   */\n  public readonly id: string;\n\n  private _locked = false; // if this is \"true\", addChild will fail\n  private readonly _children: { [id: string]: IConstruct } = { };\n  private readonly _context: { [key: string]: any } = { };\n  private readonly _metadata = new Array<MetadataEntry>();\n  private readonly _dependencies = new Set<IDependable>();\n  private _defaultChild: IConstruct | undefined;\n  private readonly _validations = new Array<IValidation>();\n  private _addr?: string; // cache\n\n  public constructor(private readonly host: Construct, scope: IConstruct, id: string) {\n    id = id ?? ''; // if undefined, convert to empty string\n\n    this.id = sanitizeId(id);\n    this.scope = scope;\n\n    if (scope && !this.id) {\n      throw new Error('Only root constructs may have an empty ID');\n    }\n\n    // add to parent scope\n    scope?.node.addChild(host, this.id);\n  }\n\n  /**\n   * The full, absolute path of this construct in the tree.\n   *\n   * Components are separated by '/'.\n   */\n  public get path(): string {\n    const components = [];\n    for (const scope of this.scopes) {\n      if (scope.node.id) {\n        components.push(scope.node.id);\n      }\n    }\n    return components.join(Node.PATH_SEP);\n  }\n\n  /**\n   * Returns an opaque tree-unique address for this construct.\n   *\n   * Addresses are 42 characters hexadecimal strings. They begin with \"c8\"\n   * followed by 40 lowercase hexadecimal characters (0-9a-f).\n   *\n   * Addresses are calculated using a SHA-1 of the components of the construct\n   * path.\n   *\n   * To enable refactorings of construct trees, constructs with the ID `Default`\n   * will be excluded from the calculation. In those cases constructs in the\n   * same tree may have the same addreess.\n   *\n   * @example c83a2846e506bcc5f10682b564084bca2d275709ee\n   */\n  public get addr(): string {\n    if (!this._addr) {\n      this._addr = addressOf(this.scopes.map(c => c.node.id));\n    }\n\n    return this._addr;\n  }\n\n  /**\n   * Return a direct child by id, or undefined\n   *\n   * @param id Identifier of direct child\n   * @returns the child if found, or undefined\n   */\n  public tryFindChild(id: string): IConstruct | undefined {\n    return this._children[sanitizeId(id)];\n  }\n\n  /**\n   * Return a direct child by id\n   *\n   * Throws an error if the child is not found.\n   *\n   * @param id Identifier of direct child\n   * @returns Child with the given id.\n   */\n  public findChild(id: string): IConstruct {\n    const ret = this.tryFindChild(id);\n    if (!ret) {\n      throw new Error(`No child with id: '${id}'`);\n    }\n    return ret;\n  }\n\n  /**\n   * Returns the child construct that has the id `Default` or `Resource\"`.\n   * This is usually the construct that provides the bulk of the underlying functionality.\n   * Useful for modifications of the underlying construct that are not available at the higher levels.\n   *\n   * @throws if there is more than one child\n   * @returns a construct or undefined if there is no default child\n   */\n  public get defaultChild(): IConstruct | undefined {\n    if (this._defaultChild !== undefined) {\n      return this._defaultChild;\n    }\n\n    const resourceChild = this.tryFindChild('Resource');\n    const defaultChild = this.tryFindChild('Default');\n    if (resourceChild && defaultChild) {\n      throw new Error(`Cannot determine default child for ${this.path}. There is both a child with id \"Resource\" and id \"Default\"`);\n    }\n\n    return defaultChild || resourceChild;\n  }\n\n  /**\n   * Override the defaultChild property.\n   *\n   * This should only be used in the cases where the correct\n   * default child is not named 'Resource' or 'Default' as it\n   * should be.\n   *\n   * If you set this to undefined, the default behavior of finding\n   * the child named 'Resource' or 'Default' will be used.\n   */\n  public set defaultChild(value: IConstruct | undefined) {\n    this._defaultChild = value;\n  }\n\n  /**\n   * All direct children of this construct.\n   */\n  public get children() {\n    return Object.values(this._children);\n  }\n\n  /**\n   * Return this construct and all of its children in the given order\n   */\n  public findAll(order: ConstructOrder = ConstructOrder.PREORDER): IConstruct[] {\n    const ret = new Array<IConstruct>();\n    visit(this.host);\n    return ret;\n\n    function visit(c: IConstruct) {\n      if (order === ConstructOrder.PREORDER) {\n        ret.push(c);\n      }\n\n      for (const child of c.node.children) {\n        visit(child);\n      }\n\n      if (order === ConstructOrder.POSTORDER) {\n        ret.push(c);\n      }\n    }\n  }\n\n  /**\n   * This can be used to set contextual values.\n   * Context must be set before any children are added, since children may consult context info during construction.\n   * If the key already exists, it will be overridden.\n   * @param key The context key\n   * @param value The context value\n   */\n  public setContext(key: string, value: any) {\n    if (this.children.length > 0) {\n      const names = this.children.map(c => c.node.id);\n      throw new Error('Cannot set context after children have been added: ' + names.join(','));\n    }\n    this._context[key] = value;\n  }\n\n  /**\n   * Retrieves a value from tree context if present. Otherwise, would throw an error.\n   *\n   * Context is usually initialized at the root, but can be overridden at any point in the tree.\n   *\n   * @param key The context key\n   * @returns The context value or throws error if there is no context value for this key\n   */\n  public getContext(key: string): any {\n    const value = this._context[key];\n\n    if (value !== undefined) { return value; }\n\n    if (value === undefined && !this.scope?.node) {\n      throw new Error(`No context value present for ${key} key`);\n    }\n\n    return this.scope && this.scope.node.getContext(key);\n  }\n\n  /**\n   * Retrieves the all context of a node from tree context.\n   *\n   * Context is usually initialized at the root, but can be overridden at any point in the tree.\n   *\n   * @param defaults Any keys to override the retrieved context\n   * @returns The context object or an empty object if there is discovered context\n   */\n  public getAllContext(defaults?: object): any {\n    if (typeof defaults === 'undefined') {\n      defaults = {};\n    }\n\n    if (this.scope === undefined) { return defaults; }\n\n    const value = { ...this._context, ...defaults };\n    return this.scope && this.scope.node.getAllContext(value);\n  }\n\n  /**\n   * Retrieves a value from tree context.\n   *\n   * Context is usually initialized at the root, but can be overridden at any point in the tree.\n   *\n   * @param key The context key\n   * @returns The context value or `undefined` if there is no context value for this key.\n   */\n  public tryGetContext(key: string): any {\n    const value = this._context[key];\n    if (value !== undefined) { return value; }\n\n    return this.scope && this.scope.node.tryGetContext(key);\n  }\n\n  /**\n   * An immutable array of metadata objects associated with this construct.\n   * This can be used, for example, to implement support for deprecation notices, source mapping, etc.\n   */\n  public get metadata() {\n    return [...this._metadata];\n  }\n\n  /**\n   * Adds a metadata entry to this construct.\n   * Entries are arbitrary values and will also include a stack trace to allow tracing back to\n   * the code location for when the entry was added. It can be used, for example, to include source\n   * mapping in CloudFormation templates to improve diagnostics.\n   *\n   * @param type a string denoting the type of metadata\n   * @param data the value of the metadata (can be a Token). If null/undefined, metadata will not be added.\n   * @param options options\n   */\n  public addMetadata(type: string, data: any, options: MetadataOptions = { }): void {\n    if (data == null) {\n      return;\n    }\n\n    const shouldTrace = options.stackTrace ?? false;\n    const trace = shouldTrace ? captureStackTrace(options.traceFromFunction ?? this.addMetadata) : undefined;\n    this._metadata.push({ type, data, trace });\n  }\n\n  /**\n   * All parent scopes of this construct.\n   *\n   * @returns a list of parent scopes. The last element in the list will always\n   * be the current construct and the first element will be the root of the\n   * tree.\n   */\n  public get scopes(): IConstruct[] {\n    const ret = new Array<IConstruct>();\n\n    let curr: IConstruct | undefined = this.host;\n    while (curr) {\n      ret.unshift(curr);\n      curr = curr.node.scope;\n    }\n\n    return ret;\n  }\n\n  /**\n   * Returns the root of the construct tree.\n   * @returns The root of the construct tree.\n   */\n  public get root() {\n    return this.scopes[0];\n  }\n\n  /**\n   * Returns true if this construct or the scopes in which it is defined are\n   * locked.\n   */\n  public get locked() {\n    if (this._locked) {\n      return true;\n    }\n\n    if (this.scope && this.scope.node.locked) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Add an ordering dependency on another construct.\n   *\n   * An `IDependable`\n   */\n  public addDependency(...deps: IDependable[]) {\n    for (const d of deps) {\n      this._dependencies.add(d);\n    }\n  }\n\n  /**\n   * Return all dependencies registered on this node (non-recursive).\n   */\n  public get dependencies(): IConstruct[] {\n    const result = new Array<IConstruct>();\n    for (const dep of this._dependencies) {\n      for (const root of Dependable.of(dep).dependencyRoots) {\n        result.push(root);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Remove the child with the given name, if present.\n   *\n   * @returns Whether a child with the given name was deleted.\n   * @experimental\n   */\n  public tryRemoveChild(childName: string): boolean {\n    if (!(childName in this._children)) { return false; }\n    delete this._children[childName];\n    return true;\n  }\n\n  /**\n   * Adds a validation to this construct.\n   *\n   * When `node.validate()` is called, the `validate()` method will be called on\n   * all validations and all errors will be returned.\n   *\n   * @param validation The validation object\n   */\n  public addValidation(validation: IValidation) {\n    this._validations.push(validation);\n  }\n\n  /**\n   * Validates this construct.\n   *\n   * Invokes the `validate()` method on all validations added through\n   * `addValidation()`.\n   *\n   * @returns an array of validation error messages associated with this\n   * construct.\n   */\n  public validate(): string[] {\n    const deprecated = ['validate', 'onValidate', 'synthesize', 'onSynthesize', 'prepare', 'onPrepare'];\n    for (const method of deprecated) {\n      if (typeof((this.host as any)[method]) === 'function') {\n        throw new Error(`the construct \"${this.path}\" has a \"${method}()\" method which is no longer supported. Use \"construct.node.addValidation()\" to add validations to a construct`);\n      }\n    }\n\n    const errors = new Array<string>();\n    for (const v of this._validations) {\n      errors.push(...v.validate());\n    }\n\n    return errors;\n  }\n\n  /**\n   * Locks this construct from allowing more children to be added. After this\n   * call, no more children can be added to this construct or to any children.\n   */\n  public lock() {\n    this._locked = true;\n  }\n\n  /**\n   * Adds a child construct to this node.\n   *\n   * @param child The child construct\n   * @param childName The type name of the child construct.\n   * @returns The resolved path part name of the child\n   */\n  private addChild(child: Construct, childName: string) {\n    if (this.locked) {\n\n      // special error if root is locked\n      if (!this.path) {\n        throw new Error('Cannot add children during synthesis');\n      }\n\n      throw new Error(`Cannot add children to \"${this.path}\" during synthesis`);\n    }\n\n    if (this._children[childName]) {\n      const name = this.id ?? '';\n      const typeName = this.host.constructor.name;\n      throw new Error(`There is already a Construct with name '${childName}' in ${typeName}${name.length > 0 ? ' [' + name + ']' : ''}`);\n    }\n\n    this._children[childName] = child;\n  }\n}\n\n/**\n * Represents the building block of the construct graph.\n *\n * All constructs besides the root construct must be created within the scope of\n * another construct.\n */\nexport class Construct implements IConstruct {\n  /**\n   * Checks if `x` is a construct.\n   *\n   * Use this method instead of `instanceof` to properly detect `Construct`\n   * instances, even when the construct library is symlinked.\n   *\n   * Explanation: in JavaScript, multiple copies of the `constructs` library on\n   * disk are seen as independent, completely different libraries. As a\n   * consequence, the class `Construct` in each copy of the `constructs` library\n   * is seen as a different class, and an instance of one class will not test as\n   * `instanceof` the other class. `npm install` will not create installations\n   * like this, but users may manually symlink construct libraries together or\n   * use a monorepo tool: in those cases, multiple copies of the `constructs`\n   * library can be accidentally installed, and `instanceof` will behave\n   * unpredictably. It is safest to avoid using `instanceof`, and using\n   * this type-testing method instead.\n   *\n   * @returns true if `x` is an object created from a class which extends `Construct`.\n   * @param x Any object\n   */\n  public static isConstruct(x: any): x is Construct {\n    return x && typeof x === 'object' && x[CONSTRUCT_SYM];\n  }\n\n  /**\n   * The tree node.\n   */\n  public readonly node: Node;\n\n  /**\n   * Creates a new construct node.\n   *\n   * @param scope The scope in which to define this construct\n   * @param id The scoped construct ID. Must be unique amongst siblings. If\n   * the ID includes a path separator (`/`), then it will be replaced by double\n   * dash `--`.\n   */\n  constructor(scope: Construct, id: string) {\n    this.node = new Node(this, scope, id);\n\n    // implement IDependable privately\n    Dependable.implement(this, {\n      dependencyRoots: [this],\n    });\n  }\n\n  /**\n   * Returns a string representation of this construct.\n   */\n  public toString() {\n    return this.node.path || '<root>';\n  }\n}\n\n/**\n * Implement this interface in order for the construct to be able to validate itself.\n */\nexport interface IValidation {\n  /**\n   * Validate the current construct.\n   *\n   * This method can be implemented by derived constructs in order to perform\n   * validation logic. It is called on all constructs before synthesis.\n   *\n   * @returns An array of validation error messages, or an empty array if there the construct is valid.\n   */\n  validate(): string[];\n}\n\n/**\n * In what order to return constructs\n */\nexport enum ConstructOrder {\n  /**\n   * Depth-first, pre-order\n   */\n  PREORDER,\n\n  /**\n   * Depth-first, post-order (leaf nodes first)\n   */\n  POSTORDER\n}\n\nconst PATH_SEP_REGEX = new RegExp(`${Node.PATH_SEP}`, 'g');\n\n/**\n * Return a sanitized version of an arbitrary string, so it can be used as an ID\n */\nfunction sanitizeId(id: string) {\n  // Escape path seps as double dashes\n  return id.replace(PATH_SEP_REGEX, '--');\n}\n\n/**\n * Options for `construct.addMetadata()`.\n */\nexport interface MetadataOptions {\n  /**\n   * Include stack trace with metadata entry.\n   * @default false\n   */\n  readonly stackTrace?: boolean;\n\n  /**\n   * A JavaScript function to begin tracing from.\n   *\n   * This option is ignored unless `stackTrace` is `true`.\n   *\n   * @default addMetadata()\n   */\n  readonly traceFromFunction?: any;\n}\n\n// Mark all instances of 'Construct'\nObject.defineProperty(Construct.prototype, CONSTRUCT_SYM, {\n  value: true,\n  enumerable: false,\n  writable: false,\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0YWRhdGEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbWV0YWRhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQW4gZW50cnkgaW4gdGhlIGNvbnN0cnVjdCBtZXRhZGF0YSB0YWJsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YUVudHJ5IHtcbiAgLyoqXG4gICAqIFRoZSBtZXRhZGF0YSBlbnRyeSB0eXBlLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IGFueTtcblxuICAvKipcbiAgICogU3RhY2sgdHJhY2UgYXQgdGhlIHBvaW50IG9mIGFkZGluZyB0aGUgbWV0YWRhdGEuXG4gICAqXG4gICAqIE9ubHkgYXZhaWxhYmxlIGlmIGBhZGRNZXRhZGF0YSgpYCBpcyBjYWxsZWQgd2l0aCBgc3RhY2tUcmFjZTogdHJ1ZWAuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm8gdHJhY2UgaW5mb3JtYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHRyYWNlPzogc3RyaW5nW107XG59XG4iXX0=","export * from './construct';\nexport * from './metadata';\nexport * from './dependency';","interface NotImplementedErrorOptions {\n  issue?: string;\n  resource?: string;\n  operation?: string;\n}\n\nexport class NotImplementedError extends Error {\n  public name: string = \"NotImplementedError\";\n  public resource?: string;\n  public operation?: string;\n  constructor(message: string, options?: NotImplementedErrorOptions) {\n    super(\n      `${message}${\n        options?.issue\n          ? `\\nFor more information see: ${options.issue}.\\nContributions welcome ❤️`\n          : \"\"\n      }`\n    );\n    this.resource = options?.resource;\n    this.operation = options?.operation;\n  }\n}\n\nexport class AbstractMemberError extends Error {\n  constructor() {\n    super(\"This member is abstract and must be implemented in a subclass.\");\n  }\n}\n","{\n  \"name\": \"@winglang/sdk\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/winglang/wing.git\",\n    \"directory\": \"libs/wingsdk\"\n  },\n  \"author\": {\n    \"name\": \"Wing Cloud\",\n    \"email\": \"ping@wing.cloud\",\n    \"organization\": true\n  },\n  \"peerDependencies\": {\n    \"constructs\": \"^10.3\"\n  },\n  \"dependencies\": {\n    \"@aws-sdk/client-cloudwatch-logs\": \"3.577.0\",\n    \"@aws-sdk/client-dynamodb\": \"3.577.0\",\n    \"@aws-sdk/client-elasticache\": \"3.577.0\",\n    \"@aws-sdk/client-lambda\": \"3.577.0\",\n    \"@aws-sdk/client-s3\": \"3.577.0\",\n    \"@aws-sdk/client-secrets-manager\": \"3.577.0\",\n    \"@aws-sdk/client-sns\": \"3.577.0\",\n    \"@aws-sdk/client-sqs\": \"3.577.0\",\n    \"@aws-sdk/s3-request-presigner\": \"3.577.0\",\n    \"@aws-sdk/types\": \"3.449.0\",\n    \"@aws-sdk/util-dynamodb\": \"3.577.0\",\n    \"@azure/core-paging\": \"^1.5.0\",\n    \"@azure/data-tables\": \"13.2.2\",\n    \"@azure/identity\": \"4.0.1\",\n    \"@azure/storage-blob\": \"12.14.0\",\n    \"@google-cloud/datastore\": \"8.4.0\",\n    \"@google-cloud/storage\": \"6.9.5\",\n    \"@smithy/util-stream\": \"2.0.17\",\n    \"@smithy/util-utf8\": \"2.0.0\",\n    \"@types/aws-lambda\": \"^8.10.119\",\n    \"@winglang/wingtunnels\": \"0.75.4\",\n    \"ajv\": \"^8.12.0\",\n    \"cdktf\": \"0.20.3\",\n    \"constructs\": \"^10.3\",\n    \"cron-parser\": \"^4.9.0\",\n    \"cron-validator\": \"^1.3.1\",\n    \"express\": \"^4.19.2\",\n    \"glob\": \"^8.1.0\",\n    \"google-auth-library\": \"^8.9.0\",\n    \"ioredis\": \"^5.3.2\",\n    \"jiti\": \"^1.21.0\",\n    \"mime\": \"^3.0.0\",\n    \"mime-types\": \"^2.1.35\",\n    \"nanoid\": \"^3.3.6\",\n    \"protobufjs\": \"7.2.5\",\n    \"safe-stable-stringify\": \"^2.4.3\",\n    \"stacktracey\": \"^2.1.8\",\n    \"toml\": \"^3.0.0\",\n    \"ulid\": \"^2.3.0\",\n    \"uuid\": \"^8.3.2\",\n    \"vlq\": \"^2.0.4\",\n    \"yaml\": \"^2.3.2\"\n  },\n  \"bundledDependencies\": [\n    \"@aws-sdk/client-cloudwatch-logs\",\n    \"@aws-sdk/client-dynamodb\",\n    \"@aws-sdk/client-elasticache\",\n    \"@aws-sdk/client-lambda\",\n    \"@aws-sdk/client-s3\",\n    \"@aws-sdk/client-secrets-manager\",\n    \"@aws-sdk/client-sns\",\n    \"@aws-sdk/client-sqs\",\n    \"@aws-sdk/s3-request-presigner\",\n    \"@aws-sdk/types\",\n    \"@aws-sdk/util-dynamodb\",\n    \"@azure/core-paging\",\n    \"@azure/data-tables\",\n    \"@azure/identity\",\n    \"@azure/storage-blob\",\n    \"@google-cloud/datastore\",\n    \"@google-cloud/storage\",\n    \"@smithy/util-stream\",\n    \"@smithy/util-utf8\",\n    \"@types/aws-lambda\",\n    \"@winglang/wingtunnels\",\n    \"ajv\",\n    \"cdktf\",\n    \"cron-parser\",\n    \"cron-validator\",\n    \"express\",\n    \"glob\",\n    \"google-auth-library\",\n    \"ioredis\",\n    \"jiti\",\n    \"mime\",\n    \"mime-types\",\n    \"nanoid\",\n    \"protobufjs\",\n    \"safe-stable-stringify\",\n    \"stacktracey\",\n    \"toml\",\n    \"ulid\",\n    \"uuid\",\n    \"vlq\",\n    \"yaml\"\n  ],\n  \"engines\": {\n    \"node\": \">= 20.0.0\"\n  },\n  \"main\": \"lib/index.js\",\n  \"license\": \"MIT\",\n  \"version\": \"0.75.4\",\n  \"types\": \"lib/index.d.ts\",\n  \"stability\": \"experimental\",\n  \"jsii\": {\n    \"outdir\": \"dist\",\n    \"targets\": {},\n    \"tsc\": {\n      \"outDir\": \"lib\",\n      \"rootDir\": \"src\"\n    }\n  },\n  \"optionalDependencies\": {\n    \"esbuild\": \"^0.19.12\"\n  },\n  \"files\": [\n    \"lib\",\n    \".jsii\",\n    \"API.md\",\n    \"patches\"\n  ],\n  \"//\": \"~~ Generated by projen. To modify, edit .projenrc.ts and run \\\"npx projen\\\".\",\n  \"scripts\": {\n    \"api-check\": \"pnpm exec projen api-check\",\n    \"api-check:watch\": \"pnpm exec projen api-check:watch\",\n    \"build\": \"pnpm exec projen build\",\n    \"bump\": \"pnpm exec projen bump\",\n    \"clobber\": \"pnpm exec projen clobber\",\n    \"compat\": \"pnpm exec projen compat\",\n    \"compile\": \"pnpm exec projen compile\",\n    \"default\": \"pnpm exec projen default\",\n    \"docgen\": \"pnpm exec projen docgen\",\n    \"eject\": \"pnpm exec projen eject\",\n    \"eslint\": \"pnpm exec projen eslint\",\n    \"package\": \"pnpm exec projen package\",\n    \"package-all\": \"pnpm exec projen package-all\",\n    \"package:js\": \"pnpm exec projen package:js\",\n    \"post-compile\": \"pnpm exec projen post-compile\",\n    \"pre-compile\": \"pnpm exec projen pre-compile\",\n    \"release\": \"pnpm exec projen release\",\n    \"test\": \"pnpm exec projen test\",\n    \"test:watch\": \"pnpm exec projen test:watch\",\n    \"unbump\": \"pnpm exec projen unbump\",\n    \"watch\": \"pnpm exec projen watch\",\n    \"projen\": \"pnpm exec projen\"\n  }\n}","// eslint-disable-next-line @typescript-eslint/no-require-imports\nconst PKG = require(\"../package.json\");\n\nexport const SDK_VERSION = PKG.version;\nexport const SDK_PACKAGE_NAME = PKG.name;\n\nif (!SDK_VERSION) {\n  throw new Error(\"SDK_VERSION is not defined\");\n}\n\nif (!SDK_PACKAGE_NAME) {\n  throw new Error(\"SDK_PACKAGE_NAME is not defined\");\n}\n\nexport function fqnForType(type: string) {\n  return `${SDK_PACKAGE_NAME}.${type}`;\n}\n","export abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(private readonly varKind: Name, private readonly name: Name, private rhs?: SafeExpr) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(readonly lhs: Code, public rhs: SafeExpr, private readonly sideEffects?: boolean) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs: Code, private readonly op: Code, rhs: SafeExpr, sideEffects?: boolean) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(private condition: Code | boolean, nodes?: ChildNode[]) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(public name: Name, public args: Code, public async?: boolean) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = typeof _jsonTypes[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponents} from \"uri-js\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponents): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","{\n  \"$id\": \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n  \"description\": \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\n  \"type\": \"object\",\n  \"required\": [\"$data\"],\n  \"properties\": {\n    \"$data\": {\n      \"type\": \"string\",\n      \"anyOf\": [{\"format\": \"relative-json-pointer\"}, {\"format\": \"json-pointer\"}]\n    }\n  },\n  \"additionalProperties\": false\n}\n","import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n","export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}","import * as uri from \"uri-js\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch?.$ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Core schema meta-schema\",\n  \"definitions\": {\n    \"schemaArray\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"items\": {\"$ref\": \"#\"}\n    },\n    \"nonNegativeInteger\": {\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"nonNegativeIntegerDefault0\": {\n      \"allOf\": [{\"$ref\": \"#/definitions/nonNegativeInteger\"}, {\"default\": 0}]\n    },\n    \"simpleTypes\": {\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n    },\n    \"stringArray\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"uniqueItems\": true,\n      \"default\": []\n    }\n  },\n  \"type\": [\"object\", \"boolean\"],\n  \"properties\": {\n    \"$id\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$schema\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"$ref\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$comment\": {\n      \"type\": \"string\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"default\": true,\n    \"readOnly\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"examples\": {\n      \"type\": \"array\",\n      \"items\": true\n    },\n    \"multipleOf\": {\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"maximum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMaximum\": {\n      \"type\": \"number\"\n    },\n    \"minimum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMinimum\": {\n      \"type\": \"number\"\n    },\n    \"maxLength\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minLength\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"pattern\": {\n      \"type\": \"string\",\n      \"format\": \"regex\"\n    },\n    \"additionalItems\": {\"$ref\": \"#\"},\n    \"items\": {\n      \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/schemaArray\"}],\n      \"default\": true\n    },\n    \"maxItems\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minItems\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"uniqueItems\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"contains\": {\"$ref\": \"#\"},\n    \"maxProperties\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minProperties\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"required\": {\"$ref\": \"#/definitions/stringArray\"},\n    \"additionalProperties\": {\"$ref\": \"#\"},\n    \"definitions\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"properties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"patternProperties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"propertyNames\": {\"format\": \"regex\"},\n      \"default\": {}\n    },\n    \"dependencies\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/stringArray\"}]\n      }\n    },\n    \"propertyNames\": {\"$ref\": \"#\"},\n    \"const\": true,\n    \"enum\": {\n      \"type\": \"array\",\n      \"items\": true,\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\"$ref\": \"#/definitions/simpleTypes\"},\n        {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/definitions/simpleTypes\"},\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      ]\n    },\n    \"format\": {\"type\": \"string\"},\n    \"contentMediaType\": {\"type\": \"string\"},\n    \"contentEncoding\": {\"type\": \"string\"},\n    \"if\": {\"$ref\": \"#\"},\n    \"then\": {\"$ref\": \"#\"},\n    \"else\": {\"$ref\": \"#\"},\n    \"allOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"anyOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"oneOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"not\": {\"$ref\": \"#\"}\n  },\n  \"default\": true\n}\n","import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nclass Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n","module.exports = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = [],\n        peg$c1 = function() { return nodes },\n        peg$c2 = peg$FAILED,\n        peg$c3 = \"#\",\n        peg$c4 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n        peg$c5 = void 0,\n        peg$c6 = { type: \"any\", description: \"any character\" },\n        peg$c7 = \"[\",\n        peg$c8 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c9 = \"]\",\n        peg$c10 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c11 = function(name) { addNode(node('ObjectPath', name, line, column)) },\n        peg$c12 = function(name) { addNode(node('ArrayPath', name, line, column)) },\n        peg$c13 = function(parts, name) { return parts.concat(name) },\n        peg$c14 = function(name) { return [name] },\n        peg$c15 = function(name) { return name },\n        peg$c16 = \".\",\n        peg$c17 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n        peg$c18 = \"=\",\n        peg$c19 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c20 = function(key, value) { addNode(node('Assign', value, line, column, key)) },\n        peg$c21 = function(chars) { return chars.join('') },\n        peg$c22 = function(node) { return node.value },\n        peg$c23 = \"\\\"\\\"\\\"\",\n        peg$c24 = { type: \"literal\", value: \"\\\"\\\"\\\"\", description: \"\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\"\" },\n        peg$c25 = null,\n        peg$c26 = function(chars) { return node('String', chars.join(''), line, column) },\n        peg$c27 = \"\\\"\",\n        peg$c28 = { type: \"literal\", value: \"\\\"\", description: \"\\\"\\\\\\\"\\\"\" },\n        peg$c29 = \"'''\",\n        peg$c30 = { type: \"literal\", value: \"'''\", description: \"\\\"'''\\\"\" },\n        peg$c31 = \"'\",\n        peg$c32 = { type: \"literal\", value: \"'\", description: \"\\\"'\\\"\" },\n        peg$c33 = function(char) { return char },\n        peg$c34 = function(char) { return char},\n        peg$c35 = \"\\\\\",\n        peg$c36 = { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n        peg$c37 = function() { return '' },\n        peg$c38 = \"e\",\n        peg$c39 = { type: \"literal\", value: \"e\", description: \"\\\"e\\\"\" },\n        peg$c40 = \"E\",\n        peg$c41 = { type: \"literal\", value: \"E\", description: \"\\\"E\\\"\" },\n        peg$c42 = function(left, right) { return node('Float', parseFloat(left + 'e' + right), line, column) },\n        peg$c43 = function(text) { return node('Float', parseFloat(text), line, column) },\n        peg$c44 = \"+\",\n        peg$c45 = { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n        peg$c46 = function(digits) { return digits.join('') },\n        peg$c47 = \"-\",\n        peg$c48 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n        peg$c49 = function(digits) { return '-' + digits.join('') },\n        peg$c50 = function(text) { return node('Integer', parseInt(text, 10), line, column) },\n        peg$c51 = \"true\",\n        peg$c52 = { type: \"literal\", value: \"true\", description: \"\\\"true\\\"\" },\n        peg$c53 = function() { return node('Boolean', true, line, column) },\n        peg$c54 = \"false\",\n        peg$c55 = { type: \"literal\", value: \"false\", description: \"\\\"false\\\"\" },\n        peg$c56 = function() { return node('Boolean', false, line, column) },\n        peg$c57 = function() { return node('Array', [], line, column) },\n        peg$c58 = function(value) { return node('Array', value ? [value] : [], line, column) },\n        peg$c59 = function(values) { return node('Array', values, line, column) },\n        peg$c60 = function(values, value) { return node('Array', values.concat(value), line, column) },\n        peg$c61 = function(value) { return value },\n        peg$c62 = \",\",\n        peg$c63 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c64 = \"{\",\n        peg$c65 = { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n        peg$c66 = \"}\",\n        peg$c67 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n        peg$c68 = function(values) { return node('InlineTable', values, line, column) },\n        peg$c69 = function(key, value) { return node('InlineTableValue', value, line, column, key) },\n        peg$c70 = function(digits) { return \".\" + digits },\n        peg$c71 = function(date) { return  date.join('') },\n        peg$c72 = \":\",\n        peg$c73 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c74 = function(time) { return time.join('') },\n        peg$c75 = \"T\",\n        peg$c76 = { type: \"literal\", value: \"T\", description: \"\\\"T\\\"\" },\n        peg$c77 = \"Z\",\n        peg$c78 = { type: \"literal\", value: \"Z\", description: \"\\\"Z\\\"\" },\n        peg$c79 = function(date, time) { return node('Date', new Date(date + \"T\" + time + \"Z\"), line, column) },\n        peg$c80 = function(date, time) { return node('Date', new Date(date + \"T\" + time), line, column) },\n        peg$c81 = /^[ \\t]/,\n        peg$c82 = { type: \"class\", value: \"[ \\\\t]\", description: \"[ \\\\t]\" },\n        peg$c83 = \"\\n\",\n        peg$c84 = { type: \"literal\", value: \"\\n\", description: \"\\\"\\\\n\\\"\" },\n        peg$c85 = \"\\r\",\n        peg$c86 = { type: \"literal\", value: \"\\r\", description: \"\\\"\\\\r\\\"\" },\n        peg$c87 = /^[0-9a-f]/i,\n        peg$c88 = { type: \"class\", value: \"[0-9a-f]i\", description: \"[0-9a-f]i\" },\n        peg$c89 = /^[0-9]/,\n        peg$c90 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c91 = \"_\",\n        peg$c92 = { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n        peg$c93 = function() { return \"\" },\n        peg$c94 = /^[A-Za-z0-9_\\-]/,\n        peg$c95 = { type: \"class\", value: \"[A-Za-z0-9_\\\\-]\", description: \"[A-Za-z0-9_\\\\-]\" },\n        peg$c96 = function(d) { return d.join('') },\n        peg$c97 = \"\\\\\\\"\",\n        peg$c98 = { type: \"literal\", value: \"\\\\\\\"\", description: \"\\\"\\\\\\\\\\\\\\\"\\\"\" },\n        peg$c99 = function() { return '\"'  },\n        peg$c100 = \"\\\\\\\\\",\n        peg$c101 = { type: \"literal\", value: \"\\\\\\\\\", description: \"\\\"\\\\\\\\\\\\\\\\\\\"\" },\n        peg$c102 = function() { return '\\\\' },\n        peg$c103 = \"\\\\b\",\n        peg$c104 = { type: \"literal\", value: \"\\\\b\", description: \"\\\"\\\\\\\\b\\\"\" },\n        peg$c105 = function() { return '\\b' },\n        peg$c106 = \"\\\\t\",\n        peg$c107 = { type: \"literal\", value: \"\\\\t\", description: \"\\\"\\\\\\\\t\\\"\" },\n        peg$c108 = function() { return '\\t' },\n        peg$c109 = \"\\\\n\",\n        peg$c110 = { type: \"literal\", value: \"\\\\n\", description: \"\\\"\\\\\\\\n\\\"\" },\n        peg$c111 = function() { return '\\n' },\n        peg$c112 = \"\\\\f\",\n        peg$c113 = { type: \"literal\", value: \"\\\\f\", description: \"\\\"\\\\\\\\f\\\"\" },\n        peg$c114 = function() { return '\\f' },\n        peg$c115 = \"\\\\r\",\n        peg$c116 = { type: \"literal\", value: \"\\\\r\", description: \"\\\"\\\\\\\\r\\\"\" },\n        peg$c117 = function() { return '\\r' },\n        peg$c118 = \"\\\\U\",\n        peg$c119 = { type: \"literal\", value: \"\\\\U\", description: \"\\\"\\\\\\\\U\\\"\" },\n        peg$c120 = function(digits) { return convertCodePoint(digits.join('')) },\n        peg$c121 = \"\\\\u\",\n        peg$c122 = { type: \"literal\", value: \"\\\\u\", description: \"\\\"\\\\\\\\u\\\"\" },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$cache = {},\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 0,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseline();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseline();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c1();\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseline() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 49 + 1,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseS();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseS();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseS();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseS();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parsecomment();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parsecomment();\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parseNL();\n              if (s6 !== peg$FAILED) {\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$parseNL();\n                }\n              } else {\n                s5 = peg$c2;\n              }\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseEOF();\n              }\n              if (s5 !== peg$FAILED) {\n                s1 = [s1, s2, s3, s4, s5];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseS();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parseS();\n          }\n        } else {\n          s1 = peg$c2;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseNL();\n          if (s3 !== peg$FAILED) {\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parseNL();\n            }\n          } else {\n            s2 = peg$c2;\n          }\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseEOF();\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseNL();\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpression() {\n      var s0;\n\n      var key    = peg$currPos * 49 + 2,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$parsecomment();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsepath();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsetablearray();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseassignment();\n          }\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomment() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 49 + 3,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c3;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseNL();\n        if (s5 === peg$FAILED) {\n          s5 = peg$parseEOF();\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = peg$c5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c2;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c2;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c2;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseNL();\n          if (s5 === peg$FAILED) {\n            s5 = peg$parseEOF();\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c6); }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c2;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c2;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 49 + 4,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c7;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseS();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseS();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsetable_key();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parseS();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parseS();\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s5 = peg$c9;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c10); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c11(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetablearray() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 49 + 5,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c7;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 91) {\n          s2 = peg$c7;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseS();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseS();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsetable_key();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parseS();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parseS();\n              }\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 93) {\n                  s6 = peg$c9;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 93) {\n                    s7 = peg$c9;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c12(s4);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetable_key() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 6,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsedot_ended_table_key_part();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsedot_ended_table_key_part();\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsetable_key_part();\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c13(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsetable_key_part();\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c14(s1);\n        }\n        s0 = s1;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetable_key_part() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 49 + 7,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseS();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseS();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsekey();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseS();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseS();\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c15(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseS();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseS();\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsequoted_key();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parseS();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseS();\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c15(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedot_ended_table_key_part() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 49 + 8,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseS();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseS();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsekey();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseS();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseS();\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s4 = peg$c16;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parseS();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parseS();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c15(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseS();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseS();\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsequoted_key();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parseS();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseS();\n            }\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s4 = peg$c16;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c17); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = [];\n                s6 = peg$parseS();\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$parseS();\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c15(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseassignment() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 49 + 9,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsekey();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseS();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseS();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c18;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c19); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parseS();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parseS();\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsevalue();\n              if (s5 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c20(s1, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsequoted_key();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseS();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseS();\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s3 = peg$c18;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c19); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              s5 = peg$parseS();\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$parseS();\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsevalue();\n                if (s5 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c20(s1, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsekey() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 10,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseASCII_BASIC();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseASCII_BASIC();\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c21(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsequoted_key() {\n      var s0, s1;\n\n      var key    = peg$currPos * 49 + 11,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedouble_quoted_single_line_string();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c22(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsesingle_quoted_single_line_string();\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c22(s1);\n        }\n        s0 = s1;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalue() {\n      var s0;\n\n      var key    = peg$currPos * 49 + 12,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$parsestring();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsedatetime();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsefloat();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseinteger();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseboolean();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsearray();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseinline_table();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0;\n\n      var key    = peg$currPos * 49 + 13,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$parsedouble_quoted_multiline_string();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsedouble_quoted_single_line_string();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsesingle_quoted_multiline_string();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsesingle_quoted_single_line_string();\n          }\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedouble_quoted_multiline_string() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 49 + 14,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3) === peg$c23) {\n        s1 = peg$c23;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseNL();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c25;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsemultiline_string_char();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsemultiline_string_char();\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c23) {\n              s4 = peg$c23;\n              peg$currPos += 3;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c24); }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c26(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedouble_quoted_single_line_string() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 49 + 15,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c27;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsestring_char();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsestring_char();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c27;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c26(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesingle_quoted_multiline_string() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 49 + 16,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3) === peg$c29) {\n        s1 = peg$c29;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c30); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseNL();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c25;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsemultiline_literal_char();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsemultiline_literal_char();\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c29) {\n              s4 = peg$c29;\n              peg$currPos += 3;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c30); }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c26(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesingle_quoted_single_line_string() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 49 + 17,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseliteral_char();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseliteral_char();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 39) {\n            s3 = peg$c31;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c26(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring_char() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 18,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$parseESCAPED();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s2 = peg$c27;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        peg$silentFails--;\n        if (s2 === peg$FAILED) {\n          s1 = peg$c5;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c2;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c33(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseliteral_char() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 19,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s2 = peg$c31;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = peg$c5;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c6); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c33(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemultiline_string_char() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 20,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$parseESCAPED();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsemultiline_string_delim();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 3) === peg$c23) {\n            s2 = peg$c23;\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c24); }\n          }\n          peg$silentFails--;\n          if (s2 === peg$FAILED) {\n            s1 = peg$c5;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c2;\n          }\n          if (s1 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c6); }\n            }\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c34(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemultiline_string_delim() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 49 + 21,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c35;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseNL();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseNLS();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseNLS();\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c37();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemultiline_literal_char() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 22,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 3) === peg$c29) {\n        s2 = peg$c29;\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c30); }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = peg$c5;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c6); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c33(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefloat() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 49 + 23,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsefloat_text();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseinteger_text();\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 101) {\n          s2 = peg$c38;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 69) {\n            s2 = peg$c40;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c41); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseinteger_text();\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c42(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsefloat_text();\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c43(s1);\n        }\n        s0 = s1;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefloat_text() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 49 + 24,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s1 = peg$c44;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c45); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$c25;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parseDIGITS();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c16;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseDIGITS();\n            if (s5 !== peg$FAILED) {\n              s3 = [s3, s4, s5];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c2;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c2;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c2;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c46(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c47;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = peg$parseDIGITS();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s4 = peg$c16;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseDIGITS();\n              if (s5 !== peg$FAILED) {\n                s3 = [s3, s4, s5];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c2;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c2;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c2;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c49(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinteger() {\n      var s0, s1;\n\n      var key    = peg$currPos * 49 + 25,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseinteger_text();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c50(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinteger_text() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 49 + 26,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s1 = peg$c44;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c45); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$c25;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseDIGIT_OR_UNDER();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseDIGIT_OR_UNDER();\n          }\n        } else {\n          s2 = peg$c2;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c16;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\n          }\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c5;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c2;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c46(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c47;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseDIGIT_OR_UNDER();\n          if (s3 !== peg$FAILED) {\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parseDIGIT_OR_UNDER();\n            }\n          } else {\n            s2 = peg$c2;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$currPos;\n            peg$silentFails++;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s4 = peg$c16;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\n            }\n            peg$silentFails--;\n            if (s4 === peg$FAILED) {\n              s3 = peg$c5;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c2;\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c49(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseboolean() {\n      var s0, s1;\n\n      var key    = peg$currPos * 49 + 27,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c51) {\n        s1 = peg$c51;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c53();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 5) === peg$c54) {\n          s1 = peg$c54;\n          peg$currPos += 5;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c55); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c56();\n        }\n        s0 = s1;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearray() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 49 + 28,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c7;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsearray_sep();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsearray_sep();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c9;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c10); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c57();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 91) {\n          s1 = peg$c7;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsearray_value();\n          if (s2 === peg$FAILED) {\n            s2 = peg$c25;\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 93) {\n              s3 = peg$c9;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c10); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c58(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c7;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsearray_value_list();\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parsearray_value_list();\n              }\n            } else {\n              s2 = peg$c2;\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s3 = peg$c9;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c10); }\n              }\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c59(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 91) {\n              s1 = peg$c7;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c8); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              s3 = peg$parsearray_value_list();\n              if (s3 !== peg$FAILED) {\n                while (s3 !== peg$FAILED) {\n                  s2.push(s3);\n                  s3 = peg$parsearray_value_list();\n                }\n              } else {\n                s2 = peg$c2;\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsearray_value();\n                if (s3 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 93) {\n                    s4 = peg$c9;\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                  }\n                  if (s4 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c60(s2, s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          }\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearray_value() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 49 + 29,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsearray_sep();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsearray_sep();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsevalue();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsearray_sep();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsearray_sep();\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c61(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearray_value_list() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 49 + 30,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsearray_sep();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsearray_sep();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsevalue();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsearray_sep();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsearray_sep();\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s4 = peg$c62;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c63); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parsearray_sep();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parsearray_sep();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c61(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearray_sep() {\n      var s0;\n\n      var key    = peg$currPos * 49 + 31,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$parseS();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseNL();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsecomment();\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinline_table() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 49 + 32,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c64;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseS();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseS();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseinline_table_assignment();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseinline_table_assignment();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parseS();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parseS();\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 125) {\n                s5 = peg$c66;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c67); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c68(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinline_table_assignment() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      var key    = peg$currPos * 49 + 33,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseS();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseS();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsekey();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseS();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseS();\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s4 = peg$c18;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c19); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parseS();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parseS();\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsevalue();\n                if (s6 !== peg$FAILED) {\n                  s7 = [];\n                  s8 = peg$parseS();\n                  while (s8 !== peg$FAILED) {\n                    s7.push(s8);\n                    s8 = peg$parseS();\n                  }\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 44) {\n                      s8 = peg$c62;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c63); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      s9 = [];\n                      s10 = peg$parseS();\n                      while (s10 !== peg$FAILED) {\n                        s9.push(s10);\n                        s10 = peg$parseS();\n                      }\n                      if (s9 !== peg$FAILED) {\n                        peg$reportedPos = s0;\n                        s1 = peg$c69(s2, s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseS();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseS();\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsekey();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parseS();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseS();\n            }\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 61) {\n                s4 = peg$c18;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c19); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = [];\n                s6 = peg$parseS();\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$parseS();\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parsevalue();\n                  if (s6 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c69(s2, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesecfragment() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 34,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s1 = peg$c16;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c17); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseDIGITS();\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c70(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedate() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      var key    = peg$currPos * 49 + 35,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDIGIT_OR_UNDER();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDIGIT_OR_UNDER();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseDIGIT_OR_UNDER();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseDIGIT_OR_UNDER();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 45) {\n                s6 = peg$c47;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c48); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseDIGIT_OR_UNDER();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseDIGIT_OR_UNDER();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 45) {\n                      s9 = peg$c47;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parseDIGIT_OR_UNDER();\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parseDIGIT_OR_UNDER();\n                        if (s11 !== peg$FAILED) {\n                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];\n                          s1 = s2;\n                        } else {\n                          peg$currPos = s1;\n                          s1 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s1;\n                        s1 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s1;\n                      s1 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c2;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c2;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c2;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c2;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c2;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c71(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetime() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      var key    = peg$currPos * 49 + 36,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDIGIT_OR_UNDER();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDIGIT_OR_UNDER();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s4 = peg$c72;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c73); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseDIGIT_OR_UNDER();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseDIGIT_OR_UNDER();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 58) {\n                  s7 = peg$c72;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c73); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseDIGIT_OR_UNDER();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseDIGIT_OR_UNDER();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesecfragment();\n                      if (s10 === peg$FAILED) {\n                        s10 = peg$c25;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];\n                        s1 = s2;\n                      } else {\n                        peg$currPos = s1;\n                        s1 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s1;\n                      s1 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c2;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c2;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c2;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c2;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c2;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c74(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetime_with_offset() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;\n\n      var key    = peg$currPos * 49 + 37,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDIGIT_OR_UNDER();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDIGIT_OR_UNDER();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s4 = peg$c72;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c73); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseDIGIT_OR_UNDER();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseDIGIT_OR_UNDER();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 58) {\n                  s7 = peg$c72;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c73); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseDIGIT_OR_UNDER();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseDIGIT_OR_UNDER();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesecfragment();\n                      if (s10 === peg$FAILED) {\n                        s10 = peg$c25;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 45) {\n                          s11 = peg$c47;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                        }\n                        if (s11 === peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 43) {\n                            s11 = peg$c44;\n                            peg$currPos++;\n                          } else {\n                            s11 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c45); }\n                          }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parseDIGIT_OR_UNDER();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseDIGIT_OR_UNDER();\n                            if (s13 !== peg$FAILED) {\n                              if (input.charCodeAt(peg$currPos) === 58) {\n                                s14 = peg$c72;\n                                peg$currPos++;\n                              } else {\n                                s14 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c73); }\n                              }\n                              if (s14 !== peg$FAILED) {\n                                s15 = peg$parseDIGIT_OR_UNDER();\n                                if (s15 !== peg$FAILED) {\n                                  s16 = peg$parseDIGIT_OR_UNDER();\n                                  if (s16 !== peg$FAILED) {\n                                    s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];\n                                    s1 = s2;\n                                  } else {\n                                    peg$currPos = s1;\n                                    s1 = peg$c2;\n                                  }\n                                } else {\n                                  peg$currPos = s1;\n                                  s1 = peg$c2;\n                                }\n                              } else {\n                                peg$currPos = s1;\n                                s1 = peg$c2;\n                              }\n                            } else {\n                              peg$currPos = s1;\n                              s1 = peg$c2;\n                            }\n                          } else {\n                            peg$currPos = s1;\n                            s1 = peg$c2;\n                          }\n                        } else {\n                          peg$currPos = s1;\n                          s1 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s1;\n                        s1 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s1;\n                      s1 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c2;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c2;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c2;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c2;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c2;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c74(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedatetime() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 49 + 38,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedate();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 84) {\n          s2 = peg$c75;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsetime();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 90) {\n              s4 = peg$c77;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c78); }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c79(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsedate();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 84) {\n            s2 = peg$c75;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c76); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsetime_with_offset();\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c80(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseS() {\n      var s0;\n\n      var key    = peg$currPos * 49 + 39,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      if (peg$c81.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c82); }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseNL() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 40,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s0 = peg$c83;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c84); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s1 = peg$c85;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c86); }\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 10) {\n            s2 = peg$c83;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c84); }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseNLS() {\n      var s0;\n\n      var key    = peg$currPos * 49 + 41,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$parseNL();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseS();\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseEOF() {\n      var s0, s1;\n\n      var key    = peg$currPos * 49 + 42,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = peg$c5;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseHEX() {\n      var s0;\n\n      var key    = peg$currPos * 49 + 43,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      if (peg$c87.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c88); }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDIGIT_OR_UNDER() {\n      var s0, s1;\n\n      var key    = peg$currPos * 49 + 44,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      if (peg$c89.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c90); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 95) {\n          s1 = peg$c91;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c92); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c93();\n        }\n        s0 = s1;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseASCII_BASIC() {\n      var s0;\n\n      var key    = peg$currPos * 49 + 45,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      if (peg$c94.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c95); }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDIGITS() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 49 + 46,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseDIGIT_OR_UNDER();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseDIGIT_OR_UNDER();\n        }\n      } else {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c96(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseESCAPED() {\n      var s0, s1;\n\n      var key    = peg$currPos * 49 + 47,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c97) {\n        s1 = peg$c97;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c98); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c99();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c100) {\n          s1 = peg$c100;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c101); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c102();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c103) {\n            s1 = peg$c103;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c104); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c105();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 2) === peg$c106) {\n              s1 = peg$c106;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c107); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c108();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.substr(peg$currPos, 2) === peg$c109) {\n                s1 = peg$c109;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c110); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c111();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.substr(peg$currPos, 2) === peg$c112) {\n                  s1 = peg$c112;\n                  peg$currPos += 2;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c113); }\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c114();\n                }\n                s0 = s1;\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  if (input.substr(peg$currPos, 2) === peg$c115) {\n                    s1 = peg$c115;\n                    peg$currPos += 2;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                  }\n                  if (s1 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c117();\n                  }\n                  s0 = s1;\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseESCAPED_UNICODE();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseESCAPED_UNICODE() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      var key    = peg$currPos * 49 + 48,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c118) {\n        s1 = peg$c118;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c119); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parseHEX();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseHEX();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseHEX();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseHEX();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseHEX();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseHEX();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseHEX();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parseHEX();\n                      if (s10 !== peg$FAILED) {\n                        s3 = [s3, s4, s5, s6, s7, s8, s9, s10];\n                        s2 = s3;\n                      } else {\n                        peg$currPos = s2;\n                        s2 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s2;\n                      s2 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$c2;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c2;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c2;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c2;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c2;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c120(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c2;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c121) {\n          s1 = peg$c121;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c122); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = peg$parseHEX();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseHEX();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseHEX();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseHEX();\n                if (s6 !== peg$FAILED) {\n                  s3 = [s3, s4, s5, s6];\n                  s2 = s3;\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$c2;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c2;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c2;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c2;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c120(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c2;\n        }\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      var nodes = [];\n\n      function genError(err, line, col) {\n        var ex = new Error(err);\n        ex.line = line;\n        ex.column = col;\n        throw ex;\n      }\n\n      function addNode(node) {\n        nodes.push(node);\n      }\n\n      function node(type, value, line, column, key) {\n        var obj = { type: type, value: value, line: line(), column: column() };\n        if (key) obj.key = key;\n        return obj;\n      }\n\n      function convertCodePoint(str, line, col) {\n        var num = parseInt(\"0x\" + str);\n\n        if (\n          !isFinite(num) ||\n          Math.floor(num) != num ||\n          num < 0 ||\n          num > 0x10FFFF ||\n          (num > 0xD7FF && num < 0xE000)\n        ) {\n          genError(\"Invalid Unicode escape code: \" + str, line, col);\n        } else {\n          return fromCodePoint(num);\n        }\n      }\n\n      function fromCodePoint() {\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = arguments.length;\n        if (!length) {\n          return '';\n        }\n        var result = '';\n        while (++index < length) {\n          var codePoint = Number(arguments[index]);\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint);\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000;\n            highSurrogate = (codePoint >> 10) + 0xD800;\n            lowSurrogate = (codePoint % 0x400) + 0xDC00;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n          if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n            result += String.fromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n        return result;\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();\n","\"use strict\";\nfunction compile(nodes) {\n  var assignedPaths = [];\n  var valueAssignments = [];\n  var currentPath = \"\";\n  var data = Object.create(null);\n  var context = data;\n  var arrayMode = false;\n\n  return reduce(nodes);\n\n  function reduce(nodes) {\n    var node;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      switch (node.type) {\n      case \"Assign\":\n        assign(node);\n        break;\n      case \"ObjectPath\":\n        setPath(node);\n        break;\n      case \"ArrayPath\":\n        addTableArray(node);\n        break;\n      }\n    }\n\n    return data;\n  }\n\n  function genError(err, line, col) {\n    var ex = new Error(err);\n    ex.line = line;\n    ex.column = col;\n    throw ex;\n  }\n\n  function assign(node) {\n    var key = node.key;\n    var value = node.value;\n    var line = node.line;\n    var column = node.column;\n\n    var fullPath;\n    if (currentPath) {\n      fullPath = currentPath + \".\" + key;\n    } else {\n      fullPath = key;\n    }\n    if (typeof context[key] !== \"undefined\") {\n      genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\n    }\n\n    context[key] = reduceValueNode(value);\n\n    if (!pathAssigned(fullPath)) {\n      assignedPaths.push(fullPath);\n      valueAssignments.push(fullPath);\n    }\n  }\n\n\n  function pathAssigned(path) {\n    return assignedPaths.indexOf(path) !== -1;\n  }\n\n  function reduceValueNode(node) {\n    if (node.type === \"Array\") {\n      return reduceArrayWithTypeChecking(node.value);\n    } else if (node.type === \"InlineTable\") {\n      return reduceInlineTableNode(node.value);\n    } else {\n      return node.value;\n    }\n  }\n\n  function reduceInlineTableNode(values) {\n    var obj = Object.create(null);\n    for (var i = 0; i < values.length; i++) {\n      var val = values[i];\n      if (val.value.type === \"InlineTable\") {\n        obj[val.key] = reduceInlineTableNode(val.value.value);\n      } else if (val.type === \"InlineTableValue\") {\n        obj[val.key] = reduceValueNode(val.value);\n      }\n    }\n\n    return obj;\n  }\n\n  function setPath(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (pathAssigned(quotedPath)) {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, Object.create(null), line, column);\n    currentPath = path;\n  }\n\n  function addTableArray(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (!pathAssigned(quotedPath)) {\n      assignedPaths.push(quotedPath);\n    }\n    assignedPaths = assignedPaths.filter(function(p) {\n      return p.indexOf(quotedPath) !== 0;\n    });\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, [], line, column);\n    currentPath = quotedPath;\n\n    if (context instanceof Array) {\n      var newObj = Object.create(null);\n      context.push(newObj);\n      context = newObj;\n    } else {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n  }\n\n  // Given a path 'a.b.c', create (as necessary) `start.a`,\n  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\n  // If `a` or `b` are arrays and have items in them, the last item in the\n  // array is used as the context for the next sub-path.\n  function deepRef(start, keys, value, line, column) {\n    var traversed = [];\n    var traversedPath = \"\";\n    var path = keys.join(\".\");\n    var ctx = start;\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      traversed.push(key);\n      traversedPath = traversed.join(\".\");\n      if (typeof ctx[key] === \"undefined\") {\n        if (i === keys.length - 1) {\n          ctx[key] = value;\n        } else {\n          ctx[key] = Object.create(null);\n        }\n      } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {\n        // already a non-object value at key, can't be used as part of a new path\n        genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\n      }\n\n      ctx = ctx[key];\n      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {\n        ctx = ctx[ctx.length - 1];\n      }\n    }\n\n    return ctx;\n  }\n\n  function reduceArrayWithTypeChecking(array) {\n    // Ensure that all items in the array are of the same type\n    var firstType = null;\n    for (var i = 0; i < array.length; i++) {\n      var node = array[i];\n      if (firstType === null) {\n        firstType = node.type;\n      } else {\n        if (node.type !== firstType) {\n          genError(\"Cannot add value of type \" + node.type + \" to array of type \" +\n            firstType + \".\", node.line, node.column);\n        }\n      }\n    }\n\n    // Recursively reduce array of nodes into array of the nodes' values\n    return array.map(reduceValueNode);\n  }\n\n  function quoteDottedString(str) {\n    if (str.indexOf(\".\") > -1) {\n      return \"\\\"\" + str + \"\\\"\";\n    } else {\n      return str;\n    }\n  }\n}\n\nmodule.exports = {\n  compile: compile\n};\n","var parser = require('./lib/parser');\nvar compiler = require('./lib/compiler');\n\nmodule.exports = {\n  parse: function(input) {\n    var nodes = parser.parse(input.toString());\n    return compiler.compile(nodes);\n  }\n};\n","'use strict';\n\nconst ALIAS = Symbol.for('yaml.alias');\nconst DOC = Symbol.for('yaml.document');\nconst MAP = Symbol.for('yaml.map');\nconst PAIR = Symbol.for('yaml.pair');\nconst SCALAR = Symbol.for('yaml.scalar');\nconst SEQ = Symbol.for('yaml.seq');\nconst NODE_TYPE = Symbol.for('yaml.node.type');\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\nfunction isCollection(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case MAP:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nfunction isNode(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case ALIAS:\n            case MAP:\n            case SCALAR:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\n\nexports.ALIAS = ALIAS;\nexports.DOC = DOC;\nexports.MAP = MAP;\nexports.NODE_TYPE = NODE_TYPE;\nexports.PAIR = PAIR;\nexports.SCALAR = SCALAR;\nexports.SEQ = SEQ;\nexports.hasAnchor = hasAnchor;\nexports.isAlias = isAlias;\nexports.isCollection = isCollection;\nexports.isDocument = isDocument;\nexports.isMap = isMap;\nexports.isNode = isNode;\nexports.isPair = isPair;\nexports.isScalar = isScalar;\nexports.isSeq = isSeq;\n","'use strict';\n\nvar identity = require('./nodes/identity.js');\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (identity.isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (identity.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (identity.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (identity.isDocument(node)) {\n        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n    const ctrl = await callVisitor(key, node, visitor, path);\n    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visitAsync_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (identity.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = await visitAsync_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (identity.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = await visitAsync_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = await visitAsync_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (identity.isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (identity.isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (identity.isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (identity.isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (identity.isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (identity.isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (identity.isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (identity.isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = identity.isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nexports.visit = visit;\nexports.visitAsync = visitAsync;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar visit = require('../visit.js');\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix)\n            return prefix + decodeURIComponent(suffix);\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {\n            const tags = {};\n            visit.visit(doc.contents, (_key, node) => {\n                if (identity.isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexports.Directives = Directives;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar visit = require('../visit.js');\n\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nfunction anchorIsValid(anchor) {\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\n        const sa = JSON.stringify(anchor);\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\n        throw new Error(msg);\n    }\n    return true;\n}\nfunction anchorNames(root) {\n    const anchors = new Set();\n    visit.visit(root, {\n        Value(_key, node) {\n            if (node.anchor)\n                anchors.add(node.anchor);\n        }\n    });\n    return anchors;\n}\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nfunction findNewAnchor(prefix, exclude) {\n    for (let i = 1; true; ++i) {\n        const name = `${prefix}${i}`;\n        if (!exclude.has(name))\n            return name;\n    }\n}\nfunction createNodeAnchors(doc, prefix) {\n    const aliasObjects = [];\n    const sourceObjects = new Map();\n    let prevAnchors = null;\n    return {\n        onAnchor: (source) => {\n            aliasObjects.push(source);\n            if (!prevAnchors)\n                prevAnchors = anchorNames(doc);\n            const anchor = findNewAnchor(prefix, prevAnchors);\n            prevAnchors.add(anchor);\n            return anchor;\n        },\n        /**\n         * With circular references, the source node is only resolved after all\n         * of its child nodes are. This is why anchors are set only after all of\n         * the nodes have been created.\n         */\n        setAnchors: () => {\n            for (const source of aliasObjects) {\n                const ref = sourceObjects.get(source);\n                if (typeof ref === 'object' &&\n                    ref.anchor &&\n                    (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {\n                    ref.node.anchor = ref.anchor;\n                }\n                else {\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\n                    error.source = source;\n                    throw error;\n                }\n            }\n        },\n        sourceObjects\n    };\n}\n\nexports.anchorIsValid = anchorIsValid;\nexports.anchorNames = anchorNames;\nexports.createNodeAnchors = createNodeAnchors;\nexports.findNewAnchor = findNewAnchor;\n","'use strict';\n\n/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\nexports.applyReviver = applyReviver;\n","'use strict';\n\nvar identity = require('./identity.js');\n\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nfunction toJS(value, arg, ctx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (Array.isArray(value))\n        return value.map((v, i) => toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (!ctx || !identity.hasAnchor(value))\n            return value.toJSON(arg, ctx);\n        const data = { aliasCount: 0, count: 1, res: undefined };\n        ctx.anchors.set(value, data);\n        ctx.onCreate = res => {\n            data.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (ctx.onCreate)\n            ctx.onCreate(res);\n        return res;\n    }\n    if (typeof value === 'bigint' && !ctx?.keep)\n        return Number(value);\n    return value;\n}\n\nexports.toJS = toJS;\n","'use strict';\n\nvar applyReviver = require('../doc/applyReviver.js');\nvar identity = require('./identity.js');\nvar toJS = require('./toJS.js');\n\nclass NodeBase {\n    constructor(type) {\n        Object.defineProperty(this, identity.NODE_TYPE, { value: type });\n    }\n    /** Create a copy of this node.  */\n    clone() {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** A plain JavaScript representation of this node. */\n    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        if (!identity.isDocument(doc))\n            throw new TypeError('A document argument is required');\n        const ctx = {\n            anchors: new Map(),\n            doc,\n            keep: true,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS.toJS(this, '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver.applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n}\n\nexports.NodeBase = NodeBase;\n","'use strict';\n\nvar anchors = require('../doc/anchors.js');\nvar visit = require('../visit.js');\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\nvar toJS = require('./toJS.js');\n\nclass Alias extends Node.NodeBase {\n    constructor(source) {\n        super(identity.ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc) {\n        let found = undefined;\n        visit.visit(doc, {\n            Node: (_key, node) => {\n                if (node === this)\n                    return visit.visit.BREAK;\n                if (node.anchor === this.source)\n                    found = node;\n            }\n        });\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        let data = anchors.get(source);\n        if (!data) {\n            // Resolve anchors for Node.prototype.toJS()\n            toJS.toJS(source, null, ctx);\n            data = anchors.get(source);\n        }\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchors.anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (identity.isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (identity.isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (identity.isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexports.Alias = Alias;\n","'use strict';\n\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\nvar toJS = require('./toJS.js');\n\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\nclass Scalar extends Node.NodeBase {\n    constructor(value) {\n        super(identity.SCALAR);\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\nScalar.PLAIN = 'PLAIN';\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\n\nexports.Scalar = Scalar;\nexports.isScalarValue = isScalarValue;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (identity.isDocument(value))\n        value = value.contents;\n    if (identity.isNode(value))\n        return value;\n    if (identity.isPair(value)) {\n        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            if (!ref.anchor)\n                ref.anchor = onAnchor(value);\n            return new Alias.Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar.Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[identity.MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[identity.SEQ]\n                    : schema[identity.MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : typeof tagObj?.nodeClass?.from === 'function'\n            ? tagObj.nodeClass.from(ctx.schema, value, ctx)\n            : new Scalar.Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    else if (!tagObj.default)\n        node.tag = tagObj.tag;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nexports.createNode = createNode;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode.createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends Node.NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (identity.isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (identity.isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && identity.isScalar(node) ? node.value : node;\n        else\n            return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!identity.isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    identity.isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return identity.isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (identity.isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\nCollection.maxFlowStringSingleLineLength = 60;\n\nexports.Collection = Collection;\nexports.collectionFromPath = collectionFromPath;\nexports.isEmptyPath = isEmptyPath;\n","'use strict';\n\n/**\n * Stringifies a comment.\n *\n * Empty comment lines are left empty,\n * lines consisting of a single space are replaced by `#`,\n * and all other lines are prefixed with a `#`.\n */\nconst stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');\nfunction indentComment(comment, indent) {\n    if (/^\\n+$/.test(comment))\n        return comment.substring(1);\n    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;\n}\nconst lineComment = (str, indent, comment) => str.endsWith('\\n')\n    ? indentComment(comment, indent)\n    : comment.includes('\\n')\n        ? '\\n' + indentComment(comment, indent)\n        : (str.endsWith(' ') ? '' : ' ') + comment;\n\nexports.indentComment = indentComment;\nexports.lineComment = lineComment;\nexports.stringifyComment = stringifyComment;\n","'use strict';\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i);\n            end = i + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i) {\n    let ch = text[i + 1];\n    while (ch === ' ' || ch === '\\t') {\n        do {\n            ch = text[(i += 1)];\n        } while (ch && ch !== '\\n');\n        ch = text[i + 1];\n    }\n    return i;\n}\n\nexports.FOLD_BLOCK = FOLD_BLOCK;\nexports.FOLD_FLOW = FOLD_FLOW;\nexports.FOLD_QUOTED = FOLD_QUOTED;\nexports.foldFlowLines = foldFlowLines;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\nvar foldFlowLines = require('./foldFlowLines.js');\n\nconst getFoldOptions = (ctx, isBlock) => ({\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\n// The negative lookbehind avoids a polynomial search,\n// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind\nlet blockEndNewlines;\ntry {\n    blockEndNewlines = new RegExp('(^|(?<!\\n))\\n+(?!\\n|$)', 'g');\n}\ncatch {\n    blockEndNewlines = /\\n+(?!\\n|$)/g;\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(blockEndNewlines, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (literal) {\n        value = value.replace(/\\n+/g, `$&${indent}`);\n        return `${header}\\n${indent}${start}${value}${end}`;\n    }\n    value = value\n        .replace(/\\n+/g, '\\n$&')\n        .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n        .replace(/\\n+/g, `$&${indent}`);\n    const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, true));\n    return `${header}\\n${indent}${body}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;\n    if ((implicitKey && value.includes('\\n')) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (!value ||\n        /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - empty string, '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (containsDocumentMarker(value)) {\n        if (indent === '') {\n            ctx.forceBlockIndent = true;\n            return blockString(item, ctx, onComment, onChompKeep);\n        }\n        else if (implicitKey && indent === indentStep) {\n            return quotedString(value, ctx);\n        }\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.Scalar.BLOCK_FOLDED:\n            case Scalar.Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nexports.stringifyString = stringifyString;\n","'use strict';\n\nvar anchors = require('../doc/anchors.js');\nvar identity = require('../nodes/identity.js');\nvar stringifyComment = require('./stringifyComment.js');\nvar stringifyString = require('./stringifyString.js');\n\nfunction createStringifyContext(doc, options) {\n    const opt = Object.assign({\n        blockQuote: true,\n        commentString: stringifyComment.stringifyComment,\n        defaultKeyType: null,\n        defaultStringType: 'PLAIN',\n        directives: null,\n        doubleQuotedAsJSON: false,\n        doubleQuotedMinMultiLineLength: 40,\n        falseStr: 'false',\n        flowCollectionPadding: true,\n        indentSeq: true,\n        lineWidth: 80,\n        minContentWidth: 20,\n        nullStr: 'null',\n        simpleKeys: false,\n        singleQuote: null,\n        trueStr: 'true',\n        verifyAliasOrder: true\n    }, doc.schema.toStringOptions, options);\n    let inFlow;\n    switch (opt.collectionStyle) {\n        case 'block':\n            inFlow = false;\n            break;\n        case 'flow':\n            inFlow = true;\n            break;\n        default:\n            inFlow = null;\n    }\n    return {\n        anchors: new Set(),\n        doc,\n        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',\n        indent: '',\n        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',\n        inFlow,\n        options: opt\n    };\n}\nfunction getTagObject(tags, item) {\n    if (item.tag) {\n        const match = tags.filter(t => t.tag === item.tag);\n        if (match.length > 0)\n            return match.find(t => t.format === item.format) ?? match[0];\n    }\n    let tagObj = undefined;\n    let obj;\n    if (identity.isScalar(item)) {\n        obj = item.value;\n        const match = tags.filter(t => t.identify?.(obj));\n        tagObj =\n            match.find(t => t.format === item.format) ?? match.find(t => !t.format);\n    }\n    else {\n        obj = item;\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj?.constructor?.name ?? typeof obj;\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n}\n// needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {\n    if (!doc.directives)\n        return '';\n    const props = [];\n    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;\n    if (anchor && anchors.anchorIsValid(anchor)) {\n        anchors$1.add(anchor);\n        props.push(`&${anchor}`);\n    }\n    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;\n    if (tag)\n        props.push(doc.directives.tagString(tag));\n    return props.join(' ');\n}\nfunction stringify(item, ctx, onComment, onChompKeep) {\n    if (identity.isPair(item))\n        return item.toString(ctx, onComment, onChompKeep);\n    if (identity.isAlias(item)) {\n        if (ctx.doc.directives)\n            return item.toString(ctx);\n        if (ctx.resolvedAliases?.has(item)) {\n            throw new TypeError(`Cannot stringify circular structure without alias nodes`);\n        }\n        else {\n            if (ctx.resolvedAliases)\n                ctx.resolvedAliases.add(item);\n            else\n                ctx.resolvedAliases = new Set([item]);\n            item = item.resolve(ctx.doc);\n        }\n    }\n    let tagObj = undefined;\n    const node = identity.isNode(item)\n        ? item\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\n    if (!tagObj)\n        tagObj = getTagObject(ctx.doc.schema.tags, node);\n    const props = stringifyProps(node, tagObj, ctx);\n    if (props.length > 0)\n        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;\n    const str = typeof tagObj.stringify === 'function'\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\n        : identity.isScalar(node)\n            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)\n            : node.toString(ctx, onComment, onChompKeep);\n    if (!props)\n        return str;\n    return identity.isScalar(node) || str[0] === '{' || str[0] === '['\n        ? `${props} ${str}`\n        : `${props}\\n${ctx.indent}${str}`;\n}\n\nexports.createStringifyContext = createStringifyContext;\nexports.stringify = stringify;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (identity.isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (identity.isCollection(key)) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            identity.isCollection(key) ||\n            (identity.isScalar(key)\n                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (identity.isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && identity.isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        identity.isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${stringifyComment.indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n')\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && identity.isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexports.stringifyPair = stringifyPair;\n","'use strict';\n\nfunction debug(logLevel, ...messages) {\n    if (logLevel === 'debug')\n        console.log(...messages);\n}\nfunction warn(logLevel, warning) {\n    if (logLevel === 'debug' || logLevel === 'warn') {\n        // https://github.com/typescript-eslint/typescript-eslint/issues/7478\n        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n        if (typeof process !== 'undefined' && process.emitWarning)\n            process.emitWarning(warning);\n        else\n            console.warn(warning);\n    }\n}\n\nexports.debug = debug;\nexports.warn = warn;\n","'use strict';\n\nvar log = require('../log.js');\nvar stringify = require('../stringify/stringify.js');\nvar identity = require('./identity.js');\nvar Scalar = require('./Scalar.js');\nvar toJS = require('./toJS.js');\n\nconst MERGE_KEY = '<<';\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (ctx?.doc.schema.merge && isMergeKey(key)) {\n        value = identity.isAlias(value) ? value.resolve(ctx.doc) : value;\n        if (identity.isSeq(value))\n            for (const it of value.items)\n                mergeToJSMap(ctx, map, it);\n        else if (Array.isArray(value))\n            for (const it of value)\n                mergeToJSMap(ctx, map, it);\n        else\n            mergeToJSMap(ctx, map, value);\n    }\n    else {\n        const jsKey = toJS.toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS.toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS.toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nconst isMergeKey = (key) => key === MERGE_KEY ||\n    (identity.isScalar(key) &&\n        key.value === MERGE_KEY &&\n        (!key.type || key.type === Scalar.Scalar.PLAIN));\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nfunction mergeToJSMap(ctx, map, value) {\n    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!identity.isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (identity.isNode(key) && ctx?.doc) {\n        const strCtx = stringify.createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexports.addPairToJSMap = addPairToJSMap;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar stringifyPair = require('../stringify/stringifyPair.js');\nvar addPairToJSMap = require('./addPairToJSMap.js');\nvar identity = require('./identity.js');\n\nfunction createPair(key, value, ctx) {\n    const k = createNode.createNode(key, undefined, ctx);\n    const v = createNode.createNode(value, undefined, ctx);\n    return new Pair(k, v);\n}\nclass Pair {\n    constructor(key, value = null) {\n        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });\n        this.key = key;\n        this.value = value;\n    }\n    clone(schema) {\n        let { key, value } = this;\n        if (identity.isNode(key))\n            key = key.clone(schema);\n        if (identity.isNode(value))\n            value = value.clone(schema);\n        return new Pair(key, value);\n    }\n    toJSON(_, ctx) {\n        const pair = ctx?.mapAsMap ? new Map() : {};\n        return addPairToJSMap.addPairToJSMap(ctx, pair, this);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        return ctx?.doc\n            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)\n            : JSON.stringify(this);\n    }\n}\n\nexports.Pair = Pair;\nexports.createPair = createPair;\n","'use strict';\n\nvar Collection = require('../nodes/Collection.js');\nvar identity = require('../nodes/identity.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyCollection(collection, ctx, options) {\n    const flow = ctx.inFlow ?? collection.flow;\n    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;\n    return stringify(collection, ctx, options);\n}\nfunction stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {\n    const { indent, options: { commentString } } = ctx;\n    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });\n    let chompKeep = false; // flag for the preceding node's status\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (identity.isNode(item)) {\n            if (!chompKeep && item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (identity.isPair(item)) {\n            const ik = identity.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (!chompKeep && ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);\n            }\n        }\n        chompKeep = false;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (chompKeep && comment)\n            chompKeep = false;\n        lines.push(blockItemPrefix + str);\n    }\n    let str;\n    if (lines.length === 0) {\n        str = flowChars.start + flowChars.end;\n    }\n    else {\n        str = lines[0];\n        for (let i = 1; i < lines.length; ++i) {\n            const line = lines[i];\n            str += line ? `\\n${indent}${line}` : '\\n';\n        }\n    }\n    if (comment) {\n        str += '\\n' + stringifyComment.indentComment(commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    else if (chompKeep && onChompKeep)\n        onChompKeep();\n    return str;\n}\nfunction stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {\n    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;\n    itemIndent += indentStep;\n    const itemCtx = Object.assign({}, ctx, {\n        indent: itemIndent,\n        inFlow: true,\n        type: null\n    });\n    let reqNewline = false;\n    let linesAtValue = 0;\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (identity.isNode(item)) {\n            if (item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, false);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (identity.isPair(item)) {\n            const ik = identity.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, false);\n                if (ik.comment)\n                    reqNewline = true;\n            }\n            const iv = identity.isNode(item.value) ? item.value : null;\n            if (iv) {\n                if (iv.comment)\n                    comment = iv.comment;\n                if (iv.commentBefore)\n                    reqNewline = true;\n            }\n            else if (item.value == null && ik?.comment) {\n                comment = ik.comment;\n            }\n        }\n        if (comment)\n            reqNewline = true;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null));\n        if (i < items.length - 1)\n            str += ',';\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (!reqNewline && (lines.length > linesAtValue || str.includes('\\n')))\n            reqNewline = true;\n        lines.push(str);\n        linesAtValue = lines.length;\n    }\n    let str;\n    const { start, end } = flowChars;\n    if (lines.length === 0) {\n        str = start + end;\n    }\n    else {\n        if (!reqNewline) {\n            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);\n            reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;\n        }\n        if (reqNewline) {\n            str = start;\n            for (const line of lines)\n                str += line ? `\\n${indentStep}${indent}${line}` : '\\n';\n            str += `\\n${indent}${end}`;\n        }\n        else {\n            str = `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;\n        }\n    }\n    if (comment) {\n        str += stringifyComment.lineComment(str, indent, commentString(comment));\n        if (onComment)\n            onComment();\n    }\n    return str;\n}\nfunction addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {\n    if (comment && chompKeep)\n        comment = comment.replace(/^\\n+/, '');\n    if (comment) {\n        const ic = stringifyComment.indentComment(commentString(comment), indent);\n        lines.push(ic.trimStart()); // Avoid double indent on first line\n    }\n}\n\nexports.stringifyCollection = stringifyCollection;\n","'use strict';\n\nvar stringifyCollection = require('../stringify/stringifyCollection.js');\nvar addPairToJSMap = require('./addPairToJSMap.js');\nvar Collection = require('./Collection.js');\nvar identity = require('./identity.js');\nvar Pair = require('./Pair.js');\nvar Scalar = require('./Scalar.js');\n\nfunction findPair(items, key) {\n    const k = identity.isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (identity.isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (identity.isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    constructor(schema) {\n        super(identity.MAP, schema);\n        this.items = [];\n    }\n    /**\n     * A generic collection parsing method that can be extended\n     * to other node classes that inherit from YAMLMap\n     */\n    static from(schema, obj, ctx) {\n        const { keepUndefined, replacer } = ctx;\n        const map = new this(schema);\n        const add = (key, value) => {\n            if (typeof replacer === 'function')\n                value = replacer.call(obj, key, value);\n            else if (Array.isArray(replacer) && !replacer.includes(key))\n                return;\n            if (value !== undefined || keepUndefined)\n                map.items.push(Pair.createPair(key, value, ctx));\n        };\n        if (obj instanceof Map) {\n            for (const [key, value] of obj)\n                add(key, value);\n        }\n        else if (obj && typeof obj === 'object') {\n            for (const key of Object.keys(obj))\n                add(key, obj[key]);\n        }\n        if (typeof schema.sortMapEntries === 'function') {\n            map.items.sort(schema.sortMapEntries);\n        }\n        return map;\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (identity.isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair.Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair.Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair.Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap.addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!identity.isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nexports.YAMLMap = YAMLMap;\nexports.findPair = findPair;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\n\nconst map = {\n    collection: 'map',\n    default: true,\n    nodeClass: YAMLMap.YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!identity.isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)\n};\n\nexports.map = map;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar stringifyCollection = require('../stringify/stringifyCollection.js');\nvar Collection = require('./Collection.js');\nvar identity = require('./identity.js');\nvar Scalar = require('./Scalar.js');\nvar toJS = require('./toJS.js');\n\nclass YAMLSeq extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:seq';\n    }\n    constructor(schema) {\n        super(identity.SEQ, schema);\n        this.items = [];\n    }\n    add(value) {\n        this.items.push(value);\n    }\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return undefined;\n        const it = this.items[idx];\n        return !keepScalar && identity.isScalar(it) ? it.value : it;\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === 'number' && idx < this.items.length;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (identity.isScalar(prev) && Scalar.isScalarValue(value))\n            prev.value = value;\n        else\n            this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx?.onCreate)\n            ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)\n            seq.push(toJS.toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '- ',\n            flowChars: { start: '[', end: ']' },\n            itemIndent: (ctx.indent || '') + '  ',\n            onChompKeep,\n            onComment\n        });\n    }\n    static from(schema, obj, ctx) {\n        const { replacer } = ctx;\n        const seq = new this(schema);\n        if (obj && Symbol.iterator in Object(obj)) {\n            let i = 0;\n            for (let it of obj) {\n                if (typeof replacer === 'function') {\n                    const key = obj instanceof Set ? it : String(i++);\n                    it = replacer.call(obj, key, it);\n                }\n                seq.items.push(createNode.createNode(it, undefined, ctx));\n            }\n        }\n        return seq;\n    }\n}\nfunction asItemIndex(key) {\n    let idx = identity.isScalar(key) ? key.value : key;\n    if (idx && typeof idx === 'string')\n        idx = Number(idx);\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\n        ? idx\n        : null;\n}\n\nexports.YAMLSeq = YAMLSeq;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\n\nconst seq = {\n    collection: 'seq',\n    default: true,\n    nodeClass: YAMLSeq.YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!identity.isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    },\n    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)\n};\n\nexports.seq = seq;\n","'use strict';\n\nvar stringifyString = require('../../stringify/stringifyString.js');\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.string = string;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar.Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar.Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexports.nullTag = nullTag;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexports.boolTag = boolTag;\n","'use strict';\n\nfunction stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexports.stringifyNumber = stringifyNumber;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN))$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intHex = intHex;\nexports.intOct = intOct;\n","'use strict';\n\nvar map = require('../common/map.js');\nvar _null = require('../common/null.js');\nvar seq = require('../common/seq.js');\nvar string = require('../common/string.js');\nvar bool = require('./bool.js');\nvar float = require('./float.js');\nvar int = require('./int.js');\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.boolTag,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float\n];\n\nexports.schema = schema;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar map = require('../common/map.js');\nvar seq = require('../common/seq.js');\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar.Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true|false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map.map, seq.seq].concat(jsonScalars, jsonError);\n\nexports.schema = schema;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyString = require('../../stringify/stringifyString.js');\n\nconst binary = {\n    identify: value => value instanceof Uint8Array,\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof Buffer === 'function') {\n            return Buffer.from(src, 'base64');\n        }\n        else if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof Buffer === 'function') {\n            str =\n                buf instanceof Buffer\n                    ? buf.toString('base64')\n                    : Buffer.from(buf.buffer).toString('base64');\n        }\n        else if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        if (!type)\n            type = Scalar.Scalar.BLOCK_LITERAL;\n        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.binary = binary;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Pair = require('../../nodes/Pair.js');\nvar Scalar = require('../../nodes/Scalar.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\n\nfunction resolvePairs(seq, onError) {\n    if (identity.isSeq(seq)) {\n        for (let i = 0; i < seq.items.length; ++i) {\n            let item = seq.items[i];\n            if (identity.isPair(item))\n                continue;\n            else if (identity.isMap(item)) {\n                if (item.items.length > 1)\n                    onError('Each pair must have its own sequence indicator');\n                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));\n                if (item.commentBefore)\n                    pair.key.commentBefore = pair.key.commentBefore\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\n                        : item.commentBefore;\n                if (item.comment) {\n                    const cn = pair.value ?? pair.key;\n                    cn.comment = cn.comment\n                        ? `${item.comment}\\n${cn.comment}`\n                        : item.comment;\n                }\n                item = pair;\n            }\n            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);\n        }\n    }\n    else\n        onError('Expected a sequence for this tag');\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new YAMLSeq.YAMLSeq(schema);\n    pairs.tag = 'tag:yaml.org,2002:pairs';\n    let i = 0;\n    if (iterable && Symbol.iterator in Object(iterable))\n        for (let it of iterable) {\n            if (typeof replacer === 'function')\n                it = replacer.call(iterable, String(i++), it);\n            let key, value;\n            if (Array.isArray(it)) {\n                if (it.length === 2) {\n                    key = it[0];\n                    value = it[1];\n                }\n                else\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\n            }\n            else if (it && it instanceof Object) {\n                const keys = Object.keys(it);\n                if (keys.length === 1) {\n                    key = keys[0];\n                    value = it[key];\n                }\n                else {\n                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);\n                }\n            }\n            else {\n                key = it;\n            }\n            pairs.items.push(Pair.createPair(key, value, ctx));\n        }\n    return pairs;\n}\nconst pairs = {\n    collection: 'seq',\n    default: false,\n    tag: 'tag:yaml.org,2002:pairs',\n    resolve: resolvePairs,\n    createNode: createPairs\n};\n\nexports.createPairs = createPairs;\nexports.pairs = pairs;\nexports.resolvePairs = resolvePairs;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar toJS = require('../../nodes/toJS.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\nvar pairs = require('./pairs.js');\n\nclass YAMLOMap extends YAMLSeq.YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (identity.isPair(pair)) {\n                key = toJS.toJS(pair.key, '', ctx);\n                value = toJS.toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS.toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n    static from(schema, iterable, ctx) {\n        const pairs$1 = pairs.createPairs(schema, iterable, ctx);\n        const omap = new this();\n        omap.items = pairs$1.items;\n        return omap;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs$1 = pairs.resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs$1.items) {\n            if (identity.isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs$1);\n    },\n    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)\n};\n\nexports.YAMLOMap = YAMLOMap;\nexports.omap = omap;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar.Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n    resolve: () => new Scalar.Scalar(false),\n    stringify: boolStringify\n};\n\nexports.falseTag = falseTag;\nexports.trueTag = trueTag;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intBin = intBin;\nexports.intHex = intHex;\nexports.intOct = intOct;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Pair = require('../../nodes/Pair.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\n\nclass YAMLSet extends YAMLMap.YAMLMap {\n    constructor(schema) {\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        let pair;\n        if (identity.isPair(key))\n            pair = key;\n        else if (key &&\n            typeof key === 'object' &&\n            'key' in key &&\n            'value' in key &&\n            key.value === null)\n            pair = new Pair.Pair(key.key, null);\n        else\n            pair = new Pair.Pair(key, null);\n        const prev = YAMLMap.findPair(this.items, pair.key);\n        if (!prev)\n            this.items.push(pair);\n    }\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key, keepPair) {\n        const pair = YAMLMap.findPair(this.items, key);\n        return !keepPair && identity.isPair(pair)\n            ? identity.isScalar(pair.key)\n                ? pair.key.value\n                : pair.key\n            : pair;\n    }\n    set(key, value) {\n        if (typeof value !== 'boolean')\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = YAMLMap.findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        }\n        else if (!prev && value) {\n            this.items.push(new Pair.Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        if (this.hasAllNullValues(true))\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\n        else\n            throw new Error('Set items must all have null values');\n    }\n    static from(schema, iterable, ctx) {\n        const { replacer } = ctx;\n        const set = new this(schema);\n        if (iterable && Symbol.iterator in Object(iterable))\n            for (let value of iterable) {\n                if (typeof replacer === 'function')\n                    value = replacer.call(iterable, value, value);\n                set.items.push(Pair.createPair(value, null, ctx));\n            }\n        return set;\n    }\n}\nYAMLSet.tag = 'tag:yaml.org,2002:set';\nconst set = {\n    collection: 'map',\n    identify: value => value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: 'tag:yaml.org,2002:set',\n    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),\n    resolve(map, onError) {\n        if (identity.isMap(map)) {\n            if (map.hasAllNullValues(true))\n                return Object.assign(new YAMLSet(), map);\n            else\n                onError('Set items must all have null values');\n        }\n        else\n            onError('Expected a mapping for this tag');\n        return map;\n    }\n};\n\nexports.YAMLSet = YAMLSet;\nexports.set = set;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber.stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => String(n).padStart(2, '0'))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.timestamp = timestamp;\n","'use strict';\n\nvar map = require('../common/map.js');\nvar _null = require('../common/null.js');\nvar seq = require('../common/seq.js');\nvar string = require('../common/string.js');\nvar binary = require('./binary.js');\nvar bool = require('./bool.js');\nvar float = require('./float.js');\nvar int = require('./int.js');\nvar omap = require('./omap.js');\nvar pairs = require('./pairs.js');\nvar set = require('./set.js');\nvar timestamp = require('./timestamp.js');\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.trueTag,\n    bool.falseTag,\n    int.intBin,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float,\n    binary.binary,\n    omap.omap,\n    pairs.pairs,\n    set.set,\n    timestamp.intTime,\n    timestamp.floatTime,\n    timestamp.timestamp\n];\n\nexports.schema = schema;\n","'use strict';\n\nvar map = require('./common/map.js');\nvar _null = require('./common/null.js');\nvar seq = require('./common/seq.js');\nvar string = require('./common/string.js');\nvar bool = require('./core/bool.js');\nvar float = require('./core/float.js');\nvar int = require('./core/int.js');\nvar schema = require('./core/schema.js');\nvar schema$1 = require('./json/schema.js');\nvar binary = require('./yaml-1.1/binary.js');\nvar omap = require('./yaml-1.1/omap.js');\nvar pairs = require('./yaml-1.1/pairs.js');\nvar schema$2 = require('./yaml-1.1/schema.js');\nvar set = require('./yaml-1.1/set.js');\nvar timestamp = require('./yaml-1.1/timestamp.js');\n\nconst schemas = new Map([\n    ['core', schema.schema],\n    ['failsafe', [map.map, seq.seq, string.string]],\n    ['json', schema$1.schema],\n    ['yaml11', schema$2.schema],\n    ['yaml-1.1', schema$2.schema]\n]);\nconst tagsByName = {\n    binary: binary.binary,\n    bool: bool.boolTag,\n    float: float.float,\n    floatExp: float.floatExp,\n    floatNaN: float.floatNaN,\n    floatTime: timestamp.floatTime,\n    int: int.int,\n    intHex: int.intHex,\n    intOct: int.intOct,\n    intTime: timestamp.intTime,\n    map: map.map,\n    null: _null.nullTag,\n    omap: omap.omap,\n    pairs: pairs.pairs,\n    seq: seq.seq,\n    set: set.set,\n    timestamp: timestamp.timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary.binary,\n    'tag:yaml.org,2002:omap': omap.omap,\n    'tag:yaml.org,2002:pairs': pairs.pairs,\n    'tag:yaml.org,2002:set': set.set,\n    'tag:yaml.org,2002:timestamp': timestamp.timestamp\n};\nfunction getTags(customTags, schemaName) {\n    let tags = schemas.get(schemaName);\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    return tags.map(tag => {\n        if (typeof tag !== 'string')\n            return tag;\n        const tagObj = tagsByName[tag];\n        if (tagObj)\n            return tagObj;\n        const keys = Object.keys(tagsByName)\n            .map(key => JSON.stringify(key))\n            .join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n    });\n}\n\nexports.coreKnownTags = coreKnownTags;\nexports.getTags = getTags;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar map = require('./common/map.js');\nvar seq = require('./common/seq.js');\nvar string = require('./common/string.js');\nvar tags = require('./tags.js');\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? tags.getTags(compat, 'compat')\n            : compat\n                ? tags.getTags(null, compat)\n                : null;\n        this.merge = !!merge;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};\n        this.tags = tags.getTags(customTags, this.name);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, identity.MAP, { value: map.map });\n        Object.defineProperty(this, identity.SCALAR, { value: string.string });\n        Object.defineProperty(this, identity.SEQ, { value: seq.seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexports.Schema = Schema;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = stringify.createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(stringifyComment.indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (identity.isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += stringifyComment.lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify.stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(stringifyComment.indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexports.stringifyDocument = stringifyDocument;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar Collection = require('../nodes/Collection.js');\nvar identity = require('../nodes/identity.js');\nvar Pair = require('../nodes/Pair.js');\nvar toJS = require('../nodes/toJS.js');\nvar Schema = require('../schema/Schema.js');\nvar stringifyDocument = require('../stringify/stringifyDocument.js');\nvar anchors = require('./anchors.js');\nvar applyReviver = require('./applyReviver.js');\nvar createNode = require('./createNode.js');\nvar directives = require('./directives.js');\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new directives.Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [identity.NODE_TYPE]: { value: identity.DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = identity.isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchors.anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias.Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode.createNode(value, tag, ctx);\n        if (flow && identity.isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair.Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (Collection.isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return identity.isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (Collection.isEmptyPath(path))\n            return !keepScalar && identity.isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return identity.isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return identity.isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (Collection.isEmptyPath(path))\n            return this.contents !== undefined;\n        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = Collection.collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (Collection.isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new directives.Directives({ version: '1.1' });\n                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new directives.Directives({ version });\n                opt = { merge: false, resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema.Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver.applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument.stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (identity.isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexports.Document = Document;\n","'use strict';\n\nclass YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '…' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '…';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '…\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end && end.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexports.YAMLError = YAMLError;\nexports.YAMLParseError = YAMLParseError;\nexports.YAMLWarning = YAMLWarning;\nexports.prettifyError = prettifyError;\n","'use strict';\n\nfunction resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let hasNewlineAfterProp = false;\n    let reqSpace = false;\n    let anchor = null;\n    let tag = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    atNewline &&\n                    indicator !== 'doc-start' &&\n                    token.source[0] === '\\t')\n                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    hasNewlineAfterProp = true;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline = false;\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== ''))\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        hasNewlineAfterProp,\n        anchor,\n        tag,\n        end,\n        start: start ?? end\n    };\n}\n\nexports.resolveProps = resolveProps;\n","'use strict';\n\nfunction containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexports.containsNewline = containsNewline;\n","'use strict';\n\nvar utilContainsNewline = require('./util-contains-newline.js');\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            utilContainsNewline.containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexports.flowIndentCheck = flowIndentCheck;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b ||\n            (identity.isScalar(a) &&\n                identity.isScalar(b) &&\n                a.value === b.value &&\n                !(a.value === '<<' && ctx.schema.merge));\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexports.mapIncludes = mapIncludes;\n","'use strict';\n\nvar Pair = require('../nodes/Pair.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilContainsNewline = require('./util-contains-newline.js');\nvar utilFlowIndentCheck = require('./util-flow-indent-check.js');\nvar utilMapIncludes = require('./util-map-includes.js');\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps.resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);\n        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps.resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexports.resolveBlockMap = resolveBlockMap;\n","'use strict';\n\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilFlowIndentCheck = require('./util-flow-indent-check.js');\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;\n    const seq = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps.resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value && value.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nexports.resolveBlockSeq = resolveBlockSeq;\n","'use strict';\n\nfunction resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexports.resolveEnd = resolveEnd;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Pair = require('../nodes/Pair.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveEnd = require('./resolve-end.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilContainsNewline = require('./util-contains-newline.js');\nvar utilMapIncludes = require('./util-map-includes.js');\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps.resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (identity.isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            // → key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            // value properties\n            const valueProps = resolveProps.resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap.YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexports.resolveFlowCollection = resolveFlowCollection;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveBlockMap = require('./resolve-block-map.js');\nvar resolveBlockSeq = require('./resolve-block-seq.js');\nvar resolveFlowCollection = require('./resolve-flow-collection.js');\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq') ||\n        !expType) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt?.collection) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = identity.isNode(res)\n        ? res\n        : new Scalar.Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexports.composeCollection = composeCollection;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\n\nfunction resolveBlockScalar(scalar, strict, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexports.resolveBlockScalar = resolveBlockScalar;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\nvar resolveEnd = require('./resolve-end.js');\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch (_) {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0',\n    a: '\\x07',\n    b: '\\b',\n    e: '\\x1b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    v: '\\v',\n    N: '\\u0085',\n    _: '\\u00a0',\n    L: '\\u2028',\n    P: '\\u2029',\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexports.resolveFlowScalar = resolveFlowScalar;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar resolveBlockScalar = require('./resolve-block-scalar.js');\nvar resolveFlowScalar = require('./resolve-flow-scalar.js');\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError)\n        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    const tag = tagToken && tagName\n        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)\n        : token.type === 'scalar'\n            ? findScalarTagByTest(ctx, value, token, onError)\n            : ctx.schema[identity.SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar.Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[identity.SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[identity.SCALAR];\n}\nfunction findScalarTagByTest({ directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[identity.SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[identity.SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexports.composeScalar = composeScalar;\n","'use strict';\n\nfunction emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        if (pos === null)\n            pos = before.length;\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexports.emptyScalarPosition = emptyScalarPosition;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar composeCollection = require('./compose-collection.js');\nvar composeScalar = require('./compose-scalar.js');\nvar resolveEnd = require('./resolve-end.js');\nvar utilEmptyScalarPosition = require('./util-empty-scalar-position.js');\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar.composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection.composeCollection(CN, ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar.composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias.Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexports.composeEmptyNode = composeEmptyNode;\nexports.composeNode = composeNode;\n","'use strict';\n\nvar Document = require('../doc/Document.js');\nvar composeNode = require('./compose-node.js');\nvar resolveEnd = require('./resolve-end.js');\nvar resolveProps = require('./resolve-props.js');\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document.Document(undefined, opts);\n    const ctx = {\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps.resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    // @ts-expect-error If Contents is set, let's trust the user\n    doc.contents = value\n        ? composeNode.composeNode(ctx, value, props, onError)\n        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexports.composeDoc = composeDoc;\n","'use strict';\n\nvar directives = require('../doc/directives.js');\nvar Document = require('../doc/Document.js');\nvar errors = require('../errors.js');\nvar identity = require('../nodes/identity.js');\nvar composeDoc = require('./compose-doc.js');\nvar resolveEnd = require('./resolve-end.js');\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new errors.YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new errors.YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new directives.Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (identity.isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        if (process.env.LOG_STREAM)\n            console.dir(token, { depth: null });\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document.Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexports.Composer = Composer;\n","'use strict';\n\nvar resolveBlockScalar = require('../compose/resolve-block-scalar.js');\nvar resolveFlowScalar = require('../compose/resolve-flow-scalar.js');\nvar errors = require('../errors.js');\nvar stringifyString = require('../stringify/stringifyString.js');\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new errors.YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexports.createScalarToken = createScalarToken;\nexports.resolveAsScalar = resolveAsScalar;\nexports.setScalarValue = setScalarValue;\n","'use strict';\n\n/**\n * Stringify a CST document, token, or collection item\n *\n * Fair warning: This applies no validation whatsoever, and\n * simply concatenates the sources in their logical order.\n */\nconst stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\nfunction stringifyToken(token) {\n    switch (token.type) {\n        case 'block-scalar': {\n            let res = '';\n            for (const tok of token.props)\n                res += stringifyToken(tok);\n            return res + token.source;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            let res = '';\n            for (const item of token.items)\n                res += stringifyItem(item);\n            return res;\n        }\n        case 'flow-collection': {\n            let res = token.start.source;\n            for (const item of token.items)\n                res += stringifyItem(item);\n            for (const st of token.end)\n                res += st.source;\n            return res;\n        }\n        case 'document': {\n            let res = stringifyItem(token);\n            if (token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n        default: {\n            let res = token.source;\n            if ('end' in token && token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n    }\n}\nfunction stringifyItem({ start, key, sep, value }) {\n    let res = '';\n    for (const st of start)\n        res += st.source;\n    if (key)\n        res += stringifyToken(key);\n    if (sep)\n        for (const st of sep)\n            res += st.source;\n    if (value)\n        res += stringifyToken(value);\n    return res;\n}\n\nexports.stringify = stringify;\n","'use strict';\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove item');\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]` – Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null` – Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]` – Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token` – The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nfunction visit(cst, visitor) {\n    if ('type' in cst && cst.type === 'document')\n        cst = { start: cst.start, value: cst.value };\n    _visit(Object.freeze([]), cst, visitor);\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current item */\nvisit.SKIP = SKIP;\n/** Remove the current item */\nvisit.REMOVE = REMOVE;\n/** Find the item at `path` from `cst` as the root */\nvisit.itemAtPath = (cst, path) => {\n    let item = cst;\n    for (const [field, index] of path) {\n        const tok = item?.[field];\n        if (tok && 'items' in tok) {\n            item = tok.items[index];\n        }\n        else\n            return undefined;\n    }\n    return item;\n};\n/**\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\n *\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\n */\nvisit.parentCollection = (cst, path) => {\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\n    const field = path[path.length - 1][0];\n    const coll = parent?.[field];\n    if (coll && 'items' in coll)\n        return coll;\n    throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n\nexports.visit = visit;\n","'use strict';\n\nvar cstScalar = require('./cst-scalar.js');\nvar cstStringify = require('./cst-stringify.js');\nvar cstVisit = require('./cst-visit.js');\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = (token) => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = (token) => !!token &&\n    (token.type === 'scalar' ||\n        token.type === 'single-quoted-scalar' ||\n        token.type === 'double-quoted-scalar' ||\n        token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n    switch (token) {\n        case BOM:\n            return '<BOM>';\n        case DOCUMENT:\n            return '<DOC>';\n        case FLOW_END:\n            return '<FLOW_END>';\n        case SCALAR:\n            return '<SCALAR>';\n        default:\n            return JSON.stringify(token);\n    }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\nexports.createScalarToken = cstScalar.createScalarToken;\nexports.resolveAsScalar = cstScalar.resolveAsScalar;\nexports.setScalarValue = cstScalar.setScalarValue;\nexports.stringify = cstStringify.stringify;\nexports.visit = cstVisit.visit;\nexports.BOM = BOM;\nexports.DOCUMENT = DOCUMENT;\nexports.FLOW_END = FLOW_END;\nexports.SCALAR = SCALAR;\nexports.isCollection = isCollection;\nexports.isScalar = isScalar;\nexports.prettyToken = prettyToken;\nexports.tokenType = tokenType;\n","'use strict';\n\nvar cst = require('./cst.js');\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = '0123456789ABCDEFabcdef'.split('');\nconst tagChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\".split('');\nconst invalidFlowScalarChars = ',[]{}'.split('');\nconst invalidAnchorChars = ' ,[]{}\\n\\r\\t'.split('');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === cst.BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            const cs = line.indexOf('#');\n            if (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd = cs - 1;\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield cst.DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if (s === '---' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return 'doc';\n            }\n            else if (s === '...' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                return 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield cst.FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else\n                this.indentNext += this.blockScalarIndent;\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ' || ch === '\\t')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield cst.SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && next === ','))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && invalidFlowScalarChars.includes(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield cst.SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.includes(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.includes(this.buffer[i + 1]) &&\n                    hexDigits.includes(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexports.Lexer = Lexer;\n","'use strict';\n\n/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexports.LineCounter = LineCounter;\n","'use strict';\n\nvar cst = require('./cst.js');\nvar lexer = require('./lexer.js');\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new lexer.Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (process.env.LOG_TOKENS)\n            console.log('|', cst.prettyToken(source));\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = cst.tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n                        it.start.push(this.sourceToken);\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken] }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (includesToken(it.start, 'explicit-key-ind')) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key, delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (atNextItem &&\n                            bv.type !== 'block-seq' &&\n                            includesToken(it.start, 'explicit-key-ind')) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexports.Parser = Parser;\n","'use strict';\n\nvar composer = require('./compose/composer.js');\nvar Document = require('./doc/Document.js');\nvar errors = require('./errors.js');\nvar log = require('./log.js');\nvar lineCounter = require('./parse/line-counter.js');\nvar parser = require('./parse/parser.js');\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;\n    return { lineCounter: lineCounter$1, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    const docs = Array.from(composer$1.compose(parser$1.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(errors.prettifyError(source, lineCounter));\n            doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer$1.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(errors.prettifyError(source, lineCounter));\n        doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    return new Document.Document(value, _replacer, options).toString(options);\n}\n\nexports.parse = parse;\nexports.parseAllDocuments = parseAllDocuments;\nexports.parseDocument = parseDocument;\nexports.stringify = stringify;\n","'use strict';\n\nvar composer = require('./compose/composer.js');\nvar Document = require('./doc/Document.js');\nvar Schema = require('./schema/Schema.js');\nvar errors = require('./errors.js');\nvar Alias = require('./nodes/Alias.js');\nvar identity = require('./nodes/identity.js');\nvar Pair = require('./nodes/Pair.js');\nvar Scalar = require('./nodes/Scalar.js');\nvar YAMLMap = require('./nodes/YAMLMap.js');\nvar YAMLSeq = require('./nodes/YAMLSeq.js');\nvar cst = require('./parse/cst.js');\nvar lexer = require('./parse/lexer.js');\nvar lineCounter = require('./parse/line-counter.js');\nvar parser = require('./parse/parser.js');\nvar publicApi = require('./public-api.js');\nvar visit = require('./visit.js');\n\n\n\nexports.Composer = composer.Composer;\nexports.Document = Document.Document;\nexports.Schema = Schema.Schema;\nexports.YAMLError = errors.YAMLError;\nexports.YAMLParseError = errors.YAMLParseError;\nexports.YAMLWarning = errors.YAMLWarning;\nexports.Alias = Alias.Alias;\nexports.isAlias = identity.isAlias;\nexports.isCollection = identity.isCollection;\nexports.isDocument = identity.isDocument;\nexports.isMap = identity.isMap;\nexports.isNode = identity.isNode;\nexports.isPair = identity.isPair;\nexports.isScalar = identity.isScalar;\nexports.isSeq = identity.isSeq;\nexports.Pair = Pair.Pair;\nexports.Scalar = Scalar.Scalar;\nexports.YAMLMap = YAMLMap.YAMLMap;\nexports.YAMLSeq = YAMLSeq.YAMLSeq;\nexports.CST = cst;\nexports.Lexer = lexer.Lexer;\nexports.LineCounter = lineCounter.LineCounter;\nexports.Parser = parser.Parser;\nexports.parse = publicApi.parse;\nexports.parseAllDocuments = publicApi.parseAllDocuments;\nexports.parseDocument = publicApi.parseDocument;\nexports.stringify = publicApi.stringify;\nexports.visit = visit.visit;\nexports.visitAsync = visit.visitAsync;\n","import { existsSync, readFileSync, readdirSync } from \"fs\";\nimport * as path from \"path\";\nimport * as toml from \"toml\";\nimport * as yaml from \"yaml\";\n\n/**\n * Creates a JSON object from a comma-separated list of values.\n * Where the key is the path and the value is the value.\n *\n * I.E. \"foo/bar=123,foo/baz=456\" would result in:\n * {\n * \"foo\": {\n *  \"bar\": \"123\",\n *  \"baz\": \"456\"\n *  }\n * }\n *\n * @param values a comma-separated list of values\n * @returns a JSON object with all values\n */\nexport function parseValuesObjectFromString(values: string) {\n  const result: any = {}; // Adjusted type for nested structures\n\n  const valuesList = values.split(\",\");\n  valuesList.forEach((v) => {\n    const [paramPath, value] = v.split(\"=\");\n    const pathParts = paramPath.split(\"/\");\n    let tempObject = result; // Start with the result object\n\n    pathParts.forEach((part, index) => {\n      // If we're at the last part, assign the value\n      if (index === pathParts.length - 1) {\n        tempObject[part] = value;\n      } else {\n        // Otherwise, initialize the part if it doesn't exist, or use the existing object\n        if (!tempObject[part]) tempObject[part] = {};\n        tempObject = tempObject[part];\n      }\n    });\n  });\n\n  return result;\n}\n\n/**\n * Extracts all fields from a JSON schema.\n *\n * @param schema the schema to extract fields from\n * @returns a set of all fields in the schema\n */\nexport function extractFieldsFromSchema(schema: any): Set<string> {\n  const fields = new Set<string>();\n\n  if (schema.properties) {\n    for (const key of Object.keys(schema.properties)) {\n      fields.add(key);\n    }\n  }\n\n  return fields;\n}\n\nexport function filterParametersBySchema(\n  fields: Set<string>,\n  parameters: any\n): any {\n  const filtered: any = {};\n\n  for (const field of fields) {\n    if (parameters.hasOwnProperty(field)) {\n      filtered[field] = parameters[field];\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Loads platform-specific values that were passed in via CLI arguments and\n * from a values file. CLI arguments take precedence over values file.\n *\n * I.E. if the cli provided values such as --value \"foo/bar=123\" and the values file\n * contained:\n *\n * ```yaml\n * foo:\n *  bar: 456\n *  baz: 789\n * ```\n *\n * The resulting values object would be:\n * {\n *  \"foo\": {\n *    \"bar\": \"123\",\n *    \"baz\": \"789\"\n *  }\n * }\n *\n * @returns a JSON object with all platform-specific values\n */\nexport function loadPlatformSpecificValues() {\n  const cliValues = parseValuesObjectFromString(process.env.WING_VALUES ?? \"\");\n\n  if (\n    process.env.WING_VALUES_FILE === undefined ||\n    process.env.WING_VALUES_FILE === \"\"\n  ) {\n    return cliValues;\n  }\n\n  const file = path.isAbsolute(process.env.WING_VALUES_FILE)\n    ? process.env.WING_VALUES_FILE\n    : path.join(process.cwd(), process.env.WING_VALUES_FILE);\n  if (!existsSync(file)) {\n    return cliValues;\n  }\n  const data = readFileSync(file, \"utf-8\");\n\n  const fileExtension = path.extname(file);\n  const fileValues = (() => {\n    switch (fileExtension) {\n      case \".yaml\":\n      case \".yml\":\n        return yaml.parse(data);\n      case \".json\":\n        return JSON.parse(data);\n      case \".toml\":\n        return toml.parse(data);\n      default:\n        throw new Error(\n          `Unsupported file extension: ${fileExtension} (expected .yml, .json, or .toml)`\n        );\n    }\n  })();\n  return { ...fileValues, ...cliValues };\n}\n\n/**\n * Scans a directory for any platform files.\n *\n * @param dir the directory to scan\n * @returns the path to any platform files\n */\nexport function scanDirForPlatformFile(dir: string): string[] {\n  const result: string[] = [];\n\n  if (!existsSync(dir)) {\n    return result;\n  }\n\n  const files = readdirSync(dir);\n  for (const file of files) {\n    if (file === \"wplatform.js\" || file.endsWith(\".wplatform.js\")) {\n      result.push(path.join(dir, file));\n    }\n  }\n\n  return result;\n}\n","// These classes are used by Wing to provide JSII subsets of the JS Array class.\n// They should not be consumed directly by users.\n// TODO: These should be interfaces, currently Wing does not support interface JSII imports\n\nimport { T1 } from \"./generics\";\nimport { InflightClient } from \"../core\";\n\n/**\n * Immutable Array\n *\n * @typeparam T1\n */\nexport class Array {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  private constructor() {}\n\n  /**\n   * The length of the array\n   * @returns the length of the array\n   */\n  public get length(): number {\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Get the value at the given index\n   * @macro ((arr, index) => { if (index < 0 || index >= arr.length) throw new Error(\"Index out of bounds\"); return arr[index]; })($self$, $args$)\n   * @param index index of the value to get\n   * @returns the value at the given index\n   */\n  public at(index: number): T1 {\n    index;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Get the value at the given index, returning nil if the index is out of bounds.\n   *\n   * @macro $self$.at($args$)\n   *\n   * @param index index of the value to get\n   * @returns the value at the given index, or undefined if the index is out of bounds\n   */\n  public tryAt(index: number): T1 | undefined {\n    index;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Merge arr to the end of this array\n   * @param arr array to merge\n   *\n   * @returns a new ImmutableArray with the values of this array followed by the values of arr\n   */\n  public concat(arr: Array): Array {\n    arr;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Checks if this array includes searchElement.\n   *\n   * @macro $self$.includes($args$)\n   *\n   * @param searchElement to search for.\n   * @returns true if this array includes searchElement.\n   */\n  public contains(searchElement: T1): boolean {\n    searchElement;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Create a mutable shallow copy of this array\n   *\n   * @macro [...($self$)]\n   *\n   * @returns a MutableArray with the same values as this array\n   */\n  public copyMut(): MutArray {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the index of the first occurrence of searchElement found.\n   *\n   * @macro $self$.indexOf($args$)\n   *\n   * @param searchElement to search for.\n   * @returns the index of the first occurrence of searchElement found, or -1 if not found.\n   */\n  public indexOf(searchElement: T1): number {\n    searchElement;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a new string containing the concatenated values in this array,\n   * separated by commas or a specified separator string. If the array has only\n   * one item, then that item will be returned without using the separator.\n   *\n   * @returns a string containing the concatenated values in this array,\n   * separated by commas or a specified separator string.\n   */\n  public join(separator?: string): string {\n    separator;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Returns the index of the last occurrence of searchElement found.\n   *\n   * @macro $self$.lastIndexOf($args$)\n   *\n   * @param searchElement to search for.\n   * @returns the index of the last occurrence of searchElement found, or -1 if not found.\n   */\n  public lastIndexOf(searchElement: T1): number {\n    searchElement;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a shallow copy of a portion of the array.\n   *\n   * @macro $self$.slice($args$)\n   *\n   * @param start the beginning index of the slice, inclusive.\n   * @param end the ending index of the slice, exclusive.\n   * @returns a new array containing the sliced elements.\n   */\n  public slice(start?: number, end?: number): Array {\n    start;\n    end;\n    throw new Error(\"Macro\");\n  }\n}\n\n/**\n * Mutable Array\n *\n * @typeparam T1\n */\nexport class MutArray {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  private constructor() {}\n\n  /**\n   * The length of the array\n   * @returns the length of the array\n   */\n  public get length(): number {\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Get the value at the given index\n   * @macro ((arr, index) => { if (index < 0 || index >= arr.length) throw new Error(\"Index out of bounds\"); return arr[index]; })($self$, $args$)\n   * @param index index of the value to get\n   * @returns the value at the given index\n   */\n  public at(index: number): T1 {\n    index;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Merge arr to the end of this array\n   * @param arr array to merge\n   *\n   * @returns a new MutableArray with the values of this array followed by the values of arr\n   */\n  public concat(arr: MutArray): MutArray {\n    arr;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Checks if this array includes searchElement.\n   *\n   * @macro $self$.includes($args$)\n   *\n   * @param searchElement to search for.\n   * @returns true if this array includes searchElement.\n   */\n  public contains(searchElement: T1): boolean {\n    searchElement;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Create an immutable shallow copy of this array\n   *\n   * @macro [...($self$)]\n   *\n   * @returns an ImmutableArray with the same values as this array\n   */\n  public copy(): Array {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the index of the first occurrence of searchElement found.\n   *\n   * @macro $self$.indexOf($args$)\n   *\n   * @param searchElement to search for.\n   * @returns the index of the first occurrence of searchElement found, or -1 if not found.\n   */\n  public indexOf(searchElement: T1): number {\n    searchElement;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a new string containing the concatenated values in this array,\n   * separated by commas or a specified separator string. If the array has only\n   * one item, then that item will be returned without using the separator.\n   *\n   * @returns a string containing the concatenated values in this array,\n   * separated by commas or a specified separator string.\n   */\n  public join(separator?: string): string {\n    separator;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Returns the index of the last occurrence of searchElement found.\n   *\n   * @macro $self$.lastIndexOf($args$)\n   *\n   * @param searchElement to search for.\n   * @returns the index of the last occurrence of searchElement found, or -1 if not found.\n   */\n  public lastIndexOf(searchElement: T1): number {\n    searchElement;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Add values to end of array\n   *\n   * @macro $self$.push($args$)\n   *\n   * @param values values to add\n   */\n  public push(...values: T1[]): void {\n    values;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Remove value from end of array\n   * @returns the value removed\n   */\n  public pop(): T1 {\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Removes value from the given index of an array\n   *\n   * @macro ((obj, args) => { if (args[0] < 0 || args[0] >= $self$.length) throw new Error(\"Index out of bounds\"); return obj.splice(args[0], 1)[0]; })($self$, [$args$])\n   *\n   * @param index the index to remove the value at\n   * @returns the value removed\n   * @throws index out of bounds error if the given index does not exist for the array\n   */\n  public popAt(index: number): T1 {\n    index;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Sets a new value at the given index of an array\n   *\n   * @macro ((obj, args) => { if (args[0] < 0 || args[0] >= $self$.length) throw new Error(\"Index out of bounds\"); obj[args[0]] = args[1]; })($self$, [$args$])\n   *\n   * @param index the index to set the value at\n   * @param value the value to set at the given index\n   * @throws index out of bounds error if the given index does not exist for the array\n   */\n  public set(index: number, value: T1): void {\n    index;\n    value;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Inserts a new value at the given index of an array\n   *\n   * @macro ((obj, args) => { if (args[0] < 0 || args[0] > $self$.length) throw new Error(\"Index out of bounds\"); obj.splice(args[0], 0, args[1]); })($self$, [$args$])\n   *\n   * @param index the index to insert the value at\n   * @param value the value to insert at the given index\n   * @throws index out of bounds error if the given index isn't valid\n   */\n  public insert(index: number, value: T1): void {\n    index;\n    value;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Removes first occurrence of a given value in an array\n   *\n   * @macro ((obj, args) => { if (obj.indexOf(args[0]) !== -1) { obj.splice(obj.indexOf(args[0]), 1); return true; } return false; })($self$, [$args$])\n   *\n   * @param value the value to remove\n   * @returns true if value was removed\n   */\n  public removeFirst(value: T1): boolean {\n    value;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a shallow copy of a portion of the array.\n   *\n   * @macro $self$.slice($args$)\n   *\n   * @param start the beginning index of the slice, inclusive.\n   * @param end the ending index of the slice, exclusive.\n   * @returns a new array containing the sliced elements.\n   */\n  public slice(start?: number, end?: number): MutArray {\n    start;\n    end;\n    throw new Error(\"Macro\");\n  }\n}\n","import Ajv from \"ajv\";\nimport { Json, JsonValidationOptions } from \"./json\";\nimport { InflightClient } from \"../core\";\nimport {\n  extractFieldsFromSchema,\n  filterParametersBySchema,\n} from \"../platform/util\";\n\n/**\n * Struct Schema\n */\nexport class JsonSchema {\n  /**\n   * @internal\n   */\n  public static _toInflightType(schema: Json) {\n    return InflightClient.forType(\n      __filename,\n      `${this.name}._createJsonSchema(${JSON.stringify(schema)})`\n    );\n  }\n\n  /**\n   * Static method for creating a StructSchema used for lifting a struct to an inflight type\n   *\n   * @internal\n   */\n  public static _createJsonSchema(schema: Json): JsonSchema {\n    return new JsonSchema(schema);\n  }\n\n  /** @internal */\n  public _rawSchema: any;\n  private validator: Ajv;\n\n  constructor(schema: Json) {\n    this._rawSchema = schema;\n    this.validator = new Ajv({ allErrors: true, allowUnionTypes: true });\n  }\n\n  /**\n   * Attempt to validate a json object against the schema\n   *\n   * @param obj the Json object to validate\n   * @throws an error if the json object is not valid\n   */\n  public validate(obj: Json, options?: JsonValidationOptions) {\n    if (options?.unsafe) {\n      return; // skip validation\n    }\n    const validator = this.validator.compile(this._rawSchema);\n    const valid = validator(obj);\n    if (!valid) {\n      const schemaId = this._rawSchema.$id.replace(\"/\", \"\");\n      throw new Error(\n        `unable to parse ${schemaId}:\\n- ${validator.errors\n          ?.map(\n            (error: any) => schemaId + error.instancePath + \" \" + error.message\n          )\n          .join(\"\\n- \")}`\n      );\n    }\n  }\n\n  /**\n   * Retrieve the json schema as a string\n   *\n   * @returns the schema as a string\n   */\n  public asStr(): String {\n    return JSON.stringify(this._rawSchema);\n  }\n\n  /** @internal */\n  public _fromJson(obj: Json, validateOptions?: JsonValidationOptions) {\n    this.validate(obj, validateOptions);\n    const fields = extractFieldsFromSchema(this._rawSchema);\n    // Filter rawParameters based on the schema\n    const filteredParameters = filterParametersBySchema(fields, obj);\n    return filteredParameters;\n  }\n\n  /** @internal */\n  public _tryFromJson(obj: Json) {\n    try {\n      return this._fromJson(obj);\n    } catch {\n      return undefined;\n    }\n  }\n\n  /** @internal */\n  public _tryParseJson(json: string | undefined) {\n    try {\n      return this._fromJson(JSON.parse(json!));\n    } catch {\n      return undefined;\n    }\n  }\n\n  /** @internal */\n  public _toInflightType() {\n    return JsonSchema._toInflightType(this._rawSchema);\n  }\n}\n","import { Json, JsonValidationOptions } from \"./json\";\nimport { JsonSchema } from \"./json_schema\";\nimport { InflightClient } from \"../core\";\n\n/**\n * Boolean\n * @wingType bool\n */\nexport class Boolean {\n  /**\n   * Parse a boolean from Json.\n   *\n   * @param json to parse boolean from.\n   * @returns a boolean.\n   */\n  public static fromJson(json: Json, options?: JsonValidationOptions): boolean {\n    const schema = JsonSchema._createJsonSchema({\n      $id: \"bool\",\n      type: \"boolean\",\n    } as any);\n    schema.validate(json, options);\n    return json as any;\n  }\n\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  private constructor() {}\n}\n","import { Construct } from \"constructs\";\nimport { NotImplementedError } from \"./errors\";\nimport { getTokenResolver } from \"./tokens\";\nimport { IInflightHost, ILiftable, IHostedLiftable } from \"../std\";\n\n/**\n * This is the name of a special operation that is used as a key\n * by the compiler in the `_liftMap` matrix to indicate that\n * some transitive object dependencies are always required no matter\n * what operations are passed to the `host`.\n *\n * As a user, this operation is hidden so it will not be\n * passed as an op to `onLift` or `onLiftType` methods.\n */\nexport const INFLIGHT_INIT_METHOD_NAME = \"$inflight_init\";\n\n/**\n * Inflight closures are liftable objects that have a single inflight\n * method called \"handle\". This method contains the inflight code\n * that will be executed by the inflight host.\n */\nconst INFLIGHT_CLOSURE_HANDLE_METHOD = \"handle\";\n\n/**\n * The prefix used to name inflight closure object types.\n */\nconst INFLIGHT_CLOSURE_TYPE_PREFIX = \"$Closure\";\n\n/**\n * Creates a liftable type from a class or enum\n * @param type The type to lift, Should be a class or enum.\n * @param moduleSpec A module specifier that the type can be imported from. e.g. \"aws-cdk-lib\"\n * @param path The dotted path to the type in the module. e.g. \"aws_s3.Bucket\" to access `require(\"aws-cdk-lib\").aws_s3.Bucket`\n * @returns A liftable type, either the same type or a wrapper\n */\nexport function toLiftableModuleType(\n  type: any,\n  moduleSpec: string,\n  path: string\n) {\n  if (\n    typeof type?._toInflightType === \"function\" ||\n    type?.constructor?.name === \"Object\"\n  ) {\n    return type;\n  } else {\n    return {\n      _toInflightType: () => `require(\"${moduleSpec}\").${path}`,\n    };\n  }\n}\n\nexport function liftObject(obj: any): string {\n  // since typeof(null) is \"object\", we cover all nullity cases (undefined and null) apriori.\n  if (obj == null) {\n    return JSON.stringify(obj);\n  }\n\n  const tokenResolver = getTokenResolver(obj);\n  if (tokenResolver) {\n    return tokenResolver.lift(obj);\n  }\n\n  // if the object is a type, and it has a \"_toInflightType\" method, we use it to serialize\n  // fyi, typeof(obj) in this case is a \"function\".\n  if (typeof obj?._toInflightType === \"function\") {\n    return obj._toInflightType();\n  }\n\n  switch (typeof obj) {\n    case \"string\":\n    case \"boolean\":\n    case \"number\":\n      return JSON.stringify(obj);\n\n    case \"object\":\n      if (Array.isArray(obj)) {\n        return `[${obj.map((o) => liftObject(o)).join(\",\")}]`;\n      }\n\n      if (obj instanceof Set) {\n        return `new Set(${liftObject(Array.from(obj))})`;\n      }\n\n      if (obj instanceof Map) {\n        return `new Map(${liftObject(Array.from(obj))})`;\n      }\n\n      // if the object is a resource (i.e. has a \"_toInflight\" method\"), we use it to serialize\n      // itself.\n      if (typeof (obj as ILiftable)._toInflight === \"function\") {\n        return (obj as ILiftable)._toInflight();\n      }\n\n      // structs are just plain objects\n      if (obj.constructor.name === \"Object\") {\n        const lines = [];\n        lines.push(\"{\");\n        for (const [k, v] of Object.entries(obj)) {\n          lines.push(`\\\"${k.replace(/\"/g, '\\\\\"')}\\\": ${liftObject(v)},`);\n        }\n        lines.push(\"}\");\n        return lines.join(\"\");\n      }\n\n      break;\n  }\n\n  throw new Error(`Unable to lift object of type ${obj?.constructor?.name}`);\n}\n\nexport type LiftMap = Record<string, Array<[any, Array<string>]>>;\nexport type LiftMapNormalized = Record<string, Map<any, Set<string>>>;\n\n/**\n * Merge two matrixes of lifting dependencies.\n *\n * See the unit tests in `lifting.test.ts` for examples.\n */\nexport function mergeLiftDeps(\n  matrix1: LiftMapNormalized = {},\n  matrix2: LiftMapNormalized = {}\n): LiftMapNormalized {\n  const result: LiftMapNormalized = {};\n  for (const [op, deps] of Object.entries(matrix1)) {\n    result[op] = new Map();\n    for (const [obj, objDeps] of deps) {\n      result[op].set(obj, new Set(objDeps));\n    }\n  }\n\n  for (const [op, deps] of Object.entries(matrix2)) {\n    const resultDeps = result[op] ?? new Map();\n    for (const [obj, objDeps] of deps) {\n      const resultObjDeps = resultDeps.get(obj) ?? new Set();\n      for (const dep of objDeps) {\n        resultObjDeps.add(dep);\n      }\n      resultDeps.set(obj, resultObjDeps);\n    }\n    result[op] = resultDeps;\n  }\n\n  return result;\n}\n\n/**\n * Converts a matrix of lifting dependencies from the format emitted by the Wing compiler\n * (using plain objects and arrays) to a denser format (using Maps and Sets),\n * deduplicating object references if needed.\n *\n * The deduplication is needed because the compiler might generate something like:\n * ```\n * [\n *   [obj1, [\"op1\"]],\n *   [obj2, [\"op2\"]],\n * ]\n * ```\n * not knowing that during preflight execution, obj1 and obj2 are the same object.\n * The deduplication will turn this into:\n * ```\n * new Map([obj1, new Set([\"op1\", \"op2\"])])\n * ```\n */\nfunction parseMatrix(data: LiftMap): LiftMapNormalized {\n  const result: LiftMapNormalized = {};\n  for (const [op, pairs] of Object.entries(data)) {\n    result[op] = new Map();\n    for (const [obj, objDeps] of pairs) {\n      if (!result[op].has(obj)) {\n        result[op].set(obj, new Set());\n      }\n      const depSet = result[op].get(obj)!;\n      for (const dep of objDeps) {\n        depSet.add(dep);\n      }\n    }\n  }\n  return result;\n}\n\n// for debugging\n// function printMatrix(data: LiftMapNormalized): string {\n//   const lines = [];\n//   for (const [op, pairs] of Object.entries(data)) {\n//     lines.push(`${op}: {`);\n//     for (const [obj, objDeps] of pairs) {\n//       if (Construct.isConstruct(obj)) {\n//         lines.push(`  ${obj.node.path}: [${[...objDeps]}]`);\n//       } else {\n//         lines.push(`  ${obj?.constructor?.name ?? obj}: [${[...objDeps]}]`);\n//       }\n//     }\n//     lines.push(\"}\");\n//   }\n//   return lines.join(\"\\n\");\n// }\n\n/**\n * Collects all of the objects that need to be lifted for a given object and set of operations, by\n * traversing the object graph.\n *\n * Internally, it keeps track of a queue of objects and corresponding operations that need to be lifted\n * by the inflight host (the explored set), and a queue of objects and operations that need to be\n * explored (the queue). Objects (any JavaScript values) can be re-added to the queue multiple times\n * if new operations are determined as needed by the inflight host.\n *\n * For example, suppose an inflight host needs to call op1 on object A and op2 on object B.\n * In addition, object B needs op3 on object A.\n * The explored set and queue after each step of the main loop is shown below:\n *\n * ```\n * explored: {} | queue: [(A, [op1]), (B, [op2])]\n * explored: {A: [op1]} | queue: [(B, [op2])]\n * explored: {A: [op1], B: [op2]} | queue: [(A, [op3])]\n * explored: {A: [op1, op3], B: [op2]} | queue: []\n */\nexport function collectLifts(\n  initialObj: any,\n  initialOps: Array<string>\n): Map<any, Set<string>> {\n  if (initialOps.includes(INFLIGHT_INIT_METHOD_NAME)) {\n    throw new Error(\n      `The operation ${INFLIGHT_INIT_METHOD_NAME} is implicit and should not be requested explicitly.`\n    );\n  }\n\n  const explored = new Map<any, Set<string>>();\n  const queue = new Array<[any, Array<string>]>([initialObj, [...initialOps]]);\n  const matrixCache = new Map<any, LiftMapNormalized>();\n\n  while (queue.length > 0) {\n    // `obj` and `ops` are the preflight object and operations requested on it\n    let [obj, ops]: [any, Array<string>] = queue.shift()!;\n\n    let newObj = false;\n    if (!explored.has(obj)) {\n      explored.set(obj, new Set());\n      newObj = true;\n    }\n\n    let existingOps = explored.get(obj)!;\n\n    // Filter out any ops that we've already processed for this object.\n    ops = ops.filter((op) => !existingOps.has(op));\n\n    // If there are no ops left and we have already seen the object, skip further processing.\n    if (ops.length === 0 && !newObj) {\n      continue;\n    }\n\n    // Add the new ops to the explored set.\n    for (const op of ops) {\n      existingOps.add(op);\n    }\n\n    // Inspect the object to see if there are any transitive dependency information.\n    // Currently there are a few ways to do this:\n    // - The compiler may generate a _liftMap property on the object\n    // - The compiler may generate a static _liftTypeMap method on a class\n\n    let matrix: LiftMapNormalized;\n    if (matrixCache.has(obj)) {\n      matrix = matrixCache.get(obj)!;\n    } else if (typeof obj === \"object\" && obj._liftMap !== undefined) {\n      matrix = parseMatrix(obj._liftMap ?? {});\n      matrixCache.set(obj, matrix);\n    } else if (\n      typeof obj === \"function\" &&\n      typeof obj._liftTypeMap !== undefined\n    ) {\n      matrix = parseMatrix(obj._liftTypeMap ?? {});\n      matrixCache.set(obj, matrix);\n    } else {\n      // If the object doesn't have any dependency information, we can skip it.\n      // In the future, we might want to do more advanced analysis to\n      // lift collections of objects with onLift methods etc.\n\n      // Before we `continue` to the next iteration, check for some basic collection types\n      // so if the user puts tokens in a collection, they'll get lifted.\n      //\n      // We can't calculate what ops to put for the collection items (for\n      // example, for cases where the items are resources) since the compiler\n      // doesn't produce that information yet.\n\n      let items_to_explore: Iterable<any> = [];\n      if (Array.isArray(obj)) {\n        items_to_explore = obj;\n      } else if (obj instanceof Set) {\n        items_to_explore = obj;\n      } else if (obj instanceof Map) {\n        items_to_explore = obj.values();\n      } else if (typeof obj === \"object\" && obj.constructor.name === \"Object\") {\n        items_to_explore = Object.values(obj);\n      }\n\n      for (const item of items_to_explore) {\n        if (!explored.has(item)) {\n          let item_ops: string[] = [];\n          // If the item is an inflight closure type then implicitly add the \"handle\" operation\n          if (isInflightClosureObject(item)) {\n            item_ops.push(INFLIGHT_CLOSURE_HANDLE_METHOD);\n          }\n          queue.push([item, item_ops]);\n        }\n      }\n      continue;\n    }\n\n    for (const op of [...ops, INFLIGHT_INIT_METHOD_NAME]) {\n      const objDeps = matrix[op];\n\n      // If the op is $inflight_init, then the operation is implicit\n      // so it's okay it's not defined in the matrix\n      if (op === INFLIGHT_INIT_METHOD_NAME && !objDeps) {\n        continue;\n      }\n\n      if (!objDeps) {\n        if (Construct.isConstruct(obj)) {\n          throw new NotImplementedError(\n            `Resource ${obj.node.path} does not support inflight operation ${op}.\\nIt might not be implemented yet.`,\n            { resource: obj.constructor.name, operation: op }\n          );\n        } else {\n          throw new Error(\n            `Unknown operation ${op} requested for object ${obj} (${obj.constructor.name})`\n          );\n        }\n      }\n\n      for (const [depObj, depOps] of objDeps.entries()) {\n        if (depOps.has(INFLIGHT_INIT_METHOD_NAME)) {\n          throw new Error(\n            `The operation ${INFLIGHT_INIT_METHOD_NAME} is implicit and should not be requested explicitly.`\n          );\n        }\n        queue.push([depObj, [...depOps]]);\n      }\n    }\n  }\n\n  return explored;\n}\n\n/**\n * Returns whether the given item is an inflight closure object.\n */\nfunction isInflightClosureObject(item: any): boolean {\n  return (\n    typeof item === \"object\" &&\n    typeof item.constructor === \"function\" &&\n    typeof item.constructor.name === \"string\" &&\n    item.constructor.name.startsWith(INFLIGHT_CLOSURE_TYPE_PREFIX) &&\n    item._liftMap !== undefined &&\n    item._liftMap[INFLIGHT_CLOSURE_HANDLE_METHOD] !== undefined\n  );\n}\n\n/**\n * Represents a type with static methods that may have other things to lift.\n */\nexport interface ILiftableType {\n  /**\n   * Compiler-generated data that describes the dependencies of this object on other\n   * objects. This is used to determine which permissions need to be granted to the\n   * inflight host.\n   * @internal\n   */\n  _liftTypeMap?: LiftMap;\n\n  /**\n   * A hook called by the Wing compiler once for each inflight host that needs to\n   * use this type inflight. The list of requested inflight methods\n   * needed by the inflight host are given by `ops`.\n   *\n   * This method is commonly used for adding permissions, environment variables, or\n   * other capabilities to the inflight host.\n   */\n  onLiftType(host: IInflightHost, ops: string[]): void;\n}\n\n/**\n * Lifting utilities.\n */\nexport class Lifting {\n  /**\n   * Perform the full lifting process on an object.\n   *\n   * Use this instead of calling `onLift` since it will also lift all of the\n   * object's dependencies, and it will ensure that the onLift methods of\n   * all objects are all called at most once.\n   */\n  public static lift(\n    obj: IHostedLiftable,\n    host: IInflightHost,\n    ops: Array<string>\n  ) {\n    // obtain all of the objects that need lifting\n    const lifts = collectLifts(obj, ops);\n\n    // call all of the onLift methods\n    for (const [liftedObj, liftedOps] of lifts) {\n      const tokens = getTokenResolver(liftedObj);\n      if (tokens) {\n        tokens.onLiftValue(host, liftedObj);\n        continue;\n      }\n\n      if (\n        typeof liftedObj === \"object\" &&\n        typeof liftedObj.onLift === \"function\"\n      ) {\n        liftedObj.onLift(host, [...liftedOps]);\n        continue;\n      }\n\n      if (\n        typeof liftedObj === \"function\" &&\n        typeof liftedObj.onLiftType === \"function\"\n      ) {\n        liftedObj.onLiftType(host, [...liftedOps]);\n        continue;\n      }\n\n      // no lift-related methods to call - it's probably a primitive\n      // so no capabilities need to be added to the inflight host\n    }\n  }\n}\n","/// This file is used to generate types within the compiler and make sure they're shared for external usage\n\nimport type { IInflight } from \"../std/resource\";\n\n// re-exporting useful types\nexport { Construct } from \"constructs\";\n\n/** Flag to signify the `inflight` side of a `preflight` object  */\nexport const INFLIGHT_SYMBOL: unique symbol = Symbol(\"@winglang/sdk.inflight\");\n\n/** This symbol is not defined in cloud/secrets.ts due to circular dependencies\n * between cloud/secrets.ts and platform/platform-manager.ts, which need to be revisited\n * in the meantime this dependency inversion is used to avoid the circular dependency\n */\nexport const SECRET_SYMBOL = Symbol(\"@winglang/sdk.cloud.Secret\");\n\n/** `preflight` representation of an `inflight`  */\nexport type Inflight<F extends AsyncFunction> = IInflight & {\n  /** Note: This is not actually callable,\n   *  this is a phantom type to ensure the type information can cross the phase boundary\n   */\n  [INFLIGHT_SYMBOL]?: F;\n};\n\n/** Extract async methods of an object and return them as discriminant types of an array */\nexport type OperationsOf<T> = (keyof Pick<\n  T,\n  {\n    [K in keyof T]: T[K] extends AsyncFunction ? K : never;\n  }[keyof T]\n>)[];\n\nexport type AnyFunction = (...args: any[]) => any;\nexport type AsyncFunction = (...args: any[]) => Promise<any>;\n\n/** An object that contains only valid data for JSON.stringify() */\nexport type Json =\n  | null\n  | string\n  | number\n  | boolean\n  | Json[]\n  | { [key: string]: Json };\n","import { ExecOptions, ExecFileOptions, exec, execFile } from \"child_process\";\nimport { readFileSync } from \"fs\";\nimport { promisify } from \"util\";\n\nconst execPromise = promisify(exec);\nconst execFilePromise = promisify(execFile);\n\nexport function readJsonSync(file: string) {\n  return JSON.parse(readFileSync(file, \"utf-8\"));\n}\n\n/**\n * Normalize windows paths to be posix-like.\n */\nexport function normalPath(path: string) {\n  if (process.platform === \"win32\") {\n    return (\n      path\n        // force posix path separator\n        .replace(/\\\\+/g, \"/\")\n    );\n  } else {\n    return path;\n  }\n}\n\n/**\n * Just a helpful wrapper around `execFile` that returns a promise.\n */\nexport async function runCommand(\n  cmd: string,\n  args: string[],\n  options?: ExecFileOptions\n): Promise<any> {\n  const { stdout } = await execFilePromise(cmd, args, options);\n  return stdout;\n}\n\n/**\n * Just a helpful wrapper around `exec` that returns a promise.\n * This will run commands through the shell, while `runCommand` doesn't.\n */\nexport async function shell(\n  cmd: string,\n  args: string[],\n  options?: ExecOptions\n): Promise<any> {\n  const { stdout } = await execPromise(cmd + \" \" + args.join(\" \"), options);\n  return stdout;\n}\n\nexport function isPath(s: string) {\n  s = normalPath(s);\n  return s.startsWith(\"./\") || s.startsWith(\"../\") || s.startsWith(\"/\");\n}\n","import { basename } from \"path\";\nimport { liftObject, LiftMap, INFLIGHT_INIT_METHOD_NAME } from \"./lifting\";\nimport {\n  AsyncFunction,\n  INFLIGHT_SYMBOL,\n  Inflight,\n  OperationsOf,\n} from \"./types\";\nimport { LiftableRecord, LiftedMap, PickNonFunctions } from \"./utility-types\";\nimport { normalPath } from \"../shared/misc\";\nimport type { IHostedLiftable, ImportInflightOptions } from \"../std/resource\";\n\nlet closureCount = 0;\n\nexport function closureId(): number {\n  return closureCount++;\n}\n\nexport type InflightBindings = Record<string, InflightBinding>;\n\n/**\n * An inflight binding.\n */\nexport interface InflightBinding {\n  /**\n   * The resource or capturable value.\n   */\n  readonly obj: any;\n\n  /**\n   * The list of operations used on the resource.\n   */\n  readonly ops?: string[];\n}\n\n/**\n * Utility class with functions about inflight clients.\n */\nexport class InflightClient {\n  /**\n   * Returns code for creating an inflight client.\n   */\n  public static for(\n    dirname: string,\n    filename: string,\n    clientClass: string,\n    args: string[]\n  ): string {\n    const inflightDir = dirname;\n    const inflightFile = basename(filename).split(\".\")[0] + \".inflight\";\n    return `new (require(\"${normalPath(\n      `${inflightDir}/${inflightFile}`\n    )}\")).${clientClass}(${args.join(\", \")})`;\n  }\n\n  /**\n   * Returns code for implementing `_toInflightType()`.\n   */\n  public static forType(filename: string, clientClass: string): string {\n    return `require(\"${normalPath(filename)}\").${clientClass}`;\n  }\n\n  private constructor() {}\n}\n\n/**\n * Prepares preflight objects for use in inflight functions.\n *\n * Conventionally, this is used by passing in a `const` object to bind it with the same name\n *\n * ```ts\n * const bucket = new cloud.Bucket(app, \"Bucket\");\n * const number = 5;\n *\n * lift({ bucket, number })\n *   .inflight(({ bucket, number }) => { ... }))\n * ```\n *\n * However, the name is not required to match the variable in the current scope.\n *\n * This is especially useful/necessary when lifting data via a reference or some other expression\n *\n * ```ts\n * const bucket = new cloud.Bucket(app, \"Bucket\");\n *\n * lift({ bkt: bucket, sum: 2 + 2, field: bucket.field })\n *   .inflight(({ bkt, sum, field }) => { ... }))\n * ```\n */\nexport function lift<TToLift extends LiftableRecord>(\n  captures: TToLift\n): Lifter<LiftedMap<TToLift>, {}> {\n  return new Lifter().lift(captures);\n}\n\n/**\n * Creates a inflight function.\n *\n * This function must not reference any variables outside of its scope.\n * If needed, use `lift` to bind variables to the scope of the function.\n *\n * Built-in NodeJS globals are available, such as `console` and `process`.\n * @wing inflight\n */\nexport function inflight<TFunction extends AsyncFunction>(\n  fn: (ctx: {}, ...args: Parameters<TFunction>) => ReturnType<TFunction>\n) {\n  return new Lifter().inflight(fn);\n}\n\n/**\n * Create an inflight function from a string.\n */\nexport function importInflight(\n  /**\n   * Raw JavaScript to use as the inflight function.\n   */\n  inflightText: string,\n\n  /**\n   * The lifts the JS needs to be able to access.\n   */\n  lifts?: ImportInflightOptions[\"lifts\"]\n) {\n  const newLifts: Record<string, any> = {};\n  const newGrants: Record<string, string[]> = {};\n\n  // convert the lifts to the correct format for the Lifter\n  for (const liftAnnotation of lifts ?? []) {\n    if (liftAnnotation.alias === undefined) {\n      throw new Error(\"The alias field is required for all lifts\");\n    }\n\n    newLifts[liftAnnotation.alias] = liftAnnotation.obj;\n    if (liftAnnotation.ops) {\n      newGrants[liftAnnotation.alias] = liftAnnotation.ops;\n    }\n  }\n\n  return (\n    lift(newLifts)\n      .grant(newGrants)\n      // cast as any because the inflight has already been pre-serialized\n      .inflight(inflightText as any)\n  );\n}\n\n/**\n * Manages the liftable objects and operations for an inflight function.\n */\nclass Lifter<\n  TLifted extends Record<string, any>,\n  TOperations extends Record<string, string[]>\n> {\n  constructor(\n    private lifts: LiftableRecord = {},\n    private grants: Record<string, string[]> = {}\n  ) {}\n\n  /**\n   * Add additional liftable objects to the scope of the inflight function.\n   * Any existing liftable objects with the same name will be overwritten.\n   *\n   * Conventionally, this is used by passing in a `const` object to bind it with the same name\n   *\n   * ```ts\n   * const bucket = new cloud.Bucket(app, \"Bucket\");\n   * const number = 5;\n   *\n   * lift({ bucket, number })\n   *   .inflight(({ bucket, number }) => { ... }))\n   * ```\n   *\n   * However, the name is not required to match the variable in the current scope.\n   *\n   * This is especially useful/necessary when lifting data via a reference or some other expression\n   *\n   * ```ts\n   * const bucket = new cloud.Bucket(app, \"Bucket\");\n   *\n   * lift({ bkt: bucket, sum: 2 + 2, field: bucket.field })\n   *   .inflight(({ bkt, sum, field }) => { ... }))\n   * ```\n   */\n  public lift<TWillLift extends LiftableRecord>(captures: TWillLift) {\n    return new Lifter<\n      Omit<TLifted, keyof TWillLift> & LiftedMap<TWillLift>,\n      TOperations\n    >(\n      {\n        ...this.lifts,\n        ...captures,\n      },\n      this.grants\n    );\n  }\n\n  /**\n   * Grant permissions for lifted resources.\n   *\n   * By default, all all possible methods are granted to lifted resources.\n   * This function restricts those:\n   *\n   * ```ts\n   * const bucket = new cloud.Bucket(app, \"Bucket\");\n   *\n   * lift({ bucket })\n   *   .grant({ bucket: [\"get\"] })\n   *   .inflight(({ bucket }) => {\n   *     await bucket.get(\"key\");\n   *     await bucket.set(\"key\", \"value\"); // Error: set is not granted\n   *   });\n   * ```\n   *\n   * fields are always accessible, even if not granted.\n   */\n  public grant<\n    TNewOps extends Partial<{\n      [K in keyof TLifted]: OperationsOf<TLifted[K]>;\n    }>\n  >(grants: TNewOps) {\n    return new Lifter<TLifted, Omit<TOperations, keyof TNewOps> & TNewOps>(\n      this.lifts,\n      {\n        ...this.grants,\n        ...grants,\n      }\n    );\n  }\n\n  /**\n   * Create an inflight function with the available lifted data.\n   *\n   * This function must not reference any variables outside of its scope.\n   * If needed, use `lift` again to bind variables to the scope of the function.\n   * Bound variables will be available as properties on the `ctx` object passed as the first argument to the function.\n   *\n   * Built-in NodeJS globals are available, such as `console` and `process`.\n   * @wing inflight\n   */\n  public inflight<TFunction extends AsyncFunction>(\n    fn: (\n      /** All lifted data available in this inflight */\n      ctx: // Get all the lifted types which were not explicitly granted\n      Omit<TLifted, keyof TOperations> & {\n        // For each of the granted types, get the lifted type with only the granted operations available (and any fields as well)\n        [K in keyof TOperations &\n          keyof TLifted]: TOperations[K] extends (infer TGrantedOps extends keyof TLifted[K])[]\n          ? PickNonFunctions<TLifted[K]> & Pick<TLifted[K], TGrantedOps>\n          : TLifted[K];\n      },\n      ...args: Parameters<TFunction>\n    ) => ReturnType<TFunction>\n  ): Inflight<TFunction> {\n    // This is a simplified version of the Wing compiler's _liftMap generation\n    // It specifies what transitive permissions need to be added based on what\n    // inflight methods are called on an object\n    // The SDK models inflight functions as objects with a \"handle\" property,\n    // so here we annotate that \"handle\" needs all of the required permissions\n    const _liftMap: LiftMap = { handle: [] };\n    for (const [key, obj] of Object.entries(this.lifts)) {\n      const knownOps =\n        this.grants[key] ??\n        Object.keys((obj as IHostedLiftable)._liftMap ?? {}).filter(\n          (x) => x !== INFLIGHT_INIT_METHOD_NAME // filter \"$inflight_init\"\n        );\n\n      _liftMap.handle.push([obj, knownOps]);\n    }\n\n    return {\n      _id: closureId(),\n      _toInflight: () => {\n        // Extremely advanced function serialization\n        const serializedFunction = fn.toString();\n\n        return `\\\n(await (async () => {\n  const $func = ${serializedFunction}\n  const $ctx = {\n  ${Object.entries(this.lifts)\n    .map(([name, liftable]) => `${name}: ${liftObject(liftable)}`)\n    .join(\",\\n\")}\n  };\n  let newFunction = async (...args) => {\n    return $func($ctx, ...args);\n  };\n  newFunction.handle = newFunction;\n  return newFunction;\n}\n)())`;\n      },\n      _liftMap,\n      // @ts-expect-error This function's type doesn't actually match, but it will just throw anyways\n      [INFLIGHT_SYMBOL]: () => {\n        throw new Error(\n          \"This is a inflight function and can only be invoked while inflight\"\n        );\n      },\n    };\n  }\n}\n","import { ILiftable } from \"./resource\";\nimport { InflightClient } from \"../core/inflight\";\nimport { normalPath } from \"../shared/misc\";\n\n/**\n * Interface that is used for setting Datetime date\n */\nexport interface DatetimeComponents {\n  /**\n   * Year\n   */\n  readonly year: number;\n  /**\n   * Month\n   */\n  readonly month: number;\n  /**\n   * Day\n   */\n  readonly day: number;\n  /**\n   * Hours\n   */\n  readonly hour: number;\n  /**\n   * Minutes\n   */\n  readonly min: number;\n  /**\n   * Seconds\n   */\n  readonly sec: number;\n  /**\n   * Milliseconds\n   */\n  readonly ms: number;\n  /**\n   *  Timezone offset in minutes from UTC\n   */\n  readonly tz: number;\n}\n\n/**\n * Represents a local or UTC date object\n * @wingType datetime\n */\nexport class Datetime implements ILiftable {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n  /**\n   * Create a Datetime from UTC timezone\n   *\n   * @returns a new `Datetime` from current time in UTC timezone\n   */\n  public static utcNow(): Datetime {\n    return new Datetime();\n  }\n\n  /**\n   * Create a Datetime from local system timezone\n   *\n   * @returns a new `Datetime` from current time in system timezone\n   */\n  public static systemNow(): Datetime {\n    const date = new Date();\n    date.setTime(date.getTime() - date.getTimezoneOffset() * 60 * 1000);\n\n    return new Datetime(date, date.getTimezoneOffset());\n  }\n\n  /**\n   * Create a Datetime from an ISO-8601 string\n   *\n   * @returns a new `Datetime` in UTC timezone\n   * @param iso ISO-8601 string\n   */\n  public static fromIso(iso: string): Datetime {\n    return new Datetime(new Date(iso));\n  }\n\n  /**\n   * Create a Datetime from a JavaScript Date object.\n   *\n   * @param date The JavaScript Date object.\n   * @returns a new `Datetime` instance.\n   */\n  public static fromDate(date: Date): Datetime {\n    return this.fromIso(date.toISOString());\n  }\n\n  /**\n   * Create a Datetime from Datetime components\n   *\n   * @param c DatetimeComponents\n   * @returns a new `Datetime`\n   */\n  public static fromComponents(c: DatetimeComponents): Datetime {\n    const date = new Date(\n      Date.UTC(c.year, c.month, c.day, c.hour, c.min, c.sec, c.ms)\n    );\n\n    return new Datetime(date, c.tz);\n  }\n\n  /** @internal */\n  private readonly _date: Date;\n  /** @internal */\n  private readonly _timezoneOffset: number = 0;\n\n  private constructor(date: Date = new Date(), timezoneOffset = 0) {\n    this._date = date;\n    this._timezoneOffset = timezoneOffset;\n  }\n\n  /** @internal */\n  public _toInflight(): string {\n    return `(require(\"${normalPath(\n      __filename\n    )}\").Datetime.fromIso(\"${this.toIso()}\"))`;\n  }\n\n  /**\n   * Return a timestamp of non-leap year seconds since epoch\n   *\n   * @returns a number representing the current timestamp in seconds\n   */\n  public get timestamp(): number {\n    return this.timestampMs / 1000;\n  }\n\n  /**\n   * Return a timestamp of non-leap year milliseconds since epoch\n   *\n   * @returns a number representing the current timestamp in milliseconds\n   */\n  public get timestampMs(): number {\n    // since converting between timezones/ declaring a date in a timezone other than the local or UTC\n    // isn't native to js, we keep the date in a UTC time, then retrieving back the the original timestamp,\n    // this way the date components (hours, month, day, minutes, etc..) are persistent\n    // and retrieved in the same order for all of the different constructing methods and the timestamp is correct.\n    return this._date.valueOf() + this._timezoneOffset * 60 * 1000;\n  }\n\n  /**\n   * Returns the hour of the local machine time or in utc\n   *\n   * @returns a number representing the datetime's hour\n   */\n  public get hours(): number {\n    return this._date.getUTCHours();\n  }\n\n  /**\n   * Returns the minute of the local machine time or in utc\n   *\n   * @returns a number representing the datetime's minute\n   */\n  public get min(): number {\n    return this._date.getUTCMinutes();\n  }\n\n  /**\n   * Returns the seconds of the local machine time or in utc\n   *\n   * @returns a number representing the datetime's seconds\n   */\n  public get sec(): number {\n    return this._date.getUTCSeconds();\n  }\n\n  /**\n   * Returns the milliseconds of the local machine time or in utc\n   *  *\n   * @returns a number representing the datetime's milliseconds\n   */\n  public get ms(): number {\n    return this._date.getUTCMilliseconds();\n  }\n\n  /**\n   * Returns the day of month in the local machine time or in utc (1 - 31)\n   *\n   * @returns a number representing the datetime's day of month\n   */\n  public get dayOfMonth(): number {\n    return this._date.getUTCDate();\n  }\n\n  /**\n   * Returns the day in month of the local machine time or in utc (0 - 6)\n   *\n   * @returns a number representing the datetime's day of week\n   */\n  public get dayOfWeek(): number {\n    return this._date.getUTCDay();\n  }\n\n  /**\n   * Returns the month of the local machine time or in utc (0 - 11)\n   *\n   * @returns a number representing the datetime's month\n   */\n  public get month(): number {\n    return this._date.getUTCMonth();\n  }\n\n  /**\n   * Returns the year of the local machine time or in utc\n   *\n   * @returns a number representing the datetime's year\n   */\n  public get year(): number {\n    return this._date.getUTCFullYear();\n  }\n\n  /**\n   * Returns the offset in minutes from UTC\n   *\n   * @returns a number representing the datetime's offset in minutes from UTC\n   */\n  public get timezone(): number {\n    return this._timezoneOffset;\n  }\n\n  /**\n   * Returns a Datetime represents the same date in utc\n   *\n   * @returns a datetime representing the datetime's date in UTC\n   */\n  public toUtc(): Datetime {\n    return new Datetime(new Date(this.timestampMs));\n  }\n\n  /**\n   * Returns ISO-8601 string\n   *\n   * @returns a ISO-8601 string representation of the datetime\n   */\n  public toIso(): string {\n    return new Date(this.timestampMs).toISOString();\n  }\n}\n","import { ILiftable } from \"./resource\";\nimport { InflightClient } from \"../core\";\nimport { normalPath } from \"../shared/misc\";\n\n/**\n * Represents a length of time.\n * @wingType duration\n */\nexport class Duration implements ILiftable {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  /**\n   * Create a Duration representing an amount of years\n   *\n   * @param amount the amount of Years the `Duration` will represent.\n   * @returns a new `Duration` representing `amount` Years.\n   */\n  public static fromYears(amount: number): Duration {\n    return new Duration(amount * 60 * 60 * 24 * 365);\n  }\n\n  /**\n   * Create a Duration representing an amount of months\n   *\n   * @param amount the amount of Months the `Duration` will represent.\n   * @returns a new `Duration` representing `amount` Months.\n   */\n  public static fromMonths(amount: number): Duration {\n    return new Duration((amount * 60 * 60 * 24 * 365) / 12);\n  }\n\n  /**\n   * Create a Duration representing an amount of days\n   *\n   * @param amount the amount of Days the `Duration` will represent.\n   * @returns a new `Duration` representing `amount` Days.\n   */\n  public static fromDays(amount: number): Duration {\n    return new Duration(amount * 60 * 60 * 24);\n  }\n\n  /**\n   * Create a Duration representing an amount of hours\n   *\n   * @param amount the amount of Hours the `Duration` will represent.\n   * @returns a new `Duration` representing `amount` Hours.\n   */\n  public static fromHours(amount: number): Duration {\n    return new Duration(amount * 60 * 60);\n  }\n\n  /**\n   * Create a Duration representing an amount of minutes\n   *\n   * @param amount the amount of Minutes the `Duration` will represent.\n   * @returns a new `Duration` representing `amount` Minutes.\n   */\n  public static fromMinutes(amount: number): Duration {\n    return new Duration(amount * 60);\n  }\n\n  /**\n   * Create a Duration representing an amount of seconds\n   *\n   * @param amount the amount of Seconds the `Duration` will represent.\n   * @returns a new `Duration` representing `amount` Seconds.\n   */\n  public static fromSeconds(amount: number): Duration {\n    return new Duration(amount);\n  }\n\n  /**\n   * Create a Duration representing an amount of milliseconds\n   *\n   * @param amount the amount of Milliseconds the `Duration` will represent.\n   * @returns a new `Duration` representing `amount` Milliseconds.\n   */\n  public static fromMilliseconds(amount: number): Duration {\n    return new Duration(amount / 1000);\n  }\n\n  /**\n   * Return the total number of seconds in this Duration\n   *\n   * @returns the value of this `Duration` expressed in Seconds.\n   */\n  public readonly seconds: number;\n\n  private constructor(seconds: number) {\n    this.seconds = seconds;\n  }\n\n  /**\n   * Return the total number of milliseconds in this Duration\n   *\n   * @returns the value of this `Duration` expressed in Milliseconds.\n   */\n  public get milliseconds() {\n    return this.seconds * 1000;\n  }\n\n  /**\n   * Return the total number of minutes in this Duration\n   *\n   * @returns the value of this `Duration` expressed in Minutes.\n   */\n  public get minutes() {\n    return this.seconds / 60;\n  }\n\n  /**\n   * Return the total number of hours in this Duration\n   *\n   * @returns the value of this `Duration` expressed in Hours.\n   */\n  public get hours() {\n    return this.minutes / 60;\n  }\n\n  /**\n   * Return the total number of days in this Duration\n   *\n   * @returns the value of this `Duration` expressed in Days.\n   */\n  public get days() {\n    return this.hours / 24;\n  }\n\n  /**\n   * Return the total number of months in this Duration\n   *\n   * @returns the value of this `Duration` expressed in Months.\n   */\n  public get months() {\n    return this.years * 12;\n  }\n\n  /**\n   * Return the total number of years in this Duration\n   *\n   * @returns the value of this `Duration` expressed in Years.\n   */\n  public get years() {\n    return this.days / 365;\n  }\n\n  /** @internal */\n  public _toInflight(): string {\n    return `(new (require(\"${normalPath(__filename)}\").Duration)(${\n      this.seconds\n    }))`;\n  }\n}\n","/**\n * Generic type argument. This type is replaced at compile time.\n *\n * @hidden\n * @skipDocs\n * @wingType  &lt;T&gt;\n */\nexport class T1 {}\n","import { InflightClient } from \"../core\";\n\n/**\n * Options for stringify() method.\n */\nexport interface JsonStringifyOptions {\n  /** Indentation spaces number */\n  readonly indent: number;\n}\n\n/**\n * Options for validating Json\n */\nexport interface JsonValidationOptions {\n  /** Unsafe mode to skip validation (may lead to runtime errors) */\n  readonly unsafe?: boolean;\n}\n\n/**\n * Json entry representation\n */\nexport interface JsonEntry {\n  /** The entry key */\n  readonly key: string;\n  /** The entry value */\n  readonly value: Json;\n}\n\n/**\n * Immutable Json\n */\nexport class Json {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  /**\n   * Returns the keys from the Json.\n   *\n   * @macro Object.keys($args$)\n   *\n   * @param json map to get the keys from\n   * @returns the keys as Array<String>\n   */\n  public static keys(json: Json | MutJson): string[] {\n    json;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the values from the Json.\n   *\n   * @macro Object.values($args$)\n   *\n   * @param json map to get the values from\n   * @returns the values as Array<Json>\n   */\n  public static values(json: Json): Json[] {\n    json;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the entries from the Json.\n   *\n   * @param json map to get the entries from\n   * @returns the entries as Array<JsonEntry>\n   */\n  public static entries(json: Json): JsonEntry[] {\n    return Object.entries(json).map(([key, value]) => ({ key, value }));\n  }\n\n  /**\n   * Deletes a key in a given Json\n   *\n   * @macro ((json, key) => { delete json[key]; })($args$)\n   *\n   * @param json to delete key from\n   * @param key the key to delete\n   */\n  public static delete(json: MutJson, key: string): void {\n    json;\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Formats Json as string\n   *\n   * @macro ((json, opts) => { return JSON.stringify(json, null, opts?.indent) })($args$)\n   *\n   * @param json to format as string\n   * @returns string representation of the Json\n   */\n  public static stringify(\n    json: Json | MutJson,\n    options?: JsonStringifyOptions\n  ): string {\n    json;\n    options;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Creates an immutable deep copy of the Json.\n   *\n   * @macro JSON.parse(JSON.stringify($args$))\n   *\n   * @param json to copy\n   * @returns the immutable copy of the Json\n   */\n  public static deepCopy(json: MutJson): Json {\n    json;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Creates a mutable deep copy of the Json.\n   *\n   * @macro JSON.parse(JSON.stringify($args$))\n   *\n   * @param json to copy\n   * @returns the mutable copy of the Json\n   */\n  public static deepCopyMut(json: Json): MutJson {\n    json;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Parse a string into a Json\n   *\n   * @macro JSON.parse($args$)\n   *\n   * @param str to parse as Json\n   * @returns Json representation of the string\n   */\n  public static parse(str: string): Json {\n    str;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Try to parse a string into a Json\n   *\n   * @macro ((args) => { try { return (args === undefined) ? undefined : JSON.parse(args); } catch (err) { return undefined; } })($args$)\n   *\n   * @param str to parse as Json\n   * @returns Json representation of the string or undefined if string is not parsable\n   */\n  public static tryParse(str?: string): Json | undefined {\n    str;\n    throw new Error(\"Macro\");\n  }\n  private constructor() {}\n  /**\n   * Checks if a Json object has a given key\n   *\n   * @macro ((obj, key) => { return obj.hasOwnProperty(key); })($self$,$args$)\n   *\n   * @param key The key to check\n   * @returns Boolean value corresponding to whether the key exists\n   */\n  public has(key: string): boolean {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the value associated with the specified Json key\n   *\n   * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error(`Json property \"${args}\" does not exist`); return obj[args] })($self$, $args$)\n   *\n   * @param key The key of the Json property\n   * @returns The value associated with the specified Json key\n   * @throws Json property does not exist if the given key is not part of an existing property\n   */\n  public get(key: string): Json {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a specified element at a given index from Json Array\n   *\n   * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error(\"Index out of bounds\"); return obj[args] })($self$, $args$)\n   *\n   * @param index The index of the element in the Json Array to return\n   * @returns The element at given index in Json Array\n   * @throws index out of bounds error if the given index does not exist for the Json Array\n   */\n  public getAt(index: number): Json {\n    index;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Optionally returns an specified element from the Json.\n   *\n   * @macro ($self$)?.[$args$]\n   *\n   * @param key The key of the element to return\n   * @returns The element associated with the specified key, or undefined if the key can't be found\n   */\n  public tryGet(key: string): Json | undefined {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Optionally returns a specified element at a given index from Json Array\n   *\n   * @macro ($self$)?.[$args$]\n   *\n   * @param index The index of the element in the Json Array to return\n   * @returns The element at given index in Json Array, or undefined if index is not valid\n   */\n  public tryGetAt(index: number): Json | undefined {\n    index;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to string if possible.\n   *\n   * @macro ((arg) => { if (typeof arg !== \"string\") {throw new Error(\"unable to parse \" + typeof arg + \" \" + arg + \" as a string\")}; return JSON.parse(JSON.stringify(arg)) })($self$)\n   *\n   * @returns a string.\n   */\n  public asStr(): string {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to string if possible.\n   *\n   * @macro ((arg) => { return (typeof arg === \"string\") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)\n   *\n   * @returns a string.\n   */\n  public tryAsStr(): string | undefined {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to number if possible.\n   *\n   * @macro ((arg) => { if (typeof arg !== \"number\") {throw new Error(\"unable to parse \" + typeof arg + \" \" + arg + \" as a number\")}; return JSON.parse(JSON.stringify(arg)) })($self$)\n   *\n   * @returns a number.\n   */\n  public asNum(): number {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to number if possible.\n   *\n   * @macro ((arg) => { return (typeof arg === \"number\") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)\n   *\n   * @returns a number.\n   */\n  public tryAsNum(): number | undefined {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to boolean if possible.\n   *\n   * @macro ((arg) => { if (typeof arg !== \"boolean\") {throw new Error(\"unable to parse \" + typeof arg + \" \" + arg + \" as a boolean\")}; return JSON.parse(JSON.stringify(arg)) })($self$)\n   *\n   * @returns a boolean.\n   */\n  public asBool(): boolean {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to boolean if possible.\n   *\n   * @macro ((arg) => { return (typeof arg === \"boolean\") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)\n   *\n   * @returns a boolean.\n   */\n  public tryAsBool(): boolean | undefined {\n    throw new Error(\"Macro\");\n  }\n}\n\n/**\n * Mutable Json\n */\nexport class MutJson {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  private constructor() {}\n\n  /**\n   * Returns the value associated with the specified Json key\n   *\n   * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error(`Json property \"${args}\" does not exist`); return obj[args] })($self$, $args$)\n   *\n   * @param key The key of the Json property\n   * @returns The value associated with the specified Json key\n   * @throws Json property does not exist if the given key is not part of an existing property\n   */\n  public get(key: string): MutJson {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a specified element at a given index from MutJson Array\n   *\n   * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error(\"Index out of bounds\"); return obj[args] })($self$, $args$)\n   *\n   * @param index The index of the element in the MutJson Array to return\n   * @returns The element at given index in MutJson Array\n   * @throws index out of bounds error if the given index does not exist for the MutJson Array\n   */\n  public getAt(index: number): MutJson {\n    index;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Adds or updates an element in MutJson with a specific key and value\n   *\n   * @macro ((obj, key, value) => { obj[key] = value; })($self$, $args$)\n   *\n   * @param key The key of the element to add\n   * @param value The value of the element to add\n   */\n  public set(key: string, value: MutJson): void {\n    key;\n    value;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Set element in MutJson Array with a specific key and value\n   *\n   * @macro ((obj, idx, value) => { obj[idx] = value; })($self$, $args$)\n   *\n   * @param value The value of the element to set\n   */\n  public setAt(index: number, value: MutJson): void {\n    index;\n    value;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Optionally returns an specified element from the Json.\n   *\n   * @macro ($self$)?.[$args$]\n   *\n   * @param key The key of the element to return\n   * @returns The element associated with the specified key, or undefined if the key can't be found\n   */\n  public tryGet(key: string): MutJson | undefined {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Optionally returns a specified element at a given index from Json Array\n   *\n   * @macro ($self$)?.[$args$]\n   *\n   * @param index The index of the element in the Json Array to return\n   * @returns The element at given index in Json Array, or undefined if index is not valid\n   */\n  public tryGetAt(index: number): MutJson | undefined {\n    index;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to string if possible.\n   *\n   * @macro ((arg) => { if (typeof arg !== \"string\") {throw new Error(\"unable to parse \" + typeof arg + \" \" + arg + \" as a string\")}; return JSON.parse(JSON.stringify(arg)) })($self$)\n   *\n   * @returns a string.\n   */\n  public asStr(): string {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to string if possible.\n   *\n   * @macro ((arg) => { return (typeof arg === \"string\") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)\n   *\n   * @returns a string.\n   */\n  public tryAsStr(): string | undefined {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to number if possible.\n   *\n   * @macro ((arg) => { if (typeof arg !== \"number\") {throw new Error(\"unable to parse \" + typeof arg + \" \" + arg + \" as a number\")}; return JSON.parse(JSON.stringify(arg)) })($self$)\n   *\n   * @returns a number.\n   */\n  public asNum(): number {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to number if possible.\n   *\n   * @macro ((arg) => { return (typeof arg === \"number\") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)\n   *\n   * @returns a number.\n   */\n  public tryAsNum(): number | undefined {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to boolean if possible.\n   *\n   * @macro ((arg) => { if (typeof arg !== \"boolean\") {throw new Error(\"unable to parse \" + typeof arg + \" \" + arg + \" as a boolean\")}; return JSON.parse(JSON.stringify(arg)) })($self$)\n   *\n   * @returns a boolean.\n   */\n  public asBool(): boolean {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Convert Json element to boolean if possible.\n   *\n   * @macro ((arg) => { return (typeof arg === \"boolean\") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)\n   *\n   * @returns a boolean.\n   */\n  public tryAsBool(): boolean | undefined {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Removes the specified element from a map.\n   *\n   * @macro (delete ($self$)[$args$])\n   *\n   * @param key The key\n   * @returns true if the given key is no longer present\n   */\n\n  public delete(key: string): boolean {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Checks if a Json object has a given key\n   *\n   * @macro ((obj, key) => { return obj.hasOwnProperty(key); })($self$,$args$)\n   *\n   * @param key The key to check\n   * @returns Boolean value corresponding to whether the key exists\n   */\n  public has(key: string): boolean {\n    key;\n    throw new Error(\"Macro\");\n  }\n}\n","// These classes are used by Wing to provide JSII subsets of the JS Map class.\n// They should not be consumed directly by users.\n// TODO: These should be interfaces, currently Wing does not support interface JSII imports\n\nimport { Array } from \"./array\";\nimport { T1 } from \"./generics\";\nimport { InflightClient } from \"../core\";\n\n/**\n * Array entry representation\n *\n * @typeparam T1\n */\nexport interface ArrayEntry {\n  /** The entry key */\n  readonly key: string;\n  /** The entry value */\n  readonly value: T1;\n}\n\n/**\n * Immutable Map\n *\n * @typeparam T1\n */\nexport class Map {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  private constructor() {}\n\n  /**\n   * Returns the number of elements in the map.\n   *\n   * TODO: For now this has to be a method rather than a getter as macros only work on methods https://github.com/winglang/wing/issues/1658\n   * @macro Object.keys($self$).length\n   *\n   * @returns The number of elements in map\n   */\n  public size(): number {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a specified element from the map.\n   *\n   * If the value that is associated to the provided key is an object, then you will get a reference\n   * to that object and any change made to that object will effectively modify it inside the map.\n   *\n   * @macro ((obj, key) => { if (!(key in obj)) throw new Error(`Map does not contain key: \"${key}\"`); return obj[key]; })($self$, $args$)\n   *\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or throw an error if the key can't be found\n   */\n  public get(key: string): T1 {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Optionally returns a specified element from the map.\n   *\n   * @macro ($self$)[$args$]\n   *\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found\n   */\n  public tryGet(key: string): T1 | undefined {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   *\n   * @macro ($args$ in ($self$))\n   *\n   * @param key The key of the element to test for presence\n   * @returns true if an element with the specified key exists in the map; otherwise false.\n   */\n  public has(key: string): boolean {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Create a mutable shallow copy of this map\n   *\n   * @macro {...($self$)}\n   *\n   * @returns a MutableMap with the same values as this map\n   */\n  public copyMut(): MutMap {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the keys of this map\n   *\n   * @macro Object.keys($self$)\n   *\n   * @returns an array containing the keys of this map\n   */\n  public keys(): string[] {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the values of this map\n   *\n   * @macro Object.values($self$)\n   *\n   * @returns an array of type T containing the values of this map\n   */\n  public values(): Array {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the entries from the map.\n   *\n   * @macro Object.entries($self$).map(([key, value]) => ({ key, value }))\n   *\n   * @returns the entries as Array<ArrayEntry>\n   */\n  public entries(): ArrayEntry[] {\n    throw new Error(\"Macro\");\n  }\n}\n\n/**\n * Mutable Map\n *\n * @typeparam T1\n */\nexport class MutMap {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  private constructor() {}\n\n  /**\n   * Returns the number of elements in the map.\n   *\n   * TODO: For now this has to be a method rather than a getter as macros only work on methods https://github.com/winglang/wing/issues/1658\n   * @macro Object.keys($self$).length\n   *\n   * @returns The number of elements in map\n   */\n  public size(): number {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Removes all elements\n   *\n   * @macro ((map) => { for(const k in map){delete map[k]}; })($self$)\n   */\n  public clear(): void {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Create an immutable shallow copy of this map\n   *\n   * @macro ({...($self$)})\n   *\n   * @returns an ImmutableMap with the same values as this map\n   */\n  public copy(): Map {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Removes the specified element from a map.\n   *\n   * @macro (delete ($self$)[$args$])\n   *\n   * @param key The key\n   * @returns true if the given key is no longer present\n   */\n  public delete(key: string): boolean {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a specified element from the map.\n   *\n   * If the value that is associated to the provided key is an object, then you will get a reference\n   * to that object and any change made to that object will effectively modify it inside the map.\n   *\n   * @macro ((obj, key) => { if (!(key in obj)) throw new Error(`MutMap does not contain key: \"${key}\"`); return obj[key]; })($self$, $args$)\n   *\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or throw an error if the key can't be found\n   */\n  public get(key: string): T1 {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Optionally returns a specified element from the map.\n   *\n   * @macro ($self$)[$args$]\n   *\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found\n   */\n  public tryGet(key: string): T1 | undefined {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   *\n   * @macro ($args$ in ($self$))\n   *\n   * @param key The key of the element to test for presence\n   * @returns true if an element with the specified key exists in the map; otherwise false.\n   */\n  public has(key: string): boolean {\n    key;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Adds or updates an entry in a Map object with a specified key and a value.\n   *\n   * TODO: revisit this macro after we support indexed args https://github.com/winglang/wing/issues/1659\n   * @macro ((obj, args) => { obj[args[0]] = args[1]; })($self$, [$args$])\n   *\n   * @param key The key of the element to add\n   * @param value The value of the element to add\n   */\n  public set(key: string, value: T1): void {\n    key;\n    value;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the keys of this map\n   *\n   * @macro Object.keys($self$)\n   *\n   * @returns an array containing the keys of this map\n   */\n  public keys(): string[] {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the values of this map\n   *\n   * @macro Object.values($self$)\n   *\n   * @returns an array containing of type T the values of this map\n   */\n  public values(): Array {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns the entries from the map.\n   *\n   * @macro Object.entries($self$).map(([key, value]) => ({ key, value }))\n   *\n   * @returns the entries as Array<ArrayEntry>\n   */\n  public entries(): ArrayEntry[] {\n    throw new Error(\"Macro\");\n  }\n}\n","import * as fs from \"fs\";\nimport * as path from \"path\";\nimport { IConstruct } from \"constructs\";\n\nconst CONNECTIONS_SYMBOL = Symbol.for(\"@winglang/sdk.core.Connections\");\n\nexport const CONNECTIONS_FILE_PATH = \"connections.json\";\n\n/**\n * Connections are a way to track relationships between constructs.\n */\nexport class Connections {\n  /**\n   * Return the matching Connections of the given construct tree.\n   */\n  public static of(construct: IConstruct): Connections {\n    let connections = (construct.node.root as any)[CONNECTIONS_SYMBOL];\n\n    if (!connections) {\n      connections = new Connections();\n      (construct.node.root as any)[CONNECTIONS_SYMBOL] = connections;\n    }\n\n    return connections;\n  }\n\n  private readonly _connections: Connection[] = [];\n  private constructor() {}\n\n  /**\n   * Adds a connection between two constructs. A connection is a piece of\n   * metadata describing how one construct is related to another construct.\n   */\n  public add(props: AddConnectionProps) {\n    const connection = props;\n\n    // avoid duplicate connections\n    if (\n      this._connections.some(\n        (c) =>\n          c.source === connection.source &&\n          c.sourceOp === connection.sourceOp &&\n          c.target === connection.target &&\n          c.targetOp === connection.targetOp &&\n          c.name === connection.name\n      )\n    ) {\n      return;\n    }\n\n    this._connections.push(connection);\n  }\n\n  /**\n   * Synthesize `connections.json` to the given directory.\n   */\n  public synth(outdir: string) {\n    const connections = this._connections.map((c) => ({\n      source: c.source.node.path,\n      sourceOp: c.sourceOp,\n      target: c.target.node.path,\n      targetOp: c.targetOp,\n      name: c.name,\n    }));\n\n    const tree = {\n      version: \"connections-0.1\",\n      connections,\n    };\n\n    fs.writeFileSync(\n      path.join(outdir, CONNECTIONS_FILE_PATH),\n      JSON.stringify(tree, undefined, 2),\n      { encoding: \"utf8\" }\n    );\n  }\n}\n\n/**\n * Props for `Connections.add`.\n */\nexport interface AddConnectionProps {\n  /**\n   * The source of the connection.\n   */\n  readonly source: IConstruct;\n\n  /**\n   * An operation that the source object supports.\n   * @default - no operation\n   */\n  readonly sourceOp?: string;\n\n  /**\n   * The target of the connection.\n   */\n  readonly target: IConstruct;\n\n  /**\n   * An operation that the target object supports.\n   * @default - no operation\n   */\n  readonly targetOp?: string;\n\n  /**\n   * A name for the connection.\n   */\n  readonly name: string;\n}\n\n/**\n * A connection to another construct.\n */\nexport interface Connection {\n  /**\n   * The source of the connection.\n   */\n  readonly source: IConstruct;\n\n  /**\n   * An operation that the source object supports.\n   * @default - no operation\n   */\n  readonly sourceOp?: string;\n\n  /**\n   * The target of the connection.\n   */\n  readonly target: IConstruct;\n\n  /**\n   * An operation that the target object supports.\n   * @default - no operation\n   */\n  readonly targetOp?: string;\n\n  /**\n   * A name for the connection.\n   */\n  readonly name: string;\n}\n","import {\n  IConstruct,\n  Node as ConstructsNode,\n  ConstructOrder,\n  IDependable,\n  MetadataOptions,\n  IValidation,\n} from \"constructs\";\nimport { Connections } from \"../core/connections\";\nimport { ParameterRegistrar } from \"../platform\";\n\nconst NODE_SYMBOL = Symbol.for(\"@winglang/sdk.std.Node\");\nexport const APP_SYMBOL = Symbol.for(\"@winglang/sdk.std.Node/app\");\nconst ROOT_SYMBOL = Symbol.for(\"@winglang/sdk.std.Node/root\");\n\nexport const CONNECTIONS_FILE_PATH = \"connections.json\";\nexport const SDK_SOURCE_MODULE = \"@winglang/sdk\";\n\n/**\n * The internal node of a construct.\n */\nexport class Node {\n  /**\n   * Marks a type as the root of the tree.\n   * @param rootConstructor\n   * @internal\n   */\n  public static _markRoot(rootConstructor: any) {\n    rootConstructor[ROOT_SYMBOL] = true;\n  }\n\n  /**\n   * Return the internal construct node.\n   */\n  public static of(construct: IConstruct): Node {\n    let node = (construct as any)[NODE_SYMBOL];\n\n    if (!node) {\n      node = new Node(construct);\n      (construct as any)[NODE_SYMBOL] = node;\n    }\n\n    return node;\n  }\n\n  /**\n   * Title of the construct for display purposes.\n   */\n  public title?: string;\n\n  /**\n   * Description of the construct for display purposes.\n   */\n  public description?: string;\n\n  /**\n   * The source file or library where the construct was defined.\n   */\n  public sourceModule?: string;\n\n  /**\n   * Whether the construct should be hidden by default in tree visualizations.\n   */\n  public hidden?: boolean;\n\n  /**\n   * The color of the construct for display purposes.\n   * Supported colors are:\n   * - orange\n   * - sky\n   * - emerald\n   * - lime\n   * - pink\n   * - amber\n   * - cyan\n   * - purple\n   * - red\n   * - violet\n   * - slate\n   */\n  public color?: string;\n\n  /**\n   * The icon of the construct for display purposes.\n   * Supported icons are from Heroicons:\n   * - https://heroicons.com/\n   * e.g.\n   * - \"academic-cap\"\n   */\n  public icon?: string;\n\n  /**\n   * Whether the node is expanded or collapsed by default in the UI.\n   * By default, nodes are collapsed. Set this to `true` if you want the node to be expanded by default.\n   *\n   * @default false\n   */\n  public expanded?: boolean;\n\n  private readonly _constructsNode: ConstructsNode;\n  private readonly _connections: Connections;\n  private _app: IApp | undefined;\n  private _root: IConstruct | undefined;\n\n  private constructor(private readonly construct: IConstruct) {\n    this._constructsNode = construct.node;\n    this._connections = Connections.of(construct); // tree-unique instance\n  }\n\n  /**\n   * Adds a connection between two constructs. A connection is a piece of\n   * metadata describing how one construct is related to another construct.\n   */\n  public addConnection(props: AddConnectionProps) {\n    this._connections.add({\n      source: props.source ?? this.construct,\n      ...props,\n    });\n  }\n\n  // ---- constructs 10.x APIs ----\n  // https://github.com/aws/constructs/blob/10.x/src/construct.ts\n\n  /**\n   * Returns the scope in which this construct is defined.\n   *\n   * The value is `undefined` at the root of the construct scope tree.\n   */\n  public get scope(): IConstruct | undefined {\n    return this._constructsNode.scope;\n  }\n\n  /**\n   * The id of this construct within the current scope.\n   *\n   * This is a a scope-unique id. To obtain an app-unique id for this construct, use `addr`.\n   */\n  public get id(): string {\n    return this._constructsNode.id;\n  }\n\n  /**\n   * The full, absolute path of this construct in the tree.\n   *\n   * Components are separated by '/'.\n   */\n  public get path(): string {\n    return this._constructsNode.path;\n  }\n\n  /**\n   * Returns an opaque tree-unique address for this construct.\n   *\n   * Addresses are 42 characters hexadecimal strings. They begin with \"c8\"\n   * followed by 40 lowercase hexadecimal characters (0-9a-f).\n   *\n   * Addresses are calculated using a SHA-1 of the components of the construct\n   * path.\n   *\n   * To enable refactorings of construct trees, constructs with the ID `Default`\n   * will be excluded from the calculation. In those cases constructs in the\n   * same tree may have the same addreess.\n   *\n   * @example c83a2846e506bcc5f10682b564084bca2d275709ee\n   */\n  public get addr(): string {\n    return this._constructsNode.addr;\n  }\n\n  /**\n   * Return a direct child by id, or undefined\n   *\n   * @param id Identifier of direct child\n   * @returns the child if found, or undefined\n   */\n  public tryFindChild(id: string): IConstruct | undefined {\n    return this._constructsNode.tryFindChild(id);\n  }\n\n  /**\n   * Return a direct child by id\n   *\n   * Throws an error if the child is not found.\n   *\n   * @param id Identifier of direct child\n   * @returns Child with the given id.\n   */\n  public findChild(id: string): IConstruct {\n    return this._constructsNode.findChild(id);\n  }\n\n  /**\n   * Returns the child construct that has the id `Default` or `Resource\"`.\n   * This is usually the construct that provides the bulk of the underlying functionality.\n   * Useful for modifications of the underlying construct that are not available at the higher levels.\n   *\n   * @throws if there is more than one child\n   * @returns a construct or undefined if there is no default child\n   */\n  public get defaultChild(): IConstruct | undefined {\n    return this._constructsNode.defaultChild;\n  }\n\n  /**\n   * Override the defaultChild property.\n   *\n   * This should only be used in the cases where the correct\n   * default child is not named 'Resource' or 'Default' as it\n   * should be.\n   *\n   * If you set this to undefined, the default behavior of finding\n   * the child named 'Resource' or 'Default' will be used.\n   */\n  public set defaultChild(value: IConstruct | undefined) {\n    this._constructsNode.defaultChild = value;\n  }\n\n  /**\n   * All direct children of this construct.\n   */\n  public get children() {\n    return this._constructsNode.children;\n  }\n\n  /**\n   * Return this construct and all of its children in the given order\n   */\n  public findAll(\n    order: ConstructOrder = ConstructOrder.PREORDER\n  ): IConstruct[] {\n    return this._constructsNode.findAll(order);\n  }\n\n  /**\n   * This can be used to set contextual values.\n   * Context must be set before any children are added, since children may consult context info during construction.\n   * If the key already exists, it will be overridden.\n   * @param key The context key\n   * @param value The context value\n   */\n  public setContext(key: string, value: any) {\n    this._constructsNode.setContext(key, value);\n  }\n\n  /**\n   * Retrieves a value from tree context if present. Otherwise, would throw an error.\n   *\n   * Context is usually initialized at the root, but can be overridden at any point in the tree.\n   *\n   * @param key The context key\n   * @returns The context value or throws error if there is no context value for this key\n   */\n  public getContext(key: string): any {\n    return this._constructsNode.getContext(key);\n  }\n\n  /**\n   * Retrieves a value from tree context.\n   *\n   * Context is usually initialized at the root, but can be overridden at any point in the tree.\n   *\n   * @param key The context key\n   * @returns The context value or `undefined` if there is no context value for this key.\n   */\n  public tryGetContext(key: string): any {\n    return this._constructsNode.tryGetContext(key);\n  }\n\n  /**\n   * An immutable array of metadata objects associated with this construct.\n   * This can be used, for example, to implement support for deprecation notices, source mapping, etc.\n   */\n  public get metadata() {\n    return this._constructsNode.metadata;\n  }\n\n  /**\n   * Adds a metadata entry to this construct.\n   * Entries are arbitrary values and will also include a stack trace to allow tracing back to\n   * the code location for when the entry was added. It can be used, for example, to include source\n   * mapping in CloudFormation templates to improve diagnostics.\n   *\n   * @param type a string denoting the type of metadata\n   * @param data the value of the metadata (can be a Token). If null/undefined, metadata will not be added.\n   * @param options options\n   */\n  public addMetadata(\n    type: string,\n    data: any,\n    options: MetadataOptions = {}\n  ): void {\n    this._constructsNode.addMetadata(type, data, options);\n  }\n\n  /**\n   * All parent scopes of this construct.\n   *\n   * @returns a list of parent scopes. The last element in the list will always\n   * be the current construct and the first element will be the root of the\n   * tree.\n   */\n  public get scopes(): IConstruct[] {\n    return this._constructsNode.scopes;\n  }\n\n  /**\n   * Returns the root of the construct tree (the `cloud.App` object).\n   *\n   * Similar to `app`.\n   *\n   * @returns The root of the construct tree.\n   */\n  public get root(): IConstruct {\n    if (!this._root) {\n      this._root = this.findRoot(this.construct);\n    }\n\n    return this._root;\n  }\n\n  /**\n   * Returns the root of the construct tree (the `cloud.App` object).\n   *\n   * Similar to `root`.\n   *\n   * @returns The root of the construct tree.\n   */\n  public get app(): IApp {\n    if (!this._app) {\n      this._app = this.findApp(this.construct);\n    }\n\n    return this._app;\n  }\n\n  /**\n   * Returns true if this construct or the scopes in which it is defined are\n   * locked.\n   */\n  public get locked() {\n    return this._constructsNode.locked;\n  }\n\n  /**\n   * Add an ordering dependency on another construct.\n   *\n   * An `IDependable`\n   */\n  public addDependency(...deps: IDependable[]) {\n    this._constructsNode.addDependency(...deps);\n  }\n\n  /**\n   * Return all dependencies registered on this node (non-recursive).\n   */\n  public get dependencies(): IConstruct[] {\n    return this._constructsNode.dependencies;\n  }\n\n  /**\n   * Remove the child with the given name, if present.\n   *\n   * @returns Whether a child with the given name was deleted.\n   * @experimental\n   */\n  public tryRemoveChild(childName: string): boolean {\n    return this._constructsNode.tryRemoveChild(childName);\n  }\n\n  /**\n   * Adds a validation to this construct.\n   *\n   * When `node.validate()` is called, the `validate()` method will be called on\n   * all validations and all errors will be returned.\n   *\n   * @param validation The validation object\n   */\n  public addValidation(validation: IValidation) {\n    this._constructsNode.addValidation(validation);\n  }\n\n  /**\n   * Validates this construct.\n   *\n   * Invokes the `validate()` method on all validations added through\n   * `addValidation()`.\n   *\n   * @returns an array of validation error messages associated with this\n   * construct.\n   */\n  public validate(): string[] {\n    return this._constructsNode.validate();\n  }\n\n  /**\n   * Locks this construct from allowing more children to be added. After this\n   * call, no more children can be added to this construct or to any children.\n   */\n  public lock() {\n    this._constructsNode.lock();\n  }\n\n  /**\n   * Returns the root app.\n   */\n  private findApp(scope: IConstruct): IApp {\n    if (isApp(scope)) {\n      return scope as IApp;\n    }\n\n    if (!scope.node.scope) {\n      throw new Error(\"Cannot find root app\");\n    }\n\n    return this.findApp(scope.node.scope);\n  }\n\n  private findRoot(scope: IConstruct): IConstruct {\n    if (isRoot(scope)) {\n      return scope;\n    }\n\n    if (!scope.node.scope) {\n      throw new Error(\"Cannot find root construct\");\n    }\n\n    return this.findRoot(scope.node.scope);\n  }\n}\n\n/**\n * Props for `Node.addConnection`.\n */\nexport interface AddConnectionProps {\n  /**\n   * The source of the connection.\n   * @default this\n   */\n  readonly source?: IConstruct;\n\n  /**\n   * An operation that the source construct supports.\n   * @default - no operation\n   */\n  readonly sourceOp?: string;\n\n  /**\n   * The target of the connection.\n   */\n  readonly target: IConstruct;\n\n  /**\n   * An operation that the target construct supports.\n   * @default - no operation\n   */\n  readonly targetOp?: string;\n\n  /**\n   * A name for the connection.\n   */\n  readonly name: string;\n}\n\n/**\n * Represents a Wing application.\n */\nexport interface IApp extends IConstruct {\n  /**\n   * Type marker.\n   * @internal\n   **/\n  readonly [APP_SYMBOL]: true;\n\n  /**\n   * The `.wing` directory into which you can emit artifacts during preflight.\n   */\n  readonly workdir: string;\n\n  /**\n   * `true` if this is a testing environment\n   */\n  readonly isTestEnvironment: boolean;\n\n  /**\n   * The directory of the entrypoint of the current program.\n   */\n  readonly entrypointDir: string;\n\n  /**\n   * The application's parameter registrar\n   */\n  readonly parameters: ParameterRegistrar;\n\n  /**\n   * Generate a unique ID for the given scope and prefix. The newly generated ID is\n   * guaranteed to be unique within the given scope.\n   * It will have the form '{prefix}{n}', where '{prefix}' is the given prefix and '{n}' is an\n   * ascending sequence of integers starting from '0'.\n   *\n   * @param scope to guarantee uniqueness in\n   * @param prefix prepended to the unique identifier\n   */\n  makeId(scope: IConstruct, prefix?: string): string;\n}\n\nfunction isApp(x: any): x is IApp {\n  return x && x[APP_SYMBOL];\n}\n\nfunction isRoot(x: any): boolean {\n  return x && x.constructor && x.constructor[ROOT_SYMBOL];\n}\n","import { Json, JsonValidationOptions } from \"./json\";\nimport { JsonSchema } from \"./json_schema\";\nimport { InflightClient } from \"../core\";\n\n/**\n * Number\n * @wingType num\n */\nexport class Number {\n  /**\n   * Parse a number from Json.\n   *\n   * @param json to parse number from.\n   * @returns a number.\n   */\n  public static fromJson(json: Json, options?: JsonValidationOptions): number {\n    const schema = JsonSchema._createJsonSchema({\n      $id: \"num\",\n      type: \"number\",\n    } as any);\n    schema.validate(json, options);\n    return json as any;\n  }\n\n  /**\n   * Parse a number from string.\n   *\n   * @macro ((args) => { if (isNaN(args)) {throw new Error(\"unable to parse \\\"\" + args + \"\\\" as a number\")}; return Number(args) })($args$)\n   *\n   * @param str to parse number from.\n   * @returns a number.\n   */\n  public static fromStr(str: string): number {\n    str;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  private constructor() {}\n}\n","import { ILiftable } from \"./resource\";\nimport { InflightClient } from \"../core\";\nimport { normalPath } from \"../shared/misc\";\n\n/**\n * Represents a compiled regular expression pattern.\n * @wingType regex\n */\nexport class Regex implements ILiftable {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  /**\n   * Compiles the provided regex pattern into a `Regex` object.\n   * @param pattern The regex pattern to compile.\n   * @returns A new `Regex` object representing the compiled pattern.\n   */\n  public static compile(pattern: string): Regex {\n    return new Regex(pattern);\n  }\n\n  /** @internal */\n  private readonly _regex: RegExp;\n\n  /**\n   * Constructs a new `Regex` object with the specified pattern.\n   * @param pattern The regular expression pattern.\n   */\n  private constructor(pattern: string) {\n    this._regex = new RegExp(pattern);\n  }\n\n  /** @internal */\n  public _toInflight(): string {\n    return `(new (require(\"${normalPath(__filename)}\").Regex)(${this._regex}))`;\n  }\n\n  /**\n   * Checks if the regular expression matches the provided text.\n   * @param text The text to check against.\n   * @returns `true` if there is a match, otherwise `false`.\n   */\n  public test(text: string): boolean {\n    return this._regex.test(text);\n  }\n\n  /**\n   * Finds the first occurrence of the pattern within the text.\n   * @param text The text to search within.\n   * @returns The first match if found, otherwise `undefined`.\n   */\n  public find(text: string): string | undefined {\n    const result = text.match(this._regex);\n    return result ? result[0] : undefined;\n  }\n\n  /**\n   * Finds the start and end index of the first match within the text.\n   * @param text The text to search within.\n   * @returns An array containing the start and end index of the match if found, otherwise `undefined`.\n   */\n  public findIndex(text: string): number[] | undefined {\n    const result = this._regex.exec(text);\n    return result ? [result.index, result.index + result[0].length] : undefined;\n  }\n\n  /**\n   * Finds the first match and its submatches.\n   * @param text The text to search within.\n   * @returns An array containing the match and all submatches.\n   */\n  public findSubmatch(text: string): string[] | undefined {\n    const result = text.match(this._regex);\n    if (result) {\n      return [result[0], ...result.slice(1)];\n    }\n    return undefined;\n  }\n\n  /**\n   * Finds the start and end index of the match and all submatches.\n   * @param text The text to search within.\n   * @returns An array containing arrays of start and end indices for the match and all submatches.\n   */\n  public findSubmatchIndex(text: string): number[][] | undefined {\n    const result = this._regex.exec(text);\n    if (!result) {\n      return undefined;\n    }\n\n    // Initialize the array with the match's start and end indices\n    const indices = [[result.index, result.index + result[0].length]];\n\n    // Add submatch indices\n    result.slice(1).forEach((submatch) => {\n      const start = text.indexOf(submatch, indices[indices.length - 1][0]);\n      const end = start + submatch.length;\n      indices.push([start, end]);\n    });\n\n    return indices;\n  }\n\n  /**\n   * Finds all non-overlapping occurrences of the pattern within the text.\n   * Returns an empty array if no matches are found.\n   * @param text The text to search within.\n   * @returns An array containing all matches found.\n   */\n  public findAll(text: string): string[] {\n    const globalRegex = this.getGlobalRegex();\n    return [...text.matchAll(globalRegex)].map((match) => match[0]);\n  }\n\n  /**\n   * Finds the start and end index of all matches within the text.\n   * Indices are zero-based.\n   * @param text The text to search within.\n   * @returns An array containing arrays of start and end indices for each match found.\n   */\n  public findAllIndex(text: string): number[][] {\n    const matches: number[][] = [];\n    const globalRegex = this.getGlobalRegex();\n\n    for (const match of text.matchAll(globalRegex)) {\n      if (match.index !== undefined) {\n        matches.push([match.index, match.index + match[0].length]);\n      }\n    }\n\n    return matches;\n  }\n\n  /**\n   * Replaces all occurrences of the match with a replacement string.\n   * @param text The text to search and replace within.\n   * @param replacement The replacement string.\n   * @returns The resulting text after all replacements.\n   */\n  public replaceAll(text: string, replacement: string): string {\n    const globalRegex = this.getGlobalRegex();\n    return text.replace(globalRegex, replacement);\n  }\n\n  /**\n   * Helper method to get the global version of a regex.\n   * @returns The current regex if it's already global, otherwise a new global regex.\n   */\n  private getGlobalRegex(): RegExp {\n    return this._regex.global ? this._regex : new RegExp(this._regex, \"g\");\n  }\n}\n","import { Construct, IConstruct } from \"constructs\";\nimport { App, LiftMap } from \"../core\";\nimport { AbstractMemberError } from \"../core/errors\";\nimport { Node } from \"../std\";\n\n/**\n * A resource that can run inflight code.\n * @skipDocs\n */\nexport interface IInflightHost extends IResource {\n  /**\n   * Adds an environment variable to the host.\n   */\n  addEnvironment(name: string, value: string): void;\n}\n\n/**\n * Code that runs at runtime and implements your application's behavior.\n * For example, handling API requests, processing queue messages, etc.\n * Inflight code can be executed on various compute platforms in the cloud,\n * such as function services (such as AWS Lambda or Azure Functions),\n * containers (such as ECS or Kubernetes), VMs or even physical servers.\n *\n * This data represents the code together with the bindings to preflight data required to run.\n *\n * @link https://www.winglang.io/docs/concepts/inflights\n * @skipDocs\n */\nexport interface IInflight extends IHostedLiftable {\n  /**\n   * An opaque identifier for this inflight code. This can be used for determining\n   * whether two inflight closures are same by identity, but should not be used\n   * for any other purpose since it may not be stable across compilations.\n   *\n   * Comparing inflight closures for value equality (i.e. whether they will bundle\n   * into the same JavaScript code) isn't possible since the exact code is only\n   * resolved after all preflight code has finished running and preflight values that\n   * are referenced by the inflight closure have settled on their values.\n   *\n   * Consider e.g.\n   *\n   * ```\n   * let arr = MutArray<str>[\"hello\"];\n   *\n   * new cloud.Function(inflight () => {\n   *   for x in arr {\n   *     log(x);\n   *   }\n   * });\n   *\n   * arr.push(\"world\");\n   * ```\n   *\n   * @internal\n   */\n  _id: number;\n}\n\n/**\n * Data that can be lifted into inflight.\n * @skipDocs\n */\nexport interface ILiftable {\n  /**\n   * Return a code snippet that can be used to reference this resource inflight.\n   *\n   * Note this code snippet may be async code, so it's unsafe to run it in a\n   * constructor or other sync context.\n   *\n   * @internal\n   */\n  _toInflight(): string;\n}\n\n/**\n * A liftable object that needs to be registered on the host as part of\n * the lifting process.\n * This is generally used so the host can set up permissions\n * to access the lifted object inflight.\n */\nexport interface IHostedLiftable extends ILiftable {\n  /**\n   * Compiler-generated data that describes the dependencies of this object on other\n   * objects. This is used to determine which permissions need to be granted to the\n   * inflight host.\n   * @internal\n   */\n  _liftMap?: LiftMap;\n\n  /**\n   * A hook called by the Wing compiler once for each inflight host that needs to\n   * use this object inflight. The list of requested inflight methods\n   * needed by the inflight host are given by `ops`.\n   *\n   * This method is commonly used for adding permissions, environment variables, or\n   * other capabilities to the inflight host.\n   */\n  onLift(host: IInflightHost, ops: string[]): void;\n}\n\nfunction hasLiftMap(x: any): x is { _liftMap: LiftMap } {\n  return x != null && typeof x._liftMap === \"object\";\n}\n\n/**\n * Abstract interface for `Resource`.\n * @skipDocs\n * @noinflight\n */\nexport interface IResource extends IConstruct, IHostedLiftable {\n  /**\n   * A hook for performing operations after the tree of resources has been\n   * created, but before they are synthesized.\n   *\n   * Currently used for binding resources to hosts.\n   *\n   * @internal\n   */\n  _preSynthesize(): void;\n}\n\n/**\n * Shared behavior between all Wing SDK resources.\n * @skipDocs\n * @noinflight\n */\nexport abstract class Resource extends Construct implements IResource {\n  /**\n   * A hook called by the Wing compiler once for each inflight host that needs to\n   * use this type inflight. The list of requested inflight methods\n   * needed by the inflight host are given by `ops`.\n   *\n   * This method is commonly used for adding permissions, environment variables, or\n   * other capabilities to the inflight host.\n   */\n  public static onLiftType(host: IInflightHost, ops: string[]): void {\n    host;\n    ops;\n  }\n\n  /**\n   * Generates an asynchronous JavaScript statement which can be used to create an inflight client\n   * for a resource.\n   *\n   * NOTE: This statement must be executed within an async context.\n   */\n  public static toInflight(obj: IResource) {\n    return obj._toInflight();\n  }\n\n  /**\n   * Create an instance of this resource with the current App factory.\n   * This is commonly used in the constructor of a pseudo-abstract resource class before the super() call.\n   *\n   * @example\n   * ```ts\n   * export class MyResource extends Resource {\n   *   constructor(scope: Construct, id: string, props: MyResourceProps) {\n   *     if (new.target === MyResource) {\n   *      return MyResource._newFromFactory(MYRESOURCE_FQN, scope, id, props);\n   *     }\n   *     super(scope, id);\n   *     // ...\n   *  ```\n   *\n   * @internal\n   */\n  protected static _newFromFactory<TResource extends Resource>(\n    fqn: string,\n    scope: Construct,\n    id: string,\n    ...props: any[]\n  ): TResource {\n    return App.of(scope).newAbstract(fqn, scope, id, ...props);\n  }\n\n  /**\n   * Return a code snippet that can be used to reference this resource inflight.\n   *\n   * @internal\n   * @abstract\n   */\n  public _toInflight(): string {\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * A hook called by the Wing compiler once for each inflight host that needs to\n   * use this resource inflight.\n   *\n   * You can override this method to perform additional logic like granting\n   * IAM permissions to the host based on what methods are being called. But\n   * you must call `super.bind(host, ops)` to ensure that the resource is\n   * actually bound.\n   */\n  public onLift(host: IInflightHost, ops: string[]): void {\n    host;\n    ops;\n  }\n\n  /**\n   * A hook for performing operations after the tree of resources has been\n   * created, but before they are synthesized.\n   *\n   * Currently used for binding resources to hosts.\n   *\n   * @internal\n   */\n  public _preSynthesize(): void {\n    if (hasLiftMap(this) && !(this instanceof AutoIdResource)) {\n      addConnectionsFromLiftMap(this, this._liftMap);\n    }\n  }\n}\n\nfunction addConnectionsFromLiftMap(\n  construct: IConstruct,\n  liftData: LiftMap,\n  baseOp?: string\n) {\n  for (const [op, liftEntries] of Object.entries(liftData)) {\n    for (const [dep, depOps] of liftEntries) {\n      if (Construct.isConstruct(dep) && !(dep instanceof AutoIdResource)) {\n        // case 1: dep is an ordinary resource\n        for (const depOp of depOps) {\n          Node.of(construct).addConnection({\n            source: construct,\n            sourceOp: baseOp ?? op,\n            target: dep,\n            targetOp: depOp,\n            name: \"call\",\n          });\n        }\n      } else if (hasLiftMap(dep)) {\n        // case 2: dep is an inflight\n        addConnectionsFromLiftMap(construct, dep._liftMap, baseOp ?? op);\n      }\n    }\n  }\n}\n\n/**\n * A resource that has an automatically generated id.\n * Used by the Wing compiler to generate unique ids for auto generated resources\n * from inflight function closures.\n * @noinflight\n */\nexport abstract class AutoIdResource extends Resource {\n  constructor(scope: Construct, idPrefix: string = \"\") {\n    const id = App.of(scope).makeId(scope, idPrefix ? `${idPrefix}_` : \"\");\n    super(scope, id);\n  }\n}\n\n/**\n * Annotations about preflight data and desired inflight operations.\n */\nexport interface LiftAnnotation {\n  /**\n   * Preflight object to lift\n   */\n  readonly obj: any;\n\n  /**\n   * Name of the object in the inflight context.\n   * Required if the object provided is not an identifier.\n   * @default \"obj\" If the object is a simple identifier, it will be used as the alias\n   */\n  readonly alias?: string;\n\n  /**\n   * Operations to lift on the object.\n   * @default * All possible operations will be available\n   */\n  readonly ops?: string[];\n}\n\n/** Options for the `@inflight` intrinsic */\nexport interface ImportInflightOptions {\n  /**\n   * Name of exported function\n   * @default \"default\"\n   * */\n  readonly export?: string;\n  /**\n   * Mapping of available symbols to a lift declaration\n   * @default * All possible operations will be available\n   */\n  readonly lifts?: LiftAnnotation[];\n}\n","// These classes are used by Wing to provide JSII subsets of the JS Set class.\n// They should not be consumed directly by users.\n// TODO: These should be interfaces, currently Wing does not support interface JSII imports\n\nimport { Array } from \"./array\";\nimport { T1 } from \"./generics\";\nimport { InflightClient } from \"../core\";\n\n/**\n * Immutable Set\n *\n * @typeparam T1\n */\nexport class Set {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  private constructor() {}\n\n  /**\n   * The length of the set\n   * @returns the length of the set\n   */\n  public get size(): number {\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Returns a boolean indicating whether an element with the specified value exists in the set.\n   * @param value The value to test for presence in the Set object.\n   * @returns `true` if an element with the specified value exists in the set; otherwise `false`.\n   */\n  public has(value: T1): boolean {\n    value;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Create a mutable shallow copy of this set\n   *\n   * @macro new Set($self$)\n   *\n   * @returns a MutableSet with the same values as this set\n   */\n  public copyMut(): MutSet {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Create an immutable array shallow copy of this set\n   *\n   * @macro [...($self$)]\n   *\n   * @returns an ImmutableArray with the same values as this set\n   */\n  public toArray(): Array {\n    throw new Error(\"Macro\");\n  }\n}\n\n/**\n * Mutable Set\n *\n * @typeparam T1\n */\nexport class MutSet {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  private constructor() {}\n\n  /**\n   * The length of the set\n   * @returns the length of the set\n   */\n  public get size(): number {\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Add value to set\n   * @param value value to add\n   * @returns true if the value was added, false if it was already in the set\n   */\n  public add(value: T1): MutSet {\n    value;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * The clear() method removes all elements from a set.\n   */\n  public clear(): void {\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Create an immutable shallow copy of this set\n   *\n   * @macro new Set($self$)\n   *\n   * @returns an ImmutableSet with the same values as this set\n   */\n  public copy(): Set {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Removes a specified value from a set, if it is in the set.\n   * @param value The value to remove from the set.\n   * @returns Returns `true` if `value` was already in the set; otherwise `false`.\n   */\n  public delete(value: T1): boolean {\n    value;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Returns a boolean indicating whether an element with the specified value exists in the set.\n   * @param value The value to test for presence in the Set object.\n   * @returns `true` if an element with the specified value exists in the set; otherwise `false`.\n   */\n  public has(value: T1): boolean {\n    value;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Create an immutable array shallow copy of this set\n   *\n   * @macro [...($self$)]\n   *\n   * @returns an ImmutableArray with the same values as this set\n   */\n  public toArray(): Array {\n    throw new Error(\"Macro\");\n  }\n}\n","// This class is used by Wing to provide JSII subsets of the JS string object.\n// They should not be consumed directly by users.\n// TODO: This should be an interface, currently Wing does not support interface JSII imports\n\nimport { Json, JsonValidationOptions } from \"./json\";\nimport { JsonSchema } from \"./json_schema\";\nimport { InflightClient } from \"../core\";\n\n/**\n * String\n * @wingType str\n */\nexport class String {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  /**\n   * Parse string from Json.\n   *\n   * @param json to create string from.\n   * @returns a string.\n   */\n  public static fromJson(json: Json, options?: JsonValidationOptions): string {\n    const schema = JsonSchema._createJsonSchema({\n      $id: \"string\",\n      type: \"string\",\n    } as any);\n    schema.validate(json, options);\n    return json as any;\n  }\n\n  private constructor() {}\n\n  /**\n   * The length of the string.\n   */\n  public get length(): number {\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Returns the character at the specified index.\n   *\n   * @macro ((args) => { if ($args$ >= $self$.length || $args$ + $self$.length < 0) {throw new Error(\"index out of bounds\")}; return $self$.at($args$) })($args$)\n   *\n   * @param index position of the character.\n   * @returns string at the specified index.\n   */\n  public at(index: number): string {\n    index;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Combines the text of two (or more) strings and returns a new string.\n   *\n   * @param strN one or more strings to concatenate to this string.\n   * @returns a new combined string.\n   */\n  public concat(strN: string): string {\n    strN;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Checks if string includes substring.\n   *\n   * @macro $self$.includes($args$)\n   *\n   * @param searchString substring to search for.\n   * @returns true if string includes substring.\n   */\n  public contains(searchString: string): boolean {\n    searchString;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Does this string end with the given searchString?\n   *\n   * @macro $self$.endsWith($args$)\n   *\n   * @param searchString substring to search for.\n   * @returns true if string ends with searchString.\n   */\n  public endsWith(searchString: string): boolean {\n    searchString;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Returns the index of the first occurrence of searchString found.\n   *\n   * @macro $self$.indexOf($args$)\n   *\n   * @param searchString substring to search for.\n   * @returns the index of the first occurrence of searchString found, or -1 if not found.\n   */\n  public indexOf(searchString: string): number {\n    searchString;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Returns this string in lower case.\n   *\n   * @macro $self$.toLocaleLowerCase()\n   *\n   * @returns a new lower case string.\n   */\n  public lowercase(): string {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Splits string by separator.\n   *\n   * @param separator separator to split by.\n   * @returns array of strings.\n   */\n  public split(separator: string): string[] {\n    separator;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Does this string start with the given searchString?\n   *\n   * @macro $self$.startsWith($args$)\n   *\n   * @param searchString substring to search for.\n   * @returns true if string starts with searchString.\n   */\n  public startsWith(searchString: string): boolean {\n    searchString;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Returns a string between indexStart, indexEnd.\n   *\n   * @param indexStart index of the character we slice at.\n   * @param indexEnd optional - index of the character we end slicing at.\n   * @returns the string contained from indexStart to indexEnd.\n   */\n  public substring(indexStart: number, indexEnd?: number): string {\n    indexStart;\n    indexEnd;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Replaces the first occurence of a substring within a string.\n   *\n   * @macro $self$.replace($args$)\n   *\n   * @param searchString The substring to search for.\n   * @param replaceString The replacement substring.\n   * @returns The modified string after replacement.\n   */\n  public replace(searchString: string, replaceString: string): string {\n    searchString;\n    replaceString;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Replaces all occurrences of a substring within a string.\n   *\n   * @macro $self$.replaceAll($args$)\n   *\n   * @param searchString The substring to search for.\n   * @param replaceString The replacement substring.\n   * @returns The modified string after replacement.\n   */\n  public replaceAll(searchString: string, replaceString: string): string {\n    searchString;\n    replaceString;\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Removes white spaces from start and end of this string.\n   *\n   * @returns a new string with white spaces removed from start and end.\n   */\n  public trim(): string {\n    throw new Error(\"Abstract\");\n  }\n\n  /**\n   * Returns this string in upper case.\n   *\n   * @macro $self$.toLocaleUpperCase()\n   *\n   * @returns a new upper case string.\n   */\n  public uppercase(): string {\n    throw new Error(\"Macro\");\n  }\n}\n","import { T1 } from \"./generics\";\nimport { Json, JsonValidationOptions } from \"./json\";\nimport { JsonSchema } from \"./json_schema\";\nimport { InflightClient } from \"../core\";\n\n/**\n * Shared behavior for all structs\n *\n * @typeparam T1\n */\nexport class Struct {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n\n  /**\n   * Converts a Json to a Struct\n   *\n   * @macro $self$._fromJson($args$)\n   */\n  public static fromJson(json: Json, options?: JsonValidationOptions): T1 {\n    json;\n    options;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Converts a Json to a Struct, returning nil if the Json is not valid\n   *\n   * @macro $self$._tryFromJson($args$)\n   */\n  public static tryFromJson(json: Json): T1 | undefined {\n    json;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Parse a Json string into a Struct\n   *\n   * @macro $self$._fromJson(JSON.parse($args$))\n   */\n  public static parseJson(json: string): T1 {\n    json;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Parse a Json string into a Struct, returning nil if the Json is not valid\n   *\n   * @macro $self$._tryParseJson($args$)\n   */\n  public static tryParseJson(json: string | undefined): T1 | undefined {\n    json;\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Retrieve the schema for this struct\n   * @macro $self$\n   */\n  public static schema(): JsonSchema {\n    throw new Error(\"Macro\");\n  }\n\n  /**\n   * Create an instance of a StructSchema from a JsonSchema\n   *\n   * @internal\n   */\n  public static _createJsonSchema(schema: Json): JsonSchema {\n    return new JsonSchema(schema);\n  }\n\n  private constructor() {}\n}\n","import { Construct } from \"constructs\";\nimport { Function, FunctionProps } from \"../cloud/function\";\nimport { fqnForType } from \"../constants\";\nimport { App, LiftMap } from \"../core\";\nimport { Node, IInflight, Resource } from \"../std\";\n\n/**\n * Global identifier for `Test`.\n */\nexport const TEST_FQN = fqnForType(\"std.Test\");\n\n/**\n * Properties for `Test`.\n *\n * This is the type users see when constructing a std.Test instance.\n * @skipDocs\n */\nexport interface TestProps extends FunctionProps {}\n\n/**\n * Inflight interface for `Test`.\n * @skipDocs\n */\nexport interface ITestClient {}\n\n/**\n * A unit test.\n *\n * @inflight `@winglang/sdk.std.ITestClient`\n * @skipDocs\n */\nexport class Test extends Resource {\n  /**\n   * The function that will be called when the test is run. This will only be created\n   * if the app is compiled with `wing test` for a non-simulator target.\n   * @internal\n   */\n  public readonly _fn: Function | undefined;\n\n  constructor(\n    scope: Construct,\n    id: string,\n    inflight: ITestHandler,\n    props: TestProps = {}\n  ) {\n    super(scope, id);\n\n    Node.of(this).title = \"Test\";\n    Node.of(this).description = \"A cloud unit test.\";\n\n    this._fn = App.of(this)?._testRunner?._addTestFunction(\n      this,\n      \"Handler\",\n      inflight,\n      props\n    );\n    if (!this._fn) {\n      Node.of(this).hidden = true;\n    }\n  }\n\n  /** @internal */\n  public get _liftMap(): LiftMap {\n    return {};\n  }\n\n  /** @internal */\n  public _toInflight(): string {\n    throw new Error(\"unimplemented\");\n  }\n}\n\n/**\n * Interface with an inflight \"handle\" method that can be used to construct\n * a `std.Test`.\n *\n * @inflight `@winglang/sdk.std.ITestHandlerClient`\n * @skipDocs\n */\nexport interface ITestHandler extends IInflight {}\n\n/**\n * Inflight client for `ITestHandler`.\n * @skipDocs\n */\nexport interface ITestHandlerClient {\n  /**\n   * Inflight function that will be called when the test is run.\n   * @inflight\n   */\n  handle(): Promise<void>;\n}\n","import { Construct } from \"constructs\";\nimport { Endpoint } from \"./endpoint\";\nimport { FunctionProps } from \"./function\";\nimport { fqnForType } from \"../constants\";\nimport { AbstractMemberError } from \"../core/errors\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { Node, Resource, Duration, IInflight } from \"../std\";\n\n/**\n * Global identifier for `Api`.\n */\n\nexport const API_FQN = fqnForType(\"cloud.Api\");\n\n/**\n * Cors Options for `Api`.\n */\nexport interface ApiCorsOptions {\n  /**\n   * The allowed origin.\n   * @example \"https://example.com\"\n   * @default - \"*\"\n   */\n  readonly allowOrigin?: string;\n\n  /**\n   * The list of allowed methods.\n   * @example [HttpMethod.GET, HttpMethod.POST]\n   * @default - [HttpMethod.GET, HttpMethod.POST, HttpMethod.PUT, HttpMethod.PATCH, HttpMethod.DELETE, HttpMethod.HEAD, HttpMethod.OPTIONS]\n   */\n  readonly allowMethods?: Array<HttpMethod>;\n\n  /**\n   * The list of allowed headers.\n   * @example [\"Content-Type\"]\n   * @default - [\"Content-Type\", \"Authorization\"]\n   */\n  readonly allowHeaders?: Array<string>;\n\n  /**\n   * The list of exposed headers.\n   * @example [\"Content-Type\"]\n   * @default - []\n   */\n  readonly exposeHeaders?: Array<string>;\n\n  /**\n   * Whether to allow credentials.\n   * @default - false\n   */\n  readonly allowCredentials?: boolean;\n\n  /**\n   * How long the browser should cache preflight request results.\n   * @default - 300 seconds\n   */\n  readonly maxAge?: Duration;\n}\n\n/**\n * Options for `Api`.\n */\n\nexport interface ApiProps {\n  /**\n   * Options for configuring the API's CORS behavior across all routes.\n   * Options can also be overridden on a per-route basis. (not yet implemented)\n   * When enabled this will add CORS headers with default options.\n   * Can be customized by passing `corsOptions`\n   * @example true\n   * @default - false, CORS configuration is disabled\n   */\n  readonly cors?: boolean;\n\n  /**\n   * Options for configuring the API's CORS behavior across all routes.\n   * Options can also be overridden on a per-route basis. (not yet implemented)\n   *\n   * @example { allowOrigin: \"https://example.com\" }\n   * @default - Default CORS options are applied when `cors` is set to `true`\n   *  allowOrigin: \"*\",\n   *  allowMethods: [\n   *   HttpMethod.GET,\n   *   HttpMethod.POST,\n   *   HttpMethod.PUT,\n   *   HttpMethod.DELETE,\n   *   HttpMethod.HEAD,\n   *   HttpMethod.OPTIONS,\n   *  ],\n   *  allowHeaders: [\"Content-Type\", \"Authorization\"],\n   *  exposeHeaders: [],\n   *  allowCredentials: false,\n   *\n   */\n  readonly corsOptions?: ApiCorsOptions;\n}\n/**\n * The OpenAPI spec.\n */\n// TODO: This should be a type from the OpenAPI spec. We can either use a external package or define it ourselves.\nexport type OpenApiSpec = any;\n\n/**\n * The OpenAPI spec extension for a route.\n * @see https://spec.openapis.org/oas/v3.0.3\n * */\nexport type OpenApiSpecExtension = any;\n\n/**\n * The OpenAPI spec for CORS headers.\n * */\nexport type OpenApiCorsHeaders = Record<string, { schema: { type: string } }>;\n\n/**\n * Type definition for default CORS headers.\n * @property {string} \"Access-Control-Allow-Origin\" - Specifies the origin that is allowed to access the resource. See {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin}\n * @property {string} \"Access-Control-Expose-Headers\" - Lists the headers that the client can access. See {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers}\n * @property {string} \"Access-Control-Allow-Credentials\" - Indicates whether the response to the request can be exposed when the credentials flag is true. See {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials}\n */\ntype CorsDefaultResponseHeaders = { [key: string]: string };\n\n/**\n * Type definition for CORS option headers.\n * @property {string} \"Access-Control-Allow-Origin\" - Specifies the origin that is allowed to access the resource. See {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin}\n * @property {string} \"Access-Control-Allow-Headers\" - Specifies the headers that are allowed in a request. See {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers}\n * @property {string} \"Access-Control-Allow-Methods\" - Specifies the methods that are allowed in a request. See {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods}\n * @property {string} \"Access-Control-Max-Age\" - Indicates how long the results of a preflight request can be cached. See {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age}\n */\ntype CorsOptionsResponseHeaders = { [key: string]: string };\n\n/**\n * Type definition for CORS headers which includes default and options headers.\n */\nexport interface CorsHeaders {\n  /**\n   * Default CORS response headers.\n   */\n  readonly defaultResponse: CorsDefaultResponseHeaders;\n\n  /**\n   * CORS options response headers.\n   */\n  readonly optionsResponse: CorsOptionsResponseHeaders;\n}\n\n/**\n * Functionality shared between all `Api` implementations.\n * @inflight `@winglang/sdk.cloud.IApiClient`\n * @abstract\n */\n\nexport class Api extends Resource {\n  /**\n   * Converts input path to a valid OpenAPI path (replaces `:` based path params with `{}`)\n   * @param path The path to convert (assumes path is valid)\n   * @returns OpenAPI path\n   */\n  public static renderOpenApiPath(path: string) {\n    return path.replace(/\\/:([A-Za-z0-9_-]+)/g, \"/{$1}\");\n  }\n\n  /**\n   * Generates an object containing default CORS response headers and OPTIONS response headers.\n   * @param corsOptions The CORS options to generate the headers from.\n   * @returns An object containing default CORS response headers and OPTIONS response headers.\n   */\n  public static renderCorsHeaders(\n    corsOptions?: ApiCorsOptions\n  ): CorsHeaders | undefined {\n    if (corsOptions == undefined) {\n      return;\n    }\n\n    const {\n      allowOrigin = \"*\",\n      allowHeaders = [],\n      allowMethods = [],\n      exposeHeaders = [],\n      allowCredentials = false,\n      maxAge = Duration.fromMinutes(5),\n    } = corsOptions;\n\n    const defaultHeaders: CorsDefaultResponseHeaders = {\n      \"Access-Control-Allow-Origin\": allowOrigin || \"*\",\n      \"Access-Control-Expose-Headers\": exposeHeaders.join(\",\") || \"\",\n      \"Access-Control-Allow-Credentials\": allowCredentials ? \"true\" : \"false\",\n    };\n\n    const optionsHeaders: CorsOptionsResponseHeaders = {\n      \"Access-Control-Allow-Origin\": allowOrigin || \"*\",\n      \"Access-Control-Allow-Headers\": allowHeaders.join(\",\") || \"\",\n      \"Access-Control-Allow-Methods\": allowMethods.join(\",\") || \"\",\n      \"Access-Control-Max-Age\": maxAge.seconds.toString(),\n    };\n\n    return {\n      defaultResponse: defaultHeaders,\n      optionsResponse: optionsHeaders,\n    };\n  }\n\n  /**\n   * The base URL of the API endpoint.\n   */\n  public get url(): string {\n    return this._endpoint.url;\n  }\n\n  /**\n   * The Endpoint of the API.\n   * @abstract\n   * @internal\n   */\n  protected get _endpoint(): Endpoint {\n    throw new AbstractMemberError();\n  }\n\n  // https://spec.openapis.org/oas/v3.0.3\n  private apiSpec: any = {\n    paths: {},\n  };\n\n  private corsDefaultValues: ApiCorsOptions = {\n    allowOrigin: \"*\",\n    allowMethods: [\n      HttpMethod.GET,\n      HttpMethod.POST,\n      HttpMethod.PUT,\n      HttpMethod.DELETE,\n      HttpMethod.HEAD,\n      HttpMethod.OPTIONS,\n    ],\n    allowHeaders: [\"Content-Type\", \"Authorization\", \"X-Requested-With\"],\n    exposeHeaders: [],\n    allowCredentials: false,\n    maxAge: Duration.fromMinutes(5),\n  };\n\n  /**\n   * CORS options for api\n   */\n  protected corsOptions?: ApiCorsOptions;\n\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: IApiClient;\n\n  constructor(scope: Construct, id: string, props: ApiProps = {}) {\n    if (new.target === Api) {\n      return Resource._newFromFactory(API_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    this.corsOptions = props.cors ? this._cors(props.corsOptions) : undefined;\n\n    Node.of(this).title = \"Api\";\n    Node.of(this).description = \"A REST API endpoint\";\n  }\n\n  /**\n   * Add a inflight handler to the api for GET requests on the given path.\n   * @param path The path to handle GET requests for.\n   * @param inflight The function to handle the request.\n   * @param props Options for the route.\n   * @abstract\n   */\n  public get(\n    path: string,\n    inflight: IApiEndpointHandler,\n    props?: ApiGetOptions\n  ): void {\n    path;\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Add a inflight handler to the api for POST requests on the given path.\n   * @param path The path to handle POST requests for.\n   * @param inflight The function to handle the request.\n   * @param props Options for the route.\n   * @abstract\n   */\n  public post(\n    path: string,\n    inflight: IApiEndpointHandler,\n    props?: ApiPostOptions\n  ): void {\n    path;\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Add a inflight handler to the api for PUT requests on the given path.\n   * @param path The path to handle PUT requests for.\n   * @param inflight The function to handle the request.\n   * @param props Options for the route.\n   * @abstract\n   */\n  public put(\n    path: string,\n    inflight: IApiEndpointHandler,\n    props?: ApiPutOptions\n  ): void {\n    path;\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Add a inflight handler to the api for DELETE requests on the given path.\n   * @param path The path to handle DELETE requests for.\n   * @param inflight The function to handle the request.\n   * @param props Options for the route.\n   * @abstract\n   */\n  public delete(\n    path: string,\n    inflight: IApiEndpointHandler,\n    props?: ApiDeleteOptions\n  ): void {\n    path;\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Add a inflight handler to the api for PATCH requests on the given path.\n   * @param path The path to handle PATCH requests for.\n   * @param inflight The function to handle the request.\n   * @param props Options for the route.\n   * @abstract\n   */\n  public patch(\n    path: string,\n    inflight: IApiEndpointHandler,\n    props?: ApiPatchOptions\n  ): void {\n    path;\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Add a inflight handler to the api for OPTIONS requests on the given path.\n   * @param path The path to handle OPTIONS requests for.\n   * @param inflight The function to handle the request.\n   * @param props Options for the route.\n   * @abstract\n   */\n  public options(\n    path: string,\n    inflight: IApiEndpointHandler,\n    props?: ApiOptionsOptions\n  ): void {\n    path;\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Add a inflight handler to the api for HEAD requests on the given path.\n   * @param path The path to handle HEAD requests for.\n   * @param inflight The function to handle the request.\n   * @param props Options for the route.\n   * @abstract\n   */\n  public head(\n    path: string,\n    inflight: IApiEndpointHandler,\n    props?: ApiHeadOptions\n  ): void {\n    path;\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Add a inflight handler to the api for CONNECT requests on the given path.\n   * @param path The path to handle CONNECT requests for.\n   * @param inflight The function to handle the request.\n   * @param props Options for the route.\n   * @abstract\n   */\n  public connect(\n    path: string,\n    inflight: IApiEndpointHandler,\n    props?: ApiConnectOptions\n  ): void {\n    path;\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n  /**\n   * Validating path:\n   * if has `:` prefix - the part following that prefix is only letter, digit or _, not empty and placed before and after \"/\"\n   * @param path\n   * @throws if the path is invalid\n   * @internal\n   */\n  protected _validatePath(path: string) {\n    if (\n      !/^((\\/\\:[a-zA-Z0-9_\\-]+|\\/[a-zA-Z0-9_\\-\\.]*)*(?:\\?[^#]*)?)?$/g.test(path)\n    ) {\n      throw new Error(\n        `Invalid path ${path}. Url parts can only contain alpha-numeric chars, \"-\", \"_\" and \".\". Params can only contain alpha-numeric chars and \"_\".`\n      );\n    }\n  }\n\n  /**\n   * Returns CORS configuration. If props are provided, they will have precedence over defaults.\n   * @param props\n   * @returns ApiCorsOptions\n   * @internal\n   */\n  protected _cors(props?: ApiCorsOptions): ApiCorsOptions {\n    return {\n      ...this.corsDefaultValues,\n      ...props,\n    };\n  }\n\n  /**\n   * Checks if two given paths are siblings.\n   * @param pathA\n   * @param pathB\n   * @returns A boolean value indicating if provided paths are siblings.\n   * @internal\n   */\n\n  protected _arePathsSiblings(pathA: string, pathB: string): boolean {\n    const partsA = pathA.split(\"/\");\n    const partsB = pathB.split(\"/\");\n\n    let shorter = partsA.length < partsB.length ? partsA : partsB;\n\n    for (let i = 0; i < shorter.length; i++) {\n      const partA = partsA[i];\n      const partB = partsB[i];\n      if (\n        (!partA.match(/^:.+?$/) || !partB.match(/^:.+?$/)) &&\n        partA[i] !== partB[i]\n      ) {\n        return false;\n      }\n\n      if (\n        partA.match(/^:.+?$/) &&\n        partB.match(/^:.+?$/) &&\n        partA[i] !== partB[i]\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks if two given paths are ambiguous.\n   * @param pathA\n   * @param pathB\n   * @returns A boolean value indicating if provided paths are ambiguous.\n   * @internal\n   */\n  protected _arePathsAmbiguous(pathA: string, pathB: string): boolean {\n    const partsA = pathA.split(\"/\");\n    const partsB = pathB.split(\"/\");\n\n    if (partsA.length !== partsB.length) {\n      return false;\n    }\n\n    for (let i = 0; i < partsA.length; i++) {\n      const partA = partsA[i];\n      const partB = partsB[i];\n\n      if (partA !== partB && !partA.match(/^:.+?$/) && !partB.match(/^:.+?$/)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks if provided path and method are ambigous with paths and methods already defined in the api spec.\n   * @param path Path to be checked\n   * @param method HTTP method\n   * @returns A boolean value indicating if provided path and method are ambiguous.\n   * @internal\n   */\n  protected _findAmbiguousPath(\n    path: string,\n    method: string\n  ): string | undefined {\n    const existingPaths = Object.keys(this.apiSpec.paths);\n\n    return existingPaths.find(\n      (existingPath) =>\n        !!this.apiSpec.paths[existingPath][method.toLowerCase()] &&\n        this._arePathsAmbiguous(existingPath, path)\n    );\n  }\n\n  /**\n   * Checks if provided path is a sibling of paths already defined in the api spec- i.e \"/:username\" and \"/:id\".\n   * @param path Path to be checked\n   * @returns A boolean value indicating if provided path has a sibling.\n   * @internal\n   */\n  private _findSiblingPath(path: string): string | undefined {\n    const existingPaths = Object.keys(this.apiSpec.paths);\n\n    return existingPaths.find((existingPath) =>\n      this._arePathsSiblings(existingPath, path)\n    );\n  }\n\n  /**\n   * Generates the OpenAPI schema for CORS headers based on the provided CORS options.\n   * @param corsOptions The CORS options to generate the schema from.\n   * @returns An object representing the OpenAPI schema for CORS headers.\n   */\n  private _corsOpenApiSchema(corsOptions?: ApiCorsOptions): OpenApiCorsHeaders {\n    const corsHeaders: OpenApiCorsHeaders = {};\n    if (corsOptions) {\n      const corsHeaderSchema = {\n        schema: {\n          type: \"string\",\n        },\n      };\n      corsHeaders[\"Access-Control-Allow-Origin\"] = corsHeaderSchema;\n      corsHeaders[\"Access-Control-Allow-Methods\"] = corsHeaderSchema;\n      corsHeaders[\"Access-Control-Allow-Headers\"] = corsHeaderSchema;\n      corsHeaders[\"Access-Control-Max-Age\"] = corsHeaderSchema;\n    }\n    return corsHeaders;\n  }\n\n  /**\n   * Add a route to the api spec.\n   * @param path The path to add.\n   * @param method The method to add.\n   * @param apiSpecExtension The extension to add to the api spec for this route and method.\n   *\n   * @internal\n   * */\n  public _addToSpec(\n    path: string,\n    method: string,\n    apiSpecExtension: OpenApiSpecExtension,\n    corsOptions?: ApiCorsOptions\n  ) {\n    if (this.apiSpec.paths[path]?.[method.toLowerCase()]) {\n      throw new Error(\n        `Endpoint for path '${path}' and method '${method}' already exists`\n      );\n    }\n    const ambiguousPath = this._findAmbiguousPath(path, method);\n    if (!!ambiguousPath) {\n      throw new Error(\n        `Endpoint for path '${path}' and method '${method}' is ambiguous - it conflicts with existing endpoint for path '${ambiguousPath}'`\n      );\n    }\n    const siblingPath = this._findSiblingPath(path);\n    if (!!siblingPath) {\n      throw new Error(\n        `Endpoint for path '${path}' and method '${method}' conflicts with existing sibling endpoint for path '${siblingPath}'- try to match the parameter names to avoid this error.`\n      );\n    }\n    const operationId = `${method.toLowerCase()}${\n      path === \"/\" ? \"\" : path.replace(\"/\", \"-\")\n    }`;\n    const pathParams = path.match(/:([A-Za-z0-9_-]+)/g);\n    const pathParameters: any[] = [];\n    if (pathParams) {\n      pathParams.forEach((param) => {\n        const paramName = param.replace(\":\", \"\");\n        pathParameters.push({\n          name: paramName,\n          in: \"path\",\n          required: true,\n          schema: {\n            type: \"string\",\n          },\n        });\n      });\n    }\n    const corsOpenApiSchema = this._corsOpenApiSchema(corsOptions);\n    const methodSpec = {\n      [method.toLowerCase()]: {\n        operationId: operationId,\n        responses: {\n          \"200\": {\n            description: \"200 response\",\n            content: {},\n            ...(Object.keys(corsOpenApiSchema).length > 0\n              ? { headers: corsOpenApiSchema }\n              : {}),\n          },\n        },\n        parameters: pathParameters,\n        ...apiSpecExtension,\n      },\n    };\n    this.apiSpec.paths[path] = {\n      ...this.apiSpec.paths[path],\n      ...methodSpec,\n    };\n  }\n\n  /**\n   * Return the OpenAPI spec for this Api.\n   * @internal */\n  public _getOpenApiSpec(): OpenApiSpec {\n    // Convert our paths to valid OpenAPI paths\n    let paths: { [key: string]: any } = {};\n    Object.keys(this.apiSpec.paths).forEach((key) => {\n      paths[Api.renderOpenApiPath(key)] = this.apiSpec.paths[key];\n    });\n\n    // https://spec.openapis.org/oas/v3.0.3\n    return {\n      ...this.apiSpec,\n      openapi: \"3.0.3\",\n      paths: paths,\n    };\n  }\n}\n\n/**\n * Base options for Api endpoints.\n */\nexport interface ApiEndpointOptions extends FunctionProps {}\n\n/**\n * Options for Api get endpoint.\n */\nexport interface ApiGetOptions extends ApiEndpointOptions {}\n\n/**\n * Options for Api post endpoint.\n */\nexport interface ApiPostOptions extends ApiEndpointOptions {}\n\n/**\n * Options for Api put endpoint.\n */\nexport interface ApiPutOptions extends ApiEndpointOptions {}\n\n/**\n * Options for Api put endpoint.\n */\nexport interface ApiDeleteOptions extends ApiEndpointOptions {}\n\n/**\n * Options for Api patch endpoint.\n */\nexport interface ApiPatchOptions extends ApiEndpointOptions {}\n\n/**\n * Options for Api patch endpoint.\n */\nexport interface ApiOptionsOptions extends ApiEndpointOptions {}\n\n/**\n * Options for Api patch endpoint.\n */\nexport interface ApiHeadOptions extends ApiEndpointOptions {}\n\n/**\n * Options for Api patch endpoint.\n */\nexport interface ApiConnectOptions extends ApiEndpointOptions {}\n\n/**\n * Inflight methods and members of `cloud.Api`.\n */\nexport interface IApiClient {}\n\n/**\n * List of inflight operations available for `Api`.\n * @internal\n */\nexport enum ApiInflightMethods {\n  /** When the API endpoint receives a request. */\n  REQUEST = \"request\",\n}\n\n/**\n * Allowed HTTP methods for a endpoint.\n */\nexport enum HttpMethod {\n  /** Get */\n  GET = \"GET\",\n  /** Head */\n  HEAD = \"HEAD\",\n  /** Post */\n  POST = \"POST\",\n  /** Put */\n  PUT = \"PUT\",\n  /** Delete */\n  DELETE = \"DELETE\",\n  /** Connect */\n  CONNECT = \"CONNECT\",\n  /** Options */\n  OPTIONS = \"OPTIONS\",\n  /** Patch */\n  PATCH = \"PATCH\",\n}\n\n/**\n * Shape of a request to an inflight handler.\n */\nexport interface ApiRequest {\n  /** The request's HTTP method. */\n  readonly method: HttpMethod;\n  /** The request's path. */\n  readonly path: string;\n  /** The request's query string values. */\n  readonly query: Record<string, string>;\n  /** The path variables. */\n  readonly vars: Record<string, string>;\n  /** The request's body. */\n  readonly body?: string;\n  /** The request's headers. */\n  readonly headers?: Record<string, string>;\n}\n\nexport const DEFAULT_RESPONSE_STATUS = 200;\n\n/**\n * Shape of a response from a inflight handler.\n */\nexport interface ApiResponse {\n  /**\n   * The response's status code.\n   * @default 200\n   **/\n  readonly status?: number;\n\n  /**\n   * The response's body.\n   * @default - no body\n   **/\n  readonly body?: string;\n  /**\n   * The response's headers.\n   * @default {}\n   **/\n  readonly headers?: Record<string, string>;\n}\n\n/**\n * A resource with an inflight \"handle\" method that can be passed to\n * one of the `Api` request preflight methods.\n *\n * @inflight `@winglang/sdk.cloud.IApiEndpointHandlerClient`\n */\nexport interface IApiEndpointHandler extends IInflight {\n  /** @internal */\n  [INFLIGHT_SYMBOL]?: IApiEndpointHandlerClient[\"handle\"];\n}\n\n/**\n * Inflight client for `IApiEndpointHandler`.\n */\nexport interface IApiEndpointHandlerClient {\n  /**\n   * Inflight that will be called when a request is made to the endpoint.\n   * @inflight\n   */\n  handle(request: ApiRequest): Promise<ApiResponse | undefined>;\n}\n\n/**\n * Parse an HTTP method string to an HttpMethod enum\n * @param method HTTP method string\n * @returns HttpMethod enum\n * @throws Error if the method is not supported\n */\nexport function parseHttpMethod(method: string): HttpMethod {\n  switch (method) {\n    case \"GET\":\n      return HttpMethod.GET;\n    case \"POST\":\n      return HttpMethod.POST;\n    case \"PUT\":\n      return HttpMethod.PUT;\n    case \"HEAD\":\n      return HttpMethod.HEAD;\n    case \"DELETE\":\n      return HttpMethod.DELETE;\n    case \"CONNECT\":\n      return HttpMethod.CONNECT;\n    case \"OPTIONS\":\n      return HttpMethod.OPTIONS;\n    case \"PATCH\":\n      return HttpMethod.PATCH;\n    default:\n      throw new Error(`Unsupported HTTP method: ${method}`);\n  }\n}\n\n/**\n * Convert an object with multi-valued parameters to a an object with\n * single-valued parameters.\n */\nexport function sanitizeParamLikeObject(\n  obj: Record<string, string | string[] | undefined>\n) {\n  const newObj: Record<string, string> = {};\n  Object.keys(obj).forEach((key) => {\n    const value = obj[key];\n    if (Array.isArray(value)) {\n      newObj[key] = value.join(\",\");\n    } else if (typeof value === \"string\") {\n      newObj[key] = value;\n    }\n  });\n  return newObj;\n}\n","import { Construct } from \"constructs\";\nimport { Function, FunctionProps } from \"./function\";\nimport { Queue, QueueProps } from \"./queue\";\nimport { fqnForType } from \"../constants\";\nimport { AbstractMemberError } from \"../core/errors\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { Node, Resource, IInflight } from \"../std\";\n\nexport const TOPIC_FQN = fqnForType(\"cloud.Topic\");\n\n/**\n * Options for `Topic`.\n */\nexport interface TopicProps {}\n\n/**\n * A topic.\n *\n * @inflight `@winglang/sdk.cloud.ITopicClient`\n * @abstract\n */\nexport class Topic extends Resource {\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: ITopicClient;\n\n  constructor(scope: Construct, id: string, props: TopicProps = {}) {\n    if (new.target === Topic) {\n      return Resource._newFromFactory(TOPIC_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Topic\";\n    Node.of(this).description = \"A pub/sub notification topic\";\n\n    props;\n  }\n\n  /**\n   * Run an inflight whenever an message is published to the topic.\n   * @abstract\n   */\n  public onMessage(\n    inflight: ITopicOnMessageHandler,\n    props?: TopicOnMessageOptions\n  ): Function {\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Subscribing queue to the topic\n   * @abstract\n   */\n  public subscribeQueue(\n    queue: Queue,\n    props?: TopicSubscribeQueueOptions\n  ): void {\n    queue;\n    props;\n    throw new AbstractMemberError();\n  }\n}\n\n/**\n * Options for `Topic.onMessage`.\n */\nexport interface TopicOnMessageOptions extends FunctionProps {}\n/**\n * Options for `Topic.subscribeQueue`.\n */\nexport interface TopicSubscribeQueueOptions extends QueueProps {}\n\n/**\n * Inflight interface for `Topic`.\n */\nexport interface ITopicClient {\n  /**\n   * Publish messages to topic, if multiple messages are passed then they\n   * will be published as a batch if supported by the target platform\n   * @param messages Payload to publish to Topic\n   * @inflight\n   */\n  publish(...messages: string[]): Promise<void>;\n}\n\n/**\n * A resource with an inflight \"handle\" method that can be passed to\n * `Topic.on_message`.\n *\n * @inflight `@winglang/sdk.cloud.ITopicOnMessageHandlerClient`\n */\nexport interface ITopicOnMessageHandler extends IInflight {\n  /** @internal */\n  [INFLIGHT_SYMBOL]?: ITopicOnMessageHandlerClient[\"handle\"];\n}\n\n/**\n * Inflight client for `ITopicOnMessageHandler`.\n */\nexport interface ITopicOnMessageHandlerClient {\n  /**\n   * Function that will be called when a message is received from the topic.\n   * @inflight\n   */\n  handle(event: string): Promise<void>;\n}\n\n/**\n * List of inflight operations available for `Topic`.\n * @internal\n */\nexport enum TopicInflightMethods {\n  /** `Topic.publish` */\n  PUBLISH = \"publish\",\n}\n","import * as fs from \"fs\";\nimport { isAbsolute, resolve } from \"path\";\nimport { Construct } from \"constructs\";\nimport { ITopicOnMessageHandler, Topic, TopicInflightMethods } from \"./topic\";\nimport { fqnForType } from \"../constants\";\nimport { App } from \"../core\";\nimport { AbstractMemberError } from \"../core/errors\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { Json, Node, Resource, Datetime, Duration, IInflight } from \"../std\";\n\n/**\n * Global identifier for `Bucket`.\n */\nexport const BUCKET_FQN = fqnForType(\"cloud.Bucket\");\n\n/**\n * Options for `Bucket`.\n */\nexport interface BucketProps {\n  /**\n   * Whether the bucket's objects should be publicly accessible.\n   * @default false\n   */\n  readonly public?: boolean;\n}\n\n/**\n * A cloud object store.\n *\n * @inflight `@winglang/sdk.cloud.IBucketClient`\n * @abstract\n */\nexport class Bucket extends Resource {\n  /** @internal */\n  protected readonly _topics = new Map<BucketEventType, Topic>();\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: IBucketClient;\n\n  constructor(scope: Construct, id: string, props: BucketProps = {}) {\n    if (new.target === Bucket) {\n      return Resource._newFromFactory(BUCKET_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Bucket\";\n    Node.of(this).description = \"A cloud object store\";\n  }\n\n  /**\n   * Add a file to the bucket that is uploaded when the app is deployed.\n   *\n   * TODO: In the future this will support uploading any `Blob` type or\n   * referencing a file from the local filesystem.\n   * @abstract\n   */\n  public addObject(key: string, body: string): void {\n    key;\n    body;\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Add a file to the bucket from system folder\n   *\n   * @param {string} key - The key or name to associate with the file.\n   * @param {string} path - The path to the file on the local system.\n   * @param {BufferEncoding} encoding - The encoding to use when reading the file. Defaults to \"utf-8\".\n   */\n\n  public addFile(\n    key: string,\n    path: string,\n    encoding: BufferEncoding = \"utf-8\"\n  ): void {\n    const app = App.of(this);\n\n    const data = fs.readFileSync(\n      isAbsolute(path) ? path : resolve(app.entrypointDir, path),\n      { encoding: encoding }\n    );\n\n    this.addObject(key, data);\n  }\n\n  /**\n   * Creates a topic for subscribing to notification events\n   * @param actionType\n   * @returns the created topic\n   */\n  protected createTopic(actionType: BucketEventType): Topic {\n    const topic = new Topic(this, actionType);\n    this.node.addDependency(topic);\n    return topic;\n  }\n\n  /**\n   * Gets topic form the topics map, or creates if not exists\n   * @param actionType\n   */\n  protected getTopic(actionType: BucketEventType): Topic {\n    if (!this._topics.has(actionType)) {\n      this._topics.set(actionType, this.createTopic(actionType));\n    }\n    return this._topics.get(actionType) as Topic;\n  }\n\n  /**\n   * Creates an inflight handler from inflight code\n   * @param eventType\n   * @param inflight\n   */\n  protected createTopicHandler(\n    eventType: BucketEventType,\n    inflight: IBucketEventHandler\n  ): ITopicOnMessageHandler {\n    eventType;\n    inflight;\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Creates a bucket event notifier\n   * @param eventNames the events to subscribe the inflight function to\n   * @param inflight the code to run upon event\n   * @param opts\n   */\n  private createBucketEvent(\n    eventNames: BucketEventType[],\n    inflight: IBucketEventHandler,\n    opts?: BucketOnCreateOptions\n  ) {\n    opts;\n    if (eventNames.includes(BucketEventType.CREATE)) {\n      const topic = this.getTopic(BucketEventType.CREATE).onMessage(\n        this.createTopicHandler(BucketEventType.CREATE, inflight)\n      );\n      for (const op of [\n        BucketInflightMethods.PUT,\n        BucketInflightMethods.PUT_JSON,\n      ]) {\n        Node.of(this).addConnection({\n          source: this,\n          sourceOp: op,\n          target: topic,\n          targetOp: TopicInflightMethods.PUBLISH,\n          name: BucketEventType.CREATE,\n        });\n      }\n    }\n    if (eventNames.includes(BucketEventType.UPDATE)) {\n      const topic = this.getTopic(BucketEventType.UPDATE).onMessage(\n        this.createTopicHandler(BucketEventType.UPDATE, inflight)\n      );\n      for (const op of [\n        BucketInflightMethods.PUT,\n        BucketInflightMethods.PUT_JSON,\n      ]) {\n        Node.of(this).addConnection({\n          source: this,\n          sourceOp: op,\n          target: topic,\n          targetOp: TopicInflightMethods.PUBLISH,\n          name: BucketEventType.UPDATE,\n        });\n      }\n    }\n    if (eventNames.includes(BucketEventType.DELETE)) {\n      const topic = this.getTopic(BucketEventType.DELETE).onMessage(\n        this.createTopicHandler(BucketEventType.DELETE, inflight)\n      );\n      for (const op of [\n        BucketInflightMethods.DELETE,\n        BucketInflightMethods.TRY_DELETE,\n      ]) {\n        Node.of(this).addConnection({\n          source: this,\n          sourceOp: op,\n          target: topic,\n          targetOp: TopicInflightMethods.PUBLISH,\n          name: BucketEventType.DELETE,\n        });\n      }\n    }\n  }\n\n  /**\n   * Run an inflight whenever a file is uploaded to the bucket.\n   */\n  public onCreate(fn: IBucketEventHandler, opts?: BucketOnCreateOptions): void {\n    if (opts) {\n      console.warn(\"bucket.onCreate does not support options yet\");\n    }\n    this.createBucketEvent([BucketEventType.CREATE], fn, opts);\n  }\n\n  /**\n   * Run an inflight whenever a file is deleted from the bucket.\n   */\n  public onDelete(fn: IBucketEventHandler, opts?: BucketOnDeleteOptions): void {\n    if (opts) {\n      console.warn(\"bucket.onDelete does not support options yet\");\n    }\n    this.createBucketEvent([BucketEventType.DELETE], fn, opts);\n  }\n\n  /**\n   * Run an inflight whenever a file is updated in the bucket.\n   */\n  public onUpdate(fn: IBucketEventHandler, opts?: BucketOnUpdateOptions): void {\n    if (opts) {\n      console.warn(\"bucket.onUpdate does not support options yet\");\n    }\n    this.createBucketEvent([BucketEventType.UPDATE], fn, opts);\n  }\n\n  /**\n   * Run an inflight whenever a file is uploaded, modified, or deleted from the bucket.\n   */\n  public onEvent(fn: IBucketEventHandler, opts?: BucketOnEventOptions): void {\n    if (opts) {\n      console.warn(\"bucket.onEvent does not support options yet\");\n    }\n    this.createBucketEvent(\n      [BucketEventType.CREATE, BucketEventType.UPDATE, BucketEventType.DELETE],\n      fn,\n      opts\n    );\n  }\n}\n\n/**\n * Metadata of a bucket object.\n */\nexport interface ObjectMetadata {\n  /** The size of the object in bytes. */\n  readonly size: number;\n\n  /** The time the object was last modified. */\n  readonly lastModified: Datetime;\n\n  /** The content type of the object, if it is known. */\n  readonly contentType?: string;\n}\n\n/**\n * Options for `Bucket.get()`.\n */\nexport interface BucketGetOptions {\n  /**\n   * The starting byte to read from.\n   * @default - undefined\n   */\n  readonly startByte?: number;\n\n  /**\n   * The ending byte to read up to (including).\n   * @default - undefined\n   */\n  readonly endByte?: number;\n}\n\n/**\n * Options for `Bucket.tryGet()`.\n */\nexport interface BucketTryGetOptions extends BucketGetOptions {}\n\n/**\n * Options for `Bucket.put()`.\n */\nexport interface BucketPutOptions {\n  /**\n   * The HTTP Content-Type of the object.\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type\n   * @default - Determined by file extension or fallback to \"application/octet-stream\"\n   */\n  readonly contentType: string;\n}\n\n/**\n * Options for `Bucket.delete()`.\n */\nexport interface BucketDeleteOptions {\n  /**\n   * Check failures on the method and retrieve errors if any\n   * @Throws if this is `true`, an error is thrown if the file is not found (or any error case).\n   * @default false\n   */\n  readonly mustExist?: boolean;\n}\n\n/**\n * Specifies the action permitted by a presigned URL for a bucket.\n */\nexport enum BucketSignedUrlAction {\n  /**\n   * Represents a HTTP GET request for a presigned URL, allowing read access for an object in the bucket.\n   */\n  DOWNLOAD = \"DOWNLOAD\",\n  /**\n   * Represents a HTTP PUT request for a presigned URL, allowing write access for an object in the bucket.\n   */\n  UPLOAD = \"UPLOAD\",\n}\n\n/**\n * Options for `Bucket.signedUrl()`.\n */\nexport interface BucketSignedUrlOptions {\n  /**\n   * The duration for the signed URL to expire.\n   * @default 15m\n   */\n  readonly duration?: Duration;\n\n  /**\n   * The action allowed by the signed URL.\n   * @default BucketSignedUrlAction.DOWNLOAD\n   */\n  readonly action?: BucketSignedUrlAction;\n}\n\n/**\n * Inflight interface for `Bucket`.\n */\nexport interface IBucketClient {\n  /**\n   * Check if an object exists in the bucket.\n   * @param key Key of the object.\n   * @inflight\n   */\n  exists(key: string): Promise<boolean>;\n\n  /**\n   * Put an object in the bucket.\n   * @param key Key of the object.\n   * @param body Content of the object we want to store into the bucket.\n   * @param options Additional options\n   * @inflight\n   */\n  put(key: string, body: string, options?: BucketPutOptions): Promise<void>;\n\n  /**\n   * Put a Json object in the bucket.\n   * @param key Key of the object.\n   * @param body Json object that we want to store into the bucket.\n   * @inflight\n   */\n  putJson(key: string, body: Json): Promise<void>;\n\n  /**\n   * Retrieve an object from the bucket.\n   * If the bytes returned are not a valid UTF-8 string, an error is thrown.\n   * @param key Key of the object.\n   * @param options Additional get options\n   * @Throws if no object with the given key exists.\n   * @Returns the object's body.\n   * @inflight\n   */\n  get(key: string, options?: BucketGetOptions): Promise<string>;\n\n  /**\n   * Get an object from the bucket if it exists\n   * If the bytes returned are not a valid UTF-8 string, an error is thrown.\n   * @param key Key of the object.\n   * @param options Additional get options\n   * @returns the contents of the object as a string if it exists, nil otherwise\n   * @inflight\n   */\n  tryGet(\n    key: string,\n    options?: BucketTryGetOptions\n  ): Promise<string | undefined>;\n\n  /**\n   * Retrieve a Json object from the bucket.\n   * @param key Key of the object.\n   * @Throws if no object with the given key exists.\n   * @Returns the object's parsed Json.\n   * @inflight\n   */\n  getJson(key: string): Promise<Json>;\n\n  /**\n   * Gets an object from the bucket if it exists, parsing it as Json.\n   * @param key Key of the object.\n   * @returns the contents of the object as Json if it exists, nil otherwise\n   * @inflight\n   */\n  tryGetJson(key: string): Promise<Json | undefined>;\n\n  /**\n   * Delete an existing object using a key from the bucket\n   * @param key Key of the object.\n   * @param opts Options available for delete an item from a bucket.\n   * @inflight\n   */\n  delete(key: string, opts?: BucketDeleteOptions): Promise<void>;\n\n  /**\n   * Delete an object from the bucket if it exists.\n   * @param key Key of the object.\n   * @returns the result of the delete operation\n   * @inflight\n   */\n  tryDelete(key: string): Promise<boolean>;\n\n  /**\n   * Retrieve existing objects keys from the bucket.\n   * @param prefix Limits the response to keys that begin with the specified prefix.\n   * @returns a list of keys or an empty array if the bucket is empty.\n   * @inflight\n   */\n  list(prefix?: string): Promise<string[]>;\n\n  /**\n   * Returns a url to the given file.\n   * @Throws if the file is not public or if object does not exist.\n   * @inflight\n   */\n  publicUrl(key: string): Promise<string>;\n\n  /**\n   * Returns a signed url to the given file.\n   * @Throws if object does not exist.\n   * @param key The key to access the cloud object\n   * @param options The signedUrlOptions where you can provide the configurations of the signed url\n   * @returns A string representing the signed url of the object which can be used to download in any downstream system\n   * @inflight\n   */\n  signedUrl(key: string, options?: BucketSignedUrlOptions): Promise<string>;\n\n  /**\n   * Get the metadata of an object in the bucket.\n   * @param key Key of the object.\n   * @Throws if there is no object with the given key.\n   * @inflight\n   */\n  metadata(key: string): Promise<ObjectMetadata>;\n\n  /**\n   * Copy an object to a new location in the bucket. If the destination object\n   * already exists, it will be overwritten.\n   * @param srcKey The key of the source object you wish to copy.\n   * @param dstKey The key of the destination object after copying.\n   * @throws if `srcKey` object doesn't exist.\n   * @inflight\n   */\n  copy(srcKey: string, dstKey: string): Promise<void>;\n\n  /**\n   * Move an object to a new location in the bucket. If the destination object\n   * already exists, it will be overwritten. Returns once the renaming is finished.\n   * @param srcKey The key of the source object you wish to rename.\n   * @param dstKey The key of the destination object after renaming.\n   * @throws if `srcKey` object doesn't exist or if it matches `dstKey`.\n   * @inflight\n   */\n  rename(srcKey: string, dstKey: string): Promise<void>;\n}\n\n/**\n * `onCreate` event options\n */\nexport interface BucketOnCreateOptions {}\n\n/**\n * `onDelete` event options\n */\nexport interface BucketOnDeleteOptions {}\n\n/**\n * `onUpdate` event options\n */\nexport interface BucketOnUpdateOptions {}\n\n/**\n * `onEvent` options\n */\nexport interface BucketOnEventOptions {}\n\n/**\n * A resource with an inflight \"handle\" method that can be passed to\n * the bucket events.\n *\n * @inflight `@winglang/sdk.cloud.IBucketEventHandlerClient`\n */\nexport interface IBucketEventHandler extends IInflight {\n  /** @internal */\n  [INFLIGHT_SYMBOL]?: IBucketEventHandlerClient[\"handle\"];\n}\n\n/**\n * A resource with an inflight \"handle\" method that can be passed to\n * the bucket events.\n *\n */\nexport interface IBucketEventHandlerClient {\n  /**\n   * Function that will be called when an event notification is fired.\n   * @inflight\n   */\n  handle(key: string, type: BucketEventType): Promise<void>;\n}\n\n/**\n * On_event notification payload- will be in use after solving issue: https://github.com/winglang/wing/issues/1927\n */\nexport interface BucketEvent {\n  /**\n   * The bucket key that triggered the event\n   */\n  readonly key: string;\n  /**\n   * Type of event\n   */\n  readonly type: BucketEventType;\n}\n\n/**\n * Bucket events to subscribe to\n */\nexport enum BucketEventType {\n  /**\n   * Create\n   */\n  CREATE = \"OnCreate\",\n  /**\n   * Delete\n   */\n  DELETE = \"OnDelete\",\n  /**\n   * Update\n   */\n  UPDATE = \"OnUpdate\",\n}\n\n/**\n * List of inflight operations available for `Bucket`.\n * @internal\n */\nexport enum BucketInflightMethods {\n  /** `Bucket.put` */\n  PUT = \"put\",\n  /** `Bucket.get` */\n  GET = \"get\",\n  /** `Bucket.list` */\n  LIST = \"list\",\n  /** `Bucket.delete` */\n  DELETE = \"delete\",\n  /** `Bucket.putJson` */\n  PUT_JSON = \"putJson\",\n  /** `Bucket.getJson` */\n  GET_JSON = \"getJson\",\n  /** `Bucket.publicUrl` */\n  PUBLIC_URL = \"publicUrl\",\n  /** `Bucket.exists` */\n  EXISTS = \"exists\",\n  /** `Bucket.tryGet` */\n  TRY_GET = \"tryGet\",\n  /** `Bucket.tryGetJson` */\n  TRY_GET_JSON = \"tryGetJson\",\n  /** `Bucket.tryDelete` */\n  TRY_DELETE = \"tryDelete\",\n  /** `Bucket.signedUrl` */\n  SIGNED_URL = \"signedUrl\",\n  /** `Bucket.metadata` */\n  METADATA = \"metadata\",\n  /** `Bucket.copy` */\n  COPY = \"copy\",\n  /** `Bucket.rename` */\n  RENAME = \"rename\",\n}\n","import { Construct } from \"constructs\";\nimport { fqnForType } from \"../constants\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `Counter`.\n */\nexport const COUNTER_FQN = fqnForType(\"cloud.Counter\");\n\n/**\n * Options for `Counter`.\n */\nexport interface CounterProps {\n  /**\n   * The initial value of the counter.\n   * @default 0\n   */\n  readonly initial?: number;\n}\n\n/**\n * A distributed atomic counter.\n * @inflight `@winglang/sdk.cloud.ICounterClient`\n * @abstract\n */\nexport class Counter extends Resource {\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: ICounterClient;\n\n  /**\n   * The initial value of the counter.\n   */\n  public readonly initial!: number;\n\n  constructor(scope: Construct, id: string, props: CounterProps = {}) {\n    if (new.target === Counter) {\n      return Resource._newFromFactory(COUNTER_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Counter\";\n    Node.of(this).description = \"A distributed atomic counter\";\n\n    this.initial = props.initial ?? 0;\n  }\n}\n\n/**\n * Inflight interface for `Counter`.\n */\nexport interface ICounterClient {\n  /**\n   * Increments the counter atomically by a certain amount and returns the previous value.\n   * @param amount amount to increment (default is 1).\n   * @param key specify the key to be incremented.\n   * @returns the previous value of the counter.\n   * @inflight\n   */\n  inc(amount?: number, key?: string): Promise<number>;\n\n  /**\n   * Decrement the counter, returning the previous value.\n   * @param amount amount to decrement (default is 1).\n   * @param key specify the key to be decremented.\n   * @returns the previous value of the counter.\n   * @inflight\n   */\n  dec(amount?: number, key?: string): Promise<number>;\n\n  /**\n   * Get the current value of the counter.\n   * Using this API may introduce race conditions since the value can change between\n   * the time it is read and the time it is used in your code.\n   * @param key specify the key to be retrieved.\n   * @returns current value\n   * @inflight\n   */\n  peek(key?: string): Promise<number>;\n\n  /**\n   * Set a counter to a given value.\n   * @param value new value\n   * @param key specify the key to be set.\n   * @inflight\n   */\n  set(value: number, key?: string): Promise<void>;\n}\n\n/**\n * List of inflight operations available for `Counter`.\n * @internal\n */\nexport enum CounterInflightMethods {\n  /** `Counter.inc` */\n  INC = \"inc\",\n  /** `Counter.dec` */\n  DEC = \"dec\",\n  /** `Counter.peek` */\n  PEEK = \"peek\",\n  /** `Counter.set` */\n  SET = \"set\",\n}\n","import { Construct } from \"constructs\";\nimport { fqnForType } from \"../constants\";\nimport { Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `Domain`.\n */\nexport const DOMAIN_FQN = fqnForType(\"cloud.Domain\");\n\n/**\n * Options for `Domain`.\n */\nexport interface DomainProps {\n  /**\n   * The website's custom domain name.\n   * @example \"example.com\"\n   */\n  readonly domainName: string;\n}\n\n/**\n * A cloud Domain\n * @inflight `@winglang/sdk.cloud.IDomainClient`\n * @abstract\n */\nexport class Domain extends Resource {\n  /** @internal */\n  protected _domain!: string;\n\n  constructor(scope: Construct, id: string, props: DomainProps) {\n    if (new.target === Domain) {\n      return Resource._newFromFactory(DOMAIN_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Domain\";\n    Node.of(this).description = \"A cloud domain\";\n\n    this._domain = props.domainName;\n  }\n\n  /**\n   * The domain name.\n   */\n  public get domainName(): string {\n    return this._domain;\n  }\n}\n\n/**\n * Inflight interface for `Domain`.\n */\nexport interface IDomainClient {}\n","import { Construct } from \"constructs\";\nimport { fqnForType } from \"../constants\";\nimport { Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `Endpoint`.\n */\nexport const ENDPOINT_FQN = fqnForType(\"cloud.Endpoint\");\n\n/**\n * Options for `Endpoint`.\n */\nexport interface EndpointProps {\n  /**\n   * The endpoint's label. For UI purposes.\n   * @example \"My Dashboard\"\n   * @default undefined\n   */\n  readonly label?: string;\n\n  /**\n   * Whether the endpoint is supported through browsers. For UI purposes.\n   * @default undefined\n   */\n  readonly browserSupport?: boolean;\n}\n\n/**\n * A cloud Endpoint\n * @inflight `@winglang/sdk.cloud.IEndpointClient`\n * @abstract\n */\nexport class Endpoint extends Resource {\n  /** @internal */\n  private _url!: string;\n\n  /** @internal */\n  protected _label: string | undefined;\n\n  /** @internal */\n  protected _browserSupport: boolean | undefined;\n\n  /**\n   * The endpoint url.\n   * @param url\n   */\n  constructor(\n    scope: Construct,\n    id: string,\n    url: string,\n    props?: EndpointProps\n  ) {\n    if (new.target === Endpoint) {\n      return Resource._newFromFactory(ENDPOINT_FQN, scope, id, url, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Endpoint\";\n    Node.of(this).description = props?.label ?? \"A cloud endpoint\";\n\n    this._url = url;\n    this._label = props?.label;\n    this._browserSupport = props?.browserSupport;\n  }\n\n  /**\n   * The endpoint url.\n   */\n  public get url(): string {\n    return this._url;\n  }\n\n  /**\n   * The endpoint label.\n   */\n  protected get label(): string | undefined {\n    return this._label;\n  }\n\n  /**\n   * The endpoint browser support.\n   */\n  protected get browserSupport(): boolean | undefined {\n    return this._browserSupport;\n  }\n}\n\n/**\n * Inflight interface for `Endpoint`.\n */\nexport interface IEndpointClient {}\n","import { Construct } from \"constructs\";\n\nexport enum CaseConventions {\n  LOWERCASE = \"lowercase\",\n  UPPERCASE = \"uppercase\",\n}\n\n/**\n * Options for `ResourceNames.generateName`\n */\nexport interface NameOptions {\n  /**\n   * Maximum length for the generated name. The length must at least the length\n   * of the hash (8 characters).\n   * @default - no maximum length\n   */\n  readonly maxLen?: number;\n\n  /**\n   * Regular expression that indicates which characters are invalid. Each group\n   * of characters will be replaced with `sep`.\n   */\n  readonly disallowedRegex: RegExp;\n\n  /**\n   * Word breaker\n   * @default \"-\"\n   */\n  readonly sep?: string;\n\n  /**\n   * Convert the generated name to all uppercase or all lowercase.\n   * @default - apply no case conversion\n   */\n  readonly case?: CaseConventions;\n\n  /**\n   * Apply a predefined prefix to the generated name\n   * @default - no prefix\n   */\n  readonly prefix?: string;\n\n  /**\n   * Apply a predefined suffix to the generated name\n   * @default - no suffix\n   */\n  readonly suffix?: string;\n\n  /**\n   * Include a hash of the resource's address in the generated name.\n   *\n   * This should only be disabled if the resource's name is guaranteed to be\n   * app-unique, or if some other source of randomness will be appended to the\n   * name.\n   *\n   * @default true\n   */\n  readonly includeHash?: boolean;\n}\n\nexport class ResourceNames {\n  public static generateName(resource: Construct, props: NameOptions): string {\n    const sep = props.sep ?? \"-\";\n    const maxLen = props.maxLen;\n\n    if (maxLen && maxLen < 8) {\n      throw new Error(\"maxLen must be at least 8\");\n    }\n\n    let name = resource.node.id;\n\n    name = applyCaseConversion(name, props.case);\n\n    if (props.prefix) {\n      name = `${props.prefix}${name}`;\n    }\n\n    let includeHash = props.includeHash ?? true;\n    let hash = includeHash ? sep + resource.node.addr.substring(0, 8) : \"\";\n    let suffix = props.suffix ?? \"\";\n\n    name = name.replace(props.disallowedRegex, sep);\n\n    // TODO: allow customizing where we \"trim\" the name, e.g.\n    // 1. trim from the end\n    // 2. trim from the beginning\n    // 3. trim from the middle\n    if (maxLen) {\n      name = name.substring(0, maxLen - hash.length - suffix.length);\n    }\n\n    name = `${name}${hash}${suffix}`;\n\n    // apply case conversion again in case the prefix, suffix, or hash is not\n    // case-conformant\n    name = applyCaseConversion(name, props.case);\n\n    return name;\n  }\n}\n\nfunction applyCaseConversion(name: string, caseConventions?: CaseConventions) {\n  if (caseConventions === CaseConventions.LOWERCASE) {\n    return name.toLocaleLowerCase();\n  }\n  if (caseConventions === CaseConventions.UPPERCASE) {\n    return name.toLocaleUpperCase();\n  }\n  return name;\n}\n","import { mkdirSync, writeFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { Construct } from \"constructs\";\nimport { fqnForType } from \"../constants\";\nimport { App, Lifting } from \"../core\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { CaseConventions, ResourceNames } from \"../shared/resource-names\";\nimport { Duration, IInflight, IInflightHost, Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `Function`.\n */\nexport const FUNCTION_FQN = fqnForType(\"cloud.Function\");\n\n/**\n * Options for `Function`.\n */\nexport interface FunctionProps {\n  /**\n   * Environment variables to pass to the function.\n   * @default - No environment variables.\n   */\n  readonly env?: { [key: string]: string };\n\n  /**\n   * The maximum amount of time the function can run.\n   * @default 1m\n   */\n  readonly timeout?: Duration;\n\n  /**\n   * The amount of memory to allocate to the function, in MB.\n   * @default 1024\n   */\n  readonly memory?: number;\n\n  /**\n   * Specifies the number of days that function logs will be kept.\n   * Setting negative value means logs will not expire.\n   * @default 30\n   */\n  readonly logRetentionDays?: number;\n\n  /**\n   * The maximum concurrent invocations that can run at one time.\n   * @default - platform specific limits (100 on the simulator)\n   */\n  readonly concurrency?: number;\n}\n\n/**\n * A function.\n *\n * @inflight `@winglang/sdk.cloud.IFunctionClient`\n * @abstract\n */\nexport class Function extends Resource implements IInflightHost {\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: IFunctionClient;\n  private readonly _env: Record<string, string> = {};\n  /**\n   * Reference to the function handler - an inflight closure.\n   */\n  protected readonly handler!: IFunctionHandler;\n\n  /**\n   * The path where the entrypoint of the function source code will be eventually written to.\n   */\n  protected readonly entrypoint!: string;\n\n  constructor(\n    scope: Construct,\n    id: string,\n    handler: IFunctionHandler,\n    props: FunctionProps = {}\n  ) {\n    if (new.target === Function) {\n      return Resource._newFromFactory(FUNCTION_FQN, scope, id, handler, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Function\";\n    Node.of(this).description = \"A cloud function (FaaS)\";\n\n    for (const [key, value] of Object.entries(props.env ?? {})) {\n      this.addEnvironment(key, value);\n    }\n\n    this.handler = handler;\n    const assetName = ResourceNames.generateName(this, {\n      // Avoid characters that may cause path issues\n      disallowedRegex: /[><:\"/\\\\|?*\\s]/g,\n      case: CaseConventions.LOWERCASE,\n      sep: \"_\",\n    });\n\n    const workdir = App.of(this).workdir;\n    mkdirSync(workdir, { recursive: true });\n    const entrypoint = join(workdir, `${assetName}.cjs`);\n    this.entrypoint = entrypoint;\n\n    if (process.env.WING_TARGET) {\n      this.addEnvironment(\"WING_TARGET\", process.env.WING_TARGET);\n    }\n\n    if (props.concurrency !== undefined && props.concurrency <= 0) {\n      throw new Error(\n        \"concurrency option on cloud.Function must be a positive integer\"\n      );\n    }\n  }\n\n  /** @internal */\n  public _preSynthesize(): void {\n    super._preSynthesize();\n\n    // write the entrypoint next to the partial inflight code emitted by the compiler,\n    // so that `require` resolves naturally.\n    const lines = this._getCodeLines(this.handler);\n    writeFileSync(this.entrypoint, lines.join(\"\\n\"));\n\n    // indicates that we are calling the inflight constructor and the\n    // inflight \"handle\" method on the handler resource.\n    Lifting.lift(this.handler, this, [\"handle\"]);\n  }\n\n  /**\n   * @internal\n   * @param handler IFunctionHandler\n   * @returns the function code lines as strings\n   */\n  protected _getCodeLines(handler: IFunctionHandler): string[] {\n    const inflightClient = handler._toInflight();\n    const lines = new Array<string>();\n    const client = \"$handler\";\n\n    lines.push('\"use strict\";');\n    lines.push(`var ${client} = undefined;`);\n    lines.push(\"exports.handler = async function(event) {\");\n    lines.push(`  ${client} = ${client} ?? (${inflightClient});`);\n    lines.push(`  return await ${client}.handle(event);`);\n    lines.push(\"};\");\n\n    return lines;\n  }\n\n  /**\n   * Add an environment variable to the function.\n   */\n  public addEnvironment(name: string, value: string) {\n    if (this._env[name] !== undefined && this._env[name] !== value) {\n      throw new Error(\n        `Environment variable \"${name}\" already set with a different value.`\n      );\n    }\n    this._env[name] = value;\n  }\n\n  /**\n   * Returns the set of environment variables for this function.\n   */\n  public get env(): Record<string, string> {\n    return { ...this._env };\n  }\n}\n\n/**\n * Inflight interface for `Function`.\n */\nexport interface IFunctionClient {\n  /**\n   * Invokes the function with a payload and waits for the result.\n   * @param payload payload to pass to the function. If not defined, an empty string will be passed.\n   * @returns An optional response from the function\n   * @inflight\n   */\n  invoke(payload?: string): Promise<string | undefined>;\n\n  /**\n   * Kicks off the execution of the function with a payload and returns immediately while the function is running.\n   * @param payload payload to pass to the function. If not defined, an empty string will be passed.\n   * @inflight\n   */\n  invokeAsync(payload?: string): Promise<void>;\n}\n\n/**\n * A resource with an inflight \"handle\" method that can be used to\n * create a `cloud.Function`.\n *\n * @inflight `@winglang/sdk.cloud.IFunctionHandlerClient`\n */\nexport interface IFunctionHandler extends IInflight {\n  /** @internal */\n  [INFLIGHT_SYMBOL]?: IFunctionHandlerClient[\"handle\"];\n}\n\n/**\n * Inflight client for `IFunctionHandler`.\n */\nexport interface IFunctionHandlerClient {\n  /**\n   * Entrypoint function that will be called when the cloud function is invoked.\n   * @inflight\n   */\n  handle(event?: string): Promise<string | undefined>;\n}\n\n/**\n * List of inflight operations available for `Function`.\n * @internal\n */\nexport enum FunctionInflightMethods {\n  /** `Function.invoke` */\n  INVOKE = \"invoke\",\n  /** `Function.invokeAsync` */\n  INVOKE_ASYNC = \"invokeAsync\",\n}\n","import { Construct } from \"constructs\";\nimport { FunctionProps } from \"./function\";\nimport { fqnForType } from \"../constants\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { IInflight, Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `OnDeploy`.\n */\nexport const ON_DEPLOY_FQN = fqnForType(\"cloud.OnDeploy\");\n\n/**\n * Options for `OnDeploy`.\n */\nexport interface OnDeployProps extends FunctionProps {\n  /**\n   * Execute this trigger only after these resources have been provisioned.\n   * @default - no additional dependencies\n   */\n  readonly executeAfter?: Construct[];\n\n  /**\n   * Adds this trigger as a dependency on other constructs.\n   * @default - no additional dependencies\n   */\n  readonly executeBefore?: Construct[];\n}\n\n/**\n * Run code every time the app is deployed.\n *\n * @inflight `@winglang/sdk.cloud.IOnDeployClient`\n * @abstract\n */\nexport class OnDeploy extends Resource {\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: IOnDeployClient;\n\n  constructor(\n    scope: Construct,\n    id: string,\n    handler: IOnDeployHandler,\n    props: OnDeployProps = {}\n  ) {\n    if (new.target === OnDeploy) {\n      return Resource._newFromFactory(ON_DEPLOY_FQN, scope, id, handler, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"OnDeploy\";\n    Node.of(this).description = \"Run code during the app's deployment.\";\n\n    handler;\n    props;\n  }\n}\n\n/**\n * A resource with an inflight \"handle\" method that can be used by `cloud.OnDeploy`.\n *\n * @inflight `@winglang/sdk.cloud.IOnDeployHandlerClient`\n */\nexport interface IOnDeployHandler extends IInflight {\n  /** @internal */\n  [INFLIGHT_SYMBOL]?: IOnDeployHandlerClient[\"handle\"];\n}\n\n/**\n * Inflight client for `IOnDeployHandler`.\n */\nexport interface IOnDeployHandlerClient {\n  /**\n   * Entrypoint function that will be called when the app is deployed.\n   * @inflight\n   */\n  handle(): Promise<void>;\n}\n\n/**\n * Inflight interface for `OnDeploy`.\n */\nexport interface IOnDeployClient {}\n","import { Construct } from \"constructs\";\nimport { Function, FunctionProps } from \"./function\";\nimport { fqnForType } from \"../constants\";\nimport { AbstractMemberError } from \"../core/errors\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { Duration, IInflight, Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `Queue`.\n */\nexport const QUEUE_FQN = fqnForType(\"cloud.Queue\");\n\n/**\n * Dead-letter queue default retries\n */\nexport const DEFAULT_DELIVERY_ATTEMPTS = 1;\n\n/**\n * Dead letter queue options.\n */\nexport interface DeadLetterQueueProps {\n  /**\n   * Queue to receive messages that failed processing.\n   */\n  readonly queue: Queue;\n  /**\n   * Number of times a message will be processed before being\n   * sent to the dead-letter queue.\n   * @default 1\n   */\n  readonly maxDeliveryAttempts?: number;\n}\n\n/**\n * Options for `Queue`.\n */\nexport interface QueueProps {\n  /**\n   * How long a queue's consumers have to process a message.\n   * @default 30s\n   */\n  readonly timeout?: Duration;\n\n  /**\n   * How long a queue retains a message.\n   * @default 1h\n   */\n  readonly retentionPeriod?: Duration;\n\n  /**\n   * A dead-letter queue.\n   * @default - no dead letter queue\n   */\n  readonly dlq?: DeadLetterQueueProps;\n}\n\n/**\n * A queue.\n *\n * @inflight `@winglang/sdk.cloud.IQueueClient`\n * @abstract\n */\nexport class Queue extends Resource {\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: IQueueClient;\n\n  constructor(scope: Construct, id: string, props: QueueProps = {}) {\n    if (new.target === Queue) {\n      return Resource._newFromFactory(QUEUE_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Queue\";\n    Node.of(this).description = \"A distributed message queue\";\n\n    props;\n  }\n\n  /**\n   * Create a function to consume messages from this queue.\n   * @abstract\n   */\n  public setConsumer(\n    handler: IQueueSetConsumerHandler,\n    props?: QueueSetConsumerOptions\n  ): Function {\n    handler;\n    props;\n    throw new AbstractMemberError();\n  }\n}\n\n/**\n * Options for Queue.setConsumer.\n */\nexport interface QueueSetConsumerOptions extends FunctionProps {\n  /**\n   * The maximum number of messages to send to subscribers at once.\n   * @default 1\n   */\n  readonly batchSize?: number;\n}\n\n/**\n * Inflight interface for `Queue`.\n */\nexport interface IQueueClient {\n  /**\n   * Push one or more messages to the queue.\n   * @param messages Payload to send to the queue. Each message must be non-empty.\n   * @inflight\n   */\n  push(...messages: string[]): Promise<void>;\n\n  /**\n   * Purge all of the messages in the queue.\n   * @inflight\n   */\n  purge(): Promise<void>;\n\n  /**\n   * Retrieve the approximate number of messages in the queue.\n   * @inflight\n   */\n  approxSize(): Promise<number>;\n\n  /**\n   * Pop a message from the queue.\n   * @returns The message, or `nil` if the queue is empty.\n   * @inflight\n   */\n  pop(): Promise<string | undefined>;\n}\n\n/**\n * A resource with an inflight \"handle\" method that can be passed to\n * `Queue.setConsumer`.\n *\n * @inflight `@winglang/sdk.cloud.IQueueSetConsumerHandlerClient`\n */\nexport interface IQueueSetConsumerHandler extends IInflight {\n  /** @internal */\n  [INFLIGHT_SYMBOL]?: IQueueSetConsumerHandlerClient[\"handle\"];\n}\n\n/**\n * Inflight client for `IQueueSetConsumerHandler`.\n */\nexport interface IQueueSetConsumerHandlerClient {\n  /**\n   * Function that will be called when a message is received from the queue.\n   * @inflight\n   */\n  handle(message: string): Promise<void>;\n}\n\n/**\n * List of inflight operations available for `Queue`.\n * @internal\n */\nexport enum QueueInflightMethods {\n  /** `Queue.push` */\n  PUSH = \"push\",\n  /** `Queue.purge` */\n  PURGE = \"purge\",\n  /** `Queue.approxSize` */\n  APPROX_SIZE = \"approxSize\",\n  /** `Queue.pop` */\n  POP = \"pop\",\n}\n","// This comes from the fact that parseInt trims characters coming\n// after digits and consider it a valid int, so `1*` becomes `1`.\nconst safeParseInt = (value: string): number => {\n  if (/^\\d+$/.test(value)) {\n    return Number(value)\n  } else {\n    return NaN\n  }\n}\n\nconst isWildcard = (value: string): boolean => {\n  return value === '*'\n}\n\nconst isQuestionMark = (value: string): boolean => {\n  return value === '?'\n}\n\nconst isInRange = (value: number, start: number, stop: number): boolean => {\n  return value >= start && value <= stop\n}\n\nconst isValidRange = (value: string, start: number, stop: number): boolean => {\n  const sides = value.split('-')\n  switch (sides.length) {\n    case 1:\n      return isWildcard(value) || isInRange(safeParseInt(value), start, stop)\n    case 2:\n      const [small, big] = sides.map((side: string): number => safeParseInt(side))\n      return small <= big && isInRange(small, start, stop) && isInRange(big, start, stop)\n    default:\n      return false\n  }\n}\n\nconst isValidStep = (value: string | undefined): boolean => {\n  return value === undefined || (value.search(/[^\\d]/) === -1 && safeParseInt(value) > 0)\n}\n\nconst validateForRange = (value: string, start: number, stop: number): boolean => {\n  if (value.search(/[^\\d-,\\/*]/) !== -1) {\n    return false\n  }\n\n  const list = value.split(',')\n  return list.every((condition: string): boolean => {\n    const splits = condition.split('/')\n    // Prevents `*/ * * * *` from being accepted.\n    if (condition.trim().endsWith('/')) {\n      return false\n    }\n\n    // Prevents `*/*/* * * * *` from being accepted\n    if (splits.length > 2) {\n      return false\n    }\n\n    // If we don't have a `/`, right will be undefined which is considered a valid step if we don't a `/`.\n    const [left, right] = splits\n    return isValidRange(left, start, stop) && isValidStep(right)\n  })\n}\n\nconst hasValidSeconds = (seconds: string): boolean => {\n  return validateForRange(seconds, 0, 59)\n}\n\nconst hasValidMinutes = (minutes: string): boolean => {\n  return validateForRange(minutes, 0, 59)\n}\n\nconst hasValidHours = (hours: string): boolean => {\n  return validateForRange(hours, 0, 23)\n}\n\nconst hasValidDays = (days: string, allowBlankDay?: boolean): boolean => {\n  return (allowBlankDay && isQuestionMark(days)) || validateForRange(days, 1, 31)\n}\n\nconst monthAlias: { [key: string]: string } = {\n  jan: '1',\n  feb: '2',\n  mar: '3',\n  apr: '4',\n  may: '5',\n  jun: '6',\n  jul: '7',\n  aug: '8',\n  sep: '9',\n  oct: '10',\n  nov: '11',\n  dec: '12'\n}\n\nconst hasValidMonths = (months: string, alias?: boolean): boolean => {\n  // Prevents alias to be used as steps\n  if (months.search(/\\/[a-zA-Z]/) !== -1) {\n    return false\n  }\n\n  if (alias) {\n    const remappedMonths = months.toLowerCase().replace(/[a-z]{3}/g, (match: string): string => {\n      return monthAlias[match] === undefined ? match : monthAlias[match]\n    })\n    // If any invalid alias was used, it won't pass the other checks as there will be non-numeric values in the months\n    return validateForRange(remappedMonths, 1, 12)\n  }\n\n  return validateForRange(months, 1, 12)\n}\n\nconst weekdaysAlias: { [key: string]: string } = {\n  sun: '0',\n  mon: '1',\n  tue: '2',\n  wed: '3',\n  thu: '4',\n  fri: '5',\n  sat: '6'\n}\n\nconst hasValidWeekdays = (weekdays: string, alias?: boolean, allowBlankDay?: boolean, allowSevenAsSunday?: boolean): boolean => {\n\n  // If there is a question mark, checks if the allowBlankDay flag is set\n  if (allowBlankDay && isQuestionMark(weekdays)) {\n    return true\n  } else if (!allowBlankDay && isQuestionMark(weekdays)) {\n    return false\n  }\n\n  // Prevents alias to be used as steps\n  if (weekdays.search(/\\/[a-zA-Z]/) !== -1) {\n    return false\n  }\n\n  if (alias) {\n    const remappedWeekdays = weekdays.toLowerCase().replace(/[a-z]{3}/g, (match: string): string => {\n      return weekdaysAlias[match] === undefined ? match : weekdaysAlias[match]\n    })\n    // If any invalid alias was used, it won't pass the other checks as there will be non-numeric values in the weekdays\n    return validateForRange(remappedWeekdays, 0, allowSevenAsSunday ? 7 : 6)\n  }\n\n  return validateForRange(weekdays, 0, allowSevenAsSunday ? 7 : 6)\n}\n\nconst hasCompatibleDayFormat = (days: string, weekdays: string, allowBlankDay?: boolean) => {\n  return !(allowBlankDay && isQuestionMark(days) && isQuestionMark(weekdays))\n}\n\nconst split = (cron: string): string[] => {\n  return cron.trim().split(/\\s+/)\n}\n\ntype Options = {\n  alias: boolean\n  seconds: boolean\n  allowBlankDay: boolean\n  allowSevenAsSunday: boolean\n}\n\nconst defaultOptions: Options = {\n  alias: false,\n  seconds: false,\n  allowBlankDay: false,\n  allowSevenAsSunday: false\n}\n\nexport const isValidCron = (cron: string, options?: Partial<Options>): boolean => {\n  options = { ...defaultOptions, ...options }\n\n  const splits = split(cron)\n\n  if (splits.length > (options.seconds ? 6 : 5) || splits.length < 5) {\n    return false\n  }\n\n  const checks: boolean[] = []\n  if (splits.length === 6) {\n    const seconds = splits.shift()\n    if (seconds) {\n      checks.push(hasValidSeconds(seconds))\n    }\n  }\n\n  // We could only check the steps gradually and return false on the first invalid block,\n  // However, this won't have any performance impact so why bother for now.\n  const [minutes, hours, days, months, weekdays] = splits\n  checks.push(hasValidMinutes(minutes))\n  checks.push(hasValidHours(hours))\n  checks.push(hasValidDays(days, options.allowBlankDay))\n  checks.push(hasValidMonths(months, options.alias))\n  checks.push(hasValidWeekdays(weekdays, options.alias, options.allowBlankDay, options.allowSevenAsSunday))\n  checks.push(hasCompatibleDayFormat(days, weekdays, options.allowBlankDay))\n\n  return checks.every(Boolean)\n}\n","import { Construct } from \"constructs\";\nimport { isValidCron } from \"cron-validator\";\nimport { Function, FunctionProps } from \"./function\";\nimport { fqnForType } from \"../constants\";\nimport { AbstractMemberError } from \"../core/errors\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { Duration, IInflight, Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `Schedule`.\n */\nexport const SCHEDULE_FQN = fqnForType(\"cloud.Schedule\");\n\n/**\n * Options for `Schedule`.\n */\nexport interface ScheduleProps {\n  /**\n   * Trigger events at a periodic rate.\n   * @example 1m\n   * @default undefined\n   */\n  readonly rate?: Duration;\n\n  /**\n   * Trigger events according to a cron schedule using the UNIX cron format. Timezone is UTC.\n   * [minute] [hour] [day of month] [month] [day of week]\n   * '*' means all possible values.\n   * '-' means a range of values.\n   * ',' means a list of values.\n   * [minute] allows 0-59.\n   * [hour] allows 0-23.\n   * [day of month] allows 1-31.\n   * [month] allows 1-12 or JAN-DEC.\n   * [day of week] allows 0-6 or SUN-SAT.\n   * @example \"* * * * *\"\n   * @default undefined\n   */\n  readonly cron?: string;\n}\n\n/**\n * A schedule.\n *\n * @inflight `@winglang/sdk.cloud.IScheduleClient`\n * @abstract\n */\nexport class Schedule extends Resource {\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: IScheduleClient;\n\n  constructor(scope: Construct, id: string, props: ScheduleProps = {}) {\n    if (new.target === Schedule) {\n      return Resource._newFromFactory(SCHEDULE_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Schedule\";\n    Node.of(this).description =\n      \"A cloud schedule to trigger events at regular intervals\";\n\n    const { cron, rate } = props;\n\n    if (rate && cron) {\n      throw new Error(\"rate and cron cannot be configured simultaneously.\");\n    }\n    if (!rate && !cron) {\n      throw new Error(\"rate or cron need to be filled.\");\n    }\n    if (rate && rate.seconds < 60) {\n      throw new Error(\"rate can not be set to less than 1 minute.\");\n    }\n    // Check for valid UNIX cron format\n    // https://www.ibm.com/docs/en/db2/11.5?topic=task-unix-cron-format\n    if (\n      cron &&\n      !isValidCron(cron, {\n        alias: true,\n        allowSevenAsSunday: true,\n        allowBlankDay: false,\n        seconds: false,\n      })\n    ) {\n      throw new Error(\"cron string must be in UNIX cron format\");\n    }\n  }\n\n  /**\n   * Create a function that runs when receiving the scheduled event.\n   * @abstract\n   */\n  public onTick(\n    inflight: IScheduleOnTickHandler,\n    props?: ScheduleOnTickOptions\n  ): Function {\n    inflight;\n    props;\n    throw new AbstractMemberError();\n  }\n}\n\n/**\n * Options for Schedule.onTick.\n */\nexport interface ScheduleOnTickOptions extends FunctionProps {}\n\n/**\n * A resource with an inflight \"handle\" method that can be passed to\n * `Schedule.on_tick`.\n *\n * @inflight `@winglang/sdk.cloud.IScheduleOnTickHandlerClient`\n */\nexport interface IScheduleOnTickHandler extends IInflight {\n  /** @internal */\n  [INFLIGHT_SYMBOL]?: IScheduleOnTickHandlerClient[\"handle\"];\n}\n\n/**\n * Inflight interface for `Schedule`.\n */\nexport interface IScheduleClient {}\n\n/**\n * List of inflight operations available for `Schedule`.\n * @internal\n */\nexport enum ScheduleInflightMethods {\n  /** When the schedule runs its scheduled actions. */\n  TICK = \"tick\",\n}\n\n/**\n * Inflight client for `IScheduleOnTickHandler`.\n */\nexport interface IScheduleOnTickHandlerClient {\n  /**\n   * Function that will be called when a message is received from the schedule.\n   * @inflight\n   */\n  handle(): Promise<void>;\n}\n","import { Construct } from \"constructs\";\nimport { fqnForType } from \"../constants\";\nimport { INFLIGHT_SYMBOL, SECRET_SYMBOL } from \"../core/types\";\nimport { Json, Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `Secret`.\n */\nexport const SECRET_FQN = fqnForType(\"cloud.Secret\");\n\n/**\n * Options for `Secret`.\n */\nexport interface SecretProps {\n  /**\n   * The secret's name.\n   *\n   * If no name is provided then a new secret is provisioned in the target.\n   * If a name is provided then the resource will reference an existing\n   * secret in the target.\n   *\n   * @default - a new secret is provisioned with a generated name\n   */\n  readonly name?: string;\n}\n\n/**\n * A cloud secret.\n *\n * @inflight `@winglang/sdk.cloud.ISecretClient`\n * @abstract\n */\nexport class Secret extends Resource {\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: ISecretClient;\n  /** @internal */\n  public [SECRET_SYMBOL] = true;\n\n  /** @internal */\n  protected _name?: string;\n\n  constructor(scope: Construct, id: string, props: SecretProps = {}) {\n    if (new.target === Secret) {\n      return Resource._newFromFactory(SECRET_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Secret\";\n    Node.of(this).description = \"A cloud secret\";\n\n    this._name = props.name;\n  }\n\n  /** Get secret name */\n  public get name(): string | undefined {\n    return this._name;\n  }\n}\n\n/**\n * Options when getting a secret value\n */\nexport interface GetSecretValueOptions {\n  /**\n   * Whether to cache the value\n   *\n   * @default true\n   */\n  readonly cache?: boolean;\n}\n\n/**\n * Inflight interface for `Secret`.\n */\nexport interface ISecretClient {\n  /**\n   * Retrieve the value of the secret.\n   * @Throws if the secret doesn't exist.\n   * @Returns the secret value as string.\n   * @inflight\n   */\n  value(options?: GetSecretValueOptions): Promise<string>;\n\n  /**\n   * Retrieve the Json value of the secret.\n   * @Throws if the secret doesn't exist or cannot be parsed as Json\n   * @Returns the secret value parsed as Json.\n   * @inflight\n   */\n  valueJson(options?: GetSecretValueOptions): Promise<Json>;\n}\n\n/**\n * List of inflight operations available for `Secret`.\n * @internal\n */\nexport enum SecretInflightMethods {\n  /** `Secret.value` */\n  VALUE = \"value\",\n  /** `Secret.valueJson` */\n  VALUE_JSON = \"valueJson\",\n}\n","import { mkdirSync, writeFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { Construct } from \"constructs\";\nimport { FunctionProps } from \"./function\";\nimport { fqnForType } from \"../constants\";\nimport { App, Lifting } from \"../core\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { CaseConventions, ResourceNames } from \"../shared/resource-names\";\nimport { IInflight, IInflightHost, Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `Service`.\n */\nexport const SERVICE_FQN = fqnForType(\"cloud.Service\");\n\n/**\n * Options for `Service`.\n */\nexport interface ServiceProps {\n  /**\n   * Environment variables to pass to the function.\n   * @default - No environment variables.\n   */\n  readonly env?: { [key: string]: string };\n\n  /**\n   * Whether the service should start automatically. If `false`, the service will need to be started\n   * manually by calling the inflight `start()` method.\n   *\n   * @default true\n   */\n  readonly autoStart?: boolean;\n}\n\n/**\n * A long-running service.\n *\n * @inflight `@winglang/sdk.cloud.IServiceClient`\n * @abstract\n */\nexport class Service extends Resource implements IInflightHost {\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: IServiceClient;\n\n  /**\n   * The path where the entrypoint of the service source code will be eventually written to.\n   */\n  protected readonly entrypoint!: string;\n\n  /**\n   * Reference to the service's handler - an inflight closure.\n   */\n  protected readonly handler!: IServiceHandler;\n\n  private readonly _env: Record<string, string> = {};\n\n  constructor(\n    scope: Construct,\n    id: string,\n    handler: IServiceHandler,\n    props: ServiceProps = {}\n  ) {\n    if (new.target === Service) {\n      return Resource._newFromFactory(SERVICE_FQN, scope, id, handler, props);\n    }\n\n    super(scope, id);\n\n    for (const [key, value] of Object.entries(props.env ?? {})) {\n      this.addEnvironment(key, value);\n    }\n\n    Node.of(this).title = \"Service\";\n    Node.of(this).description = \"A cloud service\";\n\n    const assetName = ResourceNames.generateName(this, {\n      disallowedRegex: /[><:\"/\\\\|?*\\s]/g, // avoid characters that may cause path issues\n      case: CaseConventions.LOWERCASE,\n      sep: \"_\",\n    });\n\n    const workdir = App.of(this).workdir;\n    mkdirSync(workdir, { recursive: true });\n    const entrypoint = join(workdir, `${assetName}.cjs`);\n    this.entrypoint = entrypoint;\n\n    if (process.env.WING_TARGET) {\n      this.addEnvironment(\"WING_TARGET\", process.env.WING_TARGET);\n    }\n\n    this.handler = handler;\n  }\n\n  /** @internal */\n  public _preSynthesize(): void {\n    super._preSynthesize();\n\n    const inflightClient = this.handler._toInflight();\n    const code = `\\\n      \"use strict\";\n      let $stop;\n      exports.start = async function() {\n        if ($stop) {\n          throw Error('service already started');\n        }\n        const client = await ${inflightClient};\n        const noop = () => {};\n        $stop = (await client.handle()) ?? noop;\n      };\n\n      exports.stop = async function() {\n        if (!$stop) {\n          throw Error('service not started');\n        }\n        await $stop();\n        $stop = undefined;\n      };\n      `;\n\n    writeFileSync(this.entrypoint, code);\n\n    // indicates that we are calling the inflight constructor and the\n    // inflight \"handle\" method on the handler resource.\n    Lifting.lift(this.handler, this, [\"handle\"]);\n  }\n\n  /**\n   * Add an environment variable to the function.\n   */\n  public addEnvironment(name: string, value: string) {\n    if (this._env[name] !== undefined && this._env[name] !== value) {\n      throw new Error(\n        `Environment variable \"${name}\" already set with a different value.`\n      );\n    }\n    this._env[name] = value;\n  }\n\n  /**\n   * Returns the set of environment variables for this function.\n   */\n  public get env(): Record<string, string> {\n    return { ...this._env };\n  }\n}\n\n/**\n * Options for Service.onStart.\n */\nexport interface ServiceOnStartOptions extends FunctionProps {}\n\n/**\n * Inflight interface for `Service`.\n */\nexport interface IServiceClient {\n  /**\n   * Start the service.\n   * @inflight\n   */\n  start(): Promise<void>;\n\n  /**\n   * Stop the service\n   * @inflight\n   */\n  stop(): Promise<void>;\n\n  /**\n   * Indicates whether the service is started.\n   * @inflight\n   */\n  started(): Promise<boolean>;\n}\n\n/**\n * Executed when a `cloud.Service` is started.\n *\n * @inflight `@winglang/sdk.cloud.IServiceHandlerClient`\n */\nexport interface IServiceHandler extends IInflight {\n  /** @internal */\n  [INFLIGHT_SYMBOL]?: IServiceHandlerClient[\"handle\"];\n}\n\n/**\n * Inflight client for `IServiceHandler`.\n */\nexport interface IServiceHandlerClient {\n  /**\n   * Handler to run when the service starts. This is where you implement the initialization logic of\n   * the service, start any activities asynchronously.\n   *\n   * DO NOT BLOCK! This handler should return as quickly as possible. If you need to run a long\n   * running process, start it asynchronously.\n   *\n   * @inflight\n   * @returns an optional function that can be used to cleanup any resources when the service is\n   * stopped.\n   *\n   * @example\n   *\n   * bring cloud;\n   *\n   * new cloud.Service(inflight () => {\n   *   log(\"starting service...\");\n   *   return () => {\n   *     log(\"stoping service...\");\n   *   };\n   * });\n   */\n  handle(): Promise<IServiceStopHandler | undefined>;\n}\n\n/**\n * Executed when a `cloud.Service` is stopped.\n *\n * @inflight `@winglang/sdk.cloud.IServiceStopHandlerClient`\n */\nexport interface IServiceStopHandler extends IInflight {\n  /** @internal */\n  [INFLIGHT_SYMBOL]?: IServiceStopHandlerClient[\"handle\"];\n}\n\n/**\n * Inflight client for `IServiceStopHandler`.\n */\nexport interface IServiceStopHandlerClient {\n  /**\n   * Handler to run when the service stops. This is where you implement the cleanup logic of\n   * the service, stop any activities asychronously.\n   *\n   * @inflight\n   */\n  handle(): Promise<void>;\n}\n\n/**\n * List of inflight operations for `Service`.\n * @internal\n */\nexport enum ServiceInflightMethods {\n  START = \"start\",\n  STOP = \"stop\",\n  STARTED = \"started\",\n}\n","import { isAbsolute, resolve } from \"path\";\nimport { Construct } from \"constructs\";\nimport { cloud } from \"..\";\nimport { fqnForType } from \"../constants\";\nimport { App } from \"../core\";\nimport { AbstractMemberError } from \"../core/errors\";\nimport { INFLIGHT_SYMBOL } from \"../core/types\";\nimport { Json, Node, Resource } from \"../std\";\n\n/**\n * Global identifier for `Website`.\n */\nexport const WEBSITE_FQN = fqnForType(\"cloud.Website\");\n\n/**\n * Options for `Website`\n */\nexport interface WebsiteProps extends WebsiteOptions, WebsiteDomainOptions {}\n\n/**\n * Basic options for `Website`\n */\nexport interface WebsiteOptions {\n  /**\n   * Local path to the website's static files, relative to the Wing source file or absolute.\n   * @example \"./dist\"\n   */\n  readonly path: string;\n\n  /**\n   * Name of the error document for the website.\n   * @example \"404.html\"\n   * @default - undefined\n   */\n  readonly errorDocument?: string;\n}\n\n/**\n * Options for `Website`\n */\nexport interface WebsiteDomainOptions {\n  /**\n   * The website's custom domain object.\n   * @default - undefined\n   */\n  readonly domain?: cloud.Domain;\n}\n\n/**\n * A cloud static website.\n *\n * @inflight `@winglang/sdk.cloud.IWebsiteClient`\n * @abstract\n */\nexport class Website extends Resource implements IWebsite {\n  /** @internal */\n  public [INFLIGHT_SYMBOL]?: IWebsiteClient;\n\n  /** @internal */\n  private readonly _path!: string;\n\n  /** @internal */\n  protected _domain?: cloud.Domain;\n\n  constructor(scope: Construct, id: string, props: WebsiteProps) {\n    if (new.target === Website) {\n      return Resource._newFromFactory(WEBSITE_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).title = \"Website\";\n    Node.of(this).description = \"A static website\";\n\n    this._path = isAbsolute(props.path)\n      ? props.path\n      : resolve(App.of(scope).entrypointDir, props.path);\n\n    this._domain = props.domain;\n  }\n\n  /**\n   * Absolute local path to the website's static files.\n   */\n  public get path(): string {\n    return this._path;\n  }\n\n  /**\n   * The website's url.\n   */\n  public get url(): string {\n    return this._endpoint.url;\n  }\n\n  /**\n   * The Endpoint of the Website.\n   * @abstract\n   * @internal\n   */\n  protected get _endpoint(): cloud.Endpoint {\n    throw new AbstractMemberError();\n  }\n\n  /**\n   * Add a JSON file with custom values during the website's deployment.\n   * If the path conflicts with file path from the website's static assets, an error will be thrown.\n   * @param path the file path it will be uploaded as\n   * @param data the data to write to the file\n   */\n  public addJson(path: string, data: Json): string {\n    if (!path.endsWith(\".json\")) {\n      throw new Error(\n        `key must have a .json suffix. (current: \"${path.split(\".\").pop()}\")`\n      );\n    }\n    return this.addFile(path, JSON.stringify(data), {\n      contentType: \"application/json\",\n    });\n  }\n\n  /**\n   * Add a file to the website during deployment.\n   * If the path conflicts with file path from the website's static assets, an error will be thrown.\n   * @param path the file path it will be uploaded as\n   * @param data the data to write to the file\n   * @param options configure the file's options\n   * @abstract\n   */\n  public addFile(path: string, data: string, options?: AddFileOptions): string {\n    path;\n    data;\n    options;\n    throw new AbstractMemberError();\n  }\n}\n\n/**\n * Inflight methods and members of `cloud.Website`.\n */\nexport interface IWebsiteClient {}\n\n/**\n * Options for adding a file with custom value during the website's deployment.\n */\nexport interface AddFileOptions {\n  /**\n   * File's content type\n   */\n  readonly contentType?: string;\n}\n\n/**\n * Base interface for a website\n */\nexport interface IWebsite {\n  /**\n   * The website URL\n   */\n  readonly url: string;\n}\n","export * from \"./api\";\nexport * from \"./bucket\";\nexport * from \"./counter\";\nexport * from \"./domain\";\nexport * from \"./endpoint\";\nexport * from \"./function\";\nexport * from \"./on-deploy\";\nexport * from \"./queue\";\nexport * from \"./schedule\";\nexport * from \"./secret\";\nexport * from \"./service\";\nexport * from \"./topic\";\nexport * from \"./website\";\n","import { Construct } from \"constructs\";\nimport { Resource } from \"./resource\";\nimport { Test } from \"./test\";\nimport { Function, FunctionProps, IFunctionHandler } from \"../cloud\";\nimport { fqnForType } from \"../constants\";\nimport { App, LiftMap } from \"../core\";\nimport { Node } from \"../std\";\n\n/**\n * Global identifier for `TestRunner`.\n */\nexport const TEST_RUNNER_FQN = fqnForType(\"std.TestRunner\");\n\n/**\n * Properties for `TestRunner`.\n * @skipDocs\n */\nexport interface TestRunnerProps {}\n\n/**\n * A test engine.\n *\n * @inflight `@winglang/sdk.std.ITestRunnerClient`\n * @skipDocs\n * @abstract\n */\nexport class TestRunner extends Resource {\n  /**\n   * Instantiate one or more copies of a tree inside of an app based\n   * on how many isolated environments are needed for testing.\n   * @internal\n   */\n  public static _createTree(app: App, Root: any) {\n    if (app.isTestEnvironment) {\n      app._testRunner = new TestRunner(app, \"cloud.TestRunner\");\n    }\n\n    if (Root) {\n      // mark the root type so that we can find it later through\n      // Node.of(root).root\n      Node._markRoot(Root);\n\n      if (app.isTestEnvironment) {\n        new Root(app, \"env0\");\n        const tests = app._testRunner!.findTests();\n        for (let i = 1; i < tests.length; i++) {\n          new Root(app, \"env\" + i);\n        }\n      } else {\n        new Root(app, \"Default\");\n      }\n    }\n  }\n\n  /**\n   * List of isolated environment names where we've already created a cloud.Function\n   * for a unit test. We keep track of these so that we don't synthesize\n   * multiple test functions into the same isolated environment.\n   */\n  private _synthedEnvs: Set<string> = new Set();\n\n  /**\n   * List of test paths that we have already created a cloud.Function for.\n   * We keep track of these so that we don't create identical test functions in multiple\n   * isolated environments.\n   */\n  private _synthedTests: Set<string> = new Set();\n\n  constructor(scope: Construct, id: string, props: TestRunnerProps = {}) {\n    if (new.target === TestRunner) {\n      return Resource._newFromFactory(TEST_RUNNER_FQN, scope, id, props);\n    }\n\n    super(scope, id);\n\n    Node.of(this).hidden = true;\n    Node.of(this).title = \"TestRunner\";\n    Node.of(this).description =\n      \"A suite of APIs for running tests and collecting results.\";\n\n    props;\n  }\n\n  /** @internal */\n  public _addTestFunction(\n    scope: Construct,\n    id: string,\n    inflight: IFunctionHandler,\n    props: FunctionProps\n  ): Function | undefined {\n    // searching exactly for `env${number}`\n    const testEnv = scope.node.path.match(/env[0-9]+/)?.at(0)!;\n    // searching for the rest of the path that appears after `env${number}`- this would be the test path\n    const testPath =\n      scope.node.path\n        .match(/env[\\d]+\\/.+/)\n        ?.at(0)!\n        .replace(`${testEnv}/`, \"\") +\n      \"/\" +\n      id;\n\n    if (!this._synthedEnvs.has(testEnv) && !this._synthedTests.has(testPath)) {\n      this._synthedEnvs.add(testEnv);\n      this._synthedTests.add(testPath);\n      return new Function(scope, id, inflight, props);\n    }\n\n    return undefined;\n  }\n\n  /** @internal */\n  public get _liftMap(): LiftMap {\n    return {\n      [TestRunnerInflightMethods.LIST_TESTS]: [],\n      [TestRunnerInflightMethods.RUN_TEST]: [],\n    };\n  }\n\n  /**\n   * Find all tests in the construct tree.\n   * @returns A list of tests.\n   */\n  public findTests(): Test[] {\n    const isTest = (fn: any): fn is Test => {\n      return fn instanceof Test;\n    };\n    return this.node.root.node.findAll().filter(isTest);\n  }\n}\n\n/**\n * Inflight interface for `TestRunner`.\n * @skipDocs\n */\nexport interface ITestRunnerClient {\n  /**\n   * List all tests available for this test engine.\n   * @inflight\n   * @returns A list of test names.\n   */\n  listTests(): Promise<string[]>;\n\n  /**\n   * Run a test with a given path and return the result.\n   * @inflight\n   */\n  runTest(path: string): Promise<TestResult>;\n}\n\n// TODO: include test duration?\n\n/**\n * A result of a single test.\n * @skipDocs\n */\nexport interface TestResult {\n  /**\n   * The path of the test.\n   */\n  readonly path: string;\n\n  /**\n   * Whether the test passed.\n   */\n  readonly pass: boolean;\n\n  /**\n   * Whether the test contains code that is unsupported by the target.\n   */\n  readonly unsupported?: boolean;\n\n  /**\n   * Unsupported resource tested\n   */\n  readonly unsupportedResource?: string;\n\n  /**\n   * Unsupported method used in test\n   */\n  readonly unsupportedOperation?: string;\n\n  /**\n   * Place for extra test runner arguments that can be added through platforms\n   */\n  readonly args?: Record<string, unknown>;\n\n  /**\n   * The error message if the test failed.\n   */\n  readonly error?: string;\n\n  /**\n   * List of traces emitted during the test.\n   */\n  readonly traces: Trace[];\n}\n\n/**\n * A trace emitted during simulation.\n * @skipDocs\n */\nexport interface Trace {\n  /**\n   * A JSON blob with structured data.\n   */\n  readonly data: any;\n\n  /**\n   * The type of the source that emitted the trace.\n   */\n  readonly sourceType: string;\n\n  /**\n   * The path of the resource that emitted the trace.\n   */\n  readonly sourcePath: string;\n\n  /**\n   * The type of a trace.\n   */\n  readonly type: TraceType;\n\n  /**\n   * The log level of the event.\n   */\n  readonly level: LogLevel;\n\n  /**\n   * The timestamp of the event, in ISO 8601 format.\n   * @example 2020-01-01T00:00:00.000Z\n   */\n  readonly timestamp: string;\n}\n\n/**\n * Log level\n */\nexport enum LogLevel {\n  /**\n   * Mostly used for debugging\n   */\n  VERBOSE = \"verbose\",\n\n  /**\n   * Information that is useful to developers\n   */\n  INFO = \"info\",\n\n  /**\n   * Warnings that are not errors, but may require attention\n   */\n  WARNING = \"warning\",\n\n  /**\n   * Errors that should be addressed\n   */\n  ERROR = \"error\",\n}\n\n/**\n * The type of a trace.\n * @skipDocs\n */\nexport enum TraceType {\n  /**\n   * A trace representing simulator activity.\n   */\n  SIMULATOR = \"simulator\",\n  /**\n   * A trace representing a resource activity.\n   */\n  RESOURCE = \"resource\",\n  /**\n   * A trace representing a message emitted by the logger.\n   */\n  LOG = \"log\",\n}\n\n/**\n * List of inflight operations available for `TestRunner`.\n * @internal\n */\nexport enum TestRunnerInflightMethods {\n  /** `TestRunner.runTest` */\n  RUN_TEST = \"runTest\",\n  /** `TestRunner.listTests` */\n  LIST_TESTS = \"listTests\",\n}\n","export * from \"./array\";\nexport * from \"./bool\";\nexport * from \"./datetime\";\nexport * from \"./duration\";\nexport * from \"./generics\";\nexport * from \"./json\";\nexport * from \"./json_schema\";\nexport * from \"./map\";\nexport * from \"./node\";\nexport * from \"./number\";\nexport * from \"./regex\";\nexport * from \"./resource\";\nexport * from \"./set\";\nexport * from \"./string\";\nexport * from \"./struct\";\nexport * from \"./test\";\nexport * from \"./test-runner\";\n","import Ajv from \"ajv\";\nimport { Construct } from \"constructs\";\nimport {\n  loadPlatformSpecificValues,\n  extractFieldsFromSchema,\n  filterParametersBySchema,\n} from \"./util\";\nimport { Json, Node } from \"../std\";\n\n/**\n * Options for reading parameters\n */\nexport interface ReadParameterOptions {\n  /** Schema to limit the read to */\n  readonly schema?: any;\n}\n\n/**\n * Parameter Registrar\n *\n * This class is used to register and lookup parameter values.\n */\nexport class ParameterRegistrar extends Construct {\n  /** Cache for parameter lookups */\n  private parameterValueByPath: { [key: string]: any } = {};\n  /** List of all registered parameter schemas */\n  private parameterSchemas: any[] = [];\n\n  /** @internal */\n  public readonly _rawParameters: { [key: string]: any } =\n    loadPlatformSpecificValues();\n\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n    Node.of(this).hidden = true;\n  }\n\n  /**\n   * Retrieve a parameter value by its path\n   *\n   * @param path the path of the parameter\n   * @returns the value of the parameter\n   */\n  public value(path: string): any {\n    if (this.parameterValueByPath[path] === undefined) {\n      // attempt to read the value from the raw parameters, then cache it\n      this.parameterValueByPath[path] = resolveValueFromPath(\n        this._rawParameters,\n        path\n      );\n    }\n\n    return this.parameterValueByPath[path];\n  }\n\n  /**\n   * Read parameters\n   *\n   * @param options options for reading parameters\n   * @returns the schema as a string\n   */\n  public read(options?: ReadParameterOptions): Json {\n    if (options?.schema) {\n      this.addSchema(options.schema);\n      const fields = extractFieldsFromSchema(\n        options.schema._rawSchema // If a JsonSchema object is passed in, extract raw schema from it\n          ? options.schema._rawSchema\n          : options.schema\n      );\n      return filterParametersBySchema(fields, this._rawParameters);\n    }\n    return this._rawParameters as Json;\n  }\n\n  /**\n   * Add parameter schema to registrar\n   *\n   * @param schema schema to add to the registrar\n   */\n  public addSchema(schema: any) {\n    // If a JsonSchema object is passed in, extract the raw schema from it\n    const schemaToAdd = schema._rawSchema ? schema._rawSchema : schema;\n    if (!this.parameterSchemas.includes(schemaToAdd)) {\n      this.parameterSchemas.push(schemaToAdd);\n    }\n  }\n\n  /**\n   * Helper method to add a parameter schema at a given path.\n   * This method will nest the schema under the given path, making it easier to nest schemas.\n   *\n   * @param schema the schema to add\n   * @param path the path to nest the schema under\n   * @param recursiveRequire whether or not to require all the nested properties\n   */\n  public addSchemaAtPath(schema: any, path: string, recursiveRequire = false) {\n    this.addSchema(this._nestSchemaUnderPath(schema, path, recursiveRequire));\n  }\n\n  /**\n   * This is a helper method to nest a schema under a path.\n   *\n   * I.E. if you have a json schema that looks like this:\n   * { type: \"object\", properties: { foo: { type: \"string\" } } }\n   *\n   * And we want to nest it under the path \"bar/baz\", then this method will return:\n   * { type: \"object\", properties: { bar: { type: \"object\", properties: { baz: { type: \"object\", properties: { foo: { type: \"string\" } } } } } } }\n   *\n   * making it easier to nest schemas under paths, without writing out the object boilerplate.\n   *\n   * @internal\n   */\n  public _nestSchemaUnderPath(\n    schema: any,\n    path: string,\n    recursiveRequire = false\n  ): any {\n    const parts = path.split(\"/\");\n\n    if (parts.length === 0 || path === \"\") {\n      // base case just return the schema\n      return schema;\n    }\n\n    const currentKey = parts[0];\n\n    // Create and return the schema\n    return {\n      type: \"object\",\n      properties: {\n        // recurse for the next part of the path\n        [currentKey]: this._nestSchemaUnderPath(\n          schema,\n          parts.slice(1).join(\"/\"),\n          recursiveRequire\n        ),\n      },\n      required: recursiveRequire ? [currentKey] : [],\n    };\n  }\n\n  /**\n   * @internal\n   */\n  public _preSynthesize() {\n    if (this.parameterSchemas.length === 0) {\n      return;\n    }\n\n    const platformParameterSchema = {\n      allOf: [...this.parameterSchemas],\n    };\n\n    const ajv = new Ajv({ allErrors: true });\n    const validator = ajv.compile(platformParameterSchema);\n    const valid = validator(this._rawParameters);\n\n    if (!valid) {\n      throw new Error(\n        `Parameter validation errors:\\n- ${validator.errors\n          ?.map((error: any) => error.message)\n          .join(\"\\n- \")}\n\n(hint: make sure to use --values to provide the required parameters file)\n        `\n      );\n    }\n  }\n}\n\n/**\n * Retrieves a value from an object using a given path\n *\n * @param rawParameters the object to retrieve the value from\n * @param path the path to the value (I.E. \"foo/bar/baz\")\n * @internal\n */\nexport function resolveValueFromPath(\n  rawParameters: { [key: string]: any },\n  path: string\n): any {\n  if (!rawParameters) {\n    return undefined;\n  }\n\n  const pathParts = path.split(\"/\");\n\n  if (pathParts.length === 1) {\n    return rawParameters[pathParts[0]];\n  }\n\n  // recurse\n  const nextPath = pathParts.slice(1).join(\"/\");\n  return resolveValueFromPath(rawParameters[pathParts[0]], nextPath);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGxhdGZvcm0uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGxhdGZvcm0vcGxhdGZvcm0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgeyBBcHAsIEFwcFByb3BzIH0gZnJvbSBcIi4uL2NvcmVcIjtcblxuLyoqXG4gKiBQbGF0Zm9ybSBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJUGxhdGZvcm0ge1xuICAvKipcbiAgICogVGhlIG1vZGVsIHRoZSBwbGF0Zm9ybSBpcyBidWlsdCBmb3JcbiAgICpcbiAgICogQGV4YW1wbGUgXCJzaW1cIlxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBzY2hlbWEgZm9yIHRoZSBwYXJhbWV0ZXJzIHRoZSBwbGF0Zm9ybSBhY2NlcHRzXG4gICAqL1xuICByZWFkb25seSBwYXJhbWV0ZXJzPzogYW55O1xuXG4gIC8qKlxuICAgKiBIb29rcyBmb3Igb3ZlcnJpZGluZyBuZXdJbnN0YW5jZSBjYWxsc1xuICAgKlxuICAgKiBAcGFyYW0gdHlwZSBzdHJpbmcgZnFuIG9mIHRoZSByZXNvdXJjZSB0eXBlXG4gICAqIEBwYXJhbSBzY29wZSBjb25zdHJ1Y3Qgc2NvcGVcbiAgICogQHBhcmFtIGlkIHVuaXF1ZSBzdHJpbmcgaWQgZm9yIHJlc291cmNlXG4gICAqIEBwYXJhbSBwcm9wcyBwcm9wcyB0byBwYXNzIHRvIHRoZSByZXNvdXJjZVxuICAgKi9cbiAgbmV3SW5zdGFuY2U/KHR5cGU6IHN0cmluZywgc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IGFueSk6IGFueTtcblxuICAvKipcbiAgICogTmV3IEFwcCBNZXRob2RcbiAgICpcbiAgICogQHBhcmFtIGFwcFByb3BzIHRoZSBwcm9wcyB0byBwYXNzIHRvIHRoZSBhcHBcbiAgICovXG4gIG5ld0FwcD8oYXBwUHJvcHM6IEFwcFByb3BzKTogQXBwO1xuXG4gIC8qKlxuICAgKiBQcmUtc3ludGggaG9va1xuICAgKlxuICAgKiBAcGFyYW0gYXBwIGNvbnN0cnVjdCBhcHBcbiAgICovXG4gIHByZVN5bnRoPyhhcHA6IENvbnN0cnVjdCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFBvc3Qtc3ludGggaG9va1xuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIGdlbmVyYXRlZCBjb25maWdcbiAgICovXG4gIHBvc3RTeW50aD8oY29uZmlnOiBhbnkpOiBhbnk7XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyBnZW5lcmF0ZWQgY29uZmlnXG4gICAqL1xuICB2YWxpZGF0ZT8oY29uZmlnOiBhbnkpOiBhbnk7XG5cbiAgLyoqXG4gICAqIEhvb2sgZm9yIGNyZWF0aW5nIGFuZCBzdG9yaW5nIHNlY3JldHNcbiAgICovXG4gIHN0b3JlU2VjcmV0cz8oc2VjcmV0czogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0pOiBQcm9taXNlPHZvaWQ+O1xufVxuIl19","import { readFileSync, writeFileSync } from \"fs\";\nimport { basename, dirname, join } from \"path\";\nimport { cwd } from \"process\";\nimport * as vm from \"vm\";\nimport { IPlatform } from \"./platform\";\nimport { scanDirForPlatformFile } from \"./util\";\nimport { App, AppProps, SynthHooks } from \"../core\";\nimport { SECRET_SYMBOL } from \"../core/types\";\n\ninterface PlatformManagerOptions {\n  /**\n   * Either a builtin platform name or a path to a custom platform\n   */\n  readonly platformPaths?: string[];\n}\n\nconst BUILTIN_PLATFORMS = [\"tf-aws\", \"tf-azure\", \"tf-gcp\", \"sim\"];\n\n/** @internal */\nexport const SECRETS_FILE_NAME = \"secrets.json\";\n\n/** @internal */\nexport class PlatformManager {\n  private readonly platformPaths: string[];\n  private platformInstances: IPlatform[] = [];\n\n  constructor(options: PlatformManagerOptions) {\n    this.platformPaths = options.platformPaths ?? [];\n    this.retrieveImplicitPlatforms();\n    this.createPlatformInstances();\n  }\n\n  /**\n   * Retrieve all implicit platform declarations.\n   *\n   * These are platforms that are not explicitly declared in the cli options\n   * but are implicitly available to the app.\n   *\n   * We look for platforms in the following locations:\n   * - The source directory\n   * - Any imported namespaces (provided by the wingc compiler output)\n   *\n   * To determine if a directory contains a platform, we check if it contains a file ending in \"wplatform.js\"\n   * TODO: Support platforms defined in Wing (platform.w) https://github.com/winglang/wing/issues/4937\n   */\n  private retrieveImplicitPlatforms() {\n    const importedNamespaces = process.env.WING_IMPORTED_NAMESPACES?.split(\";\");\n    const sourceDir = process.env.WING_SOURCE_DIR!;\n\n    if (sourceDir) {\n      const sourceDirPlatformFile = scanDirForPlatformFile(sourceDir);\n      if (sourceDirPlatformFile) {\n        this.platformPaths.push(...sourceDirPlatformFile);\n      }\n    }\n\n    if (importedNamespaces) {\n      importedNamespaces.forEach((namespaceDir) => {\n        const namespaceDirPlatformFile = scanDirForPlatformFile(namespaceDir);\n        if (namespaceDirPlatformFile) {\n          this.platformPaths.push(...namespaceDirPlatformFile);\n        }\n      });\n    }\n  }\n\n  private loadPlatformPath(platformPath: string) {\n    const platformName = basename(platformPath);\n\n    const isBuiltin = BUILTIN_PLATFORMS.includes(platformName);\n\n    const pathToRead = isBuiltin\n      ? join(__dirname, `../target-${platformName}/platform`)\n      : join(platformPath);\n\n    this.platformInstances.push(\n      isBuiltin\n        ? this.loadBuiltinPlatform(pathToRead)\n        : _loadCustomPlatform(pathToRead)\n    );\n  }\n\n  /**\n   * Builtin platforms are loaded from the SDK\n   *\n   * @param builtinPlatformPath path to a builtin platform\n   */\n  private loadBuiltinPlatform(builtinPlatformPath: string): any {\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    const loadedPlatform = require(builtinPlatformPath);\n    if (!loadedPlatform || !loadedPlatform.Platform) {\n      console.error(`Failed to load platform from ${builtinPlatformPath}`);\n      return;\n    }\n\n    return new loadedPlatform.Platform();\n  }\n\n  private createPlatformInstances() {\n    this.platformInstances = [];\n    this.platformPaths.forEach((platformPath) => {\n      this.loadPlatformPath(platformPath);\n    });\n  }\n\n  // This method is called from preflight.cjs in order to return an App instance\n  // that can be synthesized\n  public createApp(appProps: AppProps): App {\n    this.createPlatformInstances();\n    let appCall = this.platformInstances[0].newApp;\n\n    if (!appCall) {\n      throw new Error(\n        `No newApp method found on platform: ${this.platformPaths[0]} (Hint: The first platform provided must have a newApp method)`\n      );\n    }\n\n    let hooks = collectHooks(this.platformInstances);\n\n    const app = appCall!({\n      ...appProps,\n      synthHooks: hooks.synthHooks,\n      newInstanceOverrides: hooks.newInstanceOverrides,\n    }) as App;\n\n    let secretNames = [];\n    for (const c of app.node.findAll()) {\n      if ((c as any)[SECRET_SYMBOL]) {\n        const secret = c as any;\n        secretNames.push(secret.name);\n      }\n    }\n\n    if (secretNames.length > 0) {\n      writeFileSync(\n        join(app.outdir, SECRETS_FILE_NAME),\n        JSON.stringify(secretNames)\n      );\n    }\n\n    let registrar = app.parameters;\n\n    hooks.parameterSchemas.forEach((schema) => {\n      registrar.addSchema(schema);\n    });\n\n    return app;\n  }\n\n  public async storeSecrets(secrets: Record<string, string>): Promise<void> {\n    const hooks = collectHooks(this.platformInstances);\n    if (!hooks.storeSecretsHook) {\n      throw new Error(\n        `Cannot find a platform or platform extension that supports storing secrets`\n      );\n    }\n    await hooks.storeSecretsHook(secrets);\n  }\n}\n\n/**\n * Custom platforms need to be loaded into a custom context in order to\n * resolve their dependencies correctly.\n *\n * @internal\n */\nexport function _loadCustomPlatform(customPlatformPath: string): any {\n  const isScoped = customPlatformPath.startsWith(\"@\");\n\n  const platformBaseDir = isScoped\n    ? dirname(dirname(customPlatformPath))\n    : dirname(customPlatformPath);\n\n  const platformDir = join(platformBaseDir, \"node_modules\");\n\n  /**\n   * Support platforms that are provided as:\n   * - A single js file (e.g. \"/some/path/to/platform.js\")\n   * - A scoped package (e.g. \"@scope/platform\")\n   * - A non-scoped package (e.g. \"/some/path/platform\")\n   */\n  const fullCustomPlatformPath = customPlatformPath.endsWith(\".js\")\n    ? customPlatformPath\n    : isScoped\n    ? join(platformDir, `${customPlatformPath}/lib/index.js`)\n    : `${customPlatformPath}/index.js`;\n\n  // enable relative imports from the platform file\n  const customPlatformBaseDir = customPlatformPath.endsWith(\".js\")\n    ? dirname(customPlatformPath)\n    : customPlatformPath;\n\n  const cwdNodeModules = join(cwd(), \"node_modules\");\n  const customPlatformLib = join(cwdNodeModules, customPlatformPath, \"lib\");\n\n  const resolvablePaths = [\n    ...module.paths,\n    customPlatformBaseDir,\n    platformDir,\n    cwdNodeModules,\n    customPlatformLib,\n  ];\n\n  const requireResolve = (path: string) => {\n    return require.resolve(path, {\n      paths: resolvablePaths,\n    });\n  };\n\n  const platformRequire = (path: string) => {\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    return require(requireResolve(path));\n  };\n\n  platformRequire.resolve = requireResolve;\n\n  const platformModule = {\n    exports: {},\n  };\n  const context = vm.createContext({\n    require: platformRequire,\n    console,\n    exports: platformModule.exports,\n    module: platformModule,\n    process,\n    __dirname: customPlatformPath,\n  });\n\n  try {\n    const platformCode = readFileSync(fullCustomPlatformPath, \"utf-8\");\n    const script = new vm.Script(platformCode);\n    script.runInContext(context);\n    return new (platformModule.exports as any).Platform();\n  } catch (error) {\n    if (process.env.DEBUG) {\n      console.error(error);\n    }\n    const hint = customPlatformPath.includes(\".\")\n      ? \"Ensure the path to the platform is correct\"\n      : `Ensure you have installed the platform provider by running 'npm install ${customPlatformPath}'`;\n    console.error(\n      `An error occurred while loading the custom platform: ${customPlatformPath}\\n\\n(hint: ${hint})`\n    );\n  }\n}\n\ninterface CollectHooksResult {\n  synthHooks: SynthHooks;\n  newInstanceOverrides: any[];\n  parameterSchemas: any[];\n  storeSecretsHook?: any;\n}\n\nfunction collectHooks(platformInstances: IPlatform[]) {\n  let result: CollectHooksResult = {\n    synthHooks: {\n      preSynthesize: [],\n      postSynthesize: [],\n      validate: [],\n    },\n    newInstanceOverrides: [],\n    parameterSchemas: [],\n    storeSecretsHook: undefined,\n  };\n\n  platformInstances.forEach((instance) => {\n    if (instance.parameters) {\n      result.parameterSchemas.push(instance.parameters);\n    }\n\n    if (instance.preSynth) {\n      result.synthHooks.preSynthesize!.push(instance.preSynth.bind(instance));\n    }\n\n    if (instance.postSynth) {\n      result.synthHooks.postSynthesize!.push(instance.postSynth.bind(instance));\n    }\n\n    if (instance.validate) {\n      result.synthHooks.validate!.push(instance.validate.bind(instance));\n    }\n\n    if (instance.newInstance) {\n      result.newInstanceOverrides.push(instance.newInstance.bind(instance));\n    }\n\n    if (instance.storeSecrets) {\n      result.storeSecretsHook = instance.storeSecrets.bind(instance);\n    }\n  });\n\n  return result;\n}\n","export * from \"./parameter-registrar\";\nexport * from \"./platform\";\nexport * from \"./platform-manager\";\nexport * from \"./util\";\n","import { Construct, IConstruct } from \"constructs\";\nimport { NotImplementedError } from \"./errors\";\nimport { SDK_PACKAGE_NAME } from \"../constants\";\nimport { ParameterRegistrar } from \"../platform\";\nimport { APP_SYMBOL, IApp, Node } from \"../std/node\";\nimport { type IResource } from \"../std/resource\";\nimport { TestRunner } from \"../std/test-runner\";\n\n/**\n * Props for all `App` classes.\n */\nexport interface AppProps {\n  /**\n   * Directory where artifacts are synthesized to.\n   * @default - current working directory\n   */\n  readonly outdir?: string;\n\n  /**\n   * The name of the app.\n   * @default \"app\"\n   */\n  readonly name?: string;\n\n  /**\n   * The root construct class that should be instantiated with a scope and id.\n   * If provided, then it will be instantiated on the user's behalf.\n   * When the app is synthesized with `isTestEnvironment` set to `true`, then\n   * one instance of the root construct will be created per test; otherwise,\n   * it will be created exactly once.\n   * @default - no root construct\n   */\n  readonly rootConstruct?: any;\n\n  /**\n   * Whether or not this app is being synthesized into a test environment.\n   * @default false\n   */\n  readonly isTestEnvironment?: boolean;\n\n  /**\n   *  The absolute directory location for the wing entry point file\n   */\n  readonly entrypointDir: string;\n\n  /**\n   *  The App root id\n   * @default Default\n   */\n  readonly rootId?: string;\n\n  /**\n   * Hooks to be called at various stages of the synthesis process.\n   * @default - no hooks\n   */\n  readonly synthHooks?: SynthHooks;\n\n  /**\n   * Hooks for overriding newInstance calls\n   * @default - []\n   */\n  readonly newInstanceOverrides?: any[];\n\n  /**\n   * ParameterRegistrar of composed platforms\n   * @default - undefined\n   */\n  readonly platformParameterRegistrar?: ParameterRegistrar;\n}\n\n/**\n * Hooks for the synthesis process.\n */\nexport interface SynthHooks {\n  /**\n   * Hooks to be called before synthesizing the app.\n   */\n  readonly preSynthesize?: any[];\n\n  /**\n   * Hooks to be called after synthesizing the app.\n   */\n  readonly postSynthesize?: any[];\n\n  /**\n   * Hooks to be called for validating the synthesized configuration.\n   */\n  readonly validate?: any[];\n}\n\n/**\n * A Wing application.\n */\nexport abstract class App extends Construct implements IApp {\n  /**\n   * Returns the root app.\n   */\n  public static of(scope: Construct): App {\n    return Node.of(scope).app as App;\n  }\n\n  /** @internal */\n  public readonly [APP_SYMBOL] = true;\n\n  /**\n   * The name of the compilation target.\n   * @internal\n   */\n  public abstract readonly _target:\n    | \"sim\"\n    | \"tf-aws\"\n    | \"tf-azure\"\n    | \"tf-gcp\"\n    | \"awscdk\";\n\n  /**\n   * Wing source files directory absolute path\n   */\n  public readonly entrypointDir: string;\n\n  /**\n   * Used in `makeId` to keep track of known IDs\n   */\n  private readonly _idCounters: Record<string, number> = {};\n\n  /**\n   * The output directory.\n   */\n  public abstract readonly outdir: string;\n\n  /**\n   * Whether or not this app is being synthesized into a test environment.\n   */\n  public readonly isTestEnvironment: boolean;\n\n  /**\n   * NewInstance hooks for defining resource implementations.\n   * @internal\n   */\n  public readonly _newInstanceOverrides: any[];\n\n  /**\n   * The test runner for this app. Only created if `isTestEnvironment` is true.\n   * @internal\n   */\n  public _testRunner: TestRunner | undefined;\n\n  /**\n   * SynthHooks hooks of dependent platforms\n   * @internal\n   */\n  protected _synthHooks?: SynthHooks;\n\n  /**\n   * Parameter registrar of composed platforms\n   * @internal\n   */\n  protected _parameters?: ParameterRegistrar;\n\n  constructor(scope: Construct, id: string, props: AppProps) {\n    super(scope, id);\n    if (!props.entrypointDir) {\n      throw new Error(\"Missing environment variable: WING_SOURCE_DIR\");\n    }\n\n    // the app is also marked as root in the case where there is no root construct\n    if (!props.rootConstruct) {\n      Node._markRoot(this.constructor);\n    }\n\n    this.entrypointDir = props.entrypointDir;\n    this._newInstanceOverrides = props.newInstanceOverrides ?? [];\n    this._synthHooks = props.synthHooks;\n    this.isTestEnvironment = props.isTestEnvironment ?? false;\n  }\n\n  /**\n   * The \".wing\" directory, which is where the compiler emits its output. We are taking an implicit\n   * assumption here that it is always set to be `$outdir/.wing` which is currently hard coded into\n   * the `cli/compile.ts` file.\n   */\n  public get workdir() {\n    return `${this.outdir}/.wing`;\n  }\n\n  /**\n   * The parameter registrar for the app, can be used to find and register\n   * parameter values that were provided to the wing application.\n   */\n  public get parameters() {\n    if (!this._parameters) {\n      this._parameters = new ParameterRegistrar(this, \"ParameterRegistrar\");\n    }\n    return this._parameters!;\n  }\n\n  /**\n   * Synthesize the app into an artifact.\n   */\n  public abstract synth(): string;\n\n  /**\n   * Creates a new object of the given FQN.\n   * @param fqn the fqn of the class to instantiate\n   * @param ctor the constructor of the class to instantiate (undefined for abstract classes)\n   * @param scope the scope of the resource\n   * @param id the id of the resource\n   * @param args the arguments to pass to the resource\n   * @returns the new instance\n   * @throws if the FQN is not supported\n   */\n  public new(\n    fqn: string,\n    ctor: any,\n    scope: Construct,\n    id: string,\n    ...args: any[]\n  ): any {\n    // delegate to \"tryNew\" first, which will allow derived classes to inject\n    const instance = this.tryNew(fqn, scope, id, ...args);\n    if (instance) {\n      return instance;\n    }\n\n    // no injection, so we'll just create a new instance\n    return new ctor(scope, id, ...args);\n  }\n\n  /**\n   * Creates a new object of the given abstract class FQN.\n   */\n  public newAbstract(\n    fqn: string,\n    scope: Construct,\n    id: string,\n    ...args: any[]\n  ): any {\n    // next delegate to \"tryNew\", which will allow derived classes to inject\n    const instance = this.tryNew(fqn, scope, id, ...args);\n    if (!instance) {\n      const typeName = fqn.replace(`${SDK_PACKAGE_NAME}.`, \"\");\n      const typeNameParts = typeName.split(\".\");\n      throw new NotImplementedError(\n        `Resource \"${fqn}\" is not yet implemented for \"${this._target}\" target. Please refer to the roadmap https://github.com/orgs/winglang/projects/3/views/1?filterQuery=${typeName}`,\n        { resource: typeNameParts[typeNameParts.length - 1] }\n      );\n    }\n\n    return instance;\n  }\n\n  public makeId(scope: IConstruct, prefix: string = \"\") {\n    const key = `${scope.node.addr}|${prefix}`;\n\n    this._idCounters[key] = this._idCounters[key] ?? 0;\n\n    return `${prefix}${this._idCounters[key]++}`;\n  }\n\n  /**\n   * Can be overridden by derived classes to inject dependencies.\n   *\n   * @param fqn The fully qualified name of the class we want the type for (jsii).\n   *\n   * @returns The dependency injected specific target type for the given FQN, or undefined if not found.\n   */\n  protected typeForFqn(fqn: string): any {\n    fqn;\n    return undefined;\n  }\n\n  /**\n   * Can be overridden by derived classes to inject dependencies.\n   *\n   * @param fqn The fully qualified name of the class to instantiate (jsii).\n   * @param scope The construct scope.\n   * @param id The construct id.\n   * @param args The arguments to pass to the constructor.\n   */\n  private tryNew(\n    fqn: string,\n    scope: Construct,\n    id: string,\n    ...args: any[]\n  ): any {\n    // first check if overrides have been provided\n    for (const override of this._newInstanceOverrides) {\n      const instance = override(fqn, scope, id, ...args);\n      if (instance) {\n        return instance;\n      }\n    }\n\n    const type = this.typeForFqn(fqn);\n    if (!type) {\n      return undefined;\n    }\n\n    return new type(scope, id, ...args);\n  }\n}\n\nexport function preSynthesizeAllConstructs(app: App): void {\n  for (const c of app.node.findAll()) {\n    if (typeof (c as IResource)._preSynthesize === \"function\") {\n      (c as IResource)._preSynthesize();\n    }\n  }\n}\n","export const WING_ATTRIBUTE_RESOURCE_CONNECTIONS = \"wing:resource:connections\";\n","// This file is copied from\n// https://github.com/cdk8s-team/cdk8s-core/blob/2.x/src/dependency.ts\nimport { Node, IConstruct } from \"constructs\";\n\n/**\n * Represents the dependency graph for a given Node.\n *\n * This graph includes the dependency relationships between all nodes in the\n * node (construct) sub-tree who's root is this Node.\n *\n * Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as\n * childless children of the root node of the graph.\n *\n * The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node\n * from a different scope, that relationship is not represented in this graph.\n *\n */\nexport class DependencyGraph {\n  private readonly _fosterParent: DependencyVertex;\n\n  constructor(node: Node) {\n    this._fosterParent = new DependencyVertex();\n\n    const nodes: Record<string, DependencyVertex> = {};\n\n    function putVertex(construct: IConstruct) {\n      nodes[Node.of(construct).path] = new DependencyVertex(construct);\n    }\n\n    function getVertex(construct: IConstruct): DependencyVertex {\n      return nodes[Node.of(construct).path];\n    }\n\n    // create all vertices of the graph.\n    for (const n of node.findAll()) {\n      putVertex(n);\n    }\n\n    const deps = [];\n    for (const child of node.findAll()) {\n      for (const dep of child.node.dependencies) {\n        deps.push({ source: child, target: dep });\n      }\n    }\n\n    // create all the edges of the graph.\n    for (const dep of deps) {\n      if (!getVertex(dep.target)) {\n        // dont cross scope boundaries.\n        // since charts only renders its own children, this is ok and\n        // has the benefit of simplifying the graph. we should reconsider this behavior when moving\n        // to a more general purpose use-case.\n        continue;\n      }\n\n      const sourceDepNode = getVertex(dep.source);\n      const targetDepNode = getVertex(dep.target);\n\n      sourceDepNode.addChild(targetDepNode);\n    }\n\n    // create the root.\n    for (const n of Object.values(nodes)) {\n      if (n.inbound.length === 0) {\n        // orphans are dependency roots. lets adopt them!\n        this._fosterParent.addChild(n);\n      }\n    }\n  }\n\n  /**\n   * Returns the root of the graph.\n   *\n   * Note that this vertex will always have `null` as its `.value` since it is an artifical root\n   * that binds all the connected spaces of the graph.\n   */\n  public get root(): DependencyVertex {\n    return this._fosterParent;\n  }\n\n  /**\n   * Returns a topologically sorted array of the constructs in the sub-graph.\n   */\n  public topology(): IConstruct[] {\n    return this._fosterParent.topology();\n  }\n}\n\n/**\n * Represents a vertex in the graph.\n *\n * The value of each vertex is an `IConstruct` that is accessible via the `.value` getter.\n */\nexport class DependencyVertex {\n  private readonly _value: IConstruct | undefined;\n  private readonly _children: Set<DependencyVertex> =\n    new Set<DependencyVertex>();\n  private readonly _parents: Set<DependencyVertex> =\n    new Set<DependencyVertex>();\n\n  constructor(value: IConstruct | undefined = undefined) {\n    this._value = value;\n  }\n\n  /**\n   * Returns the IConstruct this graph vertex represents.\n   *\n   * `null` in case this is the root of the graph.\n   */\n  public get value(): IConstruct | undefined {\n    return this._value;\n  }\n\n  /**\n   * Returns the children of the vertex (i.e dependencies)\n   */\n  public get outbound(): Array<DependencyVertex> {\n    return Array.from(this._children);\n  }\n\n  /**\n   * Returns the parents of the vertex (i.e dependants)\n   */\n  public get inbound(): Array<DependencyVertex> {\n    return Array.from(this._parents);\n  }\n\n  /**\n   * Returns a topologically sorted array of the constructs in the sub-graph.\n   */\n  public topology(): IConstruct[] {\n    const found = new Set<DependencyVertex>();\n    const topology: DependencyVertex[] = [];\n\n    function visit(n: DependencyVertex) {\n      for (const c of n.outbound) {\n        visit(c);\n      }\n      if (!found.has(n)) {\n        topology.push(n);\n        found.add(n);\n      }\n    }\n\n    visit(this);\n\n    return topology.filter((d) => d.value).map((d) => d.value!);\n  }\n\n  /**\n   * Adds a vertex as a dependency of the current node.\n   * Also updates the parents of `dep`, so that it contains this node as a parent.\n   *\n   * This operation will fail in case it creates a cycle in the graph.\n   *\n   * @param dep The dependency\n   */\n  public addChild(dep: DependencyVertex) {\n    const cycle: DependencyVertex[] = dep.findRoute(this);\n    if (cycle.length !== 0) {\n      cycle.push(dep);\n      throw new Error(\n        `Dependency cycle detected: ${cycle\n          .filter((d) => d.value)\n          .map((d) => Node.of(d.value!).path)\n          .join(\" => \")}`\n      );\n    }\n\n    this._children.add(dep);\n    dep.addParent(this);\n  }\n\n  private addParent(dep: DependencyVertex) {\n    this._parents.add(dep);\n  }\n\n  private findRoute(dst: DependencyVertex): DependencyVertex[] {\n    const route: DependencyVertex[] = [];\n    visit(this);\n    return route;\n\n    function visit(n: DependencyVertex): boolean {\n      route.push(n);\n      let found = false;\n      for (const c of n.outbound) {\n        if (c === dst) {\n          route.push(c);\n          return true;\n        }\n        found = visit(c);\n      }\n      if (!found) {\n        route.pop();\n      }\n      return found;\n    }\n  }\n}\n","import { Construct, IConstruct } from \"constructs\";\nimport { UIComponent } from \"../core\";\nimport { Node } from \"../std/node\";\nimport { Resource } from \"../std/resource\";\n\nexport const VISUAL_COMPONENT_SYMBOL = Symbol.for(\n  \"@winglang/sdk.ui.VisualComponent\"\n);\n\n/**\n * A visual component is used to customize the view of other classes in the Wing Console.\n * This is a base class for all other visual components.\n * @noinflight\n */\nexport abstract class VisualComponent extends Resource {\n  /**\n   * Returns whether the given construct is a visual component.\n   */\n  public static isVisualComponent(c: IConstruct): c is VisualComponent {\n    return (c as any)[VISUAL_COMPONENT_SYMBOL] !== undefined;\n  }\n\n  /**\n   * A flag set when a component is added to a grouping component (like \"Section\")\n   * so that it's not rendered multiple times.\n   * @internal\n   */\n  public _newParent: string | undefined;\n\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    Node.of(this).hidden = true;\n    Object.defineProperty(this, VISUAL_COMPONENT_SYMBOL, {\n      value: this,\n      enumerable: false,\n      writable: false,\n    });\n  }\n\n  /** @internal */\n  public abstract _toUIComponent(): UIComponent;\n}\n","export type Colors =\n  | \"orange\"\n  | \"sky\"\n  | \"emerald\"\n  | \"lime\"\n  | \"pink\"\n  | \"amber\"\n  | \"cyan\"\n  | \"purple\"\n  | \"red\"\n  | \"violet\"\n  | \"slate\";\n\nexport const isOfTypeColors = (keyInput?: string): keyInput is Colors => {\n  return [\n    \"orange\",\n    \"sky\",\n    \"emerald\",\n    \"lime\",\n    \"pink\",\n    \"amber\",\n    \"cyan\",\n    \"purple\",\n    \"red\",\n    \"violet\",\n    \"slate\",\n  ].includes(keyInput || \"\");\n};\n","import * as fs from \"fs\";\nimport * as path from \"path\";\nimport { IConstruct } from \"constructs\";\nimport { App } from \"./app\";\nimport { Node } from \"../std\";\nimport { VisualComponent } from \"../ui/base\";\nimport { Colors, isOfTypeColors } from \"../ui/colors\";\n\nexport const TREE_FILE_PATH = \"tree.json\";\n\n/**\n * A node in the construct tree.\n */\nexport interface ConstructTreeNode {\n  /**\n   * The ID of the node. Is part of the `path`.\n   */\n  readonly id: string;\n\n  /**\n   * The path of the node.\n   */\n  readonly path: string;\n\n  /**\n   * The child nodes.\n   */\n  readonly children?: { [key: string]: ConstructTreeNode };\n\n  /**\n   * The node attributes.\n   */\n  readonly attributes?: { [key: string]: any };\n\n  /**\n   * Information on the construct class that led to this node, if available.\n   */\n  readonly constructInfo?: ConstructInfo;\n\n  /**\n   * Information on how to display this node in the UI.\n   */\n  readonly display?: DisplayInfo;\n}\n\n/**\n * Information on how to display a construct in the UI.\n */\nexport interface DisplayInfo {\n  /**\n   * Title of the resource.\n   * @default - The type and/or identifier of the resource\n   */\n  readonly title?: string;\n\n  /**\n   * Description of the resource.\n   * @default - No description\n   */\n  readonly description?: string;\n\n  /**\n   * Whether the resource should be hidden from the UI.\n   * @default false (visible)\n   */\n  readonly hidden?: boolean;\n\n  /**\n   * The source file or library where the construct was defined.\n   * @default - no source information\n   */\n  readonly sourceModule?: string;\n\n  /**\n   * UI components to display for this resource.\n   * @default - no UI components\n   */\n  readonly ui?: any[]; // UIComponent\n\n  /**\n   * The color of the resource in the UI.\n   */\n  readonly color?: Colors;\n\n  /**\n   * The icon of the resource in the UI.\n   */\n  readonly icon?: string;\n\n  /**\n   * Whether the node is expanded or collapsed by default in the UI.\n   * By default, nodes are collapsed. Set this to `true` if you want the node to be expanded by default.\n   *\n   * @default false\n   */\n  readonly expanded?: boolean;\n}\n\n/** @internal */\nexport type UIComponent =\n  | UIField\n  | UISection\n  | UIButton\n  | UIHttpClient\n  | UIFileBrowser;\n\n/** @internal */\nexport interface UIField {\n  readonly kind: \"field\";\n  readonly label: string;\n  /** The construct path to a cloud.Function */\n  readonly handler: string;\n  readonly refreshRate: number | undefined;\n  readonly link?: boolean;\n}\n\n/** @internal */\nexport interface UIButton {\n  readonly kind: \"button\";\n  readonly label: string;\n  /** The construct path to a cloud.Function */\n  readonly handler: string;\n}\n\n/** @internal */\nexport interface UISection {\n  readonly kind: \"section\";\n  readonly label?: string;\n  readonly children: UIComponent[];\n}\n\n/** @internal */\nexport interface UIHttpClient {\n  readonly kind: \"http-client\";\n  readonly label: string;\n  readonly getUrlHandler: string;\n  readonly getApiSpecHandler: string;\n}\n\n/** @internal */\nexport interface UIFileBrowser {\n  readonly kind: \"file-browser\";\n  readonly label: string;\n  readonly putHandler: string;\n  readonly deleteHandler: string;\n  readonly getHandler: string;\n  readonly listHandler: string;\n}\n\n/**\n * The construct tree.\n */\nexport interface ConstructTree {\n  /**\n   * The construct tree version.\n   */\n  readonly version: string;\n\n  /**\n   * The root node.\n   */\n  readonly tree: ConstructTreeNode;\n}\n\n/**\n * Symbol for accessing jsii runtime information.\n */\nconst JSII_RUNTIME_SYMBOL = Symbol.for(\"jsii.rtti\");\n\n/**\n * Source information on a construct (class fqn and version).\n */\nexport interface ConstructInfo {\n  /**\n   * Fully qualified class name.\n   */\n  readonly fqn: string;\n\n  /**\n   * Version of the module.\n   */\n  readonly version: string;\n}\n\nfunction constructInfoFromConstruct(\n  construct: IConstruct\n): ConstructInfo | undefined {\n  const jsiiRuntimeInfo =\n    Object.getPrototypeOf(construct).constructor[JSII_RUNTIME_SYMBOL];\n  if (\n    typeof jsiiRuntimeInfo === \"object\" &&\n    jsiiRuntimeInfo !== null &&\n    typeof jsiiRuntimeInfo.fqn === \"string\" &&\n    typeof jsiiRuntimeInfo.version === \"string\"\n  ) {\n    return { fqn: jsiiRuntimeInfo.fqn, version: jsiiRuntimeInfo.version };\n  }\n  return undefined;\n}\n\nexport function synthesizeTree(app: App, outdir: string) {\n  const visit = (construct: IConstruct): ConstructTreeNode => {\n    const children = construct.node.children.map((c) => visit(c));\n    const childrenMap = children\n      .filter((child) => child !== undefined)\n      .reduce((map, child) => Object.assign(map, { [child!.id]: child }), {});\n\n    const node: ConstructTreeNode = {\n      id: construct.node.id || \"App\",\n      path: construct.node.path,\n      children: Object.keys(childrenMap).length === 0 ? undefined : childrenMap,\n      constructInfo: constructInfoFromConstruct(construct),\n      display: synthDisplay(construct),\n    };\n\n    return node;\n  };\n\n  const tree: ConstructTree = {\n    version: \"tree-0.1\",\n    tree: visit(app.node.root),\n  };\n\n  fs.writeFileSync(\n    path.join(outdir, TREE_FILE_PATH),\n    JSON.stringify(tree, undefined, 2),\n    { encoding: \"utf8\" }\n  );\n}\n\nfunction synthDisplay(construct: IConstruct): DisplayInfo | undefined {\n  const display = Node.of(construct);\n\n  const ui: UIComponent[] = [];\n  // generate ui data only based on direct children\n  for (const child of construct.node.children) {\n    if (\n      VisualComponent.isVisualComponent(child) &&\n      child._newParent === undefined\n    ) {\n      ui.push(child._toUIComponent());\n    }\n  }\n\n  if (\n    display.description ||\n    display.title ||\n    display.hidden ||\n    ui ||\n    display.color ||\n    display.icon ||\n    display.expanded\n  ) {\n    return {\n      title: display.title,\n      description: display.description,\n      hidden: display.hidden,\n      sourceModule: display.sourceModule,\n      ui: ui.length > 0 ? ui : undefined,\n      color: isOfTypeColors(display.color) ? display.color : undefined,\n      icon: display.icon,\n      expanded: display.expanded,\n    };\n  }\n  return;\n}\n","export * from \"./app\";\nexport * from \"./attributes\";\nexport * from \"./connections\";\nexport * from \"./dependency\";\nexport * from \"./inflight\";\nexport * from \"./lifting\";\nexport * from \"./tree\";\n","import { mkdirSync, writeFileSync } from \"fs\";\nimport { join, relative } from \"path\";\nimport { Construct } from \"constructs\";\nimport { SimResourceSchema } from \"./schema-resources\";\nimport { simulatorAttrToken, simulatorHandleToken } from \"./tokens\";\nimport { bindSimulatorResource, makeSimulatorJsClient } from \"./util\";\nimport { App, LiftMap, Lifting } from \"../core\";\nimport { CaseConventions, ResourceNames } from \"../shared/resource-names\";\nimport { PolicyStatement, ToSimulatorOutput } from \"../simulator\";\nimport {\n  IInflight,\n  IInflightHost,\n  IResource as IStdResource,\n  Resource as StdResource,\n  Node,\n  Json,\n  LogLevel,\n} from \"../std\";\n\n/**\n * Contract that a resource backend must implement.\n * @inflight\n */\nexport interface IResource {\n  /**\n   * Runs when the resource is stopped.\n   */\n  onStop(): Promise<void>;\n}\n\n// TODO: make statedir a property once Wing supports properties on interfaces\n\n/**\n * Context for implementing a simulator resource.\n * @inflight\n */\nexport interface IResourceContext {\n  /**\n   * The directory for the resource's state.\n   */\n  statedir(): Promise<string>;\n\n  /**\n   * Resolves a token value. All tokens must be resolved during the\n   * constructor of the resource.\n   *\n   * @param name The name of the token.\n   * @param value The value of the token.\n   * @inflight\n   */\n  resolveToken(name: string, value: string): Promise<void>;\n\n  /**\n   * Log a message at the current point in time. Defaults to `info` level.\n   *\n   * @param message The message to log.\n   * @param level The severity of the message.\n   * @inflight\n   */\n  log(message: string, level: LogLevel | undefined): Promise<void>;\n}\n\n/**\n * Global identifier for `sim.Resource`.\n */\nexport const SIM_RESOURCE_FQN = \"@winglang/sdk.sim.Resource\";\n\n/**\n * A backend for a simulated resource.\n * @inflight `@winglang/sdk.sim.IResourceClient`\n */\nexport class Resource\n  extends StdResource\n  implements\n    IStdResource,\n    ISimulatorResource,\n    IInflightHost,\n    ISimulatorInflightHost\n{\n  private readonly permissions: Array<[IStdResource, string]> = [];\n  private readonly _env: Record<string, string> = {};\n  private readonly factory: IResourceFactory;\n  private readonly entrypoint: string;\n\n  constructor(scope: Construct, id: string, factory: IResourceFactory) {\n    super(scope, id);\n\n    Node.of(this).title = \"Resource\";\n    Node.of(this).description = \"A simulated resource\";\n    Node.of(this).color = \"emerald\";\n\n    const assetName = ResourceNames.generateName(this, {\n      disallowedRegex: /[><:\"/\\\\|?*\\s]/g, // avoid characters that may cause path issues\n      case: CaseConventions.LOWERCASE,\n      sep: \"_\",\n    });\n\n    const workdir = App.of(this).workdir;\n    mkdirSync(workdir, { recursive: true });\n    const entrypoint = join(workdir, `${assetName}.cjs`);\n    this.entrypoint = entrypoint;\n\n    if (process.env.WING_TARGET) {\n      this.addEnvironment(\"WING_TARGET\", process.env.WING_TARGET);\n    }\n\n    this.factory = factory;\n  }\n\n  public addPermission(resource: IStdResource, op: string): void {\n    this.permissions.push([resource, op]);\n  }\n\n  /** @internal */\n  public get _liftMap(): LiftMap {\n    return {\n      [ResourceInflightMethods.CALL]: [],\n    };\n  }\n\n  /**\n   * Obtain a token that can be used to reference an attribute of this\n   * resource that is only resolved once the resource is started in the simulator.\n   *\n   * If the token is used in inflight code or in the configuration of a simulated\n   * resource (e.g. as an environment variable), the relevant resource will\n   * automatically take a dependency on the resource the token belongs to.\n   *\n   * @param name The name of the token.\n   * @returns A string token.\n   */\n  public createToken(name: string): string {\n    return simulatorAttrToken(this, name);\n  }\n\n  /** @internal */\n  public _preSynthesize(): void {\n    super._preSynthesize();\n    const onStopMethod = \"onStop\";\n    const inflightClient = this.factory._toInflight();\n    const code = `\\\n        \"use strict\";\n        let $klass;\n        exports.start = async function(statedir) {\n          if ($klass) {\n            throw Error('resource already started');\n          }\n          const attrs = {};\n          const ctx = {};\n          ctx.statedir = async () => statedir;\n          ctx.resolveToken = async (name, value) => attrs[name] = value;\n          ctx.log = async (message, level) => {\n            if (!level) level = 'info';\n            console.log(level + ':' + message);\n          };\n          const client = ${inflightClient};\n          const noop = { ${onStopMethod}: () => {} };\n          const klass = (await client.handle(ctx)) ?? noop;\n          ctx.resolveToken = () => {\n            throw Error('cannot resolve attributes outside of onStop method');\n          };\n          $klass = klass;\n          return attrs;\n        };\n\n        exports.call = async function(propName, ...args) {\n          if (!$klass) {\n            throw Error('Resource is not running (it may have crashed or stopped)');\n          }\n          if (propName === '${onStopMethod}') {\n            throw Error('Cannot call \"${onStopMethod}\"');\n          }\n          const prop = $klass[propName];\n          if (!prop) {\n            throw Error('Method or property \"' + propName + '\" not found');\n          }\n          if (typeof prop !== 'function') {\n            if (args.length > 0) {\n              throw Error('Property \"' + propName + '\" is not a function');\n            }\n            return prop;\n          }\n          return await prop.call($klass, ...args);\n        };\n\n        exports.stop = async function() {\n          if (!$klass) {\n            throw Error('Resource is not running (it may have crashed or stopped)');\n          }\n          await $klass.${onStopMethod}();\n          $klass = undefined;\n        };\n        `;\n\n    writeFileSync(this.entrypoint, code);\n\n    // indicates that we are calling the inflight constructor and the\n    // inflight \"handle\" method on the handler resource.\n    Lifting.lift(this.factory, this, [\"handle\"]);\n  }\n\n  /**\n   * Add an environment variable to make available to the inflight code.\n   */\n  public addEnvironment(name: string, value: string) {\n    if (this._env[name] !== undefined && this._env[name] !== value) {\n      throw new Error(\n        `Environment variable \"${name}\" already set with a different value.`\n      );\n    }\n    this._env[name] = value;\n  }\n\n  public toSimulator(): ToSimulatorOutput {\n    const policy: Array<PolicyStatement> = [];\n    for (const [resource, operation] of this.permissions) {\n      policy.push({\n        operation,\n        resourceHandle: simulatorHandleToken(resource),\n      });\n    }\n    const props: SimResourceSchema = {\n      environmentVariables: this._env,\n      sourceCodeFile: relative(App.of(this).outdir, this.entrypoint),\n      sourceCodeLanguage: \"javascript\",\n    };\n    return {\n      type: SIM_RESOURCE_FQN,\n      props,\n      policy,\n    };\n  }\n\n  public onLift(host: IInflightHost, ops: string[]): void {\n    bindSimulatorResource(__filename, this, host, ops);\n    super.onLift(host, ops);\n  }\n\n  /** @internal */\n  public _toInflight(): string {\n    return makeSimulatorJsClient(__filename, this);\n  }\n}\n\n/**\n * Inflight interface for `sim.Resource`.\n */\nexport interface IResourceClient {\n  /**\n   * Call a method on the resource.\n   * @inflight\n   */\n  call(method: string, args?: Array<Json>): Promise<Json>;\n}\n\n/**\n * List of inflight operations available for `Resource`.\n * @internal\n */\nexport enum ResourceInflightMethods {\n  CALL = \"call\",\n}\n\n/**\n * A resource with an inflight \"handle\" method that can be passed to the\n * `sim.Resource` constructor.\n * @inflight `@winglang/sdk.sim.IResourceFactoryClient`\n */\nexport interface IResourceFactory extends IInflight {}\n\n/**\n * A resource with an inflight \"handle\" method that can be passed to the\n * `sim.Resource` constructor.\n */\nexport interface IResourceFactoryClient {\n  /**\n   * Function that will be called to initialize the simulator resource.\n   *\n   * To implement a shutdown sequence, return an object that implements the `IResource` inflight interface with an `onStop()` method.\n   *\n   * @inflight\n   */\n  handle(context: IResourceContext): Promise<IResource | undefined>;\n}\n\n/**\n * Interfaces shared by all preflight classes that host inflight code.\n */\nexport interface ISimulatorInflightHost extends IInflightHost {\n  /**\n   * Add a simulated permission to this inflight host.\n   * @param resource The resource to add\n   * @param op The action to add\n   */\n  addPermission(resource: IStdResource, op: string): void;\n}\n\nexport function isSimulatorInflightHost(\n  obj: any\n): obj is ISimulatorInflightHost {\n  return (\n    typeof obj == \"object\" &&\n    typeof (obj as ISimulatorInflightHost).addPermission === \"function\"\n  );\n}\n\n/**\n * Interfaces shared by all preflight classes targeting the simulator.\n */\nexport interface ISimulatorResource extends IStdResource {\n  /**\n   * Convert this resource to a resource schema for the simulator.\n   */\n  toSimulator(): ToSimulatorOutput;\n}\n\nexport function isSimulatorResource(obj: any): obj is ISimulatorResource {\n  return (\n    typeof obj == \"object\" &&\n    typeof (obj as ISimulatorResource).toSimulator === \"function\"\n  );\n}\n","import { access, constants } from \"fs\";\nimport { basename } from \"path\";\nimport { promisify } from \"util\";\nimport { IConstruct } from \"constructs\";\nimport { isSimulatorInflightHost } from \"./resource\";\nimport { simulatorHandleToken } from \"./tokens\";\nimport { Duration, IInflightHost, Resource } from \"../std\";\n\n/**\n * Check if a file exists for an specific path\n * @param filePath\n * @Returns Return `true` if the file exists, `false` otherwise.\n */\nexport async function exists(filePath: string): Promise<boolean> {\n  try {\n    await promisify(access)(\n      filePath,\n      constants.F_OK | constants.R_OK | constants.W_OK //eslint-disable-line no-bitwise\n    );\n    return true;\n  } catch (er) {\n    return false;\n  }\n}\n\nfunction makeEnvVarName(type: string, resource: IConstruct): string {\n  return `${type\n    .toUpperCase()\n    .replace(/[^A-Z]+/g, \"_\")}_HANDLE_${resource.node.addr.slice(-8)}`;\n}\n\nexport function bindSimulatorResource(\n  filename: string,\n  resource: Resource,\n  host: IInflightHost,\n  ops: string[]\n) {\n  // Check if host implements ISimulatorInflightHost\n  if (!isSimulatorInflightHost(host)) {\n    throw new Error(\n      \"Host resource must implement sim.ISimulatorInflightHost to bind simulator resources\"\n    );\n  }\n  const type = basename(filename).split(\".\")[0];\n  const env = makeEnvVarName(type, resource);\n  const handle = simulatorHandleToken(resource);\n  host.addEnvironment(env, handle);\n  host.node.addDependency(resource);\n  for (const op of ops) {\n    host.addPermission(resource, op);\n  }\n}\n\nexport function makeSimulatorJsClient(filename: string, resource: Resource) {\n  const type = basename(filename).split(\".\")[0];\n  const env = makeEnvVarName(type, resource);\n  return `(function() {\n  let handle = process.env.${env};\n  if (!handle) {\n    throw new Error(\"Missing environment variable: ${env}\");\n  }\n  const simulatorUrl = process.env.WING_SIMULATOR_URL;\n  if (!simulatorUrl) {\n    throw new Error(\"Missing environment variable: WING_SIMULATOR_URL\");\n  }\n  const caller = process.env.WING_SIMULATOR_CALLER;\n  if (!caller) {\n    throw new Error(\"Missing environment variable: WING_SIMULATOR_CALLER\");\n  }\n  return require(\"@winglang/sdk/lib/simulator/client\").makeSimulatorClient(simulatorUrl, handle, caller);\n})()`;\n}\n\nexport function makeSimulatorJsClientV2(filename: string, resource: Resource) {\n  const type = basename(filename).split(\".\")[0];\n  const env = makeEnvVarName(type, resource);\n  return `(function() {\n  let handle = process.env.${env};\n  if (!handle) {\n    throw new Error(\"Missing environment variable: ${env}\");\n  }\n  const simulatorUrl = process.env.WING_SIMULATOR_URL;\n  if (!simulatorUrl) {\n    throw new Error(\"Missing environment variable: WING_SIMULATOR_URL\");\n  }\n  const caller = process.env.WING_SIMULATOR_CALLER;\n  if (!caller) {\n    throw new Error(\"Missing environment variable: WING_SIMULATOR_CALLER\");\n  }\n  const backend = require(\"@winglang/sdk/lib/simulator/client\").makeSimulatorClient(simulatorUrl, handle, caller);\n  const client = new Proxy(backend, {\n    get: function(target, prop, receiver) {\n      return async function(...args) {\n        return backend.call(prop, args);\n      };\n    },\n  });\n  return client;\n})()`;\n}\n\n// helper function to convert duration to a cron string\n// maybe this belongs in a util library but for now it's here\nexport function convertDurationToCronExpression(dur: Duration): string {\n  if (dur.minutes % 1 !== 0) {\n    // our cron expression format is [minute] [hour] [day] [month] [year]\n    throw new Error(\"Cron expressions with second precision are not supported\");\n  }\n\n  const totalInMinutes = Math.floor(dur.minutes);\n\n  const h = Math.floor(totalInMinutes / 60);\n  const m = totalInMinutes % 60;\n  // [minute] [hour] [day of month] [month] [day of week]\n  const minute = m != 0 ? `*/${m}` : \"*\";\n  const hour = h != 0 ? `*/${h}` : \"*\";\n  // TODO: Support longer durations once we implement https://github.com/winglang/wing/issues/2243\n  // for now we just use * for day, month, and year\n  const dayInMonth = \"*\";\n  const month = \"*\";\n  const dayOfWeek = \"*\";\n\n  // Generate cron string based on the duration\n  const cronString = `${minute} ${hour} ${dayInMonth} ${month} ${dayOfWeek}`;\n  return cronString;\n}\n","import * as fs from \"fs\";\nimport { join } from \"path\";\nimport { CounterBackendProps } from \"./counter\";\nimport { IResource, IResourceContext } from \"./resource\";\nimport { exists } from \"./util\";\nimport { ICounterClient } from \"../cloud\";\n\nconst VALUES_FILENAME = \"values.json\";\n\nexport class CounterBackend implements ICounterClient, IResource {\n  private values: Map<string, number>;\n  private initial: number;\n  private ctx: IResourceContext;\n\n  public constructor(ctx: IResourceContext, props: CounterBackendProps) {\n    this.ctx = ctx;\n    this.initial = props.initial ?? 0;\n    this.values = new Map().set(\"default\", this.initial);\n  }\n\n  public async onStart(): Promise<void> {\n    // Load the values from disk\n    const valuesFile = join(await this.ctx.statedir(), VALUES_FILENAME);\n    const valueFilesExists = await exists(valuesFile);\n    if (valueFilesExists) {\n      const valuesContents = await fs.promises.readFile(valuesFile, \"utf-8\");\n      const values = JSON.parse(valuesContents);\n      this.values = new Map(values);\n    }\n  }\n\n  public async onStop(): Promise<void> {\n    // Save the values to disk\n    fs.writeFileSync(\n      join(await this.ctx.statedir(), VALUES_FILENAME),\n      JSON.stringify(Array.from(this.values.entries()))\n    );\n  }\n\n  public async inc(\n    amount: number = 1,\n    key: string = \"default\"\n  ): Promise<number> {\n    const prev = this.values.get(key) ?? this.initial;\n    this.values.set(key, prev + amount);\n    return prev;\n  }\n\n  public async dec(\n    amount: number = 1,\n    key: string = \"default\"\n  ): Promise<number> {\n    const prev = this.values.get(key) ?? this.initial;\n    this.values.set(key, prev - amount);\n    return prev;\n  }\n\n  public async peek(key: string = \"default\"): Promise<number> {\n    return this.values.get(key) ?? this.initial;\n  }\n\n  public async set(value: number, key: string = \"default\"): Promise<void> {\n    this.values.set(key, value);\n  }\n}\n","        \"use strict\";\n        let $klass;\n        exports.start = async function(statedir) {\n          if ($klass) {\n            throw Error('resource already started');\n          }\n          const attrs = {};\n          const ctx = {};\n          ctx.statedir = async () => statedir;\n          ctx.resolveToken = async (name, value) => attrs[name] = value;\n          ctx.log = async (message, level) => {\n            if (!level) level = 'info';\n            console.log(level + ':' + message);\n          };\n          const client = (await (async () => {\n  const $func = async (ctx, simContext) => {\n            // TODO: make CounterBackend liftable so we can add it to the list of captures\n            const CounterBackend = \n            // eslint-disable-next-line @typescript-eslint/no-require-imports\n            require(\"@winglang/sdk/lib/target-sim/counter.inflight\").CounterBackend;\n            const backend = new CounterBackend(simContext, { initial: ctx.initial });\n            await backend.onStart();\n            return backend;\n        }\n  const $ctx = {\n  initial: 0\n  };\n  let newFunction = async (...args) => {\n    return $func($ctx, ...args);\n  };\n  newFunction.handle = newFunction;\n  return newFunction;\n}\n)());\n          const noop = { onStop: () => {} };\n          const klass = (await client.handle(ctx)) ?? noop;\n          ctx.resolveToken = () => {\n            throw Error('cannot resolve attributes outside of onStop method');\n          };\n          $klass = klass;\n          return attrs;\n        };\n\n        exports.call = async function(propName, ...args) {\n          if (!$klass) {\n            throw Error('Resource is not running (it may have crashed or stopped)');\n          }\n          if (propName === 'onStop') {\n            throw Error('Cannot call \"onStop\"');\n          }\n          const prop = $klass[propName];\n          if (!prop) {\n            throw Error('Method or property \"' + propName + '\" not found');\n          }\n          if (typeof prop !== 'function') {\n            if (args.length > 0) {\n              throw Error('Property \"' + propName + '\" is not a function');\n            }\n            return prop;\n          }\n          return await prop.call($klass, ...args);\n        };\n\n        exports.stop = async function() {\n          if (!$klass) {\n            throw Error('Resource is not running (it may have crashed or stopped)');\n          }\n          await $klass.onStop();\n          $klass = undefined;\n        };\n        \nprocess.on(\"uncaughtException\", (reason) => {\n  process.send({ type: \"error\", reason });\n});\n\nprocess.on(\"message\", async (message) => {\n  const { fn, args } = message;\n  const value = await exports[fn](...args);\n  process.send({ type: \"ok\", value });\n});\n"],"mappings":";;;;;;;;;;;;;;AAyBA,QAAM,aAA+B,CAAA;AAKrC,aAAgB,aAAa,OAAa;AACxC,aAAO,cAAc,MAClB,QAAQ,oBAAoB,GAAG,EAC/B,QAAQ,OAAO,EAAE,EACjB,QAAQ,OAAO,EAAE,EACjB,YAAW,CAAE;IAClB;AANgB;AAAhB,IAAAA,SAAA,eAAA;AAWA,aAAgB,sBAAsB,UAAwB;AAC5D,iBAAW,KAAK,QAAQ;IAC1B;AAFgB;AAAhB,IAAAA,SAAA,wBAAA;AAOA,aAAgB,iBAAiB,OAAU;AACzC,aAAO,WAAW,KAAK,CAAC,MAAM,EAAE,QAAQ,KAAK,CAAC;IAChD;AAFgB;AAAhB,IAAAA,SAAA,mBAAA;;;;;;;;;;AChDA,QAAA,WAAA;AAQA,aAAgB,qBAAqB,UAAmB;AACtD,aAAO,mBAAmB,UAAU,QAAQ;IAC9C;AAFgB;AAAhB,IAAAC,SAAA,uBAAA;AAQA,aAAgB,mBACd,UACA,UAAgB;AAEhB,aAAO,WAAW,SAAS,KAAK,IAAI,UAAU,QAAQ;IACxD;AALgB;AAAhB,IAAAA,SAAA,qBAAA;AAaa,IAAAA,SAAA,wBAAwB;AAKxB,IAAAA,SAAA,6BAA6B,IAAI,OAC5C,IAAIA,SAAA,sBAAsB,MAAM,GAAG;AAMrC,aAAgB,iBAAiB,OAAa;AAC5C,aAAOA,SAAA,sBAAsB,KAAK,KAAK;IACzC;AAFgB;AAAhB,IAAAA,SAAA,mBAAA;AAQA,QAAa,YAAb,MAAsB;aAAA;;;;;;MAIb,QAAQ,OAAU;AACvB,YAAI,OAAO,UAAU,UAAU;AAC7B,iBAAO,iBAAiB,KAAK;QAC/B;AAEA,eAAO;MACT;;;;MAKO,KAAK,OAAU;AACpB,gBAAQ,OAAO,OAAO;UACpB,KAAK;AACH,mBAAO,eAAe,KAAK,WAAU,GAAA,SAAA,cAAa,KAAK,CAAC,CAAC;UAC3D;AACE,kBAAM,IAAI,MAAM,wBAAwB;QAC5C;MACF;;;;MAKO,YAAY,MAAqB,OAAU;AAChD,gBAAQ,OAAO,OAAO;UACpB,KAAK;AACH,kBAAM,WAAU,GAAA,SAAA,cAAa,KAAK;AAClC,iBAAK,eAAe,SAAS,KAAK;AAClC;UACF;AACE,kBAAM,IAAI,MAAM,wBAAwB,KAAK,EAAE;QACnD;MACF;;AApCF,IAAAA,SAAA,YAAA;;;;;;;;;;;;;ACxBA,QAAa,kBAAb,MAA4B;aAAA;;;MAG1B,eAAe,MAAmB;AAFjB,aAAA,QAAQ,IAAI,MAAK;AAGhC,cAAM,OAAO;AAEb,mBAAW,UAAU,MAAM;UACzB,IAAI,kBAAe;AACjB,kBAAM,SAAS,IAAI,MAAK;AACxB,uBAAW,KAAK,KAAK,OAAO;AAC1B,qBAAO,KAAK,GAAG,WAAW,GAAG,CAAC,EAAE,eAAe;;AAEjD,mBAAO;UACT;SACD;AAED,aAAK,IAAI,GAAG,IAAI;MAClB;;;;MAKO,OAAO,QAAqB;AACjC,aAAK,MAAM,KAAK,GAAG,MAAM;MAC3B;;;;AAxBW,IAAAC,SAAA,kBAAA;AA2Bb,QAAM,oBAAoB,OAAO,IAAI,+BAA+B;AAuBpE,QAAsB,aAAtB,MAAgC;aAAA;;;;;;MAIvB,OAAO,UAAU,UAAuB,OAAiB;AAI7D,iBAAiB,iBAAiB,IAAI;MACzC;;;;MAKO,OAAO,GAAG,UAAqB;AACpC,cAAM,MAAO,SAAiB,iBAAiB;AAC/C,YAAI,CAAC,KAAK;AACR,gBAAM,IAAI,MAAM,GAAG,QAAQ,4EAA4E;;AAEzG,eAAO;MACT;;;;;MAMO,OAAO,IAAI,UAAqB;AACrC,eAAO,KAAK,GAAG,QAAQ;MACzB;;;;AA5BoB,IAAAA,SAAA,aAAA;;;;;;;;;;AC1EtB,aAAgB,kBAAkB,OAAgB;AAChD,cAAQ,SAAS;AACjB,YAAM,SAAS,EAAE,OAAO,GAAE;AAC1B,YAAM,gBAAgB,MAAM;AAC5B,UAAI;AACF,cAAM,kBAAkB,OAAO;AAC/B,cAAM,kBAAkB,QAAQ,KAAK;;AAErC,cAAM,kBAAkB;;AAE1B,UAAI,CAAC,OAAO,OAAO;AACjB,eAAO,CAAA;;AAET,aAAO,OAAO,MAAM,MAAM,IAAI,EAAE,MAAM,CAAC,EAAE,IAAI,OAAK,EAAE,QAAQ,aAAa,EAAE,CAAC;IAC9E;AAdgB;AAAhB,IAAAC,SAAA,oBAAA;;;;;;;;;;ACDA,QAAA,SAAA,QAAA,QAAA;AAKA,QAAM,YAAY;AAUlB,aAAgB,UAAU,YAAoB;AAC5C,YAAM,OAAO,OAAO,WAAW,MAAM;AACrC,iBAAW,KAAK,YAAY;AAE1B,YAAI,MAAM,WAAW;AAAE;;AAEvB,aAAK,OAAO,CAAC;AACb,aAAK,OAAO,IAAI;;AAIlB,aAAO,OAAO,KAAK,OAAO,KAAK;IACjC;AAZgB;AAAhB,IAAAC,SAAA,YAAA;;;;;;;;;;;;;ACfA,QAAA,eAAA;AAEA,QAAA,gBAAA;AACA,QAAA,aAAA;AAEA,QAAM,gBAAgB,OAAO,IAAI,sBAAsB;AAevD,QAAa,OAAb,MAAa,MAAI;aAAA;;;;;;;;;MAYR,OAAO,GAAG,WAAqB;AACpC,eAAO,UAAU;MACnB;MAyBA,YAAoC,MAAiB,OAAmB,IAAU;AAA9C,aAAA,OAAA;AAT5B,aAAA,UAAU;AACD,aAAA,YAA0C,CAAA;AAC1C,aAAA,WAAmC,CAAA;AACnC,aAAA,YAAY,IAAI,MAAK;AACrB,aAAA,gBAAgB,oBAAI,IAAG;AAEvB,aAAA,eAAe,IAAI,MAAK;AAIvC,aAAK,MAAM;AAEX,aAAK,KAAK,WAAW,EAAE;AACvB,aAAK,QAAQ;AAEb,YAAI,SAAS,CAAC,KAAK,IAAI;AACrB,gBAAM,IAAI,MAAM,2CAA2C;;AAI7D,eAAO,KAAK,SAAS,MAAM,KAAK,EAAE;MACpC;;;;;;MAOA,IAAW,OAAI;AACb,cAAM,aAAa,CAAA;AACnB,mBAAW,SAAS,KAAK,QAAQ;AAC/B,cAAI,MAAM,KAAK,IAAI;AACjB,uBAAW,KAAK,MAAM,KAAK,EAAE;;;AAGjC,eAAO,WAAW,KAAK,MAAK,QAAQ;MACtC;;;;;;;;;;;;;;;;MAiBA,IAAW,OAAI;AACb,YAAI,CAAC,KAAK,OAAO;AACf,eAAK,SAAQ,GAAA,WAAA,WAAU,KAAK,OAAO,IAAI,OAAK,EAAE,KAAK,EAAE,CAAC;;AAGxD,eAAO,KAAK;MACd;;;;;;;MAQO,aAAa,IAAU;AAC5B,eAAO,KAAK,UAAU,WAAW,EAAE,CAAC;MACtC;;;;;;;;;MAUO,UAAU,IAAU;AACzB,cAAM,MAAM,KAAK,aAAa,EAAE;AAChC,YAAI,CAAC,KAAK;AACR,gBAAM,IAAI,MAAM,sBAAsB,EAAE,GAAG;;AAE7C,eAAO;MACT;;;;;;;;;MAUA,IAAW,eAAY;AACrB,YAAI,KAAK,kBAAkB,QAAW;AACpC,iBAAO,KAAK;;AAGd,cAAM,gBAAgB,KAAK,aAAa,UAAU;AAClD,cAAM,eAAe,KAAK,aAAa,SAAS;AAChD,YAAI,iBAAiB,cAAc;AACjC,gBAAM,IAAI,MAAM,sCAAsC,KAAK,IAAI,6DAA6D;;AAG9H,eAAO,gBAAgB;MACzB;;;;;;;;;;;MAYA,IAAW,aAAa,OAA6B;AACnD,aAAK,gBAAgB;MACvB;;;;MAKA,IAAW,WAAQ;AACjB,eAAO,OAAO,OAAO,KAAK,SAAS;MACrC;;;;MAKO,QAAQ,QAAwB,eAAe,UAAQ;AAC5D,cAAM,MAAM,IAAI,MAAK;AACrB,cAAM,KAAK,IAAI;AACf,eAAO;AAEP,iBAAS,MAAM,GAAa;AAC1B,cAAI,UAAU,eAAe,UAAU;AACrC,gBAAI,KAAK,CAAC;;AAGZ,qBAAW,SAAS,EAAE,KAAK,UAAU;AACnC,kBAAM,KAAK;;AAGb,cAAI,UAAU,eAAe,WAAW;AACtC,gBAAI,KAAK,CAAC;;QAEd;AAZS;MAaX;;;;;;;;MASO,WAAW,KAAa,OAAU;AACvC,YAAI,KAAK,SAAS,SAAS,GAAG;AAC5B,gBAAM,QAAQ,KAAK,SAAS,IAAI,OAAK,EAAE,KAAK,EAAE;AAC9C,gBAAM,IAAI,MAAM,wDAAwD,MAAM,KAAK,GAAG,CAAC;;AAEzF,aAAK,SAAS,GAAG,IAAI;MACvB;;;;;;;;;MAUO,WAAW,KAAW;AAC3B,cAAM,QAAQ,KAAK,SAAS,GAAG;AAE/B,YAAI,UAAU,QAAW;AAAE,iBAAO;;AAElC,YAAI,UAAU,UAAa,CAAC,KAAK,OAAO,MAAM;AAC5C,gBAAM,IAAI,MAAM,gCAAgC,GAAG,MAAM;;AAG3D,eAAO,KAAK,SAAS,KAAK,MAAM,KAAK,WAAW,GAAG;MACrD;;;;;;;;;MAUO,cAAc,UAAiB;AACpC,YAAI,OAAO,aAAa,aAAa;AACnC,qBAAW,CAAA;;AAGb,YAAI,KAAK,UAAU,QAAW;AAAE,iBAAO;;AAEvC,cAAM,QAAQ,EAAE,GAAG,KAAK,UAAU,GAAG,SAAQ;AAC7C,eAAO,KAAK,SAAS,KAAK,MAAM,KAAK,cAAc,KAAK;MAC1D;;;;;;;;;MAUO,cAAc,KAAW;AAC9B,cAAM,QAAQ,KAAK,SAAS,GAAG;AAC/B,YAAI,UAAU,QAAW;AAAE,iBAAO;;AAElC,eAAO,KAAK,SAAS,KAAK,MAAM,KAAK,cAAc,GAAG;MACxD;;;;;MAMA,IAAW,WAAQ;AACjB,eAAO,CAAC,GAAG,KAAK,SAAS;MAC3B;;;;;;;;;;;MAYO,YAAY,MAAc,MAAW,UAA2B,CAAA,GAAG;AACxE,YAAI,QAAQ,MAAM;AAChB;;AAGF,cAAM,cAAc,QAAQ,cAAc;AAC1C,cAAM,QAAQ,eAAc,GAAA,cAAA,mBAAkB,QAAQ,qBAAqB,KAAK,WAAW,IAAI;AAC/F,aAAK,UAAU,KAAK,EAAE,MAAM,MAAM,MAAK,CAAE;MAC3C;;;;;;;;MASA,IAAW,SAAM;AACf,cAAM,MAAM,IAAI,MAAK;AAErB,YAAI,OAA+B,KAAK;AACxC,eAAO,MAAM;AACX,cAAI,QAAQ,IAAI;AAChB,iBAAO,KAAK,KAAK;;AAGnB,eAAO;MACT;;;;;MAMA,IAAW,OAAI;AACb,eAAO,KAAK,OAAO,CAAC;MACtB;;;;;MAMA,IAAW,SAAM;AACf,YAAI,KAAK,SAAS;AAChB,iBAAO;;AAGT,YAAI,KAAK,SAAS,KAAK,MAAM,KAAK,QAAQ;AACxC,iBAAO;;AAGT,eAAO;MACT;;;;;;MAOO,iBAAiB,MAAmB;AACzC,mBAAW,KAAK,MAAM;AACpB,eAAK,cAAc,IAAI,CAAC;;MAE5B;;;;MAKA,IAAW,eAAY;AACrB,cAAM,SAAS,IAAI,MAAK;AACxB,mBAAW,OAAO,KAAK,eAAe;AACpC,qBAAW,QAAQ,aAAA,WAAW,GAAG,GAAG,EAAE,iBAAiB;AACrD,mBAAO,KAAK,IAAI;;;AAIpB,eAAO;MACT;;;;;;;MAQO,eAAe,WAAiB;AACrC,YAAI,EAAE,aAAa,KAAK,YAAY;AAAE,iBAAO;;AAC7C,eAAO,KAAK,UAAU,SAAS;AAC/B,eAAO;MACT;;;;;;;;;MAUO,cAAc,YAAuB;AAC1C,aAAK,aAAa,KAAK,UAAU;MACnC;;;;;;;;;;MAWO,WAAQ;AACb,cAAM,aAAa,CAAC,YAAY,cAAc,cAAc,gBAAgB,WAAW,WAAW;AAClG,mBAAW,UAAU,YAAY;AAC/B,cAAI,OAAQ,KAAK,KAAa,MAAM,MAAO,YAAY;AACrD,kBAAM,IAAI,MAAM,kBAAkB,KAAK,IAAI,YAAY,MAAM,iHAAiH;;;AAIlL,cAAM,SAAS,IAAI,MAAK;AACxB,mBAAW,KAAK,KAAK,cAAc;AACjC,iBAAO,KAAK,GAAG,EAAE,SAAQ,CAAE;;AAG7B,eAAO;MACT;;;;;MAMO,OAAI;AACT,aAAK,UAAU;MACjB;;;;;;;;MASQ,SAAS,OAAkB,WAAiB;AAClD,YAAI,KAAK,QAAQ;AAGf,cAAI,CAAC,KAAK,MAAM;AACd,kBAAM,IAAI,MAAM,sCAAsC;;AAGxD,gBAAM,IAAI,MAAM,2BAA2B,KAAK,IAAI,oBAAoB;;AAG1E,YAAI,KAAK,UAAU,SAAS,GAAG;AAC7B,gBAAM,OAAO,KAAK,MAAM;AACxB,gBAAM,WAAW,KAAK,KAAK,YAAY;AACvC,gBAAM,IAAI,MAAM,2CAA2C,SAAS,QAAQ,QAAQ,GAAG,KAAK,SAAS,IAAI,OAAO,OAAO,MAAM,EAAE,EAAE;;AAGnI,aAAK,UAAU,SAAS,IAAI;MAC9B;;;;AA1auB,SAAA,WAAW;AAJvB,IAAAC,SAAA,OAAA;AAubb,QAAa,YAAb,MAAsB;aAAA;;;;;;;;;;;;;;;;;;;;;;;MAqBb,OAAO,YAAY,GAAM;AAC9B,eAAO,KAAK,OAAO,MAAM,YAAY,EAAE,aAAa;MACtD;;;;;;;;;MAeA,YAAY,OAAkB,IAAU;AACtC,aAAK,OAAO,IAAI,KAAK,MAAM,OAAO,EAAE;AAGpC,qBAAA,WAAW,UAAU,MAAM;UACzB,iBAAiB,CAAC,IAAI;SACvB;MACH;;;;MAKO,WAAQ;AACb,eAAO,KAAK,KAAK,QAAQ;MAC3B;;;;AApDW,IAAAA,SAAA,YAAA;AAyEb,QAAY;AAAZ,KAAA,SAAYC,iBAAc;AAIxB,MAAAA,gBAAAA,gBAAA,UAAA,IAAA,CAAA,IAAA;AAKA,MAAAA,gBAAAA,gBAAA,WAAA,IAAA,CAAA,IAAA;IACF,GAVY,iBAAAD,SAAA,mBAAAA,SAAA,iBAAc,CAAA,EAAA;AAY1B,QAAM,iBAAiB,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG;AAKzD,aAAS,WAAW,IAAU;AAE5B,aAAO,GAAG,QAAQ,gBAAgB,IAAI;IACxC;AAHS;AA0BT,WAAO,eAAe,UAAU,WAAW,eAAe;MACxD,OAAO;MACP,YAAY;MACZ,UAAU;KACX;;;;;ACnkBD;AAAA,kGAAAE,UAAA;AAAA;AACA,WAAO,eAAeA,UAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACD5D,iBAAA,qBAAAC,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,sBAAAA,QAAA;;;;;;;;;;ACIA,QAAa,sBAAb,cAAyC,MAAK;aAAA;;;MAI5C,YAAY,SAAiB,SAAoC;AAC/D,cACE,GAAG,OAAO,GACR,SAAS,QACL;4BAA+B,QAAQ,KAAK;sCAC5C,EACN,EAAE;AATC,aAAA,OAAe;AAWpB,aAAK,WAAW,SAAS;AACzB,aAAK,YAAY,SAAS;MAC5B;;AAdF,IAAAC,SAAA,sBAAA;AAiBA,QAAa,sBAAb,cAAyC,MAAK;aAAA;;;MAC5C,cAAA;AACE,cAAM,gEAAgE;MACxE;;AAHF,IAAAA,SAAA,sBAAA;;;;;ACvBA;AAAA,kGAAAC,UAAAC,SAAA;AAAA,IAAAA,QAAA;AAAA,MACE,MAAQ;AAAA,MACR,YAAc;AAAA,QACZ,MAAQ;AAAA,QACR,KAAO;AAAA,QACP,WAAa;AAAA,MACf;AAAA,MACA,QAAU;AAAA,QACR,MAAQ;AAAA,QACR,OAAS;AAAA,QACT,cAAgB;AAAA,MAClB;AAAA,MACA,kBAAoB;AAAA,QAClB,YAAc;AAAA,MAChB;AAAA,MACA,cAAgB;AAAA,QACd,mCAAmC;AAAA,QACnC,4BAA4B;AAAA,QAC5B,+BAA+B;AAAA,QAC/B,0BAA0B;AAAA,QAC1B,sBAAsB;AAAA,QACtB,mCAAmC;AAAA,QACnC,uBAAuB;AAAA,QACvB,uBAAuB;AAAA,QACvB,iCAAiC;AAAA,QACjC,kBAAkB;AAAA,QAClB,0BAA0B;AAAA,QAC1B,sBAAsB;AAAA,QACtB,sBAAsB;AAAA,QACtB,mBAAmB;AAAA,QACnB,uBAAuB;AAAA,QACvB,2BAA2B;AAAA,QAC3B,yBAAyB;AAAA,QACzB,uBAAuB;AAAA,QACvB,qBAAqB;AAAA,QACrB,qBAAqB;AAAA,QACrB,yBAAyB;AAAA,QACzB,KAAO;AAAA,QACP,OAAS;AAAA,QACT,YAAc;AAAA,QACd,eAAe;AAAA,QACf,kBAAkB;AAAA,QAClB,SAAW;AAAA,QACX,MAAQ;AAAA,QACR,uBAAuB;AAAA,QACvB,SAAW;AAAA,QACX,MAAQ;AAAA,QACR,MAAQ;AAAA,QACR,cAAc;AAAA,QACd,QAAU;AAAA,QACV,YAAc;AAAA,QACd,yBAAyB;AAAA,QACzB,aAAe;AAAA,QACf,MAAQ;AAAA,QACR,MAAQ;AAAA,QACR,MAAQ;AAAA,QACR,KAAO;AAAA,QACP,MAAQ;AAAA,MACV;AAAA,MACA,qBAAuB;AAAA,QACrB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA,SAAW;AAAA,QACT,MAAQ;AAAA,MACV;AAAA,MACA,MAAQ;AAAA,MACR,SAAW;AAAA,MACX,SAAW;AAAA,MACX,OAAS;AAAA,MACT,WAAa;AAAA,MACb,MAAQ;AAAA,QACN,QAAU;AAAA,QACV,SAAW,CAAC;AAAA,QACZ,KAAO;AAAA,UACL,QAAU;AAAA,UACV,SAAW;AAAA,QACb;AAAA,MACF;AAAA,MACA,sBAAwB;AAAA,QACtB,SAAW;AAAA,MACb;AAAA,MACA,OAAS;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA,MAAM;AAAA,MACN,SAAW;AAAA,QACT,aAAa;AAAA,QACb,mBAAmB;AAAA,QACnB,OAAS;AAAA,QACT,MAAQ;AAAA,QACR,SAAW;AAAA,QACX,QAAU;AAAA,QACV,SAAW;AAAA,QACX,SAAW;AAAA,QACX,QAAU;AAAA,QACV,OAAS;AAAA,QACT,QAAU;AAAA,QACV,SAAW;AAAA,QACX,eAAe;AAAA,QACf,cAAc;AAAA,QACd,gBAAgB;AAAA,QAChB,eAAe;AAAA,QACf,SAAW;AAAA,QACX,MAAQ;AAAA,QACR,cAAc;AAAA,QACd,QAAU;AAAA,QACV,OAAS;AAAA,QACT,QAAU;AAAA,MACZ;AAAA,IACF;AAAA;AAAA;;;;;;;;ACvJA,QAAM,MAAM;AAEC,IAAAC,SAAA,cAAc,IAAI;AAClB,IAAAA,SAAA,mBAAmB,IAAI;AAEpC,QAAI,CAACA,SAAA,aAAa;AAChB,YAAM,IAAI,MAAM,4BAA4B;IAC9C;AAEA,QAAI,CAACA,SAAA,kBAAkB;AACrB,YAAM,IAAI,MAAM,iCAAiC;IACnD;AAEA,aAAgB,WAAW,MAAY;AACrC,aAAO,GAAGA,SAAA,gBAAgB,IAAI,IAAI;IACpC;AAFgB;AAAhB,IAAAA,SAAA,aAAA;;;;;;;;;;ACdA,QAAsB,cAAtB,MAAiC;aAAA;;;;AAAjC,IAAAC,SAAA,cAAA;AAOa,IAAAA,SAAA,aAAa;AAE1B,QAAa,OAAb,cAA0B,YAAW;aAAA;;;MAEnC,YAAY,GAAS;AACnB,cAAK;AACL,YAAI,CAACA,SAAA,WAAW,KAAK,CAAC;AAAG,gBAAM,IAAI,MAAM,0CAA0C;AACnF,aAAK,MAAM;MACb;MAEA,WAAQ;AACN,eAAO,KAAK;MACd;MAEA,WAAQ;AACN,eAAO;MACT;MAEA,IAAI,QAAK;AACP,eAAO,EAAC,CAAC,KAAK,GAAG,GAAG,EAAC;MACvB;;AAlBF,IAAAA,SAAA,OAAA;AAqBA,QAAa,QAAb,cAA2B,YAAW;aAAA;;;MAKpC,YAAY,MAAkC;AAC5C,cAAK;AACL,aAAK,SAAS,OAAO,SAAS,WAAW,CAAC,IAAI,IAAI;MACpD;MAEA,WAAQ;AACN,eAAO,KAAK;MACd;MAEA,WAAQ;AACN,YAAI,KAAK,OAAO,SAAS;AAAG,iBAAO;AACnC,cAAM,OAAO,KAAK,OAAO,CAAC;AAC1B,eAAO,SAAS,MAAM,SAAS;MACjC;MAEA,IAAI,MAAG;;AACL,gBAAO,KAAC,KAAK,UAAI,QAAA,OAAA,SAAA,KAAT,KAAK,OAAS,KAAK,OAAO,OAAO,CAAC,GAAW,MAAgB,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE;MACrF;MAEA,IAAI,QAAK;;AACP,gBAAO,KAAC,KAAK,YAAM,QAAA,OAAA,SAAA,KAAX,KAAK,SAAW,KAAK,OAAO,OAAO,CAAC,OAAkB,MAAK;AACjE,cAAI,aAAa;AAAM,kBAAM,EAAE,GAAG,KAAK,MAAM,EAAE,GAAG,KAAK,KAAK;AAC5D,iBAAO;QACT,GAAG,CAAA,CAAE;MACP;;AA7BF,IAAAA,SAAA,QAAA;AAwCa,IAAAA,SAAA,MAAM,IAAI,MAAM,EAAE;AAI/B,aAAgB,EAAE,SAA+B,MAAe;AAC9D,YAAM,OAAmB,CAAC,KAAK,CAAC,CAAC;AACjC,UAAI,IAAI;AACR,aAAO,IAAI,KAAK,QAAQ;AACtB,mBAAW,MAAM,KAAK,CAAC,CAAC;AACxB,aAAK,KAAK,KAAK,EAAE,CAAC,CAAC;;AAErB,aAAO,IAAI,MAAM,IAAI;IACvB;AARgB;AAAhB,IAAAA,SAAA,IAAA;AAUA,QAAM,OAAO,IAAI,MAAM,GAAG;AAE1B,aAAgB,IAAI,SAA+B,MAA4B;AAC7E,YAAM,OAAmB,CAAC,cAAc,KAAK,CAAC,CAAC,CAAC;AAChD,UAAI,IAAI;AACR,aAAO,IAAI,KAAK,QAAQ;AACtB,aAAK,KAAK,IAAI;AACd,mBAAW,MAAM,KAAK,CAAC,CAAC;AACxB,aAAK,KAAK,MAAM,cAAc,KAAK,EAAE,CAAC,CAAC,CAAC;;AAE1C,eAAS,IAAI;AACb,aAAO,IAAI,MAAM,IAAI;IACvB;AAVgB;AAAhB,IAAAA,SAAA,MAAA;AAYA,aAAgB,WAAW,MAAkB,KAAuB;AAClE,UAAI,eAAe;AAAO,aAAK,KAAK,GAAG,IAAI,MAAM;eACxC,eAAe;AAAM,aAAK,KAAK,GAAG;;AACtC,aAAK,KAAK,YAAY,GAAG,CAAC;IACjC;AAJgB;AAAhB,IAAAA,SAAA,aAAA;AAMA,aAAS,SAAS,MAAgB;AAChC,UAAI,IAAI;AACR,aAAO,IAAI,KAAK,SAAS,GAAG;AAC1B,YAAI,KAAK,CAAC,MAAM,MAAM;AACpB,gBAAM,MAAM,eAAe,KAAK,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC,CAAC;AACnD,cAAI,QAAQ,QAAW;AACrB,iBAAK,OAAO,IAAI,GAAG,GAAG,GAAG;AACzB;;AAEF,eAAK,GAAG,IAAI;;AAEd;;IAEJ;AAbS;AAeT,aAAS,eAAe,GAAa,GAAW;AAC9C,UAAI,MAAM;AAAM,eAAO;AACvB,UAAI,MAAM;AAAM,eAAO;AACvB,UAAI,OAAO,KAAK,UAAU;AACxB,YAAI,aAAa,QAAQ,EAAE,EAAE,SAAS,CAAC,MAAM;AAAK;AAClD,YAAI,OAAO,KAAK;AAAU,iBAAO,GAAG,EAAE,MAAM,GAAG,EAAE,CAAC,GAAG,CAAC;AACtD,YAAI,EAAE,CAAC,MAAM;AAAK,iBAAO,EAAE,MAAM,GAAG,EAAE,IAAI,EAAE,MAAM,CAAC;AACnD;;AAEF,UAAI,OAAO,KAAK,YAAY,EAAE,CAAC,MAAM,OAAO,EAAE,aAAa;AAAO,eAAO,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AAC3F;IACF;AAXS;AAaT,aAAgB,UAAU,IAAU,IAAQ;AAC1C,aAAO,GAAG,SAAQ,IAAK,KAAK,GAAG,SAAQ,IAAK,KAAK,MAAM,EAAE,GAAG,EAAE;IAChE;AAFgB;AAAhB,IAAAA,SAAA,YAAA;AAKA,aAAS,YAAY,GAA+C;AAClE,aAAO,OAAO,KAAK,YAAY,OAAO,KAAK,aAAa,MAAM,OAC1D,IACA,cAAc,MAAM,QAAQ,CAAC,IAAI,EAAE,KAAK,GAAG,IAAI,CAAC;IACtD;AAJS;AAMT,aAAgB,UAAU,GAAU;AAClC,aAAO,IAAI,MAAM,cAAc,CAAC,CAAC;IACnC;AAFgB;AAAhB,IAAAA,SAAA,YAAA;AAIA,aAAgB,cAAc,GAAU;AACtC,aAAO,KAAK,UAAU,CAAC,EACpB,QAAQ,WAAW,SAAS,EAC5B,QAAQ,WAAW,SAAS;IACjC;AAJgB;AAAhB,IAAAA,SAAA,gBAAA;AAMA,aAAgB,YAAY,KAA2B;AACrD,aAAO,OAAO,OAAO,YAAYA,SAAA,WAAW,KAAK,GAAG,IAAI,IAAI,MAAM,IAAI,GAAG,EAAE,IAAI,KAAK,GAAG;IACzF;AAFgB;AAAhB,IAAAA,SAAA,cAAA;AAKA,aAAgB,iBAAiB,KAA2B;AAC1D,UAAI,OAAO,OAAO,YAAYA,SAAA,WAAW,KAAK,GAAG,GAAG;AAClD,eAAO,IAAI,MAAM,GAAG,GAAG,EAAE;;AAE3B,YAAM,IAAI,MAAM,iCAAiC,GAAG,iCAAiC;IACvF;AALgB;AAAhB,IAAAA,SAAA,mBAAA;AAOA,aAAgB,WAAW,IAAU;AACnC,aAAO,IAAI,MAAM,GAAG,SAAQ,CAAE;IAChC;AAFgB;AAAhB,IAAAA,SAAA,aAAA;;;;;;;;;;ACrKA,QAAA,SAAA;AAeA,QAAM,aAAN,cAAyB,MAAK;aAAA;;;MAE5B,YAAY,MAAoB;AAC9B,cAAM,uBAAuB,IAAI,cAAc;AAC/C,aAAK,QAAQ,KAAK;MACpB;;AAwBF,QAAY;AAAZ,KAAA,SAAYC,iBAAc;AACxB,MAAAA,gBAAAA,gBAAA,SAAA,IAAA,CAAA,IAAA;AACA,MAAAA,gBAAAA,gBAAA,WAAA,IAAA,CAAA,IAAA;IACF,GAHY,iBAAAC,SAAA,mBAAAA,SAAA,iBAAc,CAAA,EAAA;AASb,IAAAA,SAAA,WAAW;MACtB,OAAO,IAAI,OAAA,KAAK,OAAO;MACvB,KAAK,IAAI,OAAA,KAAK,KAAK;MACnB,KAAK,IAAI,OAAA,KAAK,KAAK;;AAGrB,QAAa,QAAb,MAAkB;aAAA;;;MAKhB,YAAY,EAAC,UAAU,OAAM,IAAkB,CAAA,GAAE;AAJ9B,aAAA,SAA2C,CAAA;AAK5D,aAAK,YAAY;AACjB,aAAK,UAAU;MACjB;MAEA,OAAO,cAA2B;AAChC,eAAO,wBAAwB,OAAA,OAAO,eAAe,KAAK,KAAK,YAAY;MAC7E;MAEA,KAAK,QAAc;AACjB,eAAO,IAAI,OAAA,KAAK,KAAK,SAAS,MAAM,CAAC;MACvC;MAEU,SAAS,QAAc;AAC/B,cAAM,KAAK,KAAK,OAAO,MAAM,KAAK,KAAK,WAAW,MAAM;AACxD,eAAO,GAAG,MAAM,GAAG,GAAG,OAAO;MAC/B;MAEQ,WAAW,QAAc;;AAC/B,cAAI,MAAA,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE,eAAS,QAAA,OAAA,SAAA,SAAA,GAAE,IAAI,MAAM,MAAM,KAAK,aAAa,CAAC,KAAK,UAAU,IAAI,MAAM,GAAI;AAC3F,gBAAM,IAAI,MAAM,oBAAoB,MAAM,gCAAgC;;AAE5E,eAAQ,KAAK,OAAO,MAAM,IAAI,EAAC,QAAQ,OAAO,EAAC;MACjD;;AA5BF,IAAAA,SAAA,QAAA;AAoCA,QAAa,iBAAb,cAAoC,OAAA,KAAI;aAAA;;;MAKtC,YAAY,QAAgB,SAAe;AACzC,cAAM,OAAO;AACb,aAAK,SAAS;MAChB;MAEA,SAAS,OAAkB,EAAC,UAAU,UAAS,GAAY;AACzD,aAAK,QAAQ;AACb,aAAK,aAAY,GAAA,OAAA,MAAK,IAAI,OAAA,KAAK,QAAQ,CAAC,IAAI,SAAS;MACvD;;AAbF,IAAAA,SAAA,iBAAA;AAoBA,QAAM,QAAO,GAAA,OAAA;AAEb,QAAa,aAAb,cAAgC,MAAK;aAAA;;;MAKnC,YAAY,MAAuB;AACjC,cAAM,IAAI;AALO,aAAA,UAAuB,CAAA;AAMxC,aAAK,SAAS,KAAK;AACnB,aAAK,OAAO,EAAC,GAAG,MAAM,IAAI,KAAK,QAAQ,OAAO,OAAA,IAAG;MACnD;MAEA,MAAG;AACD,eAAO,KAAK;MACd;MAEA,KAAK,QAAc;AACjB,eAAO,IAAI,eAAe,QAAQ,KAAK,SAAS,MAAM,CAAC;MACzD;MAEA,MAAM,cAAuC,OAAgB;;AAC3D,YAAI,MAAM,QAAQ;AAAW,gBAAM,IAAI,MAAM,sCAAsC;AACnF,cAAM,OAAO,KAAK,OAAO,YAAY;AACrC,cAAM,EAAC,OAAM,IAAI;AACjB,cAAM,YAAW,KAAA,MAAM,SAAG,QAAA,OAAA,SAAA,KAAI,MAAM;AACpC,YAAI,KAAK,KAAK,QAAQ,MAAM;AAC5B,YAAI,IAAI;AACN,gBAAM,QAAQ,GAAG,IAAI,QAAQ;AAC7B,cAAI;AAAO,mBAAO;eACb;AACL,eAAK,KAAK,QAAQ,MAAM,IAAI,oBAAI,IAAG;;AAErC,WAAG,IAAI,UAAU,IAAI;AAErB,cAAM,IAAI,KAAK,OAAO,MAAM,MAAM,KAAK,OAAO,MAAM,IAAI,CAAA;AACxD,cAAM,YAAY,EAAE;AACpB,UAAE,SAAS,IAAI,MAAM;AACrB,aAAK,SAAS,OAAO,EAAC,UAAU,QAAQ,UAAS,CAAC;AAClD,eAAO;MACT;MAEA,SAAS,QAAgB,UAAiB;AACxC,cAAM,KAAK,KAAK,QAAQ,MAAM;AAC9B,YAAI,CAAC;AAAI;AACT,eAAO,GAAG,IAAI,QAAQ;MACxB;MAEA,UAAU,WAAiB,SAAuC,KAAK,SAAO;AAC5E,eAAO,KAAK,cAAc,QAAQ,CAAC,SAAwB;AACzD,cAAI,KAAK,cAAc;AAAW,kBAAM,IAAI,MAAM,kBAAkB,IAAI,gBAAgB;AACxF,kBAAO,GAAA,OAAA,KAAI,SAAS,GAAG,KAAK,SAAS;QACvC,CAAC;MACH;MAEA,UACE,SAAuC,KAAK,SAC5C,YACA,SAAiD;AAEjD,eAAO,KAAK,cACV,QACA,CAAC,SAAwB;AACvB,cAAI,KAAK,UAAU;AAAW,kBAAM,IAAI,MAAM,kBAAkB,IAAI,gBAAgB;AACpF,iBAAO,KAAK,MAAM;QACpB,GACA,YACA,OAAO;MAEX;MAEQ,cACN,QACA,WACA,aAA8B,CAAA,GAC9B,SAAiD;AAEjD,YAAI,OAAa,OAAA;AACjB,mBAAW,UAAU,QAAQ;AAC3B,gBAAM,KAAK,OAAO,MAAM;AACxB,cAAI,CAAC;AAAI;AACT,gBAAM,UAAW,WAAW,MAAM,IAAI,WAAW,MAAM,KAAK,oBAAI,IAAG;AACnE,aAAG,QAAQ,CAAC,SAAwB;AAClC,gBAAI,QAAQ,IAAI,IAAI;AAAG;AACvB,oBAAQ,IAAI,MAAM,eAAe,OAAO;AACxC,gBAAI,IAAI,UAAU,IAAI;AACtB,gBAAI,GAAG;AACL,oBAAM,MAAM,KAAK,KAAK,MAAMA,SAAA,SAAS,MAAMA,SAAA,SAAS;AACpD,sBAAO,GAAA,OAAA,KAAI,IAAI,GAAG,GAAG,IAAI,IAAI,MAAM,CAAC,IAAI,KAAK,KAAK,EAAE;uBAC1C,IAAI,YAAO,QAAP,YAAO,SAAA,SAAP,QAAU,IAAI,GAAI;AAChC,sBAAO,GAAA,OAAA,KAAI,IAAI,GAAG,CAAC,GAAG,KAAK,KAAK,EAAE;mBAC7B;AACL,oBAAM,IAAI,WAAW,IAAI;;AAE3B,oBAAQ,IAAI,MAAM,eAAe,SAAS;UAC5C,CAAC;;AAEH,eAAO;MACT;;AAhGF,IAAAA,SAAA,aAAA;;;;;;;;;;ACpHA,QAAA,SAAA;AACA,QAAA,UAAA;AAEA,QAAA,SAAA;AAAQ,WAAA,eAAAC,UAAA,KAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,OAAA;IAAC,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,OAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,OAAA;IAAG,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,aAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,OAAA;IAAS,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,OAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,OAAA;IAAG,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,eAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,OAAA;IAAW,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,aAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,OAAA;IAAS,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,cAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,OAAA;IAAU,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,QAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,OAAA;IAAI,EAAA,CAAA;AACxE,QAAA,UAAA;AAAQ,WAAA,eAAAA,UAAA,SAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,QAAA;IAAK,EAAA,CAAA;AAAc,WAAA,eAAAA,UAAA,cAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,QAAA;IAAU,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,kBAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,QAAA;IAAc,EAAA,CAAA;AAAkB,WAAA,eAAAA,UAAA,YAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,QAAA;IAAQ,EAAA,CAAA;AAQlE,IAAAA,SAAA,YAAY;MACvB,IAAI,IAAI,OAAA,MAAM,GAAG;MACjB,KAAK,IAAI,OAAA,MAAM,IAAI;MACnB,IAAI,IAAI,OAAA,MAAM,GAAG;MACjB,KAAK,IAAI,OAAA,MAAM,IAAI;MACnB,IAAI,IAAI,OAAA,MAAM,KAAK;MACnB,KAAK,IAAI,OAAA,MAAM,KAAK;MACpB,KAAK,IAAI,OAAA,MAAM,GAAG;MAClB,IAAI,IAAI,OAAA,MAAM,IAAI;MAClB,KAAK,IAAI,OAAA,MAAM,IAAI;MACnB,KAAK,IAAI,OAAA,MAAM,GAAG;;AAGpB,QAAe,OAAf,MAAmB;aAAA;;;MAGjB,gBAAa;AACX,eAAO;MACT;MAEA,cAAc,QAAmB,YAAqB;AACpD,eAAO;MACT;;AAOF,QAAM,MAAN,cAAkB,KAAI;aAAA;;;MACpB,YAA6B,SAAgC,MAAoB,KAAc;AAC7F,cAAK;AADsB,aAAA,UAAA;AAAgC,aAAA,OAAA;AAAoB,aAAA,MAAA;MAEjF;MAEA,OAAO,EAAC,KAAK,GAAE,GAAY;AACzB,cAAM,UAAU,MAAM,QAAA,SAAS,MAAM,KAAK;AAC1C,cAAM,MAAM,KAAK,QAAQ,SAAY,KAAK,MAAM,KAAK,GAAG;AACxD,eAAO,GAAG,OAAO,IAAI,KAAK,IAAI,GAAG,GAAG,MAAM;MAC5C;MAEA,cAAc,OAAkB,WAAoB;AAClD,YAAI,CAAC,MAAM,KAAK,KAAK,GAAG;AAAG;AAC3B,YAAI,KAAK;AAAK,eAAK,MAAM,aAAa,KAAK,KAAK,OAAO,SAAS;AAChE,eAAO;MACT;MAEA,IAAI,QAAK;AACP,eAAO,KAAK,eAAe,OAAA,cAAc,KAAK,IAAI,QAAQ,CAAA;MAC5D;;AAGF,QAAM,SAAN,cAAqB,KAAI;aAAA;;;MACvB,YAAqB,KAAkB,KAAgC,aAAqB;AAC1F,cAAK;AADc,aAAA,MAAA;AAAkB,aAAA,MAAA;AAAgC,aAAA,cAAA;MAEvE;MAEA,OAAO,EAAC,GAAE,GAAY;AACpB,eAAO,GAAG,KAAK,GAAG,MAAM,KAAK,GAAG,MAAM;MACxC;MAEA,cAAc,OAAkB,WAAoB;AAClD,YAAI,KAAK,eAAe,OAAA,QAAQ,CAAC,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,KAAK;AAAa;AAC3E,aAAK,MAAM,aAAa,KAAK,KAAK,OAAO,SAAS;AAClD,eAAO;MACT;MAEA,IAAI,QAAK;AACP,cAAM,QAAQ,KAAK,eAAe,OAAA,OAAO,CAAA,IAAK,EAAC,GAAG,KAAK,IAAI,MAAK;AAChE,eAAO,aAAa,OAAO,KAAK,GAAG;MACrC;;AAGF,QAAM,WAAN,cAAuB,OAAM;aAAA;;;MAC3B,YAAY,KAA4B,IAAU,KAAe,aAAqB;AACpF,cAAM,KAAK,KAAK,WAAW;AADW,aAAA,KAAA;MAExC;MAEA,OAAO,EAAC,GAAE,GAAY;AACpB,eAAO,GAAG,KAAK,GAAG,IAAI,KAAK,EAAE,KAAK,KAAK,GAAG,MAAM;MAClD;;AAGF,QAAM,QAAN,cAAoB,KAAI;aAAA;;;MAEtB,YAAqB,OAAW;AAC9B,cAAK;AADc,aAAA,QAAA;AADZ,aAAA,QAAmB,CAAA;MAG5B;MAEA,OAAO,EAAC,GAAE,GAAY;AACpB,eAAO,GAAG,KAAK,KAAK,MAAM;MAC5B;;AAGF,QAAM,QAAN,cAAoB,KAAI;aAAA;;;MAEtB,YAAqB,OAAY;AAC/B,cAAK;AADc,aAAA,QAAA;AADZ,aAAA,QAAmB,CAAA;MAG5B;MAEA,OAAO,EAAC,GAAE,GAAY;AACpB,cAAM,QAAQ,KAAK,QAAQ,IAAI,KAAK,KAAK,KAAK;AAC9C,eAAO,QAAQ,KAAK,MAAM;MAC5B;;AAGF,QAAM,QAAN,cAAoB,KAAI;aAAA;;;MACtB,YAAqB,OAAW;AAC9B,cAAK;AADc,aAAA,QAAA;MAErB;MAEA,OAAO,EAAC,GAAE,GAAY;AACpB,eAAO,SAAS,KAAK,KAAK,MAAM;MAClC;MAEA,IAAI,QAAK;AACP,eAAO,KAAK,MAAM;MACpB;;AAGF,QAAM,UAAN,cAAsB,KAAI;aAAA;;;MACxB,YAAoB,MAAc;AAChC,cAAK;AADa,aAAA,OAAA;MAEpB;MAEA,OAAO,EAAC,GAAE,GAAY;AACpB,eAAO,GAAG,KAAK,IAAI,MAAM;MAC3B;MAEA,gBAAa;AACX,eAAO,GAAG,KAAK,IAAI,KAAK,OAAO;MACjC;MAEA,cAAc,OAAkB,WAAoB;AAClD,aAAK,OAAO,aAAa,KAAK,MAAM,OAAO,SAAS;AACpD,eAAO;MACT;MAEA,IAAI,QAAK;AACP,eAAO,KAAK,gBAAgB,OAAA,cAAc,KAAK,KAAK,QAAQ,CAAA;MAC9D;;AAGF,QAAe,aAAf,cAAkC,KAAI;aAAA;;;MACpC,YAAqB,QAAqB,CAAA,GAAE;AAC1C,cAAK;AADc,aAAA,QAAA;MAErB;MAEA,OAAO,MAAe;AACpB,eAAO,KAAK,MAAM,OAAO,CAAC,MAAM,MAAM,OAAO,EAAE,OAAO,IAAI,GAAG,EAAE;MACjE;MAEA,gBAAa;AACX,cAAM,EAAC,MAAK,IAAI;AAChB,YAAI,IAAI,MAAM;AACd,eAAO,KAAK;AACV,gBAAM,IAAI,MAAM,CAAC,EAAE,cAAa;AAChC,cAAI,MAAM,QAAQ,CAAC;AAAG,kBAAM,OAAO,GAAG,GAAG,GAAG,CAAC;mBACpC;AAAG,kBAAM,CAAC,IAAI;;AAClB,kBAAM,OAAO,GAAG,CAAC;;AAExB,eAAO,MAAM,SAAS,IAAI,OAAO;MACnC;MAEA,cAAc,OAAkB,WAAoB;AAClD,cAAM,EAAC,MAAK,IAAI;AAChB,YAAI,IAAI,MAAM;AACd,eAAO,KAAK;AAEV,gBAAM,IAAI,MAAM,CAAC;AACjB,cAAI,EAAE,cAAc,OAAO,SAAS;AAAG;AACvC,wBAAc,OAAO,EAAE,KAAK;AAC5B,gBAAM,OAAO,GAAG,CAAC;;AAEnB,eAAO,MAAM,SAAS,IAAI,OAAO;MACnC;MAEA,IAAI,QAAK;AACP,eAAO,KAAK,MAAM,OAAO,CAAC,OAAkB,MAAM,SAAS,OAAO,EAAE,KAAK,GAAG,CAAA,CAAE;MAChF;;AAOF,QAAe,YAAf,cAAiC,WAAU;aAAA;;;MACzC,OAAO,MAAe;AACpB,eAAO,MAAM,KAAK,KAAK,MAAM,OAAO,IAAI,IAAI,MAAM,KAAK;MACzD;;AAGF,QAAM,OAAN,cAAmB,WAAU;aAAA;;;;AAE7B,QAAM,OAAN,cAAmB,UAAS;aAAA;;;;AACV,SAAA,OAAO;AAGzB,QAAM,KAAN,MAAM,YAAW,UAAS;aAAA;;;MAGxB,YAAoB,WAA2B,OAAmB;AAChE,cAAM,KAAK;AADO,aAAA,YAAA;MAEpB;MAEA,OAAO,MAAe;AACpB,YAAI,OAAO,MAAM,KAAK,SAAS,MAAM,MAAM,OAAO,IAAI;AACtD,YAAI,KAAK;AAAM,kBAAQ,UAAU,KAAK,KAAK,OAAO,IAAI;AACtD,eAAO;MACT;MAEA,gBAAa;AACX,cAAM,cAAa;AACnB,cAAM,OAAO,KAAK;AAClB,YAAI,SAAS;AAAM,iBAAO,KAAK;AAC/B,YAAI,IAAI,KAAK;AACb,YAAI,GAAG;AACL,gBAAM,KAAK,EAAE,cAAa;AAC1B,cAAI,KAAK,OAAO,MAAM,QAAQ,EAAE,IAAI,IAAI,KAAK,EAAE,IAAK;;AAEtD,YAAI,GAAG;AACL,cAAI,SAAS;AAAO,mBAAO,aAAa,MAAK,IAAI,EAAE;AACnD,cAAI,KAAK,MAAM;AAAQ,mBAAO;AAC9B,iBAAO,IAAI,IAAG,IAAI,IAAI,GAAG,aAAa,MAAK,CAAC,CAAC,IAAI,EAAE,KAAK;;AAE1D,YAAI,SAAS,SAAS,CAAC,KAAK,MAAM;AAAQ,iBAAO;AACjD,eAAO;MACT;MAEA,cAAc,OAAkB,WAAoB;;AAClD,aAAK,QAAO,KAAA,KAAK,UAAI,QAAA,OAAA,SAAA,SAAA,GAAE,cAAc,OAAO,SAAS;AACrD,YAAI,EAAE,MAAM,cAAc,OAAO,SAAS,KAAK,KAAK;AAAO;AAC3D,aAAK,YAAY,aAAa,KAAK,WAAW,OAAO,SAAS;AAC9D,eAAO;MACT;MAEA,IAAI,QAAK;AACP,cAAM,QAAQ,MAAM;AACpB,qBAAa,OAAO,KAAK,SAAS;AAClC,YAAI,KAAK;AAAM,mBAAS,OAAO,KAAK,KAAK,KAAK;AAC9C,eAAO;MACT;;AA1CgB,OAAA,OAAO;AAiDzB,QAAe,MAAf,cAA2B,UAAS;aAAA;;;;AAClB,QAAA,OAAO;AAGzB,QAAM,UAAN,cAAsB,IAAG;aAAA;;;MACvB,YAAoB,WAAe;AACjC,cAAK;AADa,aAAA,YAAA;MAEpB;MAEA,OAAO,MAAe;AACpB,eAAO,OAAO,KAAK,SAAS,MAAM,MAAM,OAAO,IAAI;MACrD;MAEA,cAAc,OAAkB,WAAoB;AAClD,YAAI,CAAC,MAAM,cAAc,OAAO,SAAS;AAAG;AAC5C,aAAK,YAAY,aAAa,KAAK,WAAW,OAAO,SAAS;AAC9D,eAAO;MACT;MAEA,IAAI,QAAK;AACP,eAAO,SAAS,MAAM,OAAO,KAAK,UAAU,KAAK;MACnD;;AAGF,QAAM,WAAN,cAAuB,IAAG;aAAA;;;MACxB,YACmB,SACA,MACA,MACA,IAAY;AAE7B,cAAK;AALY,aAAA,UAAA;AACA,aAAA,OAAA;AACA,aAAA,OAAA;AACA,aAAA,KAAA;MAGnB;MAEA,OAAO,MAAe;AACpB,cAAM,UAAU,KAAK,MAAM,QAAA,SAAS,MAAM,KAAK;AAC/C,cAAM,EAAC,MAAM,MAAM,GAAE,IAAI;AACzB,eAAO,OAAO,OAAO,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE,KAAK,IAAI,QAAQ,MAAM,OAAO,IAAI;MACxF;MAEA,IAAI,QAAK;AACP,cAAM,QAAQ,aAAa,MAAM,OAAO,KAAK,IAAI;AACjD,eAAO,aAAa,OAAO,KAAK,EAAE;MACpC;;AAGF,QAAM,UAAN,cAAsB,IAAG;aAAA;;;MACvB,YACmB,MACA,SACA,MACT,UAAc;AAEtB,cAAK;AALY,aAAA,OAAA;AACA,aAAA,UAAA;AACA,aAAA,OAAA;AACT,aAAA,WAAA;MAGV;MAEA,OAAO,MAAe;AACpB,eAAO,OAAO,KAAK,OAAO,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI,KAAK,QAAQ,MAAM,MAAM,OAAO,IAAI;MAC9F;MAEA,cAAc,OAAkB,WAAoB;AAClD,YAAI,CAAC,MAAM,cAAc,OAAO,SAAS;AAAG;AAC5C,aAAK,WAAW,aAAa,KAAK,UAAU,OAAO,SAAS;AAC5D,eAAO;MACT;MAEA,IAAI,QAAK;AACP,eAAO,SAAS,MAAM,OAAO,KAAK,SAAS,KAAK;MAClD;;AAGF,QAAM,OAAN,cAAmB,UAAS;aAAA;;;MAE1B,YAAmB,MAAmB,MAAmB,OAAe;AACtE,cAAK;AADY,aAAA,OAAA;AAAmB,aAAA,OAAA;AAAmB,aAAA,QAAA;MAEzD;MAEA,OAAO,MAAe;AACpB,cAAM,SAAS,KAAK,QAAQ,WAAW;AACvC,eAAO,GAAG,MAAM,YAAY,KAAK,IAAI,IAAI,KAAK,IAAI,MAAM,MAAM,OAAO,IAAI;MAC3E;;AARgB,SAAA,OAAO;AAWzB,QAAM,SAAN,cAAqB,WAAU;aAAA;;;MAG7B,OAAO,MAAe;AACpB,eAAO,YAAY,MAAM,OAAO,IAAI;MACtC;;AAJgB,WAAA,OAAO;AAOzB,QAAM,MAAN,cAAkB,UAAS;aAAA;;;MAIzB,OAAO,MAAe;AACpB,YAAI,OAAO,QAAQ,MAAM,OAAO,IAAI;AACpC,YAAI,KAAK;AAAO,kBAAQ,KAAK,MAAM,OAAO,IAAI;AAC9C,YAAI,KAAK;AAAS,kBAAQ,KAAK,QAAQ,OAAO,IAAI;AAClD,eAAO;MACT;MAEA,gBAAa;;AACX,cAAM,cAAa;AACnB,SAAA,KAAA,KAAK,WAAK,QAAA,OAAA,SAAA,SAAA,GAAE,cAAa;AACzB,SAAA,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE,cAAa;AAC3B,eAAO;MACT;MAEA,cAAc,OAAkB,WAAoB;;AAClD,cAAM,cAAc,OAAO,SAAS;AACpC,SAAA,KAAA,KAAK,WAAK,QAAA,OAAA,SAAA,SAAA,GAAE,cAAc,OAAO,SAAS;AAC1C,SAAA,KAAA,KAAK,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE,cAAc,OAAO,SAAS;AAC5C,eAAO;MACT;MAEA,IAAI,QAAK;AACP,cAAM,QAAQ,MAAM;AACpB,YAAI,KAAK;AAAO,mBAAS,OAAO,KAAK,MAAM,KAAK;AAChD,YAAI,KAAK;AAAS,mBAAS,OAAO,KAAK,QAAQ,KAAK;AACpD,eAAO;MACT;;AAOF,QAAM,QAAN,cAAoB,UAAS;aAAA;;;MAE3B,YAAqB,OAAW;AAC9B,cAAK;AADc,aAAA,QAAA;MAErB;MAEA,OAAO,MAAe;AACpB,eAAO,SAAS,KAAK,KAAK,MAAM,MAAM,OAAO,IAAI;MACnD;;AAPgB,UAAA,OAAO;AAUzB,QAAM,UAAN,cAAsB,UAAS;aAAA;;;MAE7B,OAAO,MAAe;AACpB,eAAO,YAAY,MAAM,OAAO,IAAI;MACtC;;AAHgB,YAAA,OAAO;AAiCzB,QAAa,UAAb,MAAoB;aAAA;;;MASlB,YAAY,UAAsB,OAAuB,CAAA,GAAE;AANlD,aAAA,UAA0B,CAAA;AAElB,aAAA,eAAyB,CAAA;AACzB,aAAA,aAAwB,CAAA;AAIvC,aAAK,OAAO,EAAC,GAAG,MAAM,IAAI,KAAK,QAAQ,OAAO,GAAE;AAChD,aAAK,YAAY;AACjB,aAAK,SAAS,IAAI,QAAA,MAAM,EAAC,QAAQ,SAAQ,CAAC;AAC1C,aAAK,SAAS,CAAC,IAAI,KAAI,CAAE;MAC3B;MAEA,WAAQ;AACN,eAAO,KAAK,MAAM,OAAO,KAAK,IAAI;MACpC;;MAGA,KAAK,QAAc;AACjB,eAAO,KAAK,OAAO,KAAK,MAAM;MAChC;;MAGA,UAAU,QAAc;AACtB,eAAO,KAAK,UAAU,KAAK,MAAM;MACnC;;MAGA,WAAW,cAAuC,OAAgB;AAChE,cAAM,OAAO,KAAK,UAAU,MAAM,cAAc,KAAK;AACrD,cAAM,KAAK,KAAK,QAAQ,KAAK,MAAM,MAAM,KAAK,QAAQ,KAAK,MAAM,IAAI,oBAAI,IAAG;AAC5E,WAAG,IAAI,IAAI;AACX,eAAO;MACT;MAEA,cAAc,QAAgB,UAAiB;AAC7C,eAAO,KAAK,UAAU,SAAS,QAAQ,QAAQ;MACjD;;;MAIA,UAAU,WAAe;AACvB,eAAO,KAAK,UAAU,UAAU,WAAW,KAAK,OAAO;MACzD;MAEA,YAAS;AACP,eAAO,KAAK,UAAU,UAAU,KAAK,OAAO;MAC9C;MAEQ,KACN,SACA,cACA,KACA,UAAkB;AAElB,cAAM,OAAO,KAAK,OAAO,OAAO,YAAY;AAC5C,YAAI,QAAQ,UAAa;AAAU,eAAK,WAAW,KAAK,GAAG,IAAI;AAC/D,aAAK,UAAU,IAAI,IAAI,SAAS,MAAM,GAAG,CAAC;AAC1C,eAAO;MACT;;MAGA,MAAM,cAA6B,KAAe,WAAmB;AACnE,eAAO,KAAK,KAAK,QAAA,SAAS,OAAO,cAAc,KAAK,SAAS;MAC/D;;MAGA,IAAI,cAA6B,KAAgB,WAAmB;AAClE,eAAO,KAAK,KAAK,QAAA,SAAS,KAAK,cAAc,KAAK,SAAS;MAC7D;;MAGA,IAAI,cAA6B,KAAgB,WAAmB;AAClE,eAAO,KAAK,KAAK,QAAA,SAAS,KAAK,cAAc,KAAK,SAAS;MAC7D;;MAGA,OAAO,KAAW,KAAe,aAAqB;AACpD,eAAO,KAAK,UAAU,IAAI,OAAO,KAAK,KAAK,WAAW,CAAC;MACzD;;MAGA,IAAI,KAAW,KAAa;AAC1B,eAAO,KAAK,UAAU,IAAI,SAAS,KAAKA,SAAA,UAAU,KAAK,GAAG,CAAC;MAC7D;;MAGA,KAAK,GAAmB;AACtB,YAAI,OAAO,KAAK;AAAY,YAAC;iBACpB,MAAM,OAAA;AAAK,eAAK,UAAU,IAAI,QAAQ,CAAC,CAAC;AACjD,eAAO;MACT;;MAGA,UAAU,WAA+C;AACvD,cAAM,OAAmB,CAAC,GAAG;AAC7B,mBAAW,CAAC,KAAK,KAAK,KAAK,WAAW;AACpC,cAAI,KAAK,SAAS;AAAG,iBAAK,KAAK,GAAG;AAClC,eAAK,KAAK,GAAG;AACb,cAAI,QAAQ,SAAS,KAAK,KAAK,KAAK;AAClC,iBAAK,KAAK,GAAG;AACb,aAAA,GAAA,OAAA,YAAW,MAAM,KAAK;;;AAG1B,aAAK,KAAK,GAAG;AACb,eAAO,IAAI,OAAA,MAAM,IAAI;MACvB;;MAGA,GAAG,WAA2B,UAAkB,UAAgB;AAC9D,aAAK,WAAW,IAAI,GAAG,SAAS,CAAC;AAEjC,YAAI,YAAY,UAAU;AACxB,eAAK,KAAK,QAAQ,EAAE,KAAI,EAAG,KAAK,QAAQ,EAAE,MAAK;mBACtC,UAAU;AACnB,eAAK,KAAK,QAAQ,EAAE,MAAK;mBAChB,UAAU;AACnB,gBAAM,IAAI,MAAM,0CAA0C;;AAE5D,eAAO;MACT;;MAGA,OAAO,WAAyB;AAC9B,eAAO,KAAK,UAAU,IAAI,GAAG,SAAS,CAAC;MACzC;;MAGA,OAAI;AACF,eAAO,KAAK,UAAU,IAAI,KAAI,CAAE;MAClC;;MAGA,QAAK;AACH,eAAO,KAAK,cAAc,IAAI,IAAI;MACpC;MAEQ,KAAK,MAAW,SAAe;AACrC,aAAK,WAAW,IAAI;AACpB,YAAI;AAAS,eAAK,KAAK,OAAO,EAAE,OAAM;AACtC,eAAO;MACT;;MAGA,IAAI,WAAiB,SAAe;AAClC,eAAO,KAAK,KAAK,IAAI,QAAQ,SAAS,GAAG,OAAO;MAClD;;MAGA,SACE,cACA,MACA,IACA,SACA,UAAgB,KAAK,KAAK,MAAM,QAAA,SAAS,MAAM,QAAA,SAAS,KAAG;AAE3D,cAAM,OAAO,KAAK,OAAO,OAAO,YAAY;AAC5C,eAAO,KAAK,KAAK,IAAI,SAAS,SAAS,MAAM,MAAM,EAAE,GAAG,MAAM,QAAQ,IAAI,CAAC;MAC7E;;MAGA,MACE,cACA,UACA,SACA,UAAgB,QAAA,SAAS,OAAK;AAE9B,cAAM,OAAO,KAAK,OAAO,OAAO,YAAY;AAC5C,YAAI,KAAK,KAAK,KAAK;AACjB,gBAAM,MAAM,oBAAoB,OAAA,OAAO,WAAW,KAAK,IAAI,QAAQ,QAAQ;AAC3E,iBAAO,KAAK,SAAS,MAAM,IAAG,GAAA,OAAA,KAAI,GAAG,WAAW,CAAC,MAAK;AACpD,iBAAK,IAAI,OAAM,GAAA,OAAA,KAAI,GAAG,IAAI,CAAC,GAAG;AAC9B,oBAAQ,IAAI;UACd,CAAC;;AAEH,eAAO,KAAK,KAAK,IAAI,QAAQ,MAAM,SAAS,MAAM,QAAQ,GAAG,MAAM,QAAQ,IAAI,CAAC;MAClF;;;MAIA,MACE,cACA,KACA,SACA,UAAgB,KAAK,KAAK,MAAM,QAAA,SAAS,MAAM,QAAA,SAAS,OAAK;AAE7D,YAAI,KAAK,KAAK,eAAe;AAC3B,iBAAO,KAAK,MAAM,eAAc,GAAA,OAAA,iBAAgB,GAAG,KAAK,OAAO;;AAEjE,cAAM,OAAO,KAAK,OAAO,OAAO,YAAY;AAC5C,eAAO,KAAK,KAAK,IAAI,QAAQ,MAAM,SAAS,MAAM,GAAG,GAAG,MAAM,QAAQ,IAAI,CAAC;MAC7E;;MAGA,SAAM;AACJ,eAAO,KAAK,cAAc,GAAG;MAC/B;;MAGA,MAAM,OAAW;AACf,eAAO,KAAK,UAAU,IAAI,MAAM,KAAK,CAAC;MACxC;;MAGA,MAAM,OAAY;AAChB,eAAO,KAAK,UAAU,IAAI,MAAM,KAAK,CAAC;MACxC;;MAGA,OAAO,OAAuB;AAC5B,cAAM,OAAO,IAAI,OAAM;AACvB,aAAK,WAAW,IAAI;AACpB,aAAK,KAAK,KAAK;AACf,YAAI,KAAK,MAAM,WAAW;AAAG,gBAAM,IAAI,MAAM,wCAAwC;AACrF,eAAO,KAAK,cAAc,MAAM;MAClC;;MAGA,IAAI,SAAgB,WAA+B,aAAmB;AACpE,YAAI,CAAC,aAAa,CAAC;AAAa,gBAAM,IAAI,MAAM,8CAA8C;AAC9F,cAAM,OAAO,IAAI,IAAG;AACpB,aAAK,WAAW,IAAI;AACpB,aAAK,KAAK,OAAO;AACjB,YAAI,WAAW;AACb,gBAAM,QAAQ,KAAK,KAAK,GAAG;AAC3B,eAAK,YAAY,KAAK,QAAQ,IAAI,MAAM,KAAK;AAC7C,oBAAU,KAAK;;AAEjB,YAAI,aAAa;AACf,eAAK,YAAY,KAAK,UAAU,IAAI,QAAO;AAC3C,eAAK,KAAK,WAAW;;AAEvB,eAAO,KAAK,cAAc,OAAO,OAAO;MAC1C;;MAGA,MAAM,OAAW;AACf,eAAO,KAAK,UAAU,IAAI,MAAM,KAAK,CAAC;MACxC;;MAGA,MAAM,MAAc,WAAkB;AACpC,aAAK,aAAa,KAAK,KAAK,OAAO,MAAM;AACzC,YAAI;AAAM,eAAK,KAAK,IAAI,EAAE,SAAS,SAAS;AAC5C,eAAO;MACT;;MAGA,SAAS,WAAkB;AACzB,cAAM,MAAM,KAAK,aAAa,IAAG;AACjC,YAAI,QAAQ;AAAW,gBAAM,IAAI,MAAM,sCAAsC;AAC7E,cAAM,UAAU,KAAK,OAAO,SAAS;AACrC,YAAI,UAAU,KAAM,cAAc,UAAa,YAAY,WAAY;AACrE,gBAAM,IAAI,MAAM,mCAAmC,OAAO,OAAO,SAAS,WAAW;;AAEvF,aAAK,OAAO,SAAS;AACrB,eAAO;MACT;;MAGA,KAAK,MAAY,OAAa,OAAA,KAAK,OAAiB,UAAgB;AAClE,aAAK,WAAW,IAAI,KAAK,MAAM,MAAM,KAAK,CAAC;AAC3C,YAAI;AAAU,eAAK,KAAK,QAAQ,EAAE,QAAO;AACzC,eAAO;MACT;;MAGA,UAAO;AACL,eAAO,KAAK,cAAc,IAAI;MAChC;MAEA,SAAS,IAAI,GAAC;AACZ,eAAO,MAAM,GAAG;AACd,eAAK,MAAM,cAAa;AACxB,eAAK,MAAM,cAAc,KAAK,MAAM,OAAO,KAAK,UAAU;;MAE9D;MAEQ,UAAU,MAAc;AAC9B,aAAK,UAAU,MAAM,KAAK,IAAI;AAC9B,eAAO;MACT;MAEQ,WAAW,MAAoB;AACrC,aAAK,UAAU,MAAM,KAAK,IAAI;AAC9B,aAAK,OAAO,KAAK,IAAI;MACvB;MAEQ,cAAc,IAAsB,IAAqB;AAC/D,cAAM,IAAI,KAAK;AACf,YAAI,aAAa,MAAO,MAAM,aAAa,IAAK;AAC9C,eAAK,OAAO,IAAG;AACf,iBAAO;;AAET,cAAM,IAAI,MAAM,0BAA0B,KAAK,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,KAAK,GAAG,IAAI,GAAG;MACrF;MAEQ,UAAU,MAAe;AAC/B,cAAM,IAAI,KAAK;AACf,YAAI,EAAE,aAAa,KAAK;AACtB,gBAAM,IAAI,MAAM,8BAA8B;;AAEhD,aAAK,YAAY,EAAE,OAAO;AAC1B,eAAO;MACT;MAEA,IAAY,QAAK;AACf,eAAO,KAAK,OAAO,CAAC;MACtB;MAEA,IAAY,YAAS;AACnB,cAAM,KAAK,KAAK;AAChB,eAAO,GAAG,GAAG,SAAS,CAAC;MACzB;MAEA,IAAY,UAAU,MAAgB;AACpC,cAAM,KAAK,KAAK;AAChB,WAAG,GAAG,SAAS,CAAC,IAAI;MACtB;;AAjUF,IAAAA,SAAA,UAAA;AAwUA,aAAS,SAAS,OAAkB,MAAe;AACjD,iBAAW,KAAK;AAAM,cAAM,CAAC,KAAK,MAAM,CAAC,KAAK,MAAM,KAAK,CAAC,KAAK;AAC/D,aAAO;IACT;AAHS;AAKT,aAAS,aAAa,OAAkB,MAAc;AACpD,aAAO,gBAAgB,OAAA,cAAc,SAAS,OAAO,KAAK,KAAK,IAAI;IACrE;AAFS;AAKT,aAAS,aAAa,MAAgB,OAAkB,WAAoB;AAC1E,UAAI,gBAAgB,OAAA;AAAM,eAAO,YAAY,IAAI;AACjD,UAAI,CAAC,YAAY,IAAI;AAAG,eAAO;AAC/B,aAAO,IAAI,OAAA,MACT,KAAK,OAAO,OAAO,CAAC,OAAmB,MAAwB;AAC7D,YAAI,aAAa,OAAA;AAAM,cAAI,YAAY,CAAC;AACxC,YAAI,aAAa,OAAA;AAAO,gBAAM,KAAK,GAAG,EAAE,MAAM;;AACzC,gBAAM,KAAK,CAAC;AACjB,eAAO;MACT,GAAG,CAAA,CAAE,CAAC;AAGR,eAAS,YAAY,GAAO;AAC1B,cAAM,IAAI,UAAU,EAAE,GAAG;AACzB,YAAI,MAAM,UAAa,MAAM,EAAE,GAAG,MAAM;AAAG,iBAAO;AAClD,eAAO,MAAM,EAAE,GAAG;AAClB,eAAO;MACT;AALS;AAOT,eAAS,YAAY,GAAW;AAC9B,eACE,aAAa,OAAA,SACb,EAAE,OAAO,KACP,CAAC,MAAM,aAAa,OAAA,QAAQ,MAAM,EAAE,GAAG,MAAM,KAAK,UAAU,EAAE,GAAG,MAAM,MAAS;MAGtF;AAPS;IAQX;AA3BS;AA6BT,aAAS,cAAc,OAAkB,MAAe;AACtD,iBAAW,KAAK;AAAM,cAAM,CAAC,KAAK,MAAM,CAAC,KAAK,MAAM,KAAK,CAAC,KAAK;IACjE;AAFS;AAKT,aAAgB,IAAI,GAAkB;AACpC,aAAO,OAAO,KAAK,aAAa,OAAO,KAAK,YAAY,MAAM,OAAO,CAAC,KAAI,GAAA,OAAA,MAAK,IAAI,CAAC,CAAC;IACvF;AAFgB;AAAhB,IAAAA,SAAA,MAAA;AAIA,QAAM,UAAU,QAAQA,SAAA,UAAU,GAAG;AAGrC,aAAgB,OAAO,MAAY;AACjC,aAAO,KAAK,OAAO,OAAO;IAC5B;AAFgB;AAAhB,IAAAA,SAAA,MAAA;AAIA,QAAM,SAAS,QAAQA,SAAA,UAAU,EAAE;AAGnC,aAAgB,MAAM,MAAY;AAChC,aAAO,KAAK,OAAO,MAAM;IAC3B;AAFgB;AAAhB,IAAAA,SAAA,KAAA;AAMA,aAAS,QAAQ,IAAQ;AACvB,aAAO,CAAC,GAAG,MAAO,MAAM,OAAA,MAAM,IAAI,MAAM,OAAA,MAAM,KAAI,GAAA,OAAA,KAAI,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,IAAI,CAAC,CAAC;IAC9E;AAFS;AAIT,aAAS,IAAI,GAAO;AAClB,aAAO,aAAa,OAAA,OAAO,KAAI,GAAA,OAAA,MAAK,CAAC;IACvC;AAFS;;;;;;;;;;AC3zBT,QAAA,YAAA;AACA,QAAA,SAAA;AAIA,aAAgB,OAAkC,KAAQ;AACxD,YAAM,OAA0B,CAAA;AAChC,iBAAW,QAAQ;AAAK,aAAK,IAAI,IAAI;AACrC,aAAO;IACT;AAJgB;AAAhB,IAAAC,SAAA,SAAA;AAMA,aAAgB,kBAAkB,IAAe,QAAiB;AAChE,UAAI,OAAO,UAAU;AAAW,eAAO;AACvC,UAAI,OAAO,KAAK,MAAM,EAAE,WAAW;AAAG,eAAO;AAC7C,wBAAkB,IAAI,MAAM;AAC5B,aAAO,CAAC,eAAe,QAAQ,GAAG,KAAK,MAAM,GAAG;IAClD;AALgB;AAAhB,IAAAA,SAAA,oBAAA;AAOA,aAAgB,kBAAkB,IAAe,SAAoB,GAAG,QAAM;AAC5E,YAAM,EAAC,MAAM,KAAI,IAAI;AACrB,UAAI,CAAC,KAAK;AAAc;AACxB,UAAI,OAAO,WAAW;AAAW;AACjC,YAAM,QAAQ,KAAK,MAAM;AACzB,iBAAW,OAAO,QAAQ;AACxB,YAAI,CAAC,MAAM,GAAG;AAAG,0BAAgB,IAAI,qBAAqB,GAAG,GAAG;;IAEpE;AARgB;AAAhB,IAAAA,SAAA,oBAAA;AAUA,aAAgB,eACd,QACA,OAAyC;AAEzC,UAAI,OAAO,UAAU;AAAW,eAAO,CAAC;AACxC,iBAAW,OAAO;AAAQ,YAAI,MAAM,GAAG;AAAG,iBAAO;AACjD,aAAO;IACT;AAPgB;AAAhB,IAAAA,SAAA,iBAAA;AASA,aAAgB,qBAAqB,QAAmB,OAAsB;AAC5E,UAAI,OAAO,UAAU;AAAW,eAAO,CAAC;AACxC,iBAAW,OAAO;AAAQ,YAAI,QAAQ,UAAU,MAAM,IAAI,GAAG;AAAG,iBAAO;AACvE,aAAO;IACT;AAJgB;AAAhB,IAAAA,SAAA,uBAAA;AAMA,aAAgB,eACd,EAAC,cAAc,WAAU,GACzB,QACA,SACA,OAAsB;AAEtB,UAAI,CAAC,OAAO;AACV,YAAI,OAAO,UAAU,YAAY,OAAO,UAAU;AAAW,iBAAO;AACpE,YAAI,OAAO,UAAU;AAAU,kBAAO,GAAA,UAAA,KAAI,MAAM;;AAElD,cAAO,GAAA,UAAA,KAAI,YAAY,GAAG,UAAU,IAAG,GAAA,UAAA,aAAY,OAAO,CAAC;IAC7D;AAXgB;AAAhB,IAAAA,SAAA,iBAAA;AAaA,aAAgB,iBAAiB,KAAW;AAC1C,aAAO,oBAAoB,mBAAmB,GAAG,CAAC;IACpD;AAFgB;AAAhB,IAAAA,SAAA,mBAAA;AAIA,aAAgB,eAAe,KAAoB;AACjD,aAAO,mBAAmB,kBAAkB,GAAG,CAAC;IAClD;AAFgB;AAAhB,IAAAA,SAAA,iBAAA;AAIA,aAAgB,kBAAkB,KAAoB;AACpD,UAAI,OAAO,OAAO;AAAU,eAAO,GAAG,GAAG;AACzC,aAAO,IAAI,QAAQ,MAAM,IAAI,EAAE,QAAQ,OAAO,IAAI;IACpD;AAHgB;AAAhB,IAAAA,SAAA,oBAAA;AAKA,aAAgB,oBAAoB,KAAW;AAC7C,aAAO,IAAI,QAAQ,OAAO,GAAG,EAAE,QAAQ,OAAO,GAAG;IACnD;AAFgB;AAAhB,IAAAA,SAAA,sBAAA;AAIA,aAAgB,SAAY,IAAa,GAAiB;AACxD,UAAI,MAAM,QAAQ,EAAE,GAAG;AACrB,mBAAW,KAAK;AAAI,YAAE,CAAC;aAClB;AACL,UAAE,EAAE;;IAER;AANgB;AAAhB,IAAAA,SAAA,WAAA;AAwBA,aAAS,mBAA4C,EACnD,YACA,aACA,aACA,aAAY,GACS;AACrB,aAAO,CAAC,KAAK,MAAM,IAAI,WAAU;AAC/B,cAAM,MACJ,OAAO,SACH,OACA,cAAc,UAAA,QACb,gBAAgB,UAAA,OAAO,WAAW,KAAK,MAAM,EAAE,IAAI,YAAY,KAAK,MAAM,EAAE,GAAG,MAChF,gBAAgB,UAAA,QACf,YAAY,KAAK,IAAI,IAAI,GAAG,QAC7B,YAAY,MAAM,EAAE;AAC1B,eAAO,WAAW,UAAA,QAAQ,EAAE,eAAe,UAAA,QAAQ,aAAa,KAAK,GAAG,IAAI;MAC9E;IACF;AAjBS;AAwBI,IAAAA,SAAA,iBAAiC;MAC5C,OAAO,mBAAmB;QACxB,YAAY,CAAC,KAAK,MAAM,OACtB,IAAI,IAAG,GAAA,UAAA,KAAI,EAAE,gBAAgB,IAAI,kBAAkB,MAAK;AACtD,cAAI,IACF,GAAA,UAAA,KAAI,IAAI,aACR,MAAM,IAAI,OAAO,IAAI,IAAI,GACzB,MAAM,IAAI,OAAO,KAAI,GAAA,UAAA,KAAI,EAAE,QAAQ,EAAE,MAAK,GAAA,UAAA,mBAAkB,EAAE,KAAK,IAAI,GAAG,CAAC;QAE/E,CAAC;QACH,aAAa,CAAC,KAAK,MAAM,OACvB,IAAI,IAAG,GAAA,UAAA,KAAI,EAAE,aAAa,MAAK;AAC7B,cAAI,SAAS,MAAM;AACjB,gBAAI,OAAO,IAAI,IAAI;iBACd;AACL,gBAAI,OAAO,KAAI,GAAA,UAAA,KAAI,EAAE,QAAQ;AAC7B,yBAAa,KAAK,IAAI,IAAI;;QAE9B,CAAC;QACH,aAAa,CAAC,MAAM,OAAQ,SAAS,OAAO,OAAO,EAAC,GAAG,MAAM,GAAG,GAAE;QAClE,cAAc;OACf;MACD,OAAO,mBAAmB;QACxB,YAAY,CAAC,KAAK,MAAM,OACtB,IAAI,IAAG,GAAA,UAAA,KAAI,EAAE,gBAAgB,IAAI,kBAAkB,MACjD,IAAI,OAAO,KAAI,GAAA,UAAA,KAAI,IAAI,sBAAsB,EAAE,MAAM,IAAI,MAAM,EAAE,MAAM,IAAI,EAAE,CAAC;QAElF,aAAa,CAAC,KAAK,MAAM,OACvB,IAAI,IAAG,GAAA,UAAA,KAAI,EAAE,aAAa,MACxB,IAAI,OAAO,IAAI,SAAS,OAAO,QAAO,GAAA,UAAA,KAAI,EAAE,MAAM,IAAI,MAAM,EAAE,MAAM,IAAI,EAAE,CAAC;QAE/E,aAAa,CAAC,MAAM,OAAQ,SAAS,OAAO,OAAO,KAAK,IAAI,MAAM,EAAE;QACpE,cAAc,CAAC,KAAK,UAAU,IAAI,IAAI,SAAS,KAAK;OACrD;;AAGH,aAAgB,qBAAqB,KAAc,IAAwB;AACzE,UAAI,OAAO;AAAM,eAAO,IAAI,IAAI,SAAS,IAAI;AAC7C,YAAM,QAAQ,IAAI,IAAI,UAAS,GAAA,UAAA,MAAK;AACpC,UAAI,OAAO;AAAW,qBAAa,KAAK,OAAO,EAAE;AACjD,aAAO;IACT;AALgB;AAAhB,IAAAA,SAAA,uBAAA;AAOA,aAAgB,aAAa,KAAc,OAAa,IAA0B;AAChF,aAAO,KAAK,EAAE,EAAE,QAAQ,CAAC,MAAM,IAAI,QAAO,GAAA,UAAA,KAAI,KAAK,IAAG,GAAA,UAAA,aAAY,CAAC,CAAC,IAAI,IAAI,CAAC;IAC/E;AAFgB;AAAhB,IAAAA,SAAA,eAAA;AAIA,QAAM,WAAoC,CAAA;AAE1C,aAAgB,QAAQ,KAAc,GAAiB;AACrD,aAAO,IAAI,WAAW,QAAQ;QAC5B,KAAK;QACL,MAAM,SAAS,EAAE,IAAI,MAAM,SAAS,EAAE,IAAI,IAAI,IAAI,OAAA,MAAM,EAAE,IAAI;OAC/D;IACH;AALgB;AAAhB,IAAAA,SAAA,UAAA;AAOA,QAAY;AAAZ,KAAA,SAAYC,OAAI;AACd,MAAAA,MAAAA,MAAA,KAAA,IAAA,CAAA,IAAA;AACA,MAAAA,MAAAA,MAAA,KAAA,IAAA,CAAA,IAAA;IACF,GAHY,OAAAD,SAAA,SAAAA,SAAA,OAAI,CAAA,EAAA;AAKhB,aAAgB,aACd,UACA,cACA,kBAA0B;AAG1B,UAAI,oBAAoB,UAAA,MAAM;AAC5B,cAAM,WAAW,iBAAiB,KAAK;AACvC,eAAO,mBACH,YACE,GAAA,UAAA,WAAU,QAAQ,YAClB,GAAA,UAAA,YAAW,QAAQ,YACrB,YACA,GAAA,UAAA,WAAU,QAAQ,MAClB,GAAA,UAAA,WAAU,QAAQ;;AAExB,aAAO,oBAAmB,GAAA,UAAA,aAAY,QAAQ,EAAE,SAAQ,IAAK,MAAM,kBAAkB,QAAQ;IAC/F;AAjBgB;AAAhB,IAAAA,SAAA,eAAA;AAmBA,aAAgB,gBACd,IACA,KACA,OAAwB,GAAG,KAAK,cAAY;AAE5C,UAAI,CAAC;AAAM;AACX,YAAM,gBAAgB,GAAG;AACzB,UAAI,SAAS;AAAM,cAAM,IAAI,MAAM,GAAG;AACtC,SAAG,KAAK,OAAO,KAAK,GAAG;IACzB;AATgB;AAAhB,IAAAA,SAAA,kBAAA;;;;;;;;;AC3MA,QAAA,YAAA;AAEA,QAAM,QAAQ;;MAEZ,MAAM,IAAI,UAAA,KAAK,MAAM;;MAErB,QAAQ,IAAI,UAAA,KAAK,QAAQ;MACzB,cAAc,IAAI,UAAA,KAAK,cAAc;MACrC,YAAY,IAAI,UAAA,KAAK,YAAY;MACjC,oBAAoB,IAAI,UAAA,KAAK,oBAAoB;MACjD,UAAU,IAAI,UAAA,KAAK,UAAU;MAC7B,gBAAgB,IAAI,UAAA,KAAK,gBAAgB;;MAEzC,SAAS,IAAI,UAAA,KAAK,SAAS;MAC3B,QAAQ,IAAI,UAAA,KAAK,QAAQ;MACzB,MAAM,IAAI,UAAA,KAAK,MAAM;;MAErB,MAAM,IAAI,UAAA,KAAK,MAAM;MACrB,OAAO,IAAI,UAAA,KAAK,OAAO;;MAEvB,MAAM,IAAI,UAAA,KAAK,MAAM;MACrB,SAAS,IAAI,UAAA,KAAK,SAAS;MAC3B,SAAS,IAAI,UAAA,KAAK,SAAS;MAC3B,UAAU,IAAI,UAAA,KAAK,UAAU;;AAG/B,IAAAE,SAAA,UAAe;;;;;;;;;;ACxBf,QAAA,YAAA;AAEA,QAAA,SAAA;AACA,QAAA,UAAA;AAEa,IAAAC,SAAA,eAAuC;MAClD,SAAS,CAAC,EAAC,QAAO,OAAM,GAAA,UAAA,kBAAiB,OAAO;;AAGrC,IAAAA,SAAA,oBAA4C;MACvD,SAAS,CAAC,EAAC,SAAS,WAAU,MAC5B,cACI,GAAA,UAAA,QAAO,OAAO,qBAAqB,UAAU,cAC7C,GAAA,UAAA,QAAO,OAAO;;AAStB,aAAgB,YACd,KACA,QAAgCA,SAAA,cAChC,YACA,mBAA2B;AAE3B,YAAM,EAAC,GAAE,IAAI;AACb,YAAM,EAAC,KAAK,eAAe,UAAS,IAAI;AACxC,YAAM,SAAS,gBAAgB,KAAK,OAAO,UAAU;AACrD,UAAI,sBAAiB,QAAjB,sBAAiB,SAAjB,oBAAsB,iBAAiB,WAAY;AACrD,iBAAS,KAAK,MAAM;aACf;AACL,qBAAa,KAAI,GAAA,UAAA,MAAK,MAAM,GAAG;;IAEnC;AAdgB;AAAhB,IAAAA,SAAA,cAAA;AAgBA,aAAgB,iBACd,KACA,QAAgCA,SAAA,cAChC,YAAuB;AAEvB,YAAM,EAAC,GAAE,IAAI;AACb,YAAM,EAAC,KAAK,eAAe,UAAS,IAAI;AACxC,YAAM,SAAS,gBAAgB,KAAK,OAAO,UAAU;AACrD,eAAS,KAAK,MAAM;AACpB,UAAI,EAAE,iBAAiB,YAAY;AACjC,qBAAa,IAAI,QAAA,QAAE,OAAO;;IAE9B;AAZgB;AAAhB,IAAAA,SAAA,mBAAA;AAcA,aAAgB,iBAAiB,KAAc,WAAe;AAC5D,UAAI,OAAO,QAAA,QAAE,QAAQ,SAAS;AAC9B,UAAI,IAAG,GAAA,UAAA,KAAI,QAAA,QAAE,OAAO,aAAa,MAC/B,IAAI,GACF,WACA,MAAM,IAAI,QAAO,GAAA,UAAA,KAAI,QAAA,QAAE,OAAO,WAAW,SAAS,GAClD,MAAM,IAAI,OAAO,QAAA,QAAE,SAAS,IAAI,CAAC,CAClC;IAEL;AATgB;AAAhB,IAAAA,SAAA,mBAAA;AAWA,aAAgB,aAAa,EAC3B,KACA,SACA,aACA,MACA,WACA,GAAE,GACc;AAEhB,UAAI,cAAc;AAAW,cAAM,IAAI,MAAM,0BAA0B;AACvE,YAAM,MAAM,IAAI,KAAK,KAAK;AAC1B,UAAI,SAAS,KAAK,WAAW,QAAA,QAAE,QAAQ,CAAC,MAAK;AAC3C,YAAI,MAAM,MAAK,GAAA,UAAA,KAAI,QAAA,QAAE,OAAO,IAAI,CAAC,GAAG;AACpC,YAAI,IAAG,GAAA,UAAA,KAAI,GAAG,+BAA+B,MAC3C,IAAI,QAAO,GAAA,UAAA,KAAI,GAAG,kBAAiB,GAAA,UAAA,WAAU,QAAA,QAAE,cAAc,GAAG,SAAS,CAAC,CAAC;AAE7E,YAAI,QAAO,GAAA,UAAA,KAAI,GAAG,gBAAe,GAAA,UAAA,OAAM,GAAG,aAAa,IAAI,OAAO,EAAE;AACpE,YAAI,GAAG,KAAK,SAAS;AACnB,cAAI,QAAO,GAAA,UAAA,KAAI,GAAG,WAAW,WAAW;AACxC,cAAI,QAAO,GAAA,UAAA,KAAI,GAAG,SAAS,IAAI;;MAEnC,CAAC;IACH;AAtBgB;AAAhB,IAAAA,SAAA,eAAA;AAwBA,aAAS,SAAS,KAAc,QAAY;AAC1C,YAAM,MAAM,IAAI,MAAM,OAAO,MAAM;AACnC,UAAI,IACF,GAAA,UAAA,KAAI,QAAA,QAAE,OAAO,aACb,MAAM,IAAI,OAAO,QAAA,QAAE,UAAS,GAAA,UAAA,MAAK,GAAG,GAAG,IACvC,GAAA,UAAA,KAAI,QAAA,QAAE,OAAO,SAAS,GAAG,GAAG;AAE9B,UAAI,MAAK,GAAA,UAAA,KAAI,QAAA,QAAE,MAAM,IAAI;IAC3B;AARS;AAUT,aAAS,aAAa,IAAe,MAAU;AAC7C,YAAM,EAAC,KAAK,cAAc,UAAS,IAAI;AACvC,UAAI,UAAU,QAAQ;AACpB,YAAI,OAAM,GAAA,UAAA,SAAQ,GAAG,eAAuB,IAAI,IAAI,GAAG;aAClD;AACL,YAAI,QAAO,GAAA,UAAA,KAAI,YAAY,WAAW,IAAI;AAC1C,YAAI,OAAO,KAAK;;IAEpB;AARS;AAUT,QAAM,IAAI;MACR,SAAS,IAAI,UAAA,KAAK,SAAS;MAC3B,YAAY,IAAI,UAAA,KAAK,YAAY;MACjC,QAAQ,IAAI,UAAA,KAAK,QAAQ;MACzB,cAAc,IAAI,UAAA,KAAK,cAAc;MACrC,SAAS,IAAI,UAAA,KAAK,SAAS;MAC3B,QAAQ,IAAI,UAAA,KAAK,QAAQ;MACzB,cAAc,IAAI,UAAA,KAAK,cAAc;;AAGvC,aAAS,gBACP,KACA,OACA,YAAuB;AAEvB,YAAM,EAAC,aAAY,IAAI,IAAI;AAC3B,UAAI,iBAAiB;AAAO,gBAAO,GAAA,UAAA;AACnC,aAAO,YAAY,KAAK,OAAO,UAAU;IAC3C;AARS;AAUT,aAAS,YACP,KACA,OACA,aAAyB,CAAA,GAAE;AAE3B,YAAM,EAAC,KAAK,GAAE,IAAI;AAClB,YAAM,YAAyC;QAC7C,kBAAkB,IAAI,UAAU;QAChC,gBAAgB,KAAK,UAAU;;AAEjC,sBAAgB,KAAK,OAAO,SAAS;AACrC,aAAO,IAAI,OAAO,GAAG,SAAS;IAChC;AAZS;AAcT,aAAS,kBAAkB,EAAC,UAAS,GAAc,EAAC,aAAY,GAAa;AAC3E,YAAM,WAAW,gBACb,GAAA,UAAA,OAAM,SAAS,IAAG,GAAA,OAAA,cAAa,cAAc,OAAA,KAAK,GAAG,CAAC,KACtD;AACJ,aAAO,CAAC,QAAA,QAAE,eAAc,GAAA,UAAA,WAAU,QAAA,QAAE,cAAc,QAAQ,CAAC;IAC7D;AALS;AAOT,aAAS,gBACP,EAAC,SAAS,IAAI,EAAC,cAAa,EAAC,GAC7B,EAAC,YAAY,aAAY,GAAa;AAEtC,UAAI,UAAU,eAAe,iBAAgB,GAAA,UAAA,OAAM,aAAa,IAAI,OAAO;AAC3E,UAAI,YAAY;AACd,mBAAU,GAAA,UAAA,OAAM,OAAO,IAAG,GAAA,OAAA,cAAa,YAAY,OAAA,KAAK,GAAG,CAAC;;AAE9D,aAAO,CAAC,EAAE,YAAY,OAAO;IAC/B;AATS;AAWT,aAAS,gBACP,KACA,EAAC,QAAQ,QAAO,GAChB,WAAsC;AAEtC,YAAM,EAAC,SAAS,MAAM,aAAa,GAAE,IAAI;AACzC,YAAM,EAAC,MAAM,cAAc,cAAc,WAAU,IAAI;AACvD,gBAAU,KACR,CAAC,EAAE,SAAS,OAAO,GACnB,CAAC,EAAE,QAAQ,OAAO,UAAU,aAAa,OAAO,GAAG,IAAI,WAAU,GAAA,UAAA,MAAK,CAAC;AAEzE,UAAI,KAAK,UAAU;AACjB,kBAAU,KAAK,CAAC,EAAE,SAAS,OAAO,WAAW,aAAa,QAAQ,GAAG,IAAI,OAAO,CAAC;;AAEnF,UAAI,KAAK,SAAS;AAChB,kBAAU,KACR,CAAC,EAAE,QAAQ,WAAW,GACtB,CAAC,EAAE,eAAc,GAAA,UAAA,KAAI,YAAY,GAAG,UAAU,EAAE,GAChD,CAAC,QAAA,QAAE,MAAM,IAAI,CAAC;;AAGlB,UAAI;AAAc,kBAAU,KAAK,CAAC,EAAE,cAAc,YAAY,CAAC;IACjE;AAtBS;;;;;;;;;;AC/JT,QAAA,WAAA;AACA,QAAA,YAAA;AACA,QAAA,UAAA;AAEA,QAAM,YAAoC;MACxC,SAAS;;AAGX,aAAgB,qBAAqB,IAAa;AAChD,YAAM,EAAC,KAAK,QAAQ,aAAY,IAAI;AACpC,UAAI,WAAW,OAAO;AACpB,yBAAiB,IAAI,KAAK;iBACjB,OAAO,UAAU,YAAY,OAAO,WAAW,MAAM;AAC9D,YAAI,OAAO,QAAA,QAAE,IAAI;aACZ;AACL,YAAI,QAAO,GAAA,UAAA,KAAI,YAAY,WAAW,IAAI;AAC1C,YAAI,OAAO,IAAI;;IAEnB;AAVgB;AAAhB,IAAAC,SAAA,uBAAA;AAYA,aAAgB,kBAAkB,IAAe,OAAW;AAC1D,YAAM,EAAC,KAAK,OAAM,IAAI;AACtB,UAAI,WAAW,OAAO;AACpB,YAAI,IAAI,OAAO,KAAK;AACpB,yBAAiB,EAAE;aACd;AACL,YAAI,IAAI,OAAO,IAAI;;IAEvB;AARgB;AAAhB,IAAAA,SAAA,oBAAA;AAUA,aAAS,iBAAiB,IAAe,mBAA2B;AAClE,YAAM,EAAC,KAAK,KAAI,IAAI;AAEpB,YAAM,MAAuB;QAC3B;QACA,SAAS;QACT;QACA,QAAQ;QACR,YAAY;QACZ,aAAa;QACb,QAAQ,CAAA;QACR;;AAEF,OAAA,GAAA,SAAA,aAAY,KAAK,WAAW,QAAW,iBAAiB;IAC1D;AAdS;;;;;;;;;;AC9BT,QAAM,aAAa,CAAC,UAAU,UAAU,WAAW,WAAW,QAAQ,UAAU,OAAO;AAIvF,QAAM,YAAyB,IAAI,IAAI,UAAU;AAEjD,aAAgB,WAAW,GAAU;AACnC,aAAO,OAAO,KAAK,YAAY,UAAU,IAAI,CAAC;IAChD;AAFgB;AAAhB,IAAAC,SAAA,aAAA;AA2BA,aAAgB,WAAQ;AACtB,YAAM,SAAsE;QAC1E,QAAQ,EAAC,MAAM,UAAU,OAAO,CAAA,EAAE;QAClC,QAAQ,EAAC,MAAM,UAAU,OAAO,CAAA,EAAE;QAClC,OAAO,EAAC,MAAM,SAAS,OAAO,CAAA,EAAE;QAChC,QAAQ,EAAC,MAAM,UAAU,OAAO,CAAA,EAAE;;AAEpC,aAAO;QACL,OAAO,EAAC,GAAG,QAAQ,SAAS,MAAM,SAAS,MAAM,MAAM,KAAI;QAC3D,OAAO,CAAC,EAAC,OAAO,CAAA,EAAE,GAAG,OAAO,QAAQ,OAAO,QAAQ,OAAO,OAAO,OAAO,MAAM;QAC9E,MAAM,EAAC,OAAO,CAAA,EAAE;QAChB,KAAK,CAAA;QACL,UAAU,CAAA;;IAEd;AAdgB;AAAhB,IAAAA,SAAA,WAAA;;;;;;;;;;AC/BA,aAAgB,sBACd,EAAC,QAAQ,KAAI,GACb,MAAc;AAEd,YAAM,QAAQ,KAAK,MAAM,MAAM,IAAI;AACnC,aAAO,SAAS,UAAU,QAAQ,eAAe,QAAQ,KAAK;IAChE;AANgB;AAAhB,IAAAC,SAAA,wBAAA;AAQA,aAAgB,eAAe,QAAyB,OAAgB;AACtE,aAAO,MAAM,MAAM,KAAK,CAAC,SAAS,cAAc,QAAQ,IAAI,CAAC;IAC/D;AAFgB;AAAhB,IAAAA,SAAA,iBAAA;AAIA,aAAgB,cAAc,QAAyB,MAAU;;AAC/D,aACE,OAAO,KAAK,OAAO,MAAM,YACzB,KAAA,KAAK,WAAW,gBAAU,QAAA,OAAA,SAAA,SAAA,GAAE,KAAK,CAAC,QAAQ,OAAO,GAAG,MAAM,MAAS;IAEvE;AALgB;AAAhB,IAAAA,SAAA,gBAAA;;;;;;;;;;ACTA,QAAA,UAAA;AACA,QAAA,kBAAA;AACA,QAAA,WAAA;AACA,QAAA,YAAA;AACA,QAAA,SAAA;AAEA,QAAY;AAAZ,KAAA,SAAYC,WAAQ;AAClB,MAAAA,UAAAA,UAAA,SAAA,IAAA,CAAA,IAAA;AACA,MAAAA,UAAAA,UAAA,OAAA,IAAA,CAAA,IAAA;IACF,GAHY,WAAAC,SAAA,aAAAA,SAAA,WAAQ,CAAA,EAAA;AAKpB,aAAgB,eAAe,QAAuB;AACpD,YAAM,QAAQ,aAAa,OAAO,IAAI;AACtC,YAAM,UAAU,MAAM,SAAS,MAAM;AACrC,UAAI,SAAS;AACX,YAAI,OAAO,aAAa;AAAO,gBAAM,IAAI,MAAM,wCAAwC;aAClF;AACL,YAAI,CAAC,MAAM,UAAU,OAAO,aAAa,QAAW;AAClD,gBAAM,IAAI,MAAM,0CAA0C;;AAE5D,YAAI,OAAO,aAAa;AAAM,gBAAM,KAAK,MAAM;;AAEjD,aAAO;IACT;AAZgB;AAAhB,IAAAA,SAAA,iBAAA;AAcA,aAAgB,aAAa,IAAuB;AAClD,YAAM,QAAmB,MAAM,QAAQ,EAAE,IAAI,KAAK,KAAK,CAAC,EAAE,IAAI,CAAA;AAC9D,UAAI,MAAM,MAAM,QAAA,UAAU;AAAG,eAAO;AACpC,YAAM,IAAI,MAAM,0CAA0C,MAAM,KAAK,GAAG,CAAC;IAC3E;AAJgB;AAAhB,IAAAA,SAAA,eAAA;AAMA,aAAgB,uBAAuB,IAAkB,OAAiB;AACxE,YAAM,EAAC,KAAK,MAAM,KAAI,IAAI;AAC1B,YAAM,WAAW,cAAc,OAAO,KAAK,WAAW;AACtD,YAAM,aACJ,MAAM,SAAS,KACf,EAAE,SAAS,WAAW,KAAK,MAAM,WAAW,MAAK,GAAA,gBAAA,uBAAsB,IAAI,MAAM,CAAC,CAAC;AACrF,UAAI,YAAY;AACd,cAAM,YAAY,eAAe,OAAO,MAAM,KAAK,eAAe,SAAS,KAAK;AAChF,YAAI,GAAG,WAAW,MAAK;AACrB,cAAI,SAAS;AAAQ,uBAAW,IAAI,OAAO,QAAQ;;AAC9C,4BAAgB,EAAE;QACzB,CAAC;;AAEH,aAAO;IACT;AAdgB;AAAhB,IAAAA,SAAA,yBAAA;AAgBA,QAAM,YAA2B,oBAAI,IAAI,CAAC,UAAU,UAAU,WAAW,WAAW,MAAM,CAAC;AAC3F,aAAS,cAAc,OAAmB,aAA+B;AACvE,aAAO,cACH,MAAM,OAAO,CAAC,MAAM,UAAU,IAAI,CAAC,KAAM,gBAAgB,WAAW,MAAM,OAAQ,IAClF,CAAA;IACN;AAJS;AAMT,aAAS,WAAW,IAAkB,OAAmB,UAAoB;AAC3E,YAAM,EAAC,KAAK,MAAM,KAAI,IAAI;AAC1B,YAAM,WAAW,IAAI,IAAI,aAAY,GAAA,UAAA,YAAW,IAAI,EAAE;AACtD,YAAM,UAAU,IAAI,IAAI,YAAW,GAAA,UAAA,aAAY;AAC/C,UAAI,KAAK,gBAAgB,SAAS;AAChC,YAAI,IAAG,GAAA,UAAA,KAAI,QAAQ,iCAAiC,IAAI,QAAQ,IAAI,gBAAgB,MAClF,IACG,OAAO,OAAM,GAAA,UAAA,KAAI,IAAI,KAAK,EAC1B,OAAO,WAAU,GAAA,UAAA,YAAW,IAAI,EAAE,EAClC,GAAG,eAAe,OAAO,MAAM,KAAK,aAAa,GAAG,MAAM,IAAI,OAAO,SAAS,IAAI,CAAC,CAAC;;AAG3F,UAAI,IAAG,GAAA,UAAA,KAAI,OAAO,gBAAgB;AAClC,iBAAW,KAAK,UAAU;AACxB,YAAI,UAAU,IAAI,CAAC,KAAM,MAAM,WAAW,KAAK,gBAAgB,SAAU;AACvE,6BAAmB,CAAC;;;AAGxB,UAAI,KAAI;AACR,sBAAgB,EAAE;AAClB,UAAI,MAAK;AAET,UAAI,IAAG,GAAA,UAAA,KAAI,OAAO,kBAAkB,MAAK;AACvC,YAAI,OAAO,MAAM,OAAO;AACxB,yBAAiB,IAAI,OAAO;MAC9B,CAAC;AAED,eAAS,mBAAmB,GAAS;AACnC,gBAAQ,GAAG;UACT,KAAK;AACH,gBACG,QAAO,GAAA,UAAA,KAAI,QAAQ,mBAAmB,QAAQ,eAAe,EAC7D,OAAO,UAAS,GAAA,UAAA,UAAS,IAAI,EAAE,EAC/B,QAAO,GAAA,UAAA,KAAI,IAAI,WAAW,EAC1B,OAAO,UAAS,GAAA,UAAA,MAAK;AACxB;UACF,KAAK;AACH,gBACG,QACC,GAAA,UAAA,KAAI,QAAQ,oBAAoB,IAAI;oBAC5B,QAAQ,mBAAmB,IAAI,OAAO,IAAI,QAAQ,IAAI,GAAG,EAElE,OAAO,UAAS,GAAA,UAAA,MAAK,IAAI,EAAE;AAC9B;UACF,KAAK;AACH,gBACG,QACC,GAAA,UAAA,KAAI,QAAQ,qBAAqB,IAAI;oBAC7B,QAAQ,oBAAoB,IAAI,OAAO,IAAI,QAAQ,IAAI,SAAS,IAAI,QAAQ,EAErF,OAAO,UAAS,GAAA,UAAA,MAAK,IAAI,EAAE;AAC9B;UACF,KAAK;AACH,gBACG,QAAO,GAAA,UAAA,KAAI,IAAI,mBAAmB,IAAI,aAAa,IAAI,WAAW,EAClE,OAAO,SAAS,KAAK,EACrB,QAAO,GAAA,UAAA,KAAI,IAAI,kBAAkB,IAAI,QAAQ,EAC7C,OAAO,SAAS,IAAI;AACvB;UACF,KAAK;AACH,gBAAI,QAAO,GAAA,UAAA,KAAI,IAAI,cAAc,IAAI,aAAa,IAAI,YAAY;AAClE,gBAAI,OAAO,SAAS,IAAI;AACxB;UAEF,KAAK;AACH,gBACG,QACC,GAAA,UAAA,KAAI,QAAQ,oBAAoB,QAAQ;mBACjC,QAAQ,qBAAqB,IAAI,WAAW,EAEpD,OAAO,UAAS,GAAA,UAAA,MAAK,IAAI,GAAG;;MAErC;AA7CS;IA8CX;AAzES;AA2ET,aAAS,iBAAiB,EAAC,KAAK,YAAY,mBAAkB,GAAiB,MAAU;AAEvF,UAAI,IAAG,GAAA,UAAA,KAAI,UAAU,kBAAkB,MACrC,IAAI,QAAO,GAAA,UAAA,KAAI,UAAU,IAAI,kBAAkB,KAAK,IAAI,CAAC;IAE7D;AALS;AAOT,aAAgB,cACd,UACA,MACA,YACA,UAAU,SAAS,SAAO;AAE1B,YAAM,KAAK,YAAY,SAAS,UAAU,UAAA,UAAU,KAAK,UAAA,UAAU;AACnE,UAAI;AACJ,cAAQ,UAAU;QAChB,KAAK;AACH,kBAAO,GAAA,UAAA,KAAI,IAAI,IAAI,EAAE;QACvB,KAAK;AACH,kBAAO,GAAA,UAAA,mBAAkB,IAAI;AAC7B;QACF,KAAK;AACH,kBAAO,GAAA,UAAA,KAAI,IAAI,cAAc,IAAI,kCAAkC,IAAI;AACvE;QACF,KAAK;AACH,iBAAO,SAAQ,GAAA,UAAA,OAAM,IAAI,mBAAmB,IAAI,GAAG;AACnD;QACF,KAAK;AACH,iBAAO,QAAO;AACd;QACF;AACE,kBAAO,GAAA,UAAA,YAAW,IAAI,IAAI,EAAE,IAAI,QAAQ;;AAE5C,aAAO,YAAY,SAAS,UAAU,QAAO,GAAA,UAAA,KAAI,IAAI;AAErD,eAAS,QAAQ,QAAc,UAAA,KAAG;AAChC,gBAAO,GAAA,UAAA,MAAI,GAAA,UAAA,YAAW,IAAI,gBAAgB,OAAO,cAAa,GAAA,UAAA,cAAa,IAAI,MAAM,UAAA,GAAG;MAC1F;AAFS;IAGX;AA/BgB;AAAhB,IAAAA,SAAA,gBAAA;AAiCA,aAAgB,eACd,WACA,MACA,YACA,SAAkB;AAElB,UAAI,UAAU,WAAW,GAAG;AAC1B,eAAO,cAAc,UAAU,CAAC,GAAG,MAAM,YAAY,OAAO;;AAE9D,UAAI;AACJ,YAAM,SAAQ,GAAA,OAAA,QAAO,SAAS;AAC9B,UAAI,MAAM,SAAS,MAAM,QAAQ;AAC/B,cAAM,UAAS,GAAA,UAAA,YAAW,IAAI;AAC9B,eAAO,MAAM,OAAO,UAAS,GAAA,UAAA,MAAK,IAAI,OAAO,MAAM;AACnD,eAAO,MAAM;AACb,eAAO,MAAM;AACb,eAAO,MAAM;aACR;AACL,eAAO,UAAA;;AAET,UAAI,MAAM;AAAQ,eAAO,MAAM;AAC/B,iBAAW,KAAK;AAAO,gBAAO,GAAA,UAAA,KAAI,MAAM,cAAc,GAAe,MAAM,YAAY,OAAO,CAAC;AAC/F,aAAO;IACT;AAvBgB;AAAhB,IAAAA,SAAA,iBAAA;AA2BA,QAAM,YAAoC;MACxC,SAAS,CAAC,EAAC,OAAM,MAAM,WAAW,MAAM;MACxC,QAAQ,CAAC,EAAC,QAAQ,YAAW,MAC3B,OAAO,UAAU,YAAW,GAAA,UAAA,YAAW,MAAM,OAAM,GAAA,UAAA,YAAW,WAAW;;AAG7E,aAAgB,gBAAgB,IAAgB;AAC9C,YAAM,MAAM,oBAAoB,EAAE;AAClC,OAAA,GAAA,SAAA,aAAY,KAAK,SAAS;IAC5B;AAHgB;AAAhB,IAAAA,SAAA,kBAAA;AAKA,aAAS,oBAAoB,IAAgB;AAC3C,YAAM,EAAC,KAAK,MAAM,OAAM,IAAI;AAC5B,YAAM,cAAa,GAAA,OAAA,gBAAe,IAAI,QAAQ,MAAM;AACpD,aAAO;QACL;QACA,SAAS;QACT;QACA,QAAQ,OAAO;QACf;QACA,aAAa;QACb,cAAc;QACd,QAAQ,CAAA;QACR;;IAEJ;AAdS;;;;;;;;;;ACrNT,QAAA,YAAA;AACA,QAAA,SAAA;AAEA,aAAgB,eAAe,IAAkB,IAAW;AAC1D,YAAM,EAAC,YAAY,MAAK,IAAI,GAAG;AAC/B,UAAI,OAAO,YAAY,YAAY;AACjC,mBAAW,OAAO,YAAY;AAC5B,wBAAc,IAAI,KAAK,WAAW,GAAG,EAAE,OAAO;;iBAEvC,OAAO,WAAW,MAAM,QAAQ,KAAK,GAAG;AACjD,cAAM,QAAQ,CAAC,KAAK,MAAc,cAAc,IAAI,GAAG,IAAI,OAAO,CAAC;;IAEvE;AATgB;AAAhB,IAAAC,SAAA,iBAAA;AAWA,aAAS,cAAc,IAAkB,MAAuB,cAAqB;AACnF,YAAM,EAAC,KAAK,eAAe,MAAM,KAAI,IAAI;AACzC,UAAI,iBAAiB;AAAW;AAChC,YAAM,aAAY,GAAA,UAAA,KAAI,IAAI,IAAG,GAAA,UAAA,aAAY,IAAI,CAAC;AAC9C,UAAI,eAAe;AACjB,SAAA,GAAA,OAAA,iBAAgB,IAAI,2BAA2B,SAAS,EAAE;AAC1D;;AAGF,UAAI,aAAY,GAAA,UAAA,KAAI,SAAS;AAC7B,UAAI,KAAK,gBAAgB,SAAS;AAChC,qBAAY,GAAA,UAAA,KAAI,SAAS,OAAO,SAAS,gBAAgB,SAAS;;AAIpE,UAAI,GAAG,YAAW,GAAA,UAAA,KAAI,SAAS,OAAM,GAAA,UAAA,WAAU,YAAY,CAAC,EAAE;IAChE;AAhBS;;;;;;;;;;ACZT,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,UAAA;AACA,QAAA,SAAA;AACA,aAAgB,uBAAuB,KAAiB,MAAY;AAClE,YAAM,EAAC,KAAK,MAAM,GAAE,IAAI;AACxB,UAAI,GAAG,iBAAiB,KAAK,MAAM,MAAM,GAAG,KAAK,aAAa,GAAG,MAAK;AACpE,YAAI,UAAU,EAAC,kBAAiB,GAAA,UAAA,KAAI,IAAI,GAAE,GAAG,IAAI;AACjD,YAAI,MAAK;MACX,CAAC;IACH;AANgB;AAAhB,IAAAC,SAAA,yBAAA;AAQA,aAAgB,iBACd,EAAC,KAAK,MAAM,IAAI,EAAC,KAAI,EAAC,GACtB,YACA,SAAa;AAEb,cAAO,GAAA,UAAA,IACL,GAAG,WAAW,IAAI,CAAC,UACjB,GAAA,UAAA,KAAI,iBAAiB,KAAK,MAAM,MAAM,KAAK,aAAa,IAAG,GAAA,UAAA,KAAI,OAAO,MAAM,IAAI,EAAE,CAAC,CACpF;IAEL;AAVgB;AAAhB,IAAAA,SAAA,mBAAA;AAYA,aAAgB,kBAAkB,KAAiB,SAAa;AAC9D,UAAI,UAAU,EAAC,iBAAiB,QAAO,GAAG,IAAI;AAC9C,UAAI,MAAK;IACX;AAHgB;AAAhB,IAAAA,SAAA,oBAAA;AAKA,aAAgB,YAAY,KAAY;AACtC,aAAO,IAAI,WAAW,QAAQ;;QAE5B,KAAK,OAAO,UAAU;QACtB,OAAM,GAAA,UAAA;OACP;IACH;AANgB;AAAhB,IAAAA,SAAA,cAAA;AAQA,aAAgB,cAAc,KAAc,MAAY,UAAuB;AAC7E,cAAO,GAAA,UAAA,KAAI,YAAY,GAAG,CAAC,SAAS,IAAI,KAAK,QAAQ;IACvD;AAFgB;AAAhB,IAAAA,SAAA,gBAAA;AAIA,aAAgB,eACd,KACA,MACA,UACA,eAAuB;AAEvB,YAAM,QAAO,GAAA,UAAA,KAAI,IAAI,IAAG,GAAA,UAAA,aAAY,QAAQ,CAAC;AAC7C,aAAO,iBAAgB,GAAA,UAAA,KAAI,IAAI,OAAO,cAAc,KAAK,MAAM,QAAQ,CAAC,KAAK;IAC/E;AARgB;AAAhB,IAAAA,SAAA,iBAAA;AAUA,aAAgB,iBACd,KACA,MACA,UACA,eAAuB;AAEvB,YAAM,QAAO,GAAA,UAAA,KAAI,IAAI,IAAG,GAAA,UAAA,aAAY,QAAQ,CAAC;AAC7C,aAAO,iBAAgB,GAAA,UAAA,IAAG,OAAM,GAAA,UAAA,KAAI,cAAc,KAAK,MAAM,QAAQ,CAAC,CAAC,IAAI;IAC7E;AARgB;AAAhB,IAAAA,SAAA,mBAAA;AAUA,aAAgB,oBAAoB,WAAqB;AACvD,aAAO,YAAY,OAAO,KAAK,SAAS,EAAE,OAAO,CAAC,MAAM,MAAM,WAAW,IAAI,CAAA;IAC/E;AAFgB;AAAhB,IAAAA,SAAA,sBAAA;AAIA,aAAgB,iBAAiB,IAAe,WAAoB;AAClE,aAAO,oBAAoB,SAAS,EAAE,OACpC,CAAC,MAAM,EAAC,GAAA,OAAA,mBAAkB,IAAI,UAAU,CAAC,CAAc,CAAC;IAE5D;AAJgB;AAAhB,IAAAA,SAAA,mBAAA;AAMA,aAAgB,iBACd,EAAC,YAAY,MAAM,IAAI,EAAC,KAAK,cAAc,YAAY,UAAS,GAAG,GAAE,GACrE,MACA,SACA,YAAoB;AAEpB,YAAM,gBAAgB,cAAa,GAAA,UAAA,KAAI,UAAU,KAAK,IAAI,KAAK,YAAY,GAAG,UAAU,KAAK;AAC7F,YAAM,SAAkC;QACtC,CAAC,QAAA,QAAE,eAAc,GAAA,UAAA,WAAU,QAAA,QAAE,cAAc,SAAS,CAAC;QACrD,CAAC,QAAA,QAAE,YAAY,GAAG,UAAU;QAC5B,CAAC,QAAA,QAAE,oBAAoB,GAAG,kBAAkB;QAC5C,CAAC,QAAA,QAAE,UAAU,QAAA,QAAE,QAAQ;;AAEzB,UAAI,GAAG,KAAK;AAAY,eAAO,KAAK,CAAC,QAAA,QAAE,gBAAgB,QAAA,QAAE,cAAc,CAAC;AACxE,YAAM,QAAO,GAAA,UAAA,KAAI,aAAa,KAAK,IAAI,OAAO,GAAG,MAAM,CAAC;AACxD,aAAO,YAAY,UAAA,OAAM,GAAA,UAAA,KAAI,IAAI,SAAS,OAAO,KAAK,IAAI,OAAM,GAAA,UAAA,KAAI,IAAI,IAAI,IAAI;IAClF;AAhBgB;AAAhB,IAAAA,SAAA,mBAAA;AAkBA,QAAM,aAAY,GAAA,UAAA;AAElB,aAAgB,WAAW,EAAC,KAAK,IAAI,EAAC,KAAI,EAAC,GAAe,SAAe;AACvE,YAAM,IAAI,KAAK,gBAAgB,MAAM;AACrC,YAAM,EAAC,OAAM,IAAI,KAAK;AACtB,YAAM,KAAK,OAAO,SAAS,CAAC;AAE5B,aAAO,IAAI,WAAW,WAAW;QAC/B,KAAK,GAAG,SAAQ;QAChB,KAAK;QACL,OAAM,GAAA,UAAA,KAAI,OAAO,SAAS,eAAe,aAAY,GAAA,OAAA,SAAQ,KAAK,MAAM,CAAC,IAAI,OAAO,KAAK,CAAC;OAC3F;IACH;AAVgB;AAAhB,IAAAA,SAAA,aAAA;AAYA,aAAgB,cAAc,KAAe;AAC3C,YAAM,EAAC,KAAK,MAAM,SAAS,GAAE,IAAI;AACjC,YAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,UAAI,GAAG,WAAW;AAChB,cAAM,WAAW,IAAI,IAAI,SAAS,IAAI;AACtC,sBAAc,MAAM,IAAI,OAAO,UAAU,KAAK,CAAC;AAC/C,eAAO;;AAET,UAAI,IAAI,OAAO,IAAI;AACnB,oBAAc,MAAM,IAAI,MAAK,CAAE;AAC/B,aAAO;AAEP,eAAS,cAAc,UAAoB;AACzC,cAAM,MAAM,IAAI,MAAM,QAAO,GAAA,UAAA,KAAI,IAAI,SAAS;AAC9C,YAAI,SAAS,KAAK,GAAG,KAAK,CAAC,MAAK;AAC9B,cAAI,UACF;YACE;YACA,UAAU;YACV,cAAc,OAAA,KAAK;aAErB,KAAK;AAEP,cAAI,IAAG,GAAA,UAAA,KAAI,KAAK,GAAG,QAAQ;QAC7B,CAAC;MACH;AAbS;IAcX;AA1BgB;AAAhB,IAAAA,SAAA,gBAAA;AA4BA,aAAgB,cAAc,KAAe;AAC3C,YAAM,EAAC,KAAK,QAAQ,SAAS,GAAE,IAAI;AAEnC,UAAI,CAAC,MAAM,QAAQ,MAAM;AAAG,cAAM,IAAI,MAAM,0BAA0B;AACtE,YAAM,cAAc,OAAO,KAAK,CAAC,SAAmB,GAAA,OAAA,mBAAkB,IAAI,GAAG,CAAC;AAC9E,UAAI,eAAe,CAAC,GAAG,KAAK;AAAa;AAEzC,YAAM,QAAQ,IAAI,IAAI,SAAS,KAAK;AACpC,YAAM,WAAW,IAAI,KAAK,QAAQ;AAElC,UAAI,MAAM,MACR,OAAO,QAAQ,CAAC,MAAiB,MAAa;AAC5C,cAAM,SAAS,IAAI,UACjB;UACE;UACA,YAAY;UACZ,eAAe;WAEjB,QAAQ;AAEV,YAAI,OAAO,QAAO,GAAA,UAAA,KAAI,KAAK,OAAO,QAAQ,EAAE;AAC5C,cAAM,SAAS,IAAI,oBAAoB,QAAQ,QAAQ;AAGvD,YAAI,CAAC;AAAQ,cAAI,IAAG,GAAA,UAAA,KAAI,KAAK,CAAC;MAChC,CAAC,CAAC;AAGJ,UAAI,OACF,OACA,MAAM,IAAI,MAAK,GACf,MAAM,IAAI,MAAM,IAAI,CAAC;IAEzB;AAjCgB;AAAhB,IAAAA,SAAA,gBAAA;;;;;;;;;;AC5HA,QAAA,YAAA;AACA,QAAA,UAAA;AAEA,QAAA,SAAA;AACA,QAAA,WAAA;AAIA,aAAgB,iBAAiB,KAAiB,KAA2B;AAC3E,YAAM,EAAC,KAAK,SAAS,QAAQ,cAAc,GAAE,IAAI;AACjD,YAAM,cAAc,IAAI,MAAM,KAAK,GAAG,MAAM,QAAQ,cAAc,EAAE;AACpE,YAAM,YAAY,WAAW,KAAK,SAAS,WAAW;AACtD,UAAI,GAAG,KAAK,mBAAmB;AAAO,WAAG,KAAK,eAAe,aAAa,IAAI;AAE9E,YAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,UAAI,UACF;QACE,QAAQ;QACR,YAAY,UAAA;QACZ,eAAe,GAAG,GAAG,aAAa,IAAI,OAAO;QAC7C,cAAc;QACd,eAAe;SAEjB,KAAK;AAEP,UAAI,KAAK,OAAO,MAAM,IAAI,MAAM,IAAI,CAAC;IACvC;AAlBgB;AAAhB,IAAAC,SAAA,mBAAA;AAoBA,aAAgB,gBAAgB,KAAiB,KAA0B;;AACzE,YAAM,EAAC,KAAK,SAAS,QAAQ,cAAc,OAAO,GAAE,IAAI;AACxD,wBAAkB,IAAI,GAAG;AACzB,YAAM,WACJ,CAAC,SAAS,IAAI,UAAU,IAAI,QAAQ,KAAK,GAAG,MAAM,QAAQ,cAAc,EAAE,IAAI,IAAI;AACpF,YAAM,cAAc,WAAW,KAAK,SAAS,QAAQ;AACrD,YAAM,QAAQ,IAAI,IAAI,OAAO;AAC7B,UAAI,WAAW,OAAO,eAAe;AACrC,UAAI,IAAG,KAAA,IAAI,WAAK,QAAA,OAAA,SAAA,KAAI,KAAK;AAEzB,eAAS,kBAAe;AACtB,YAAI,IAAI,WAAW,OAAO;AACxB,sBAAW;AACX,cAAI,IAAI;AAAW,uBAAW,GAAG;AACjC,qBAAW,MAAM,IAAI,MAAK,CAAE;eACvB;AACL,gBAAM,WAAW,IAAI,QAAQ,cAAa,IAAK,aAAY;AAC3D,cAAI,IAAI;AAAW,uBAAW,GAAG;AACjC,qBAAW,MAAM,QAAQ,KAAK,QAAQ,CAAC;;MAE3C;AAVS;AAYT,eAAS,gBAAa;AACpB,cAAM,WAAW,IAAI,IAAI,YAAY,IAAI;AACzC,YAAI,IACF,MAAM,aAAY,GAAA,UAAA,UAAS,GAC3B,CAAC,MACC,IAAI,OAAO,OAAO,KAAK,EAAE,IACvB,GAAA,UAAA,KAAI,CAAC,eAAe,GAAG,eAAuB,IAC9C,MAAM,IAAI,OAAO,WAAU,GAAA,UAAA,KAAI,CAAC,SAAS,GACzC,MAAM,IAAI,MAAM,CAAC,CAAC,CACnB;AAEL,eAAO;MACT;AAZS;AAcT,eAAS,eAAY;AACnB,cAAM,gBAAe,GAAA,UAAA,KAAI,WAAW;AACpC,YAAI,OAAO,cAAc,IAAI;AAC7B,oBAAY,UAAA,GAAG;AACf,eAAO;MACT;AALS;AAOT,eAAS,YAAY,SAAe,IAAI,SAAQ,GAAA,UAAA,aAAY,UAAA,KAAG;AAC7D,cAAM,UAAU,GAAG,KAAK,cAAc,QAAA,QAAE,OAAO,QAAA,QAAE;AACjD,cAAM,aAAa,EAAG,aAAa,OAAO,CAAC,SAAU,IAAI,WAAW;AACpE,YAAI,OACF,QACA,GAAA,UAAA,KAAI,MAAM,IAAG,GAAA,OAAA,kBAAiB,KAAK,aAAa,SAAS,UAAU,CAAC,IACpE,IAAI,SAAS;MAEjB;AARS;AAUT,eAAS,WAAW,QAAkB;;AACpC,YAAI,IAAG,GAAA,UAAA,MAAIC,MAAA,IAAI,WAAK,QAAAA,QAAA,SAAAA,MAAI,KAAK,GAAG,MAAM;MACxC;AAFS;IAGX;AAxDgB;AAAhB,IAAAD,SAAA,kBAAA;AA0DA,aAAS,WAAW,KAAe;AACjC,YAAM,EAAC,KAAK,MAAM,GAAE,IAAI;AACxB,UAAI,GAAG,GAAG,YAAY,MAAM,IAAI,OAAO,OAAM,GAAA,UAAA,KAAI,GAAG,UAAU,IAAI,GAAG,kBAAkB,GAAG,CAAC;IAC7F;AAHS;AAKT,aAAS,QAAQ,KAAiB,MAAU;AAC1C,YAAM,EAAC,IAAG,IAAI;AACd,UAAI,IACF,GAAA,UAAA,mBAAkB,IAAI,KACtB,MAAK;AACH,YACG,OAAO,QAAA,QAAE,UAAS,GAAA,UAAA,KAAI,QAAA,QAAE,OAAO,eAAe,IAAI,MAAM,QAAA,QAAE,OAAO,WAAW,IAAI,GAAG,EACnF,OAAO,QAAA,QAAE,SAAQ,GAAA,UAAA,KAAI,QAAA,QAAE,OAAO,SAAS;AAC1C,SAAA,GAAA,SAAA,cAAa,GAAG;MAClB,GACA,MAAM,IAAI,MAAK,CAAE;IAErB;AAZS;AAcT,aAAS,kBAAkB,EAAC,UAAS,GAAiB,KAA0B;AAC9E,UAAI,IAAI,SAAS,CAAC,UAAU;AAAQ,cAAM,IAAI,MAAM,8BAA8B;IACpF;AAFS;AAIT,aAAS,WAAW,KAAc,SAAiB,QAAiC;AAClF,UAAI,WAAW;AAAW,cAAM,IAAI,MAAM,YAAY,OAAO,qBAAqB;AAClF,aAAO,IAAI,WACT,WACA,OAAO,UAAU,aAAa,EAAC,KAAK,OAAM,IAAI,EAAC,KAAK,QAAQ,OAAM,GAAA,UAAA,WAAU,MAAM,EAAC,CAAC;IAExF;AANS;AAQT,aAAgB,gBACd,QACA,YACA,iBAAiB,OAAK;AAGtB,aACE,CAAC,WAAW,UACZ,WAAW,KAAK,CAAC,OACf,OAAO,UACH,MAAM,QAAQ,MAAM,IACpB,OAAO,WACP,UAAU,OAAO,UAAU,YAAY,CAAC,MAAM,QAAQ,MAAM,IAC5D,OAAO,UAAU,MAAO,kBAAkB,OAAO,UAAU,WAAY;IAGjF;AAhBgB;AAAhB,IAAAA,SAAA,kBAAA;AAkBA,aAAgB,qBACd,EAAC,QAAQ,MAAM,MAAM,cAAa,GAClC,KACA,SAAe;AAGf,UAAI,MAAM,QAAQ,IAAI,OAAO,IAAI,CAAC,IAAI,QAAQ,SAAS,OAAO,IAAI,IAAI,YAAY,SAAS;AACzF,cAAM,IAAI,MAAM,0BAA0B;;AAG5C,YAAM,OAAO,IAAI;AACjB,UAAI,SAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM,KAAK,CAAC,QAAQ,CAAC,OAAO,UAAU,eAAe,KAAK,QAAQ,GAAG,CAAC,GAAG;AAC3E,cAAM,IAAI,MAAM,2CAA2C,OAAO,KAAK,KAAK,KAAK,GAAG,CAAC,EAAE;;AAGzF,UAAI,IAAI,gBAAgB;AACtB,cAAM,QAAQ,IAAI,eAAe,OAAO,OAAO,CAAC;AAChD,YAAI,CAAC,OAAO;AACV,gBAAM,MACJ,YAAY,OAAO,+BAA+B,aAAa,QAC/D,KAAK,WAAW,IAAI,eAAe,MAAM;AAC3C,cAAI,KAAK,mBAAmB;AAAO,iBAAK,OAAO,MAAM,GAAG;;AACnD,kBAAM,IAAI,MAAM,GAAG;;;IAG9B;AAzBgB;AAAhB,IAAAA,SAAA,uBAAA;;;;;;;;;;AC/IA,QAAA,YAAA;AACA,QAAA,SAAA;AA6CA,aAAgB,aACd,IACA,EAAC,SAAS,YAAY,QAAQ,YAAY,eAAe,aAAY,GAAgB;AAErF,UAAI,YAAY,UAAa,WAAW,QAAW;AACjD,cAAM,IAAI,MAAM,sDAAsD;;AAGxE,UAAI,YAAY,QAAW;AACzB,cAAM,MAAM,GAAG,OAAO,OAAO;AAC7B,eAAO,eAAe,SAClB;UACE,QAAQ;UACR,aAAY,GAAA,UAAA,KAAI,GAAG,UAAU,IAAG,GAAA,UAAA,aAAY,OAAO,CAAC;UACpD,eAAe,GAAG,GAAG,aAAa,IAAI,OAAO;YAE/C;UACE,QAAQ,IAAI,UAAU;UACtB,aAAY,GAAA,UAAA,KAAI,GAAG,UAAU,IAAG,GAAA,UAAA,aAAY,OAAO,CAAC,IAAG,GAAA,UAAA,aAAY,UAAU,CAAC;UAC9E,eAAe,GAAG,GAAG,aAAa,IAAI,OAAO,KAAI,GAAA,OAAA,gBAAe,UAAU,CAAC;;;AAInF,UAAI,WAAW,QAAW;AACxB,YAAI,eAAe,UAAa,kBAAkB,UAAa,iBAAiB,QAAW;AACzF,gBAAM,IAAI,MAAM,6EAA6E;;AAE/F,eAAO;UACL;UACA;UACA;UACA;;;AAIJ,YAAM,IAAI,MAAM,6CAA6C;IAC/D;AApCgB;AAAhB,IAAAE,SAAA,eAAA;AAsCA,aAAgB,oBACd,WACA,IACA,EAAC,UAAU,cAAc,QAAQ,MAAM,WAAW,aAAY,GAAgB;AAE9E,UAAI,SAAS,UAAa,aAAa,QAAW;AAChD,cAAM,IAAI,MAAM,qDAAqD;;AAGvE,YAAM,EAAC,IAAG,IAAI;AAEd,UAAI,aAAa,QAAW;AAC1B,cAAM,EAAC,WAAW,aAAa,KAAI,IAAI;AACvC,cAAM,WAAW,IAAI,IAAI,SAAQ,GAAA,UAAA,KAAI,GAAG,IAAI,IAAG,GAAA,UAAA,aAAY,QAAQ,CAAC,IAAI,IAAI;AAC5E,yBAAiB,QAAQ;AACzB,kBAAU,aAAY,GAAA,UAAA,OAAM,SAAS,IAAG,GAAA,OAAA,cAAa,UAAU,QAAQ,KAAK,gBAAgB,CAAC;AAC7F,kBAAU,sBAAqB,GAAA,UAAA,KAAI,QAAQ;AAC3C,kBAAU,cAAc,CAAC,GAAG,aAAa,UAAU,kBAAkB;;AAGvE,UAAI,SAAS,QAAW;AACtB,cAAM,WAAW,gBAAgB,UAAA,OAAO,OAAO,IAAI,IAAI,QAAQ,MAAM,IAAI;AACzE,yBAAiB,QAAQ;AACzB,YAAI,iBAAiB;AAAW,oBAAU,eAAe;;AAI3D,UAAI;AAAW,kBAAU,YAAY;AAErC,eAAS,iBAAiB,WAAe;AACvC,kBAAU,OAAO;AACjB,kBAAU,YAAY,GAAG,YAAY;AACrC,kBAAU,YAAY,CAAA;AACtB,WAAG,oBAAoB,oBAAI,IAAG;AAC9B,kBAAU,aAAa,GAAG;AAC1B,kBAAU,YAAY,CAAC,GAAG,GAAG,WAAW,SAAS;MACnD;AAPS;IAQX;AArCgB;AAAhB,IAAAA,SAAA,sBAAA;AAuCA,aAAgB,oBACd,WACA,EAAC,kBAAkB,aAAa,eAAe,cAAc,UAAS,GAAgB;AAEtF,UAAI,kBAAkB;AAAW,kBAAU,gBAAgB;AAC3D,UAAI,iBAAiB;AAAW,kBAAU,eAAe;AACzD,UAAI,cAAc;AAAW,kBAAU,YAAY;AACnD,gBAAU,mBAAmB;AAC7B,gBAAU,cAAc;IAC1B;AATgB;AAAhB,IAAAA,SAAA,sBAAA;;;;;AC7HA;AAAA,2HAAAC,UAAAC,SAAA;AAAA;AAMA,IAAAA,QAAO,UAAU,gCAAS,MAAM,GAAG,GAAG;AACpC,UAAI,MAAM;AAAG,eAAO;AAEpB,UAAI,KAAK,KAAK,OAAO,KAAK,YAAY,OAAO,KAAK,UAAU;AAC1D,YAAI,EAAE,gBAAgB,EAAE;AAAa,iBAAO;AAE5C,YAAI,QAAQ,GAAG;AACf,YAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,mBAAS,EAAE;AACX,cAAI,UAAU,EAAE;AAAQ,mBAAO;AAC/B,eAAK,IAAI,QAAQ,QAAQ;AACvB,gBAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AAAG,qBAAO;AACjC,iBAAO;AAAA,QACT;AAIA,YAAI,EAAE,gBAAgB;AAAQ,iBAAO,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE;AAC5E,YAAI,EAAE,YAAY,OAAO,UAAU;AAAS,iBAAO,EAAE,QAAQ,MAAM,EAAE,QAAQ;AAC7E,YAAI,EAAE,aAAa,OAAO,UAAU;AAAU,iBAAO,EAAE,SAAS,MAAM,EAAE,SAAS;AAEjF,eAAO,OAAO,KAAK,CAAC;AACpB,iBAAS,KAAK;AACd,YAAI,WAAW,OAAO,KAAK,CAAC,EAAE;AAAQ,iBAAO;AAE7C,aAAK,IAAI,QAAQ,QAAQ;AACvB,cAAI,CAAC,OAAO,UAAU,eAAe,KAAK,GAAG,KAAK,CAAC,CAAC;AAAG,mBAAO;AAEhE,aAAK,IAAI,QAAQ,QAAQ,KAAI;AAC3B,cAAI,MAAM,KAAK,CAAC;AAEhB,cAAI,CAAC,MAAM,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC;AAAG,mBAAO;AAAA,QACrC;AAEA,eAAO;AAAA,MACT;AAGA,aAAO,MAAI,KAAK,MAAI;AAAA,IACtB,GAvCiB;AAAA;AAAA;;;ACNjB;AAAA,gIAAAC,UAAAC,SAAA;AAAA;AAEA,QAAI,WAAWA,QAAO,UAAU,SAAU,QAAQ,MAAM,IAAI;AAE1D,UAAI,OAAO,QAAQ,YAAY;AAC7B,aAAK;AACL,eAAO,CAAC;AAAA,MACV;AAEA,WAAK,KAAK,MAAM;AAChB,UAAI,MAAO,OAAO,MAAM,aAAc,KAAK,GAAG,OAAO,WAAW;AAAA,MAAC;AACjE,UAAI,OAAO,GAAG,QAAQ,WAAW;AAAA,MAAC;AAElC,gBAAU,MAAM,KAAK,MAAM,QAAQ,IAAI,MAAM;AAAA,IAC/C;AAGA,aAAS,WAAW;AAAA,MAClB,iBAAiB;AAAA,MACjB,OAAO;AAAA,MACP,UAAU;AAAA,MACV,sBAAsB;AAAA,MACtB,eAAe;AAAA,MACf,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,IACR;AAEA,aAAS,gBAAgB;AAAA,MACvB,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,IACT;AAEA,aAAS,gBAAgB;AAAA,MACvB,OAAO;AAAA,MACP,aAAa;AAAA,MACb,YAAY;AAAA,MACZ,mBAAmB;AAAA,MACnB,cAAc;AAAA,IAChB;AAEA,aAAS,eAAe;AAAA,MACtB,SAAS;AAAA,MACT,MAAM;AAAA,MACN,OAAO;AAAA,MACP,UAAU;AAAA,MACV,SAAS;AAAA,MACT,SAAS;AAAA,MACT,kBAAkB;AAAA,MAClB,kBAAkB;AAAA,MAClB,YAAY;AAAA,MACZ,WAAW;AAAA,MACX,WAAW;AAAA,MACX,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,UAAU;AAAA,MACV,aAAa;AAAA,MACb,eAAe;AAAA,MACf,eAAe;AAAA,IACjB;AAGA,aAAS,UAAU,MAAM,KAAK,MAAM,QAAQ,SAAS,YAAY,eAAe,eAAe,cAAc,UAAU;AACrH,UAAI,UAAU,OAAO,UAAU,YAAY,CAAC,MAAM,QAAQ,MAAM,GAAG;AACjE,YAAI,QAAQ,SAAS,YAAY,eAAe,eAAe,cAAc,QAAQ;AACrF,iBAAS,OAAO,QAAQ;AACtB,cAAI,MAAM,OAAO,GAAG;AACpB,cAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,gBAAI,OAAO,SAAS,eAAe;AACjC,uBAAS,IAAE,GAAG,IAAE,IAAI,QAAQ;AAC1B,0BAAU,MAAM,KAAK,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,MAAM,MAAM,GAAG,YAAY,SAAS,KAAK,QAAQ,CAAC;AAAA,YACzG;AAAA,UACF,WAAW,OAAO,SAAS,eAAe;AACxC,gBAAI,OAAO,OAAO,OAAO,UAAU;AACjC,uBAAS,QAAQ;AACf,0BAAU,MAAM,KAAK,MAAM,IAAI,IAAI,GAAG,UAAU,MAAM,MAAM,MAAM,cAAc,IAAI,GAAG,YAAY,SAAS,KAAK,QAAQ,IAAI;AAAA,YACjI;AAAA,UACF,WAAW,OAAO,SAAS,YAAa,KAAK,WAAW,EAAE,OAAO,SAAS,eAAgB;AACxF,sBAAU,MAAM,KAAK,MAAM,KAAK,UAAU,MAAM,KAAK,YAAY,SAAS,KAAK,MAAM;AAAA,UACvF;AAAA,QACF;AACA,aAAK,QAAQ,SAAS,YAAY,eAAe,eAAe,cAAc,QAAQ;AAAA,MACxF;AAAA,IACF;AArBS;AAwBT,aAAS,cAAc,KAAK;AAC1B,aAAO,IAAI,QAAQ,MAAM,IAAI,EAAE,QAAQ,OAAO,IAAI;AAAA,IACpD;AAFS;AAAA;AAAA;;;;;;;;ACvFT,QAAA,SAAA;AACA,QAAA,QAAA;AACA,QAAA,WAAA;AAMA,QAAM,iBAAiB,oBAAI,IAAI;MAC7B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAED,aAAgB,UAAU,QAAmB,QAA0B,MAAI;AACzE,UAAI,OAAO,UAAU;AAAW,eAAO;AACvC,UAAI,UAAU;AAAM,eAAO,CAAC,OAAO,MAAM;AACzC,UAAI,CAAC;AAAO,eAAO;AACnB,aAAO,UAAU,MAAM,KAAK;IAC9B;AALgB;AAAhB,IAAAC,SAAA,YAAA;AAOA,QAAM,eAAe,oBAAI,IAAI;MAC3B;MACA;MACA;MACA;MACA;KACD;AAED,aAAS,OAAO,QAAuB;AACrC,iBAAW,OAAO,QAAQ;AACxB,YAAI,aAAa,IAAI,GAAG;AAAG,iBAAO;AAClC,cAAM,MAAM,OAAO,GAAG;AACtB,YAAI,MAAM,QAAQ,GAAG,KAAK,IAAI,KAAK,MAAM;AAAG,iBAAO;AACnD,YAAI,OAAO,OAAO,YAAY,OAAO,GAAG;AAAG,iBAAO;;AAEpD,aAAO;IACT;AARS;AAUT,aAAS,UAAU,QAAuB;AACxC,UAAI,QAAQ;AACZ,iBAAW,OAAO,QAAQ;AACxB,YAAI,QAAQ;AAAQ,iBAAO;AAC3B;AACA,YAAI,eAAe,IAAI,GAAG;AAAG;AAC7B,YAAI,OAAO,OAAO,GAAG,KAAK,UAAU;AAClC,WAAA,GAAA,OAAA,UAAS,OAAO,GAAG,GAAG,CAAC,QAAS,SAAS,UAAU,GAAG,CAAE;;AAE1D,YAAI,UAAU;AAAU,iBAAO;;AAEjC,aAAO;IACT;AAZS;AAcT,aAAgB,YAAY,UAAuB,KAAK,IAAI,WAAmB;AAC7E,UAAI,cAAc;AAAO,aAAK,YAAY,EAAE;AAC5C,YAAM,IAAI,SAAS,MAAM,EAAE;AAC3B,aAAO,aAAa,UAAU,CAAC;IACjC;AAJgB;AAAhB,IAAAA,SAAA,cAAA;AAMA,aAAgB,aAAa,UAAuB,GAAgB;AAClE,YAAM,aAAa,SAAS,UAAU,CAAC;AACvC,aAAO,WAAW,MAAM,GAAG,EAAE,CAAC,IAAI;IACpC;AAHgB;AAAhB,IAAAA,SAAA,eAAA;AAKA,QAAM,sBAAsB;AAC5B,aAAgB,YAAY,IAAsB;AAChD,aAAO,KAAK,GAAG,QAAQ,qBAAqB,EAAE,IAAI;IACpD;AAFgB;AAAhB,IAAAA,SAAA,cAAA;AAIA,aAAgB,WAAW,UAAuB,QAAgB,IAAU;AAC1E,WAAK,YAAY,EAAE;AACnB,aAAO,SAAS,QAAQ,QAAQ,EAAE;IACpC;AAHgB;AAAhB,IAAAA,SAAA,aAAA;AAKA,QAAM,SAAS;AAEf,aAAgB,cAAyB,QAAmB,QAAc;AACxE,UAAI,OAAO,UAAU;AAAW,eAAO,CAAA;AACvC,YAAM,EAAC,UAAU,YAAW,IAAI,KAAK;AACrC,YAAM,QAAQ,YAAY,OAAO,QAAQ,KAAK,MAAM;AACpD,YAAM,UAA0C,EAAC,IAAI,MAAK;AAC1D,YAAM,aAAa,YAAY,aAAa,OAAO,KAAK;AACxD,YAAM,YAAuB,CAAA;AAC7B,YAAM,aAA0B,oBAAI,IAAG;AAEvC,eAAS,QAAQ,EAAC,SAAS,KAAI,GAAG,CAAC,KAAK,SAAS,GAAG,kBAAiB;AACnE,YAAI,kBAAkB;AAAW;AACjC,cAAM,WAAW,aAAa;AAC9B,YAAIC,UAAS,QAAQ,aAAa;AAClC,YAAI,OAAO,IAAI,QAAQ,KAAK;AAAU,UAAAA,UAAS,OAAO,KAAK,MAAM,IAAI,QAAQ,CAAC;AAC9E,kBAAU,KAAK,MAAM,IAAI,OAAO;AAChC,kBAAU,KAAK,MAAM,IAAI,cAAc;AACvC,gBAAQ,OAAO,IAAIA;AAEnB,iBAAS,OAAkB,KAAW;AAEpC,gBAAM,WAAW,KAAK,KAAK,YAAY;AACvC,gBAAM,YAAYA,UAAS,SAASA,SAAQ,GAAG,IAAI,GAAG;AACtD,cAAI,WAAW,IAAI,GAAG;AAAG,kBAAM,SAAS,GAAG;AAC3C,qBAAW,IAAI,GAAG;AAClB,cAAI,WAAW,KAAK,KAAK,GAAG;AAC5B,cAAI,OAAO,YAAY;AAAU,uBAAW,KAAK,KAAK,QAAQ;AAC9D,cAAI,OAAO,YAAY,UAAU;AAC/B,6BAAiB,KAAK,SAAS,QAAQ,GAAG;qBACjC,QAAQ,YAAY,QAAQ,GAAG;AACxC,gBAAI,IAAI,CAAC,MAAM,KAAK;AAClB,+BAAiB,KAAK,UAAU,GAAG,GAAG,GAAG;AACzC,wBAAU,GAAG,IAAI;mBACZ;AACL,mBAAK,KAAK,GAAG,IAAI;;;AAGrB,iBAAO;QACT;AAnBS;AAqBT,iBAAS,UAAqB,QAAe;AAC3C,cAAI,OAAO,UAAU,UAAU;AAC7B,gBAAI,CAAC,OAAO,KAAK,MAAM;AAAG,oBAAM,IAAI,MAAM,mBAAmB,MAAM,GAAG;AACtE,mBAAO,KAAK,MAAM,IAAI,MAAM,EAAE;;QAElC;AALS;MAMX,CAAC;AAED,aAAO;AAEP,eAAS,iBAAiB,MAAiB,MAA6B,KAAW;AACjF,YAAI,SAAS,UAAa,CAAC,MAAM,MAAM,IAAI;AAAG,gBAAM,SAAS,GAAG;MAClE;AAFS;AAIT,eAAS,SAAS,KAAW;AAC3B,eAAO,IAAI,MAAM,cAAc,GAAG,oCAAoC;MACxE;AAFS;IAGX;AAxDgB;AAAhB,IAAAD,SAAA,gBAAA;;;;;;;;;;ACnFA,QAAA,eAAA;AACA,QAAA,aAAA;AACA,QAAA,kBAAA;AACA,QAAA,aAAA;AACA,QAAA,aAAA;AACA,QAAA,YAAA;AACA,QAAA,cAAA;AACA,QAAA,YAAA;AACA,QAAA,UAAA;AACA,QAAA,YAAA;AACA,QAAA,SAAA;AASA,QAAA,WAAA;AASA,aAAgB,qBAAqB,IAAa;AAChD,UAAI,YAAY,EAAE,GAAG;AACnB,sBAAc,EAAE;AAChB,YAAI,kBAAkB,EAAE,GAAG;AACzB,2BAAiB,EAAE;AACnB;;;AAGJ,uBAAiB,IAAI,OAAM,GAAA,aAAA,sBAAqB,EAAE,CAAC;IACrD;AATgB;AAAhB,IAAAE,SAAA,uBAAA;AAWA,aAAS,iBACP,EAAC,KAAK,cAAc,QAAQ,WAAW,KAAI,GAC3C,MAAW;AAEX,UAAI,KAAK,KAAK,KAAK;AACjB,YAAI,KAAK,eAAc,GAAA,UAAA,KAAI,QAAA,QAAE,IAAI,KAAK,QAAA,QAAE,MAAM,IAAI,UAAU,QAAQ,MAAK;AACvE,cAAI,MAAK,GAAA,UAAA,mBAAkB,cAAc,QAAQ,IAAI,CAAC,EAAE;AACxD,+BAAqB,KAAK,IAAI;AAC9B,cAAI,KAAK,IAAI;QACf,CAAC;aACI;AACL,YAAI,KAAK,eAAc,GAAA,UAAA,KAAI,QAAA,QAAE,IAAI,KAAK,kBAAkB,IAAI,CAAC,IAAI,UAAU,QAAQ,MACjF,IAAI,KAAK,cAAc,QAAQ,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC;;IAGtD;AAfS;AAiBT,aAAS,kBAAkB,MAAqB;AAC9C,cAAO,GAAA,UAAA,MAAK,QAAA,QAAE,YAAY,QAAQ,QAAA,QAAE,UAAU,KAAK,QAAA,QAAE,kBAAkB,KAAK,QAAA,QAAE,QAAQ,IACpF,QAAA,QAAE,IACJ,GAAG,KAAK,cAAa,GAAA,UAAA,OAAM,QAAA,QAAE,cAAc,QAAQ,UAAA,GAAG;IACxD;AAJS;AAMT,aAAS,qBAAqB,KAAc,MAAqB;AAC/D,UAAI,GACF,QAAA,QAAE,QACF,MAAK;AACH,YAAI,IAAI,QAAA,QAAE,eAAc,GAAA,UAAA,KAAI,QAAA,QAAE,MAAM,IAAI,QAAA,QAAE,YAAY,EAAE;AACxD,YAAI,IAAI,QAAA,QAAE,aAAY,GAAA,UAAA,KAAI,QAAA,QAAE,MAAM,IAAI,QAAA,QAAE,UAAU,EAAE;AACpD,YAAI,IAAI,QAAA,QAAE,qBAAoB,GAAA,UAAA,KAAI,QAAA,QAAE,MAAM,IAAI,QAAA,QAAE,kBAAkB,EAAE;AACpE,YAAI,IAAI,QAAA,QAAE,WAAU,GAAA,UAAA,KAAI,QAAA,QAAE,MAAM,IAAI,QAAA,QAAE,QAAQ,EAAE;AAChD,YAAI,KAAK;AAAY,cAAI,IAAI,QAAA,QAAE,iBAAgB,GAAA,UAAA,KAAI,QAAA,QAAE,MAAM,IAAI,QAAA,QAAE,cAAc,EAAE;MACnF,GACA,MAAK;AACH,YAAI,IAAI,QAAA,QAAE,eAAc,GAAA,UAAA,MAAK;AAC7B,YAAI,IAAI,QAAA,QAAE,aAAY,GAAA,UAAA,aAAY;AAClC,YAAI,IAAI,QAAA,QAAE,qBAAoB,GAAA,UAAA,aAAY;AAC1C,YAAI,IAAI,QAAA,QAAE,UAAU,QAAA,QAAE,IAAI;AAC1B,YAAI,KAAK;AAAY,cAAI,IAAI,QAAA,QAAE,iBAAgB,GAAA,UAAA,MAAK;MACtD,CAAC;IAEL;AAlBS;AAoBT,aAAS,iBAAiB,IAAgB;AACxC,YAAM,EAAC,QAAQ,MAAM,IAAG,IAAI;AAC5B,uBAAiB,IAAI,MAAK;AACxB,YAAI,KAAK,YAAY,OAAO;AAAU,yBAAe,EAAE;AACvD,uBAAe,EAAE;AACjB,YAAI,IAAI,QAAA,QAAE,SAAS,IAAI;AACvB,YAAI,IAAI,QAAA,QAAE,QAAQ,CAAC;AACnB,YAAI,KAAK;AAAa,yBAAe,EAAE;AACvC,wBAAgB,EAAE;AAClB,sBAAc,EAAE;MAClB,CAAC;AACD;IACF;AAZS;AAcT,aAAS,eAAe,IAAgB;AAEtC,YAAM,EAAC,KAAK,aAAY,IAAI;AAC5B,SAAG,YAAY,IAAI,MAAM,cAAa,GAAA,UAAA,KAAI,YAAY,YAAY;AAClE,UAAI,IAAG,GAAA,UAAA,KAAI,GAAG,SAAS,iBAAiB,MAAM,IAAI,QAAO,GAAA,UAAA,KAAI,GAAG,SAAS,WAAU,GAAA,UAAA,aAAY,CAAC;AAChG,UAAI,IAAG,GAAA,UAAA,KAAI,GAAG,SAAS,iBAAiB,MAAM,IAAI,QAAO,GAAA,UAAA,KAAI,GAAG,SAAS,WAAU,GAAA,UAAA,aAAY,CAAC;IAClG;AANS;AAQT,aAAS,cAAc,QAAmB,MAAqB;AAC7D,YAAM,QAAQ,OAAO,UAAU,YAAY,OAAO,KAAK,QAAQ;AAC/D,aAAO,UAAU,KAAK,KAAK,UAAU,KAAK,KAAK,YAAW,GAAA,UAAA,mBAAkB,KAAK,QAAQ,UAAA;IAC3F;AAHS;AAMT,aAAS,cAAc,IAAe,OAAW;AAC/C,UAAI,YAAY,EAAE,GAAG;AACnB,sBAAc,EAAE;AAChB,YAAI,kBAAkB,EAAE,GAAG;AACzB,2BAAiB,IAAI,KAAK;AAC1B;;;AAGJ,OAAA,GAAA,aAAA,mBAAkB,IAAI,KAAK;IAC7B;AATS;AAWT,aAAS,kBAAkB,EAAC,QAAQ,KAAI,GAAY;AAClD,UAAI,OAAO,UAAU;AAAW,eAAO,CAAC;AACxC,iBAAW,OAAO;AAAQ,YAAI,KAAK,MAAM,IAAI,GAAG;AAAG,iBAAO;AAC1D,aAAO;IACT;AAJS;AAMT,aAAS,YAAY,IAAa;AAChC,aAAO,OAAO,GAAG,UAAU;IAC7B;AAFS;AAIT,aAAS,iBAAiB,IAAkB,OAAW;AACrD,YAAM,EAAC,QAAQ,KAAK,KAAI,IAAI;AAC5B,UAAI,KAAK,YAAY,OAAO;AAAU,uBAAe,EAAE;AACvD,oBAAc,EAAE;AAChB,uBAAiB,EAAE;AACnB,YAAM,YAAY,IAAI,MAAM,SAAS,QAAA,QAAE,MAAM;AAC7C,sBAAgB,IAAI,SAAS;AAE7B,UAAI,IAAI,QAAO,GAAA,UAAA,KAAI,SAAS,QAAQ,QAAA,QAAE,MAAM,EAAE;IAChD;AATS;AAWT,aAAS,cAAc,IAAgB;AACrC,OAAA,GAAA,OAAA,mBAAkB,EAAE;AACpB,2BAAqB,EAAE;IACzB;AAHS;AAKT,aAAS,gBAAgB,IAAkB,WAAgB;AACzD,UAAI,GAAG,KAAK;AAAK,eAAO,eAAe,IAAI,CAAA,GAAI,OAAO,SAAS;AAC/D,YAAM,SAAQ,GAAA,WAAA,gBAAe,GAAG,MAAM;AACtC,YAAM,gBAAe,GAAA,WAAA,wBAAuB,IAAI,KAAK;AACrD,qBAAe,IAAI,OAAO,CAAC,cAAc,SAAS;IACpD;AALS;AAOT,aAAS,qBAAqB,IAAgB;AAC5C,YAAM,EAAC,QAAQ,eAAe,MAAM,KAAI,IAAI;AAC5C,UAAI,OAAO,QAAQ,KAAK,0BAAyB,GAAA,OAAA,sBAAqB,QAAQ,KAAK,KAAK,GAAG;AACzF,aAAK,OAAO,KAAK,6CAA6C,aAAa,GAAG;;IAElF;AALS;AAOT,aAAS,eAAe,IAAgB;AACtC,YAAM,EAAC,QAAQ,KAAI,IAAI;AACvB,UAAI,OAAO,YAAY,UAAa,KAAK,eAAe,KAAK,cAAc;AACzE,SAAA,GAAA,OAAA,iBAAgB,IAAI,uCAAuC;;IAE/D;AALS;AAOT,aAAS,cAAc,IAAgB;AACrC,YAAM,QAAQ,GAAG,OAAO,GAAG,KAAK,QAAQ;AACxC,UAAI;AAAO,WAAG,UAAS,GAAA,UAAA,YAAW,GAAG,KAAK,aAAa,GAAG,QAAQ,KAAK;IACzE;AAHS;AAKT,aAAS,iBAAiB,IAAgB;AACxC,UAAI,GAAG,OAAO,UAAU,CAAC,GAAG,UAAU;AAAQ,cAAM,IAAI,MAAM,6BAA6B;IAC7F;AAFS;AAIT,aAAS,eAAe,EAAC,KAAK,WAAW,QAAQ,eAAe,KAAI,GAAe;AACjF,YAAM,MAAM,OAAO;AACnB,UAAI,KAAK,aAAa,MAAM;AAC1B,YAAI,MAAK,GAAA,UAAA,KAAI,QAAA,QAAE,IAAI,eAAe,GAAG,GAAG;iBAC/B,OAAO,KAAK,YAAY,YAAY;AAC7C,cAAM,cAAa,GAAA,UAAA,OAAM,aAAa;AACtC,cAAM,WAAW,IAAI,WAAW,QAAQ,EAAC,KAAK,UAAU,KAAI,CAAC;AAC7D,YAAI,MAAK,GAAA,UAAA,KAAI,QAAA,QAAE,IAAI,kBAAkB,GAAG,KAAK,UAAU,KAAK,QAAQ,UAAU;;IAElF;AATS;AAWT,aAAS,cAAc,IAAa;AAClC,YAAM,EAAC,KAAK,WAAW,cAAc,iBAAiB,KAAI,IAAI;AAC9D,UAAI,UAAU,QAAQ;AAEpB,YAAI,IACF,GAAA,UAAA,KAAI,QAAA,QAAE,MAAM,UACZ,MAAM,IAAI,OAAO,QAAA,QAAE,IAAI,GACvB,MAAM,IAAI,OAAM,GAAA,UAAA,SAAQ,eAAuB,IAAI,QAAA,QAAE,OAAO,GAAG,CAAC;aAE7D;AACL,YAAI,QAAO,GAAA,UAAA,KAAI,YAAY,WAAW,QAAA,QAAE,OAAO;AAC/C,YAAI,KAAK;AAAa,0BAAgB,EAAE;AACxC,YAAI,QAAO,GAAA,UAAA,KAAI,QAAA,QAAE,MAAM,QAAQ;;IAEnC;AAdS;AAgBT,aAAS,gBAAgB,EAAC,KAAK,WAAW,OAAO,MAAK,GAAY;AAChE,UAAI,iBAAiB,UAAA;AAAM,YAAI,QAAO,GAAA,UAAA,KAAI,SAAS,UAAU,KAAK;AAClE,UAAI,iBAAiB,UAAA;AAAM,YAAI,QAAO,GAAA,UAAA,KAAI,SAAS,UAAU,KAAK;IACpE;AAHS;AAKT,aAAS,eACP,IACA,OACA,YACA,WAAgB;AAEhB,YAAM,EAAC,KAAK,QAAQ,MAAM,WAAW,MAAM,KAAI,IAAI;AACnD,YAAM,EAAC,MAAK,IAAI;AAChB,UAAI,OAAO,SAAS,KAAK,yBAAyB,EAAC,GAAA,OAAA,sBAAqB,QAAQ,KAAK,IAAI;AACvF,YAAI,MAAM,MAAM,YAAY,IAAI,QAAS,MAAM,IAAI,KAAc,UAAU,CAAC;AAC5E;;AAEF,UAAI,CAAC,KAAK;AAAK,yBAAiB,IAAI,KAAK;AACzC,UAAI,MAAM,MAAK;AACb,mBAAW,SAAS,MAAM;AAAO,wBAAc,KAAK;AACpD,sBAAc,MAAM,IAAI;MAC1B,CAAC;AAED,eAAS,cAAc,OAAgB;AACrC,YAAI,EAAC,GAAA,gBAAA,gBAAe,QAAQ,KAAK;AAAG;AACpC,YAAI,MAAM,MAAM;AACd,cAAI,IAAG,GAAA,WAAA,eAAc,MAAM,MAAM,MAAM,KAAK,aAAa,CAAC;AAC1D,0BAAgB,IAAI,KAAK;AACzB,cAAI,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,MAAM,QAAQ,YAAY;AAC/D,gBAAI,KAAI;AACR,aAAA,GAAA,WAAA,iBAAgB,EAAE;;AAEpB,cAAI,MAAK;eACJ;AACL,0BAAgB,IAAI,KAAK;;AAG3B,YAAI,CAAC;AAAW,cAAI,IAAG,GAAA,UAAA,KAAI,QAAA,QAAE,MAAM,QAAQ,aAAa,CAAC,EAAE;MAC7D;AAfS;IAgBX;AAlCS;AAoCT,aAAS,gBAAgB,IAAkB,OAAgB;AACzD,YAAM,EACJ,KACA,QACA,MAAM,EAAC,YAAW,EAAC,IACjB;AACJ,UAAI;AAAa,SAAA,GAAA,WAAA,gBAAe,IAAI,MAAM,IAAI;AAC9C,UAAI,MAAM,MAAK;AACb,mBAAW,QAAQ,MAAM,OAAO;AAC9B,eAAI,GAAA,gBAAA,eAAc,QAAQ,IAAI,GAAG;AAC/B,wBAAY,IAAI,KAAK,SAAS,KAAK,YAAY,MAAM,IAAI;;;MAG/D,CAAC;IACH;AAdS;AAgBT,aAAS,iBAAiB,IAAkB,OAAiB;AAC3D,UAAI,GAAG,UAAU,QAAQ,CAAC,GAAG,KAAK;AAAa;AAC/C,wBAAkB,IAAI,KAAK;AAC3B,UAAI,CAAC,GAAG,KAAK;AAAiB,2BAAmB,IAAI,KAAK;AAC1D,wBAAkB,IAAI,GAAG,SAAS;IACpC;AALS;AAOT,aAAS,kBAAkB,IAAkB,OAAiB;AAC5D,UAAI,CAAC,MAAM;AAAQ;AACnB,UAAI,CAAC,GAAG,UAAU,QAAQ;AACxB,WAAG,YAAY;AACf;;AAEF,YAAM,QAAQ,CAAC,MAAK;AAClB,YAAI,CAAC,aAAa,GAAG,WAAW,CAAC,GAAG;AAClC,2BAAiB,IAAI,SAAS,CAAC,6BAA6B,GAAG,UAAU,KAAK,GAAG,CAAC,GAAG;;MAEzF,CAAC;AACD,wBAAkB,IAAI,KAAK;IAC7B;AAZS;AAcT,aAAS,mBAAmB,IAAkB,IAAc;AAC1D,UAAI,GAAG,SAAS,KAAK,EAAE,GAAG,WAAW,KAAK,GAAG,SAAS,MAAM,IAAI;AAC9D,yBAAiB,IAAI,iDAAiD;;IAE1E;AAJS;AAMT,aAAS,kBAAkB,IAAkB,IAAc;AACzD,YAAM,QAAQ,GAAG,KAAK,MAAM;AAC5B,iBAAW,WAAW,OAAO;AAC3B,cAAM,OAAO,MAAM,OAAO;AAC1B,YAAI,OAAO,QAAQ,aAAY,GAAA,gBAAA,eAAc,GAAG,QAAQ,IAAI,GAAG;AAC7D,gBAAM,EAAC,KAAI,IAAI,KAAK;AACpB,cAAI,KAAK,UAAU,CAAC,KAAK,KAAK,CAAC,MAAM,kBAAkB,IAAI,CAAC,CAAC,GAAG;AAC9D,6BAAiB,IAAI,iBAAiB,KAAK,KAAK,GAAG,CAAC,kBAAkB,OAAO,GAAG;;;;IAIxF;AAXS;AAaT,aAAS,kBAAkB,OAAmB,MAAc;AAC1D,aAAO,MAAM,SAAS,IAAI,KAAM,SAAS,YAAY,MAAM,SAAS,SAAS;IAC/E;AAFS;AAIT,aAAS,aAAa,IAAgB,GAAW;AAC/C,aAAO,GAAG,SAAS,CAAC,KAAM,MAAM,aAAa,GAAG,SAAS,QAAQ;IACnE;AAFS;AAIT,aAAS,kBAAkB,IAAkB,WAAqB;AAChE,YAAM,KAAiB,CAAA;AACvB,iBAAW,KAAK,GAAG,WAAW;AAC5B,YAAI,aAAa,WAAW,CAAC;AAAG,aAAG,KAAK,CAAC;iBAChC,UAAU,SAAS,SAAS,KAAK,MAAM;AAAU,aAAG,KAAK,SAAS;;AAE7E,SAAG,YAAY;IACjB;AAPS;AAST,aAAS,iBAAiB,IAAkB,KAAW;AACrD,YAAM,aAAa,GAAG,UAAU,SAAS,GAAG;AAC5C,aAAO,QAAQ,UAAU;AACzB,OAAA,GAAA,OAAA,iBAAgB,IAAI,KAAK,GAAG,KAAK,WAAW;IAC9C;AAJS;AAMT,QAAa,aAAb,MAAuB;aAAA;;;MAiBrB,YAAY,IAAkB,KAA6B,SAAe;AACxE,SAAA,GAAA,UAAA,sBAAqB,IAAI,KAAK,OAAO;AACrC,aAAK,MAAM,GAAG;AACd,aAAK,YAAY,GAAG;AACpB,aAAK,UAAU;AACf,aAAK,OAAO,GAAG;AACf,aAAK,SAAS,GAAG,OAAO,OAAO;AAC/B,aAAK,QAAQ,IAAI,SAAS,GAAG,KAAK,SAAS,KAAK,UAAU,KAAK,OAAO;AACtE,aAAK,eAAc,GAAA,OAAA,gBAAe,IAAI,KAAK,QAAQ,SAAS,KAAK,KAAK;AACtE,aAAK,aAAa,IAAI;AACtB,aAAK,eAAe,GAAG;AACvB,aAAK,SAAS,CAAA;AACd,aAAK,KAAK;AACV,aAAK,MAAM;AAEX,YAAI,KAAK,OAAO;AACd,eAAK,aAAa,GAAG,IAAI,MAAM,WAAW,QAAQ,KAAK,OAAO,EAAE,CAAC;eAC5D;AACL,eAAK,aAAa,KAAK;AACvB,cAAI,EAAC,GAAA,UAAA,iBAAgB,KAAK,QAAQ,IAAI,YAAY,IAAI,cAAc,GAAG;AACrE,kBAAM,IAAI,MAAM,GAAG,OAAO,kBAAkB,KAAK,UAAU,IAAI,UAAU,CAAC,EAAE;;;AAIhF,YAAI,UAAU,MAAM,IAAI,cAAc,IAAI,WAAW,OAAO;AAC1D,eAAK,YAAY,GAAG,IAAI,MAAM,SAAS,QAAA,QAAE,MAAM;;MAEnD;MAEA,OAAO,WAAiB,eAA4B,YAAuB;AACzE,aAAK,YAAW,GAAA,UAAA,KAAI,SAAS,GAAG,eAAe,UAAU;MAC3D;MAEA,WAAW,WAAiB,eAA4B,YAAuB;AAC7E,aAAK,IAAI,GAAG,SAAS;AACrB,YAAI;AAAY,qBAAU;;AACrB,eAAK,MAAK;AACf,YAAI,eAAe;AACjB,eAAK,IAAI,KAAI;AACb,wBAAa;AACb,cAAI,KAAK;AAAW,iBAAK,IAAI,MAAK;eAC7B;AACL,cAAI,KAAK;AAAW,iBAAK,IAAI,MAAK;;AAC7B,iBAAK,IAAI,KAAI;;MAEtB;MAEA,KAAK,WAAiB,YAAuB;AAC3C,aAAK,YAAW,GAAA,UAAA,KAAI,SAAS,GAAG,QAAW,UAAU;MACvD;MAEA,KAAK,WAAgB;AACnB,YAAI,cAAc,QAAW;AAC3B,eAAK,MAAK;AACV,cAAI,CAAC,KAAK;AAAW,iBAAK,IAAI,GAAG,KAAK;AACtC;;AAEF,aAAK,IAAI,GAAG,SAAS;AACrB,aAAK,MAAK;AACV,YAAI,KAAK;AAAW,eAAK,IAAI,MAAK;;AAC7B,eAAK,IAAI,KAAI;MACpB;MAEA,UAAU,WAAe;AACvB,YAAI,CAAC,KAAK;AAAO,iBAAO,KAAK,KAAK,SAAS;AAC3C,cAAM,EAAC,WAAU,IAAI;AACrB,aAAK,MAAK,GAAA,UAAA,KAAI,UAAU,uBAAsB,GAAA,UAAA,IAAG,KAAK,aAAY,GAAI,SAAS,CAAC,GAAG;MACrF;MAEA,MAAM,QAAkB,aAAgC,YAAuB;AAC7E,YAAI,aAAa;AACf,eAAK,UAAU,WAAW;AAC1B,eAAK,OAAO,QAAQ,UAAU;AAC9B,eAAK,UAAU,CAAA,CAAE;AACjB;;AAEF,aAAK,OAAO,QAAQ,UAAU;MAChC;MAEQ,OAAO,QAAkB,YAAuB;AACtD;AAAC,SAAC,SAAS,SAAA,mBAAmB,SAAA,aAAa,MAAM,KAAK,IAAI,OAAO,UAAU;MAC7E;MAEA,aAAU;AACR,SAAA,GAAA,SAAA,aAAY,MAAM,KAAK,IAAI,cAAc,SAAA,iBAAiB;MAC5D;MAEA,QAAK;AACH,YAAI,KAAK,cAAc;AAAW,gBAAM,IAAI,MAAM,yCAAyC;AAC3F,SAAA,GAAA,SAAA,kBAAiB,KAAK,KAAK,KAAK,SAAS;MAC3C;MAEA,GAAG,MAAoB;AACrB,YAAI,CAAC,KAAK;AAAW,eAAK,IAAI,GAAG,IAAI;MACvC;MAEA,UAAU,KAAuB,QAAa;AAC5C,YAAI;AAAQ,iBAAO,OAAO,KAAK,QAAQ,GAAG;;AACrC,eAAK,SAAS;MACrB;MAEA,WAAW,OAAa,WAAuB,aAAmB,UAAA,KAAG;AACnE,aAAK,IAAI,MAAM,MAAK;AAClB,eAAK,WAAW,OAAO,UAAU;AACjC,oBAAS;QACX,CAAC;MACH;MAEA,WAAW,QAAc,UAAA,KAAK,aAAmB,UAAA,KAAG;AAClD,YAAI,CAAC,KAAK;AAAO;AACjB,cAAM,EAAC,KAAK,YAAY,YAAY,IAAG,IAAI;AAC3C,YAAI,IAAG,GAAA,UAAA,KAAG,GAAA,UAAA,KAAI,UAAU,kBAAkB,UAAU,CAAC;AACrD,YAAI,UAAU,UAAA;AAAK,cAAI,OAAO,OAAO,IAAI;AACzC,YAAI,WAAW,UAAU,IAAI,gBAAgB;AAC3C,cAAI,OAAO,KAAK,aAAY,CAAE;AAC9B,eAAK,WAAU;AACf,cAAI,UAAU,UAAA;AAAK,gBAAI,OAAO,OAAO,KAAK;;AAE5C,YAAI,KAAI;MACV;MAEA,eAAY;AACV,cAAM,EAAC,KAAK,YAAY,YAAY,KAAK,GAAE,IAAI;AAC/C,gBAAO,GAAA,UAAA,IAAG,eAAc,GAAI,mBAAkB,CAAE;AAEhD,iBAAS,iBAAc;AACrB,cAAI,WAAW,QAAQ;AAErB,gBAAI,EAAE,sBAAsB,UAAA;AAAO,oBAAM,IAAI,MAAM,0BAA0B;AAC7E,kBAAM,KAAK,MAAM,QAAQ,UAAU,IAAI,aAAa,CAAC,UAAU;AAC/D,oBAAO,GAAA,UAAA,MAAI,GAAA,WAAA,gBAAe,IAAI,YAAY,GAAG,KAAK,eAAe,WAAA,SAAS,KAAK,CAAC;;AAElF,iBAAO,UAAA;QACT;AARS;AAUT,iBAAS,qBAAkB;AACzB,cAAI,IAAI,gBAAgB;AACtB,kBAAM,oBAAoB,IAAI,WAAW,iBAAiB,EAAC,KAAK,IAAI,eAAc,CAAC;AACnF,oBAAO,GAAA,UAAA,MAAK,iBAAiB,IAAI,UAAU;;AAE7C,iBAAO,UAAA;QACT;AANS;MAOX;MAEA,UAAU,MAAqB,OAAW;AACxC,cAAM,aAAY,GAAA,YAAA,cAAa,KAAK,IAAI,IAAI;AAC5C,SAAA,GAAA,YAAA,qBAAoB,WAAW,KAAK,IAAI,IAAI;AAC5C,SAAA,GAAA,YAAA,qBAAoB,WAAW,IAAI;AACnC,cAAM,cAAc,EAAC,GAAG,KAAK,IAAI,GAAG,WAAW,OAAO,QAAW,OAAO,OAAS;AACjF,sBAAc,aAAa,KAAK;AAChC,eAAO;MACT;MAEA,eAAe,WAAsB,QAAoB;AACvD,cAAM,EAAC,IAAI,IAAG,IAAI;AAClB,YAAI,CAAC,GAAG,KAAK;AAAa;AAC1B,YAAI,GAAG,UAAU,QAAQ,UAAU,UAAU,QAAW;AACtD,aAAG,QAAQ,OAAA,eAAe,MAAM,KAAK,UAAU,OAAO,GAAG,OAAO,MAAM;;AAExE,YAAI,GAAG,UAAU,QAAQ,UAAU,UAAU,QAAW;AACtD,aAAG,QAAQ,OAAA,eAAe,MAAM,KAAK,UAAU,OAAO,GAAG,OAAO,MAAM;;MAE1E;MAEA,oBAAoB,WAAsB,OAAW;AACnD,cAAM,EAAC,IAAI,IAAG,IAAI;AAClB,YAAI,GAAG,KAAK,gBAAgB,GAAG,UAAU,QAAQ,GAAG,UAAU,OAAO;AACnE,cAAI,GAAG,OAAO,MAAM,KAAK,eAAe,WAAW,UAAA,IAAI,CAAC;AACxD,iBAAO;;MAEX;;AA3LF,IAAAA,SAAA,aAAA;AA8LA,aAAS,YACP,IACA,SACA,KACA,UAAmB;AAEnB,YAAM,MAAM,IAAI,WAAW,IAAI,KAAK,OAAO;AAC3C,UAAI,UAAU,KAAK;AACjB,YAAI,KAAK,KAAK,QAAQ;iBACb,IAAI,SAAS,IAAI,UAAU;AACpC,SAAA,GAAA,UAAA,iBAAgB,KAAK,GAAG;iBACf,WAAW,KAAK;AACzB,SAAA,GAAA,UAAA,kBAAiB,KAAK,GAAG;iBAChB,IAAI,WAAW,IAAI,UAAU;AACtC,SAAA,GAAA,UAAA,iBAAgB,KAAK,GAAG;;IAE5B;AAhBS;AAkBT,QAAM,eAAe;AACrB,QAAM,wBAAwB;AAC9B,aAAgB,QACd,OACA,EAAC,WAAW,WAAW,YAAW,GAAY;AAE9C,UAAI;AACJ,UAAI;AACJ,UAAI,UAAU;AAAI,eAAO,QAAA,QAAE;AAC3B,UAAI,MAAM,CAAC,MAAM,KAAK;AACpB,YAAI,CAAC,aAAa,KAAK,KAAK;AAAG,gBAAM,IAAI,MAAM,yBAAyB,KAAK,EAAE;AAC/E,sBAAc;AACd,eAAO,QAAA,QAAE;aACJ;AACL,cAAM,UAAU,sBAAsB,KAAK,KAAK;AAChD,YAAI,CAAC;AAAS,gBAAM,IAAI,MAAM,yBAAyB,KAAK,EAAE;AAC9D,cAAM,KAAa,CAAC,QAAQ,CAAC;AAC7B,sBAAc,QAAQ,CAAC;AACvB,YAAI,gBAAgB,KAAK;AACvB,cAAI,MAAM;AAAW,kBAAM,IAAI,MAAM,SAAS,kBAAkB,EAAE,CAAC;AACnE,iBAAO,YAAY,YAAY,EAAE;;AAEnC,YAAI,KAAK;AAAW,gBAAM,IAAI,MAAM,SAAS,QAAQ,EAAE,CAAC;AACxD,eAAO,UAAU,YAAY,EAAE;AAC/B,YAAI,CAAC;AAAa,iBAAO;;AAG3B,UAAI,OAAO;AACX,YAAM,WAAW,YAAY,MAAM,GAAG;AACtC,iBAAW,WAAW,UAAU;AAC9B,YAAI,SAAS;AACX,kBAAO,GAAA,UAAA,KAAI,IAAI,IAAG,GAAA,UAAA,cAAY,GAAA,OAAA,qBAAoB,OAAO,CAAC,CAAC;AAC3D,kBAAO,GAAA,UAAA,KAAI,IAAI,OAAO,IAAI;;;AAG9B,aAAO;AAEP,eAAS,SAAS,aAAqB,IAAU;AAC/C,eAAO,iBAAiB,WAAW,IAAI,EAAE,gCAAgC,SAAS;MACpF;AAFS;IAGX;AAtCgB;AAAhB,IAAAA,SAAA,UAAA;;;;;;;;;AC7hBA,QAAqB,kBAArB,cAA6C,MAAK;aAAA;;;MAKhD,YAAY,QAA8B;AACxC,cAAM,mBAAmB;AACzB,aAAK,SAAS;AACd,aAAK,MAAM,KAAK,aAAa;MAC/B;;AATF,IAAAC,SAAA,UAAA;;;;;;;;;ACFA,QAAA,YAAA;AAGA,QAAqB,kBAArB,cAA6C,MAAK;aAAA;;;MAIhD,YAAY,UAAuB,QAAgB,KAAa,KAAY;AAC1E,cAAM,OAAO,2BAA2B,GAAG,YAAY,MAAM,EAAE;AAC/D,aAAK,cAAa,GAAA,UAAA,YAAW,UAAU,QAAQ,GAAG;AAClD,aAAK,iBAAgB,GAAA,UAAA,cAAY,GAAA,UAAA,aAAY,UAAU,KAAK,UAAU,CAAC;MACzE;;AARF,IAAAC,SAAA,UAAA;;;;;;;;;;ACOA,QAAA,YAAA;AACA,QAAA,qBAAA;AACA,QAAA,UAAA;AACA,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,aAAA;AA0DA,QAAa,YAAb,MAAsB;aAAA;;;MAkBpB,YAAY,KAAkB;;AATrB,aAAA,OAAmB,CAAA;AACnB,aAAA,iBAA2C,CAAA;AASlD,YAAI;AACJ,YAAI,OAAO,IAAI,UAAU;AAAU,mBAAS,IAAI;AAChD,aAAK,SAAS,IAAI;AAClB,aAAK,WAAW,IAAI;AACpB,aAAK,OAAO,IAAI,QAAQ;AACxB,aAAK,UAAS,KAAA,IAAI,YAAM,QAAA,OAAA,SAAA,MAAI,GAAA,UAAA,aAAY,WAAM,QAAN,WAAM,SAAA,SAAN,OAAS,IAAI,YAAY,KAAK,CAAC;AACvE,aAAK,aAAa,IAAI;AACtB,aAAK,YAAY,IAAI;AACrB,aAAK,OAAO,IAAI;AAChB,aAAK,SAAS,WAAM,QAAN,WAAM,SAAA,SAAN,OAAQ;AACtB,aAAK,OAAO,CAAA;MACd;;AA9BF,IAAAC,SAAA,YAAA;AAqCA,aAAgB,cAAyB,KAAc;AAErD,YAAM,OAAO,mBAAmB,KAAK,MAAM,GAAG;AAC9C,UAAI;AAAM,eAAO;AACjB,YAAM,UAAS,GAAA,UAAA,aAAY,KAAK,KAAK,aAAa,IAAI,KAAK,MAAM;AACjE,YAAM,EAAC,KAAK,MAAK,IAAI,KAAK,KAAK;AAC/B,YAAM,EAAC,cAAa,IAAI,KAAK;AAC7B,YAAM,MAAM,IAAI,UAAA,QAAQ,KAAK,OAAO,EAAC,KAAK,OAAO,cAAa,CAAC;AAC/D,UAAI;AACJ,UAAI,IAAI,QAAQ;AACd,2BAAmB,IAAI,WAAW,SAAS;UACzC,KAAK,mBAAA;UACL,OAAM,GAAA,UAAA;SACP;;AAGH,YAAM,eAAe,IAAI,UAAU,UAAU;AAC7C,UAAI,eAAe;AAEnB,YAAM,YAAuB;QAC3B;QACA,WAAW,KAAK,KAAK;QACrB,MAAM,QAAA,QAAE;QACR,YAAY,QAAA,QAAE;QACd,oBAAoB,QAAA,QAAE;QACtB,WAAW,CAAC,QAAA,QAAE,IAAI;QAClB,aAAa,CAAC,UAAA,GAAG;QACjB,WAAW;QACX,WAAW,CAAA;QACX,mBAAmB,oBAAI,IAAG;QAC1B,cAAc,IAAI,WAChB,UACA,KAAK,KAAK,KAAK,WAAW,OACtB,EAAC,KAAK,IAAI,QAAQ,OAAM,GAAA,UAAA,WAAU,IAAI,MAAM,EAAC,IAC7C,EAAC,KAAK,IAAI,OAAM,CAAC;QAEvB;QACA,iBAAiB;QACjB,QAAQ,IAAI;QACZ,WAAW;QACX;QACA,QAAQ,IAAI,UAAU;QACtB,YAAY,UAAA;QACZ,eAAe,IAAI,eAAe,KAAK,KAAK,MAAM,KAAK;QACvD,YAAW,GAAA,UAAA;QACX,MAAM,KAAK;QACX,MAAM;;AAGR,UAAI;AACJ,UAAI;AACF,aAAK,cAAc,IAAI,GAAG;AAC1B,SAAA,GAAA,WAAA,sBAAqB,SAAS;AAC9B,YAAI,SAAS,KAAK,KAAK,KAAK,QAAQ;AAEpC,cAAM,eAAe,IAAI,SAAQ;AACjC,qBAAa,GAAG,IAAI,UAAU,QAAA,QAAE,KAAK,CAAC,UAAU,YAAY;AAE5D,YAAI,KAAK,KAAK,KAAK;AAAS,uBAAa,KAAK,KAAK,KAAK,QAAQ,YAAY,GAAG;AAE/E,cAAM,eAAe,IAAI,SAAS,GAAG,QAAA,QAAE,IAAI,IAAI,GAAG,QAAA,QAAE,KAAK,IAAI,UAAU;AACvE,cAAM,WAAgC,aAAa,MAAM,KAAK,MAAM,IAAG,CAAE;AACzE,aAAK,MAAM,MAAM,cAAc,EAAC,KAAK,SAAQ,CAAC;AAE9C,iBAAS,SAAS;AAClB,iBAAS,SAAS,IAAI;AACtB,iBAAS,YAAY;AACrB,YAAI,IAAI;AAAS,mBAAmC,SAAS;AAC7D,YAAI,KAAK,KAAK,KAAK,WAAW,MAAM;AAClC,mBAAS,SAAS,EAAC,cAAc,cAAc,aAAa,IAAI,QAAO;;AAEzE,YAAI,KAAK,KAAK,aAAa;AACzB,gBAAM,EAAC,OAAO,MAAK,IAAI;AACvB,mBAAS,YAAY;YACnB,OAAO,iBAAiB,UAAA,OAAO,SAAY;YAC3C,OAAO,iBAAiB,UAAA,OAAO,SAAY;YAC3C,cAAc,iBAAiB,UAAA;YAC/B,cAAc,iBAAiB,UAAA;;AAEjC,cAAI,SAAS;AAAQ,qBAAS,OAAO,aAAY,GAAA,UAAA,WAAU,SAAS,SAAS;;AAE/E,YAAI,WAAW;AACf,eAAO;eACA,GAAG;AACV,eAAO,IAAI;AACX,eAAO,IAAI;AACX,YAAI;AAAY,eAAK,OAAO,MAAM,0CAA0C,UAAU;AAEtF,cAAM;;AAEN,aAAK,cAAc,OAAO,GAAG;;IAEjC;AA5FgB;AAAhB,IAAAA,SAAA,gBAAA;AA8FA,aAAgB,WAEd,MACA,QACA,KAAW;;AAEX,aAAM,GAAA,UAAA,YAAW,KAAK,KAAK,aAAa,QAAQ,GAAG;AACnD,YAAM,YAAY,KAAK,KAAK,GAAG;AAC/B,UAAI;AAAW,eAAO;AAEtB,UAAI,OAAO,QAAQ,KAAK,MAAM,MAAM,GAAG;AACvC,UAAI,SAAS,QAAW;AACtB,cAAM,UAAS,KAAA,KAAK,eAAS,QAAA,OAAA,SAAA,SAAA,GAAG,GAAG;AACnC,cAAM,EAAC,SAAQ,IAAI,KAAK;AACxB,YAAI;AAAQ,iBAAO,IAAI,UAAU,EAAC,QAAQ,UAAU,MAAM,OAAM,CAAC;;AAGnE,UAAI,SAAS;AAAW;AACxB,aAAQ,KAAK,KAAK,GAAG,IAAI,gBAAgB,KAAK,MAAM,IAAI;IAC1D;AAnBgB;AAAhB,IAAAA,SAAA,aAAA;AAqBA,aAAS,gBAA2B,KAAc;AAChD,WAAI,GAAA,UAAA,WAAU,IAAI,QAAQ,KAAK,KAAK,UAAU;AAAG,eAAO,IAAI;AAC5D,aAAO,IAAI,WAAW,MAAM,cAAc,KAAK,MAAM,GAAG;IAC1D;AAHS;AAMT,aAAgB,mBAA8B,QAAiB;AAC7D,iBAAW,OAAO,KAAK,eAAe;AACpC,YAAI,cAAc,KAAK,MAAM;AAAG,iBAAO;;IAE3C;AAJgB;AAAhB,IAAAA,SAAA,qBAAA;AAMA,aAAS,cAAc,IAAe,IAAa;AACjD,aAAO,GAAG,WAAW,GAAG,UAAU,GAAG,SAAS,GAAG,QAAQ,GAAG,WAAW,GAAG;IAC5E;AAFS;AAMT,aAAS,QAEP,MACA;AAEA,UAAI;AACJ,aAAO,QAAQ,MAAM,KAAK,KAAK,GAAG,MAAM;AAAU,cAAM;AACxD,aAAO,OAAO,KAAK,QAAQ,GAAG,KAAK,cAAc,KAAK,MAAM,MAAM,GAAG;IACvE;AARS;AAWT,aAAgB,cAEd,MACA;AAEA,YAAM,IAAI,KAAK,KAAK,YAAY,MAAM,GAAG;AACzC,YAAM,WAAU,GAAA,UAAA,cAAa,KAAK,KAAK,aAAa,CAAC;AACrD,UAAI,UAAS,GAAA,UAAA,aAAY,KAAK,KAAK,aAAa,KAAK,QAAQ,MAAS;AAEtE,UAAI,OAAO,KAAK,KAAK,MAAM,EAAE,SAAS,KAAK,YAAY,QAAQ;AAC7D,eAAO,eAAe,KAAK,MAAM,GAAG,IAAI;;AAG1C,YAAM,MAAK,GAAA,UAAA,aAAY,OAAO;AAC9B,YAAM,WAAW,KAAK,KAAK,EAAE,KAAK,KAAK,QAAQ,EAAE;AACjD,UAAI,OAAO,YAAY,UAAU;AAC/B,cAAM,MAAM,cAAc,KAAK,MAAM,MAAM,QAAQ;AACnD,YAAI,QAAO,QAAG,QAAH,QAAG,SAAA,SAAH,IAAK,YAAW;AAAU;AACrC,eAAO,eAAe,KAAK,MAAM,GAAG,GAAG;;AAGzC,UAAI,QAAO,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,YAAW;AAAU;AAC1C,UAAI,CAAC,SAAS;AAAU,sBAAc,KAAK,MAAM,QAAQ;AACzD,UAAI,QAAO,GAAA,UAAA,aAAY,GAAG,GAAG;AAC3B,cAAM,EAAC,OAAM,IAAI;AACjB,cAAM,EAAC,SAAQ,IAAI,KAAK;AACxB,cAAM,QAAQ,OAAO,QAAQ;AAC7B,YAAI;AAAO,oBAAS,GAAA,UAAA,YAAW,KAAK,KAAK,aAAa,QAAQ,KAAK;AACnE,eAAO,IAAI,UAAU,EAAC,QAAQ,UAAU,MAAM,OAAM,CAAC;;AAEvD,aAAO,eAAe,KAAK,MAAM,GAAG,QAAQ;IAC9C;AA/BgB;AAAhB,IAAAA,SAAA,gBAAA;AAiCA,QAAM,uBAAuB,oBAAI,IAAI;MACnC;MACA;MACA;MACA;MACA;KACD;AAED,aAAS,eAEP,WACA,EAAC,QAAQ,QAAQ,KAAI,GAAY;;AAEjC,YAAI,KAAA,UAAU,cAAQ,QAAA,OAAA,SAAA,SAAA,GAAG,CAAC,OAAM;AAAK;AACrC,iBAAW,QAAQ,UAAU,SAAS,MAAM,CAAC,EAAE,MAAM,GAAG,GAAG;AACzD,YAAI,OAAO,WAAW;AAAW;AACjC,cAAM,aAAa,QAAO,GAAA,OAAA,kBAAiB,IAAI,CAAC;AAChD,YAAI,eAAe;AAAW;AAC9B,iBAAS;AAET,cAAM,QAAQ,OAAO,WAAW,YAAY,OAAO,KAAK,KAAK,QAAQ;AACrE,YAAI,CAAC,qBAAqB,IAAI,IAAI,KAAK,OAAO;AAC5C,oBAAS,GAAA,UAAA,YAAW,KAAK,KAAK,aAAa,QAAQ,KAAK;;;AAG5D,UAAI;AACJ,UAAI,OAAO,UAAU,aAAa,OAAO,QAAQ,EAAC,GAAA,OAAA,sBAAqB,QAAQ,KAAK,KAAK,GAAG;AAC1F,cAAM,QAAO,GAAA,UAAA,YAAW,KAAK,KAAK,aAAa,QAAQ,OAAO,IAAI;AAClE,cAAM,cAAc,KAAK,MAAM,MAAM,IAAI;;AAI3C,YAAM,EAAC,SAAQ,IAAI,KAAK;AACxB,YAAM,OAAO,IAAI,UAAU,EAAC,QAAQ,UAAU,MAAM,OAAM,CAAC;AAC3D,UAAI,IAAI,WAAW,IAAI,KAAK;AAAQ,eAAO;AAC3C,aAAO;IACT;AA5BS;;;;;ACvST;AAAA,0HAAAC,UAAAC,SAAA;AAAA,IAAAA,QAAA;AAAA,MACE,KAAO;AAAA,MACP,aAAe;AAAA,MACf,MAAQ;AAAA,MACR,UAAY,CAAC,OAAO;AAAA,MACpB,YAAc;AAAA,QACZ,OAAS;AAAA,UACP,MAAQ;AAAA,UACR,OAAS,CAAC,EAAC,QAAU,wBAAuB,GAAG,EAAC,QAAU,eAAc,CAAC;AAAA,QAC3E;AAAA,MACF;AAAA,MACA,sBAAwB;AAAA,IAC1B;AAAA;AAAA;;;;;;;;;AaZA,eAAAC,QAAA;0CAAyBC,OAAzB,MAAA,IAAA,GAAA,OAAA,GAAA,OAAA,MAAA,QAAA;eAAA,IAAA,IAAA,UAAA,IAAA;;YACKA,KAAKC,SAAS,GAAG;eACf,CAAL,IAAUD,KAAK,CAAL,EAAQE,MAAM,GAAG,EAAjB;cACJC,KAAKH,KAAKC,SAAS;mBAChBG,IAAI,GAAGA,IAAID,IAAI,EAAEC,GAAG;iBACvBA,CAAL,IAAUJ,KAAKI,CAAL,EAAQF,MAAM,GAAG,EAAjB;;eAENC,EAAL,IAAWH,KAAKG,EAAL,EAASD,MAAM,CAAf;iBACJF,KAAKK,KAAK,EAAV;eACD;iBACCL,KAAK,CAAL;;;AAVTD;AAcA,eAAAO,OAAuBC,KAAvB;eACQ,QAAQA,MAAM;;AADtBD;AAIA,eAAAE,OAAuBC,GAAvB;eACQA,MAAMC,SAAY,cAAeD,MAAM,OAAO,SAASE,OAAOC,UAAUC,SAASC,KAAKL,CAA/B,EAAkCM,MAAM,GAAxC,EAA6CC,IAA7C,EAAmDD,MAAM,GAAzD,EAA8DE,MAA9D,EAAsEC,YAAtE;;AAD/DV;AAIA,eAAAW,YAA4BZ,KAA5B;eACQA,IAAIY,YAAJ;;AADRA;AAIA,eAAAC,QAAwBC,KAAxB;eACQA,QAAQX,UAAaW,QAAQ,OAAQA,eAAeC,QAAQD,MAAO,OAAOA,IAAIpB,WAAW,YAAYoB,IAAIN,SAASM,IAAIE,eAAeF,IAAIP,OAAO,CAACO,GAAD,IAAQC,MAAMV,UAAUV,MAAMY,KAAKO,GAA3B,IAAoC,CAAA;;AADpMD;AAKA,eAAAI,OAAuBC,QAAgBC,QAAvC;YACOL,MAAMI;YACRC,QAAQ;mBACAC,OAAOD,QAAQ;gBACrBC,GAAJ,IAAWD,OAAOC,GAAP;;;eAGNN;;AAPRG;AD5BA,eAAAI,UAA0BC,QAA1B;YAEEC,UAAU,YACVC,MAAM,WACNC,UAAU,SACVC,WAAW,WACXC,YAAWnC,MAAMiC,SAAS,UAAf,UACJ,WACPG,OAAO,WACPC,gBAAe9B,OAAOA,OAAO,YAAY4B,YAAW,MAAMA,YAAWA,YAAW,MAAMA,YAAWA,SAA3E,IAAuF,MAAM5B,OAAO,gBAAgB4B,YAAW,MAAMA,YAAWA,SAAnD,IAA+D,MAAM5B,OAAO,MAAM4B,YAAWA,SAAxB,CAAzK,kBACA,2BACfG,eAAe,uCACfC,aAAavC,MAAMwC,cAAcF,YAApB,GACbG,YAAYX,SAAQ,gFAAgF,mBACvFA,SAAQ,sBAAsB,sBAC5B9B,MAAM+B,SAASE,SAAS,kBAAkBQ,SAA1C,GACfC,UAAUnC,OAAOwB,UAAU/B,MAAM+B,SAASE,SAAS,aAAxB,IAAyC,GAA1D,GACVU,YAAYpC,OAAOA,OAAO8B,gBAAe,MAAMrC,MAAM4C,eAAcN,cAAc,OAAlC,CAA5B,IAA0E,GAAjF,GACZO,aAAatC,OAAOA,OAAO,SAAP,IAAoB,MAAMA,OAAO,WAAW0B,OAAlB,IAA6B,MAAM1B,OAAO,MAAM0B,UAAUA,OAAvB,IAAkC,MAAM1B,OAAO,UAAU0B,OAAjB,IAA4B,MAAMA,OAA9I,GACba,qBAAqBvC,OAAOA,OAAO,SAAP,IAAoB,MAAMA,OAAO,WAAW0B,OAAlB,IAA6B,MAAM1B,OAAO,MAAM0B,UAAUA,OAAvB,IAAkC,MAAM1B,OAAO,YAAY0B,OAAnB,IAA8B,UAAUA,OAApJ,kBACN1B,OAAOuC,qBAAqB,QAAQA,qBAAqB,QAAQA,qBAAqB,QAAQA,kBAA9F,GACfC,OAAOxC,OAAO4B,YAAW,OAAlB,GACPa,QAAQzC,OAAOA,OAAOwC,OAAO,QAAQA,IAAtB,IAA8B,MAAME,YAA3C,GACRC,gBAAgB3C,OAAmEA,OAAOwC,OAAO,KAAd,IAAuB,QAAQC,KAAlG,mBACAzC,OAAwD,WAAWA,OAAOwC,OAAO,KAAd,IAAuB,QAAQC,KAAlG,mBACAzC,OAAOA,OAAwCwC,IAAxC,IAAgD,YAAYxC,OAAOwC,OAAO,KAAd,IAAuB,QAAQC,KAAlG,mBACAzC,OAAOA,OAAOA,OAAOwC,OAAO,KAAd,IAAuB,UAAUA,IAAxC,IAAgD,YAAYxC,OAAOwC,OAAO,KAAd,IAAuB,QAAQC,KAAlG,mBACAzC,OAAOA,OAAOA,OAAOwC,OAAO,KAAd,IAAuB,UAAUA,IAAxC,IAAgD,YAAYxC,OAAOwC,OAAO,KAAd,IAAuB,QAAQC,KAAlG,mBACAzC,OAAOA,OAAOA,OAAOwC,OAAO,KAAd,IAAuB,UAAUA,IAAxC,IAAgD,YAAmBA,OAAO,QAAiBC,KAAlG,mBACAzC,OAAOA,OAAOA,OAAOwC,OAAO,KAAd,IAAuB,UAAUA,IAAxC,IAAgD,YAA2CC,KAAlG,mBACAzC,OAAOA,OAAOA,OAAOwC,OAAO,KAAd,IAAuB,UAAUA,IAAxC,IAAgD,YAA2CA,IAAlG,mBACAxC,OAAOA,OAAOA,OAAOwC,OAAO,KAAd,IAAuB,UAAUA,IAAxC,IAAgD,SAAvD,kBACDxC,OAAO,CAAC2C,eAAeC,eAAeC,eAAeC,eAAeC,eAAeC,eAAeC,eAAeC,eAAeC,aAAzH,EAAwIpD,KAAK,GAA7I,CAAP,GACfqD,UAAUpD,OAAOA,OAAOqC,gBAAe,MAAMP,aAA5B,IAA4C,GAAnD,gBACG9B,OAAOqD,eAAe,UAAUD,OAAhC,wBACQpD,OAAOqD,eAAerD,OAAO,iBAAiB4B,YAAW,MAAnC,IAA6CwB,OAAnE,gBACRpD,OAAO,SAAS4B,YAAW,SAASnC,MAAM4C,eAAcN,cAAc,OAAlC,IAA6C,GAAjF,GACbuB,cAActD,OAAO,QAAQA,OAAOuD,qBAAqB,MAAMF,eAAe,MAAMG,UAAvD,IAAqE,KAApF,eACFxD,OAAOA,OAAO8B,gBAAe,MAAMrC,MAAM4C,eAAcN,YAApB,CAA5B,IAAiE,GAAxE,GACZ0B,QAAQzD,OAAOsD,cAAc,MAAMZ,eAAe,QAAQgB,YAAY,OAAYA,SAA1E,GACRC,QAAQ3D,OAAO0B,UAAU,GAAjB,GACRkC,aAAa5D,OAAOA,OAAOoC,YAAY,GAAnB,IAA0B,MAAMqB,QAAQzD,OAAO,QAAQ2D,KAAf,IAAwB,GAAvE,GACbE,SAAS7D,OAAO8B,gBAAe,MAAMrC,MAAM4C,eAAcN,cAAc,UAAlC,CAA5B,GACT+B,WAAW9D,OAAO6D,SAAS,GAAhB,GACXE,cAAc/D,OAAO6D,SAAS,GAAhB,GACdG,iBAAiBhE,OAAOA,OAAO8B,gBAAe,MAAMrC,MAAM4C,eAAcN,cAAc,OAAlC,CAA5B,IAA0E,GAAjF,GACjBkC,gBAAgBjE,OAAOA,OAAO,QAAQ8D,QAAf,IAA2B,GAAlC,GAChBI,iBAAiBlE,OAAO,QAAQA,OAAO+D,cAAcE,aAArB,IAAsC,GAArD,oBACAjE,OAAOgE,iBAAiBC,aAAxB,oBACAjE,OAAO+D,cAAcE,aAArB,iBACH,QAAQJ,SAAS,KAC/BM,QAAQnE,OAAOiE,gBAAgB,MAAMC,iBAAiB,MAAME,iBAAiB,MAAMC,iBAAiB,MAAMC,WAAlG,GACRC,SAASvE,OAAOA,OAAO6D,SAAS,MAAMpE,MAAM,YAAY+E,UAAlB,CAAtB,IAAuD,GAA9D,GACTC,YAAYzE,OAAOA,OAAO6D,SAAS,WAAhB,IAA+B,GAAtC,GACZa,aAAa1E,OAAOA,OAAO,WAAW4D,aAAaK,aAA/B,IAAgD,MAAMC,iBAAiB,MAAMG,iBAAiB,MAAMC,WAA3G,GACbK,OAAO3E,OAAOmC,UAAU,QAAQuC,aAAa1E,OAAO,QAAQuE,MAAf,IAAyB,MAAMvE,OAAO,QAAQyE,SAAf,IAA4B,GAAjG,GACPG,iBAAiB5E,OAAOA,OAAO,WAAW4D,aAAaK,aAA/B,IAAgD,MAAMC,iBAAiB,MAAME,iBAAiB,MAAME,WAA3G,GACjBO,YAAY7E,OAAO4E,iBAAiB5E,OAAO,QAAQuE,MAAf,IAAyB,MAAMvE,OAAO,QAAQyE,SAAf,IAA4B,GAAnF,GACZK,iBAAiB9E,OAAO2E,OAAO,MAAME,SAApB,GACjBE,gBAAgB/E,OAAOmC,UAAU,QAAQuC,aAAa1E,OAAO,QAAQuE,MAAf,IAAyB,GAA/D,GAEhBS,eAAe,OAAO7C,UAAU,SAASnC,OAAOA,OAAO,YAAYA,OAAO,MAAMoC,YAAY,IAAzB,IAAiC,OAAOqB,QAAQ,MAAMzD,OAAO,SAAS2D,QAAQ,GAAxB,IAA+B,IAAxG,IAAgH,OAAOM,gBAAgB,MAAMC,iBAAiB,MAAMG,iBAAiB,MAAMC,cAAc,GAAhN,IAAuNtE,OAAO,SAASuE,SAAS,GAAzB,IAAgC,MAAMvE,OAAO,SAASyE,YAAY,GAA5B,IAAmC,MACzUQ,gBAAgB,WAAWjF,OAAOA,OAAO,YAAYA,OAAO,MAAMoC,YAAY,IAAzB,IAAiC,OAAOqB,QAAQ,MAAMzD,OAAO,SAAS2D,QAAQ,GAAxB,IAA+B,IAAxG,IAAgH,OAAOM,gBAAgB,MAAMC,iBAAiB,MAAME,iBAAiB,MAAME,cAAc,GAAhN,IAAuNtE,OAAO,SAASuE,SAAS,GAAzB,IAAgC,MAAMvE,OAAO,SAASyE,YAAY,GAA5B,IAAmC,MAC3TS,gBAAgB,OAAO/C,UAAU,SAASnC,OAAOA,OAAO,YAAYA,OAAO,MAAMoC,YAAY,IAAzB,IAAiC,OAAOqB,QAAQ,MAAMzD,OAAO,SAAS2D,QAAQ,GAAxB,IAA+B,IAAxG,IAAgH,OAAOM,gBAAgB,MAAMC,iBAAiB,MAAMG,iBAAiB,MAAMC,cAAc,GAAhN,IAAuNtE,OAAO,SAASuE,SAAS,GAAzB,IAAgC,MACjSY,eAAe,MAAMnF,OAAO,SAASyE,YAAY,GAA5B,IAAmC,MACxDW,iBAAiB,MAAMpF,OAAO,MAAMoC,YAAY,IAAzB,IAAiC,OAAOqB,QAAQ,MAAMzD,OAAO,SAAS2D,QAAQ,GAAxB,IAA+B;eAGtG;sBACO,IAAI0B,OAAO5F,MAAM,OAAO+B,SAASE,SAAS,aAA/B,GAA+C,GAA1D;wBACE,IAAI2D,OAAO5F,MAAM,aAAa4C,eAAcN,YAAjC,GAAgD,GAA3D;oBACJ,IAAIsD,OAAO5F,MAAM,mBAAmB4C,eAAcN,YAAvC,GAAsD,GAAjE;oBACA,IAAIsD,OAAO5F,MAAM,mBAAmB4C,eAAcN,YAAvC,GAAsD,GAAjE;6BACS,IAAIsD,OAAO5F,MAAM,gBAAgB4C,eAAcN,YAApC,GAAmD,GAA9D;qBACR,IAAIsD,OAAO5F,MAAM,UAAU4C,eAAcN,cAAc,kBAAkByC,UAA9D,GAA2E,GAAtF;wBACG,IAAIa,OAAO5F,MAAM,UAAU4C,eAAcN,cAAc,gBAA5C,GAA+D,GAA1E;kBACN,IAAIsD,OAAO5F,MAAM,OAAO4C,eAAcN,YAA3B,GAA0C,GAArD;sBACI,IAAIsD,OAAOhD,eAAc,GAAzB;uBACC,IAAIgD,OAAO5F,MAAM,UAAU4C,eAAcL,UAA9B,GAA2C,GAAtD;uBACA,IAAIqD,OAAOvD,eAAc,GAAzB;uBACA,IAAIuD,OAAO,OAAO3C,eAAe,IAAjC;uBACA,IAAI2C,OAAO,WAAWhC,eAAe,MAAMrD,OAAOA,OAAO,iBAAiB4B,YAAW,MAAnC,IAA6C,MAAMwB,UAAU,GAApE,IAA2E,QAAtH;;;;AAjFhB9B;AAqFA,UAAA,eAAeA,UAAU,KAAV;ADrFf,UAAA,eAAeA,UAAU,IAAV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADAf,UAAMgE,SAAS;AAGf,UAAMC,OAAO;AACb,UAAMC,OAAO;AACb,UAAMC,OAAO;AACb,UAAMC,OAAO;AACb,UAAMC,OAAO;AACb,UAAMC,cAAc;AACpB,UAAMC,WAAW;AACjB,UAAMC,YAAY;AAGlB,UAAMC,gBAAgB;AACtB,UAAMC,gBAAgB;AACtB,UAAMC,kBAAkB;AAGxB,UAAMC,SAAS;oBACF;qBACC;yBACI;;AAIlB,UAAMC,gBAAgBZ,OAAOC;AAC7B,UAAMY,QAAQC,KAAKD;AACnB,UAAME,qBAAqBC,OAAOC;AAUlC,eAASC,QAAMC,MAAM;cACd,IAAIC,WAAWT,OAAOQ,IAAP,CAAf;;AADED;AAYT,eAASG,IAAIC,OAAOC,IAAI;YACjBC,SAAS,CAAA;YACXpH,SAASkH,MAAMlH;eACZA,UAAU;iBACTA,MAAP,IAAiBmH,GAAGD,MAAMlH,MAAN,CAAH;;eAEXoH;;AANCH;AAmBT,eAASI,UAAUC,QAAQH,IAAI;YACxBI,QAAQD,OAAOxG,MAAM,GAAb;YACVsG,SAAS;YACTG,MAAMvH,SAAS,GAAG;mBAGZuH,MAAM,CAAN,IAAW;mBACXA,MAAM,CAAN;;iBAGDD,OAAOE,QAAQlB,iBAAiB,GAAhC;YACHmB,SAASH,OAAOxG,MAAM,GAAb;YACT4G,UAAUT,IAAIQ,QAAQN,EAAZ,EAAgB/G,KAAK,GAArB;eACTgH,SAASM;;AAbRL;AA6BT,eAASM,WAAWL,QAAQ;YACrBM,SAAS,CAAA;YACXC,UAAU;YACR7H,SAASsH,OAAOtH;eACf6H,UAAU7H,QAAQ;cAClB8H,QAAQR,OAAOS,WAAWF,SAAlB;cACVC,SAAS,SAAUA,SAAS,SAAUD,UAAU7H,QAAQ;gBAErDgI,QAAQV,OAAOS,WAAWF,SAAlB;iBACTG,QAAQ,UAAW,OAAQ;qBACxBC,OAAOH,QAAQ,SAAU,OAAOE,QAAQ,QAAS,KAAxD;mBACM;qBAGCC,KAAKH,KAAZ;;;iBAGK;mBACCG,KAAKH,KAAZ;;;eAGKF;;AArBCD;AAgCT,UAAMO,aAAa,gCAAbA,YAAa,OAAA;eAAStB,OAAOuB,cAAP,MAAA,QAAA,kBAAwBjB,KAAxB,CAAA;SAAT;AAWnB,UAAMkB,eAAe,gCAAfA,cAAwBC,WAAW;YACpCA,YAAY,KAAO,IAAM;iBACrBA,YAAY;;YAEhBA,YAAY,KAAO,IAAM;iBACrBA,YAAY;;YAEhBA,YAAY,KAAO,IAAM;iBACrBA,YAAY;;eAEbzC;SAVa;AAwBrB,UAAM0C,eAAe,gCAAfA,cAAwBC,OAAOC,MAAM;eAGnCD,QAAQ,KAAK,MAAMA,QAAQ,QAAQC,QAAQ,MAAM;SAHpC;AAWrB,UAAMC,QAAQ,gCAARA,OAAiBC,OAAOC,WAAWC,WAAW;YAC/CC,IAAI;gBACAD,YAAYnC,MAAMiC,QAAQ1C,IAAd,IAAsB0C,SAAS;iBAC1CjC,MAAMiC,QAAQC,SAAd;;;;UACqBD,QAAQlC,gBAAgBV,QAAQ;UAAG+C,KAAKjD;UAAM;kBACnEa,MAAMiC,QAAQlC,aAAd;;eAEFC,MAAMoC,KAAKrC,gBAAgB,KAAKkC,SAASA,QAAQ3C,KAAjD;SAPM;AAiBd,UAAM+C,SAAS,gCAATA,QAAkBC,OAAO;YAExBnB,SAAS,CAAA;YACToB,cAAcD,MAAM/I;YACtBiJ,IAAI;YACJC,IAAIhD;YACJiD,OAAOlD;YAMPmD,QAAQL,MAAMM,YAAYlD,SAAlB;YACRiD,QAAQ,GAAG;kBACN;;iBAGAE,IAAI,GAAGA,IAAIF,OAAO,EAAEE,GAAG;cAE3BP,MAAMhB,WAAWuB,CAAjB,KAAuB,KAAM;oBAC1B,WAAN;;iBAEMrB,KAAKc,MAAMhB,WAAWuB,CAAjB,CAAZ;;iBAMQC,QAAQH,QAAQ,IAAIA,QAAQ,IAAI,GAAGG,QAAQP,eAAwC;cAOvFQ,OAAOP;;gBACFQ,IAAI,GAAGZ,IAAIjD;;;YAA0BiD,KAAKjD;YAAM;gBAEpD2D,SAASP,aAAa;sBACnB,eAAN;;gBAGKT,QAAQH,aAAaW,MAAMhB,WAAWwB,OAAjB,CAAb;gBAEVhB,SAAS3C,QAAQ2C,QAAQ9B,OAAOd,SAASsD,KAAKQ,CAArB,GAAyB;sBAC/C,UAAN;;iBAGIlB,QAAQkB;gBACPC,IAAIb,KAAKM,OAAOtD,OAAQgD,KAAKM,OAAOrD,OAAOA,OAAO+C,IAAIM;gBAExDZ,QAAQmB,GAAG;;;gBAITC,aAAa/D,OAAO8D;gBACtBD,IAAIhD,MAAMd,SAASgE,UAAf,GAA4B;sBAC7B,UAAN;;iBAGIA;;cAIAC,MAAMhC,OAAO5H,SAAS;iBACrByI,MAAMQ,IAAIO,MAAMI,KAAKJ,QAAQ,CAA7B;cAIH/C,MAAMwC,IAAIW,GAAV,IAAiBjE,SAASuD,GAAG;oBAC1B,UAAN;;eAGIzC,MAAMwC,IAAIW,GAAV;eACAA;iBAGEC,OAAOZ,KAAK,GAAGC,CAAtB;;eAIMtC,OAAOuB,cAAP,MAAA,QAAwBP,MAAxB;SAjFO;AA2Ff,UAAMkC,SAAS,gCAATA,QAAkBf,OAAO;YACxBnB,SAAS,CAAA;gBAGPD,WAAWoB,KAAX;YAGJC,cAAcD,MAAM/I;YAGpBkJ,IAAIhD;YACJwC,QAAQ;YACRS,OAAOlD;;;;;+BAGgB8C,MAA3B,OAAA,QAAA,EAAA,GAAA,OAAA,EAAA,6BAAA,QAAA,UAAA,KAAA,GAAA,OAAA,4BAAA,MAAkC;gBAAvBgB,iBAAuB,MAAA;gBAC7BA,iBAAe,KAAM;qBACjB9B,KAAKtB,mBAAmBoD,cAAnB,CAAZ;;;;;;;;;;;;;;;;;YAIEC,cAAcpC,OAAO5H;YACrBiK,iBAAiBD;YAMjBA,aAAa;iBACT/B,KAAK9B,SAAZ;;eAIM8D,iBAAiBjB,aAAa;cAIhCkB,IAAIvE;;;;;kCACmBoD,MAA3B,OAAA,QAAA,EAAA,GAAA,QAAA,EAAA,8BAAA,SAAA,WAAA,KAAA,GAAA,OAAA,6BAAA,MAAkC;kBAAvBgB,eAAuB,OAAA;kBAC7BA,gBAAgBb,KAAKa,eAAeG,GAAG;oBACtCH;;;;;;;;;;;;;;;;;cAMAI,wBAAwBF,iBAAiB;cAC3CC,IAAIhB,IAAIzC,OAAOd,SAAS+C,SAASyB,qBAAzB,GAAiD;oBACtD,UAAN;;oBAGSD,IAAIhB,KAAKiB;cACfD;;;;;kCAEuBnB,MAA3B,OAAA,QAAA,EAAA,GAAA,QAAA,EAAA,8BAAA,SAAA,WAAA,KAAA,GAAA,OAAA,6BAAA,MAAkC;kBAAvBgB,gBAAuB,OAAA;kBAC7BA,gBAAeb,KAAK,EAAER,QAAQ/C,QAAQ;wBACnC,UAAN;;kBAEGoE,iBAAgBb,GAAG;oBAElBkB,IAAI1B;;sBACCG,IAAIjD;;;kBAA0BiD,KAAKjD;kBAAM;sBAC3C8D,IAAIb,KAAKM,OAAOtD,OAAQgD,KAAKM,OAAOrD,OAAOA,OAAO+C,IAAIM;sBACxDiB,IAAIV,GAAG;;;sBAGLW,UAAUD,IAAIV;sBACdC,aAAa/D,OAAO8D;yBACnBzB,KACNtB,mBAAmB2B,aAAaoB,IAAIW,UAAUV,YAAY,CAAvC,CAAnB,CADD;sBAGIlD,MAAM4D,UAAUV,UAAhB;;uBAGE1B,KAAKtB,mBAAmB2B,aAAa8B,GAAG,CAAhB,CAAnB,CAAZ;uBACO3B,MAAMC,OAAOyB,uBAAuBF,kBAAkBD,WAAtD;wBACC;kBACNC;;;;;;;;;;;;;;;;;YAIFvB;YACAQ;;eAGItB,OAAOxH,KAAK,EAAZ;SArFO;AAmGf,UAAMkK,YAAY,gCAAZA,WAAqBvB,OAAO;eAC1B1B,UAAU0B,OAAO,SAASzB,QAAQ;iBACjClB,cAAcmE,KAAKjD,MAAnB,IACJwB,OAAOxB,OAAOrH,MAAM,CAAb,EAAgBgB,YAAhB,CAAP,IACAqG;SAHG;SADU;AAmBlB,UAAMkD,UAAU,gCAAVA,SAAmBzB,OAAO;eACxB1B,UAAU0B,OAAO,SAASzB,QAAQ;iBACjCjB,cAAckE,KAAKjD,MAAnB,IACJ,SAASwC,OAAOxC,MAAP,IACTA;SAHG;SADQ;AAWhB,UAAMmD,WAAW;;;;;;mBAML;;;;;;;;gBAQH;oBACG9C;oBACAO;;kBAEDY;kBACAgB;mBACCU;qBACEF;;AD5VP,UAAMI,UAA6C,CAAA;AAE1D,eAAAC,WAA2BC,KAA3B;YACOC,IAAID,IAAI7C,WAAW,CAAf;YACN+C,IAAAA;YAEAD,IAAI;AAAIC,cAAI,OAAOD,EAAEjK,SAAS,EAAX,EAAeM,YAAf;iBACd2J,IAAI;AAAKC,cAAI,MAAMD,EAAEjK,SAAS,EAAX,EAAeM,YAAf;iBACnB2J,IAAI;AAAMC,cAAI,OAAQD,KAAK,IAAK,KAAKjK,SAAS,EAA1B,EAA8BM,YAA9B,IAA8C,OAAQ2J,IAAI,KAAM,KAAKjK,SAAS,EAA1B,EAA8BM,YAA9B;;AAC5E4J,cAAI,OAAQD,KAAK,KAAM,KAAKjK,SAAS,EAA3B,EAA+BM,YAA/B,IAA+C,OAAS2J,KAAK,IAAK,KAAM,KAAKjK,SAAS,EAAjC,EAAqCM,YAArC,IAAqD,OAAQ2J,IAAI,KAAM,KAAKjK,SAAS,EAA1B,EAA8BM,YAA9B;eAExH4J;;AATRH;AAYA,eAAAI,YAA4BzK,KAA5B;YACK0K,SAAS;YACT/B,IAAI;YACFgC,KAAK3K,IAAIN;eAERiJ,IAAIgC,IAAI;cACRJ,IAAIK,SAAS5K,IAAI6K,OAAOlC,IAAI,GAAG,CAAlB,GAAsB,EAA/B;cAEN4B,IAAI,KAAK;sBACFjE,OAAOC,aAAagE,CAApB;iBACL;qBAEGA,KAAK,OAAOA,IAAI,KAAK;gBACxBI,KAAKhC,KAAM,GAAG;kBACZmC,KAAKF,SAAS5K,IAAI6K,OAAOlC,IAAI,GAAG,CAAlB,GAAsB,EAA/B;wBACDrC,OAAOC,cAAegE,IAAI,OAAO,IAAMO,KAAK,EAA5C;mBACJ;wBACI9K,IAAI6K,OAAOlC,GAAG,CAAd;;iBAEN;qBAEG4B,KAAK,KAAK;gBACbI,KAAKhC,KAAM,GAAG;kBACZmC,KAAKF,SAAS5K,IAAI6K,OAAOlC,IAAI,GAAG,CAAlB,GAAsB,EAA/B;kBACLoC,KAAKH,SAAS5K,IAAI6K,OAAOlC,IAAI,GAAG,CAAlB,GAAsB,EAA/B;wBACDrC,OAAOC,cAAegE,IAAI,OAAO,MAAQO,KAAK,OAAO,IAAMC,KAAK,EAAhE;mBACJ;wBACI/K,IAAI6K,OAAOlC,GAAG,CAAd;;iBAEN;iBAED;sBACM3I,IAAI6K,OAAOlC,GAAG,CAAd;iBACL;;;eAIA+B;;AArCRD;AAwCA,eAAAO,4BAAqCC,YAA0BC,UAA/D;iBACAC,kBAA2BnL,KAA3B;cACQoL,SAASX,YAAYzK,GAAZ;iBACP,CAACoL,OAAOC,MAAMH,SAASI,UAAtB,IAAoCtL,MAAMoL;;AAFrDD,eAAAA,mBAAAA;YAKKF,WAAWM;AAAQN,qBAAWM,SAASjF,OAAO2E,WAAWM,MAAlB,EAA0BrE,QAAQgE,SAASM,aAAaL,iBAAxD,EAA0ExK,YAA1E,EAAwFuG,QAAQgE,SAASO,YAAY,EAArH;YACvCR,WAAWS,aAAavL;AAAW8K,qBAAWS,WAAWpF,OAAO2E,WAAWS,QAAlB,EAA4BxE,QAAQgE,SAASM,aAAaL,iBAA1D,EAA4EjE,QAAQgE,SAASS,cAActB,UAA3G,EAAuHnD,QAAQgE,SAASM,aAAa5K,WAArJ;YACzDqK,WAAWW,SAASzL;AAAW8K,qBAAWW,OAAOtF,OAAO2E,WAAWW,IAAlB,EAAwB1E,QAAQgE,SAASM,aAAaL,iBAAtD,EAAwExK,YAAxE,EAAsFuG,QAAQgE,SAASW,UAAUxB,UAAjH,EAA6HnD,QAAQgE,SAASM,aAAa5K,WAA3J;YACjDqK,WAAWa,SAAS3L;AAAW8K,qBAAWa,OAAOxF,OAAO2E,WAAWa,IAAlB,EAAwB5E,QAAQgE,SAASM,aAAaL,iBAAtD,EAAwEjE,QAAS+D,WAAWM,SAASL,SAASa,WAAWb,SAASc,mBAAoB3B,UAAtJ,EAAkKnD,QAAQgE,SAASM,aAAa5K,WAAhM;YACjDqK,WAAWgB,UAAU9L;AAAW8K,qBAAWgB,QAAQ3F,OAAO2E,WAAWgB,KAAlB,EAAyB/E,QAAQgE,SAASM,aAAaL,iBAAvD,EAAyEjE,QAAQgE,SAASgB,WAAW7B,UAArG,EAAiHnD,QAAQgE,SAASM,aAAa5K,WAA/I;YACnDqK,WAAWkB,aAAahM;AAAW8K,qBAAWkB,WAAW7F,OAAO2E,WAAWkB,QAAlB,EAA4BjF,QAAQgE,SAASM,aAAaL,iBAA1D,EAA4EjE,QAAQgE,SAASkB,cAAc/B,UAA3G,EAAuHnD,QAAQgE,SAASM,aAAa5K,WAArJ;eAEtDqK;;AAbRD;AAgBA,eAAAqB,mBAA4BrM,KAA5B;eACQA,IAAIkH,QAAQ,WAAW,IAAvB,KAAgC;;AADxCmF;AAIA,eAAAC,eAAwBV,MAAaV,UAArC;YACOqB,UAAUX,KAAKP,MAAMH,SAASsB,WAApB,KAAoC,CAAA;qCAChCD,SAFrB,CAAA,GAEUE,UAFV,SAAA,CAAA;YAIKA,SAAS;iBACLA,QAAQjM,MAAM,GAAd,EAAmBmG,IAAI0F,kBAAvB,EAA2CvM,KAAK,GAAhD;eACD;iBACC8L;;;AAPTU;AAWA,eAAAI,eAAwBd,MAAaV,UAArC;YACOqB,UAAUX,KAAKP,MAAMH,SAASyB,WAApB,KAAoC,CAAA;sCAC1BJ,SAF3B,CAAA,GAEUE,UAFV,UAAA,CAAA,GAEmBG,OAFnB,UAAA,CAAA;YAIKH,SAAS;sCACUA,QAAQ9L,YAAR,EAAsBH,MAAM,IAA5B,EAAkCqM,QAAlC,qEAAfC,OADK,uBAAA,CAAA,GACCC,QADD,uBAAA,CAAA;cAENC,cAAcD,QAAQA,MAAMvM,MAAM,GAAZ,EAAiBmG,IAAI0F,kBAArB,IAA2C,CAAA;cACjEY,aAAaH,KAAKtM,MAAM,GAAX,EAAgBmG,IAAI0F,kBAApB;cACba,yBAAyBhC,SAASsB,YAAYvC,KAAKgD,WAAWA,WAAWvN,SAAS,CAA/B,CAA1B;cACzByN,aAAaD,yBAAyB,IAAI;cAC1CE,kBAAkBH,WAAWvN,SAASyN;cACtCE,SAAStM,MAAcoM,UAAd;mBAENtN,IAAI,GAAGA,IAAIsN,YAAY,EAAEtN,GAAG;mBAC7BA,CAAP,IAAYmN,YAAYnN,CAAZ,KAAkBoN,WAAWG,kBAAkBvN,CAA7B,KAAmC;;cAG9DqN,wBAAwB;mBACpBC,aAAa,CAApB,IAAyBb,eAAee,OAAOF,aAAa,CAApB,GAAwBjC,QAAvC;;cAGpBoC,gBAAgBD,OAAOE,OAA4C,SAACC,KAAKC,OAAOxE,OAAxF;gBACO,CAACwE,SAASA,UAAU,KAAK;kBACtBC,cAAcF,IAAIA,IAAI9N,SAAS,CAAjB;kBAChBgO,eAAeA,YAAYzE,QAAQyE,YAAYhO,WAAWuJ,OAAO;4BACxDvJ;qBACN;oBACFiI,KAAK,EAAEsB,OAAOvJ,QAAS,EAAlB,CAAT;;;mBAGK8N;aACL,CAAA,CAVmB;cAYhBG,oBAAoBL,cAAcM,KAAK,SAACC,GAAGC,GAAJ;mBAAUA,EAAEpO,SAASmO,EAAEnO;WAA1C,EAAkD,CAAlD;cAEtBqO,UAAAA;cACAJ,qBAAqBA,kBAAkBjO,SAAS,GAAG;gBAChDsO,WAAWX,OAAO1N,MAAM,GAAGgO,kBAAkB1E,KAAlC;gBACXgF,UAAUZ,OAAO1N,MAAMgO,kBAAkB1E,QAAQ0E,kBAAkBjO,MAAzD;sBACNsO,SAASlO,KAAK,GAAd,IAAqB,OAAOmO,QAAQnO,KAAK,GAAb;iBAChC;sBACIuN,OAAOvN,KAAK,GAAZ;;cAGP8M,MAAM;uBACE,MAAMA;;iBAGXmB;eACD;iBACCnC;;;AAlDTc;AAsDA,UAAMwB,YAAY;AAClB,UAAMC,wBAA4C,GAAI9C,MAAM,OAAX,EAAqB,CAArB,MAA4BlL;AAE7E,eAAAiO,MAAsBC,WAAtB;YAAwCC,UAAxC,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAA6D,CAAA;YACtDrD,aAA2B,CAAA;YAC3BC,WAAYoD,QAAQC,QAAQ,QAAQC,eAAeC;YAErDH,QAAQI,cAAc;AAAUL,uBAAaC,QAAQ/C,SAAS+C,QAAQ/C,SAAS,MAAM,MAAM,OAAO8C;YAEhG9B,UAAU8B,UAAUhD,MAAM6C,SAAhB;YAEZ3B,SAAS;cACR4B,uBAAuB;uBAEf5C,SAASgB,QAAQ,CAAR;uBACTb,WAAWa,QAAQ,CAAR;uBACXX,OAAOW,QAAQ,CAAR;uBACPoC,OAAO/D,SAAS2B,QAAQ,CAAR,GAAY,EAArB;uBACPT,OAAOS,QAAQ,CAAR,KAAc;uBACrBN,QAAQM,QAAQ,CAAR;uBACRJ,WAAWI,QAAQ,CAAR;gBAGlBqC,MAAM3D,WAAW0D,IAAjB,GAAwB;yBAChBA,OAAOpC,QAAQ,CAAR;;iBAEb;uBAEKhB,SAASgB,QAAQ,CAAR,KAAcpM;uBACvBuL,WAAY2C,UAAUQ,QAAQ,GAAlB,MAA2B,KAAKtC,QAAQ,CAAR,IAAapM;uBACzDyL,OAAQyC,UAAUQ,QAAQ,IAAlB,MAA4B,KAAKtC,QAAQ,CAAR,IAAapM;uBACtDwO,OAAO/D,SAAS2B,QAAQ,CAAR,GAAY,EAArB;uBACPT,OAAOS,QAAQ,CAAR,KAAc;uBACrBN,QAASoC,UAAUQ,QAAQ,GAAlB,MAA2B,KAAKtC,QAAQ,CAAR,IAAapM;uBACtDgM,WAAYkC,UAAUQ,QAAQ,GAAlB,MAA2B,KAAKtC,QAAQ,CAAR,IAAapM;gBAGhEyO,MAAM3D,WAAW0D,IAAjB,GAAwB;yBAChBA,OAAQN,UAAUhD,MAAM,+BAAhB,IAAmDkB,QAAQ,CAAR,IAAapM;;;cAIjF8K,WAAWW,MAAM;uBAETA,OAAOc,eAAeJ,eAAerB,WAAWW,MAAMV,QAAhC,GAA2CA,QAA1D;;cAIfD,WAAWM,WAAWpL,UAAa8K,WAAWS,aAAavL,UAAa8K,WAAWW,SAASzL,UAAa8K,WAAW0D,SAASxO,UAAa,CAAC8K,WAAWa,QAAQb,WAAWgB,UAAU9L,QAAW;uBACtLuO,YAAY;qBACbzD,WAAWM,WAAWpL,QAAW;uBAChCuO,YAAY;qBACbzD,WAAWkB,aAAahM,QAAW;uBAClCuO,YAAY;iBACjB;uBACKA,YAAY;;cAIpBJ,QAAQI,aAAaJ,QAAQI,cAAc,YAAYJ,QAAQI,cAAczD,WAAWyD,WAAW;uBAC3FlI,QAAQyE,WAAWzE,SAAS,kBAAkB8H,QAAQI,YAAY;;cAIxEI,gBAAgB1E,SAASkE,QAAQ/C,UAAUN,WAAWM,UAAU,IAAI5K,YAA5C,CAAR;cAGlB,CAAC2N,QAAQS,mBAAmB,CAACD,iBAAiB,CAACA,cAAcC,iBAAiB;gBAE7E9D,WAAWW,SAAS0C,QAAQU,cAAeF,iBAAiBA,cAAcE,aAAc;kBAEvF;2BACQpD,OAAOzB,SAASD,QAAQe,WAAWW,KAAK1E,QAAQgE,SAASM,aAAaf,WAA9C,EAA2D9J,YAA3D,CAAjB;uBACV6J,GAAG;2BACAhE,QAAQyE,WAAWzE,SAAS,oEAAoEgE;;;wCAIjFS,YAAYwD,YAAxC;iBACM;wCAEsBxD,YAAYC,QAAxC;;cAIG4D,iBAAiBA,cAAcV,OAAO;0BAC3BA,MAAMnD,YAAYqD,OAAhC;;eAEK;qBACK9H,QAAQyE,WAAWzE,SAAS;;eAGjCyE;;AAzFRmD;AA4FA,eAAAa,oBAA6BhE,YAA0BqD,SAAvD;YACOpD,WAAYoD,QAAQC,QAAQ,QAAQC,eAAeC;YACnDS,YAA0B,CAAA;YAE5BjE,WAAWS,aAAavL,QAAW;oBAC5BwH,KAAKsD,WAAWS,QAA1B;oBACU/D,KAAK,GAAf;;YAGGsD,WAAWW,SAASzL,QAAW;oBAExBwH,KAAK+E,eAAeJ,eAAehG,OAAO2E,WAAWW,IAAlB,GAAyBV,QAAxC,GAAmDA,QAAlE,EAA4EhE,QAAQgE,SAASyB,aAAa,SAACwC,GAAGC,IAAIC,IAAR;mBAAe,MAAMD,MAAMC,KAAK,QAAQA,KAAK,MAAM;WAA7J,CAAf;;YAGG,OAAOpE,WAAW0D,SAAS,YAAY,OAAO1D,WAAW0D,SAAS,UAAU;oBACrEhH,KAAK,GAAf;oBACUA,KAAKrB,OAAO2E,WAAW0D,IAAlB,CAAf;;eAGMO,UAAUxP,SAASwP,UAAUpP,KAAK,EAAf,IAAqBK;;AAnBhD8O;AAsBA,UAAMK,OAAO;AACb,UAAMC,OAAO;AACb,UAAMC,OAAO;AAEb,UAAMC,OAAO;AAEb,eAAAC,kBAAkCjH,OAAlC;YACOnB,SAAuB,CAAA;eAEtBmB,MAAM/I,QAAQ;cAChB+I,MAAM4C,MAAMiE,IAAZ,GAAmB;oBACd7G,MAAMvB,QAAQoI,MAAM,EAApB;qBACE7G,MAAM4C,MAAMkE,IAAZ,GAAmB;oBACrB9G,MAAMvB,QAAQqI,MAAM,GAApB;qBACE9G,MAAM4C,MAAMmE,IAAZ,GAAmB;oBACrB/G,MAAMvB,QAAQsI,MAAM,GAApB;mBACD/O,IAAP;qBACUgI,UAAU,OAAOA,UAAU,MAAM;oBACnC;iBACF;gBACAkH,KAAKlH,MAAM4C,MAAMoE,IAAZ;gBACPE,IAAI;kBACDC,IAAID,GAAG,CAAH;sBACFlH,MAAM9I,MAAMiQ,EAAElQ,MAAd;qBACDiI,KAAKiI,CAAZ;mBACM;oBACA,IAAIC,MAAM,kCAAV;;;;eAKFvI,OAAOxH,KAAK,EAAZ;;AAzBR4P;AA4BA,eAAAI,UAA0B7E,YAA1B;YAAoDqD,UAApD,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAyE,CAAA;YAClEpD,WAAYoD,QAAQC,MAAMC,eAAeC;YACzCS,YAA0B,CAAA;YAG1BJ,gBAAgB1E,SAASkE,QAAQ/C,UAAUN,WAAWM,UAAU,IAAI5K,YAA5C,CAAR;YAGlBmO,iBAAiBA,cAAcgB;AAAWhB,wBAAcgB,UAAU7E,YAAYqD,OAApC;YAE1CrD,WAAWW,MAAM;cAEhBV,SAASyB,YAAY1C,KAAKgB,WAAWW,IAArC,GAA4C;UAAA,WAKvC0C,QAAQU,cAAeF,iBAAiBA,cAAcE,YAAa;gBAEvE;yBACQpD,OAAQ,CAAC0C,QAAQC,MAAMpE,SAASD,QAAQe,WAAWW,KAAK1E,QAAQgE,SAASM,aAAaf,WAA9C,EAA2D9J,YAA3D,CAAjB,IAA6FwJ,SAASH,UAAUiB,WAAWW,IAA9B;qBACvHpB,GAAG;yBACAhE,QAAQyE,WAAWzE,SAAS,iDAAiD,CAAC8H,QAAQC,MAAM,UAAU,aAAa,oBAAoB/D;;;;oCAMzHS,YAAYC,QAAxC;YAEIoD,QAAQI,cAAc,YAAYzD,WAAWM,QAAQ;oBAC9C5D,KAAKsD,WAAWM,MAA1B;oBACU5D,KAAK,GAAf;;YAGKoI,YAAYd,oBAAoBhE,YAAYqD,OAAhC;YACdyB,cAAc5P,QAAW;cACxBmO,QAAQI,cAAc,UAAU;sBACzB/G,KAAK,IAAf;;oBAGSA,KAAKoI,SAAf;cAEI9E,WAAWa,QAAQb,WAAWa,KAAKkE,OAAO,CAAvB,MAA8B,KAAK;sBAC/CrI,KAAK,GAAf;;;YAIEsD,WAAWa,SAAS3L,QAAW;cAC9ByP,IAAI3E,WAAWa;cAEf,CAACwC,QAAQ2B,iBAAiB,CAACnB,iBAAiB,CAACA,cAAcmB,eAAe;gBACzEP,kBAAkBE,CAAlB;;cAGDG,cAAc5P,QAAW;gBACxByP,EAAE1I,QAAQ,SAAS,MAAnB;;oBAGKS,KAAKiI,CAAf;;YAGG3E,WAAWgB,UAAU9L,QAAW;oBACzBwH,KAAK,GAAf;oBACUA,KAAKsD,WAAWgB,KAA1B;;YAGGhB,WAAWkB,aAAahM,QAAW;oBAC5BwH,KAAK,GAAf;oBACUA,KAAKsD,WAAWkB,QAA1B;;eAGM+C,UAAUpP,KAAK,EAAf;;AAxERgQ;AA2EA,eAAAI,kBAAkC5K,OAAoB6K,UAAtD;YAA8E7B,UAA9E,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAmG,CAAA;YAAI8B,oBAAvG,UAAA,CAAA;YACOlP,SAAuB,CAAA;YAEzB,CAACkP,mBAAmB;kBAChBhC,MAAM0B,UAAUxK,OAAMgJ,OAAhB,GAA0BA,OAAhC;qBACIF,MAAM0B,UAAUK,UAAU7B,OAApB,GAA8BA,OAApC;;kBAEFA,WAAW,CAAA;YAEjB,CAACA,QAAQ+B,YAAYF,SAAS5E,QAAQ;iBAClCA,SAAS4E,SAAS5E;iBAElBG,WAAWyE,SAASzE;iBACpBE,OAAOuE,SAASvE;iBAChB+C,OAAOwB,SAASxB;iBAChB7C,OAAO4D,kBAAkBS,SAASrE,QAAQ,EAAnC;iBACPG,QAAQkE,SAASlE;eAClB;cACFkE,SAASzE,aAAavL,UAAagQ,SAASvE,SAASzL,UAAagQ,SAASxB,SAASxO,QAAW;mBAE3FuL,WAAWyE,SAASzE;mBACpBE,OAAOuE,SAASvE;mBAChB+C,OAAOwB,SAASxB;mBAChB7C,OAAO4D,kBAAkBS,SAASrE,QAAQ,EAAnC;mBACPG,QAAQkE,SAASlE;iBAClB;gBACF,CAACkE,SAASrE,MAAM;qBACZA,OAAOxG,MAAKwG;kBACfqE,SAASlE,UAAU9L,QAAW;uBAC1B8L,QAAQkE,SAASlE;qBAClB;uBACCA,QAAQ3G,MAAK2G;;mBAEf;kBACFkE,SAASrE,KAAKkE,OAAO,CAArB,MAA4B,KAAK;uBAC7BlE,OAAO4D,kBAAkBS,SAASrE,IAA3B;qBACR;qBACDxG,MAAKoG,aAAavL,UAAamF,MAAKsG,SAASzL,UAAamF,MAAKqJ,SAASxO,WAAc,CAACmF,MAAKwG,MAAM;yBAC/FA,OAAO,MAAMqE,SAASrE;2BACnB,CAACxG,MAAKwG,MAAM;yBACfA,OAAOqE,SAASrE;uBACjB;yBACCA,OAAOxG,MAAKwG,KAAKnM,MAAM,GAAG2F,MAAKwG,KAAK/C,YAAY,GAAtB,IAA6B,CAAhD,IAAqDoH,SAASrE;;uBAEtEA,OAAO4D,kBAAkBxO,OAAO4K,IAAzB;;qBAERG,QAAQkE,SAASlE;;mBAGlBP,WAAWpG,MAAKoG;mBAChBE,OAAOtG,MAAKsG;mBACZ+C,OAAOrJ,MAAKqJ;;iBAEbpD,SAASjG,MAAKiG;;eAGfY,WAAWgE,SAAShE;eAEpBjL;;AA1DRgP;AA6DA,eAAAI,QAAwBC,SAAgBC,aAAoBlC,SAA5D;YACOmC,oBAAoBxP,OAAO,EAAEsK,QAAS,OAAX,GAAqB+C,OAA5B;eACnBwB,UAAUI,kBAAkB9B,MAAMmC,SAASE,iBAAf,GAAmCrC,MAAMoC,aAAaC,iBAAnB,GAAuCA,mBAAmB,IAA/G,GAAsHA,iBAAhI;;AAFRH;AAOA,eAAAI,UAA0BC,KAASrC,SAAnC;YACK,OAAOqC,QAAQ,UAAU;gBACtBb,UAAU1B,MAAMuC,KAAKrC,OAAX,GAAqBA,OAA/B;mBACIrO,OAAO0Q,GAAP,MAAgB,UAAU;gBAC9BvC,MAAM0B,UAAyBa,KAAKrC,OAA9B,GAAwCA,OAA9C;;eAGAqC;;AAPRD;AAYA,eAAAE,MAAsBC,MAAUC,MAAUxC,SAA1C;YACK,OAAOuC,SAAS,UAAU;iBACtBf,UAAU1B,MAAMyC,MAAMvC,OAAZ,GAAsBA,OAAhC;mBACGrO,OAAO4Q,IAAP,MAAiB,UAAU;iBAC9Bf,UAAyBe,MAAMvC,OAA/B;;YAGJ,OAAOwC,SAAS,UAAU;iBACtBhB,UAAU1B,MAAM0C,MAAMxC,OAAZ,GAAsBA,OAAhC;mBACGrO,OAAO6Q,IAAP,MAAiB,UAAU;iBAC9BhB,UAAyBgB,MAAMxC,OAA/B;;eAGDuC,SAASC;;AAbjBF;AAgBA,eAAAG,gBAAgC/Q,KAAYsO,SAA5C;eACQtO,OAAOA,IAAIM,SAAJ,EAAe4G,QAAS,CAACoH,WAAW,CAACA,QAAQC,MAAME,aAAauC,SAASxC,aAAawC,QAAS3G,UAA/F;;AADf0G;AAIA,eAAAE,kBAAkCjR,KAAYsO,SAA9C;eACQtO,OAAOA,IAAIM,SAAJ,EAAe4G,QAAS,CAACoH,WAAW,CAACA,QAAQC,MAAME,aAAajD,cAAcgD,aAAahD,aAAcf,WAAzG;;AADfwG;ADviBA,UAAMC,UAA2B;gBACvB;oBAEI;eAEL,gCAAA9C,OAAUnD,YAA0BqD,SAA7C;cAEM,CAACrD,WAAWW,MAAM;uBACVpF,QAAQyE,WAAWzE,SAAS;;iBAGjCyE;WANA;mBASI,gCAAA6E,WAAU7E,YAA0BqD,SAAjD;cACQ6C,SAAS7K,OAAO2E,WAAWM,MAAlB,EAA0B5K,YAA1B,MAA4C;cAGvDsK,WAAW0D,UAAUwC,SAAS,MAAM,OAAOlG,WAAW0D,SAAS,IAAI;uBAC3DA,OAAOxO;;cAIf,CAAC8K,WAAWa,MAAM;uBACVA,OAAO;;iBAOZb;WAjBI;;ADbb,UAAMiG,YAA2B;gBACvB;oBACIE,QAAKpC;eACVoC,QAAKhD;mBACDgD,QAAKtB;;ADAlB,eAAAuB,SAAkBC,cAAlB;eACQ,OAAOA,aAAaH,WAAW,YAAYG,aAAaH,SAAS7K,OAAOgL,aAAa/F,MAApB,EAA4B5K,YAA5B,MAA8C;;AADvH0Q;AAKA,UAAMH,YAA2B;gBACvB;oBAEI;eAEL,gCAAA9C,OAAUnD,YAA0BqD,SAA7C;cACQgD,eAAerG;uBAGRkG,SAASE,SAASC,YAAT;uBAGTC,gBAAgBD,aAAaxF,QAAQ,QAAQwF,aAAarF,QAAQ,MAAMqF,aAAarF,QAAQ;uBAC7FH,OAAO3L;uBACP8L,QAAQ9L;iBAEdmR;WAXA;mBAcI,gCAAAxB,WAAUwB,cAA2BhD,SAAlD;cAEMgD,aAAa3C,UAAU0C,SAASC,YAAT,IAAyB,MAAM,OAAOA,aAAa3C,SAAS,IAAI;yBAC7EA,OAAOxO;;cAIjB,OAAOmR,aAAaH,WAAW,WAAW;yBAChC5F,SAAU+F,aAAaH,SAAS,QAAQ;yBACxCA,SAAShR;;cAInBmR,aAAaC,cAAc;wCACRD,aAAaC,aAAa/Q,MAAM,GAAhC,qEAAfsL,OADuB,uBAAA,CAAA,GACjBG,QADiB,uBAAA,CAAA;yBAEjBH,OAAQA,QAAQA,SAAS,MAAMA,OAAO3L;yBACtC8L,QAAQA;yBACRsF,eAAepR;;uBAIhBgM,WAAWhM;iBAEjBmR;WAvBI;;AD5Bb,UAAMJ,YAA2B;gBACvB;oBACIM,UAAGxC;eACRwC,UAAGpD;mBACCoD,UAAG1B;;ADShB,UAAM2B,IAAkB,CAAA;AACxB,UAAMnQ,QAAQ;AAGd,UAAMc,eAAe,4BAA4Bd,QAAQ,8EAA8E,MAAM;AAC7I,UAAMK,WAAW;AACjB,UAAME,eAAe9B,OAAOA,OAAO,YAAY4B,WAAW,MAAMA,WAAWA,WAAW,MAAMA,WAAWA,QAA3E,IAAuF,MAAM5B,OAAO,gBAAgB4B,WAAW,MAAMA,WAAWA,QAAnD,IAA+D,MAAM5B,OAAO,MAAM4B,WAAWA,QAAxB,CAAzK;AAarB,UAAM+P,UAAU;AAChB,UAAMC,UAAU;AAChB,UAAMC,UAAUpS,MAAMmS,SAAS,WAAf;AAQhB,UAAME,gBAAgB;AAatB,UAAMvG,aAAa,IAAIlG,OAAOhD,cAAc,GAAzB;AACnB,UAAMoJ,cAAc,IAAIpG,OAAOvD,cAAc,GAAzB;AACpB,UAAMiQ,iBAAiB,IAAI1M,OAAO5F,MAAM,OAAOkS,SAAS,SAAS,SAASE,OAAxC,GAAkD,GAA7D;AAEvB,UAAMG,aAAa,IAAI3M,OAAO5F,MAAM,OAAO4C,cAAcyP,aAA3B,GAA2C,GAAtD;AACnB,UAAMG,cAAcD;AAIpB,eAAA5G,iBAA0BnL,KAA1B;YACOoL,SAASX,YAAYzK,GAAZ;eACP,CAACoL,OAAOC,MAAMC,UAAb,IAA2BtL,MAAMoL;;AAF3CD;AAKA,UAAM+F,YAA8C;gBAC1C;eAED,gCAAA,SAAUjG,YAA0BqD,SAA7C;cACQ2D,mBAAmBhH;cACnBiH,KAAKD,iBAAiBC,KAAMD,iBAAiBnG,OAAOmG,iBAAiBnG,KAAKtL,MAAM,GAA5B,IAAmC,CAAA;2BAC5EsL,OAAO3L;cAEpB8R,iBAAiBhG,OAAO;gBACvBkG,iBAAiB;gBACfC,UAAwB,CAAA;gBACxBC,UAAUJ,iBAAiBhG,MAAMzL,MAAM,GAA7B;qBAEPX,IAAI,GAAGD,KAAKyS,QAAQ3S,QAAQG,IAAID,IAAI,EAAEC,GAAG;kBAC3CyS,SAASD,QAAQxS,CAAR,EAAWW,MAAM,GAAjB;sBAEP8R,OAAO,CAAP,GAAR;qBACM;sBACEC,UAAUD,OAAO,CAAP,EAAU9R,MAAM,GAAhB;2BACPX,KAAI,GAAGD,MAAK2S,QAAQ7S,QAAQG,KAAID,KAAI,EAAEC,IAAG;uBAC9C8H,KAAK4K,QAAQ1S,EAAR,CAAR;;;qBAGG;mCACa2S,UAAUvB,kBAAkBqB,OAAO,CAAP,GAAWhE,OAA7B;;qBAEvB;mCACamE,OAAOxB,kBAAkBqB,OAAO,CAAP,GAAWhE,OAA7B;;;mCAGP;0BACT2C,kBAAkBqB,OAAO,CAAP,GAAWhE,OAA7B,CAAR,IAAiD2C,kBAAkBqB,OAAO,CAAP,GAAWhE,OAA7B;;;;gBAKhD6D;AAAgBF,+BAAiBG,UAAUA;;2BAG/BnG,QAAQ9L;mBAEhBN,MAAI,GAAGD,OAAKsS,GAAGxS,QAAQG,MAAID,MAAI,EAAEC,KAAG;gBACtC6S,OAAOR,GAAGrS,GAAH,EAAMW,MAAM,GAAZ;iBAER,CAAL,IAAUyQ,kBAAkByB,KAAK,CAAL,CAAlB;gBAEN,CAACpE,QAAQS,gBAAgB;kBAExB;qBACE,CAAL,IAAU5E,SAASD,QAAQ+G,kBAAkByB,KAAK,CAAL,GAASpE,OAA3B,EAAoC3N,YAApC,CAAjB;uBACF6J,GAAG;iCACMhE,QAAQyL,iBAAiBzL,SAAS,6EAA6EgE;;mBAE3H;mBACD,CAAL,IAAUyG,kBAAkByB,KAAK,CAAL,GAASpE,OAA3B,EAAoC3N,YAApC;;eAGRd,GAAH,IAAQ6S,KAAK5S,KAAK,GAAV;;iBAGFmS;WAzDA;mBA4DI,gCAAA,aAAUA,kBAAmC3D,SAA1D;cACQrD,aAAagH;cACbC,KAAKrR,QAAQoR,iBAAiBC,EAAzB;cACPA,IAAI;qBACErS,IAAI,GAAGD,KAAKsS,GAAGxS,QAAQG,IAAID,IAAI,EAAEC,GAAG;kBACtC8S,SAASrM,OAAO4L,GAAGrS,CAAH,CAAP;kBACT+S,QAAQD,OAAO5J,YAAY,GAAnB;kBACR8J,YAAaF,OAAOhT,MAAM,GAAGiT,KAAhB,EAAwB1L,QAAQsE,aAAaL,gBAA9C,EAAgEjE,QAAQsE,aAAa5K,WAArF,EAAkGsG,QAAQ4K,gBAAgBzH,UAA1H;kBACdyI,SAASH,OAAOhT,MAAMiT,QAAQ,CAArB;kBAGT;yBACO,CAACtE,QAAQC,MAAMpE,SAASD,QAAQ+G,kBAAkB6B,QAAQxE,OAA1B,EAAmC3N,YAAnC,CAAjB,IAAqEwJ,SAASH,UAAU8I,MAAnB;uBACtFtI,GAAG;2BACAhE,QAAQyE,WAAWzE,SAAS,0DAA0D,CAAC8H,QAAQC,MAAM,UAAU,aAAa,oBAAoB/D;;iBAGzJ3K,CAAH,IAAQgT,YAAY,MAAMC;;uBAGhBhH,OAAOoG,GAAGpS,KAAK,GAAR;;cAGbsS,UAAUH,iBAAiBG,UAAUH,iBAAiBG,WAAW,CAAA;cAEnEH,iBAAiBO;AAASJ,oBAAQ,SAAR,IAAqBH,iBAAiBO;cAChEP,iBAAiBQ;AAAML,oBAAQ,MAAR,IAAkBH,iBAAiBQ;cAExDpF,SAAS,CAAA;mBACJ0F,QAAQX,SAAS;gBACvBA,QAAQW,IAAR,MAAkBtB,EAAEsB,IAAF,GAAS;qBACvBpL,KACNoL,KAAK7L,QAAQsE,aAAaL,gBAA1B,EAA4CjE,QAAQsE,aAAa5K,WAAjE,EAA8EsG,QAAQ6K,YAAY1H,UAAlG,IACA,MACA+H,QAAQW,IAAR,EAAc7L,QAAQsE,aAAaL,gBAAnC,EAAqDjE,QAAQsE,aAAa5K,WAA1E,EAAuFsG,QAAQ8K,aAAa3H,UAA5G,CAHD;;;cAOEgD,OAAO3N,QAAQ;uBACPuM,QAAQoB,OAAOvN,KAAK,GAAZ;;iBAGbmL;WA1CI;;ADrHb,UAAM+H,YAAY;AAIlB,UAAM9B,YAAqD;gBACjD;eAED,gCAAA,SAAUjG,YAA0BqD,SAA7C;cACQ/B,UAAUtB,WAAWa,QAAQb,WAAWa,KAAKT,MAAM2H,SAAtB;cAC/BC,gBAAgBhI;cAEhBsB,SAAS;gBACNhB,SAAS+C,QAAQ/C,UAAU0H,cAAc1H,UAAU;gBACnD2H,MAAM3G,QAAQ,CAAR,EAAW5L,YAAX;gBACNwS,MAAM5G,QAAQ,CAAR;gBACN6G,YAAe7H,SAAf,OAAyB+C,QAAQ4E,OAAOA;gBACxCpE,gBAAgB1E,QAAQgJ,SAAR;0BAERF,MAAMA;0BACNC,MAAMA;0BACNrH,OAAO3L;gBAEjB2O,eAAe;8BACFA,cAAcV,MAAM6E,eAAe3E,OAAnC;;iBAEX;0BACQ9H,QAAQyM,cAAczM,SAAS;;iBAGvCyM;WAtBA;mBAyBI,gCAAA,aAAUA,eAA6B3E,SAApD;cACQ/C,SAAS+C,QAAQ/C,UAAU0H,cAAc1H,UAAU;cACnD2H,MAAMD,cAAcC;cACpBE,YAAe7H,SAAf,OAAyB+C,QAAQ4E,OAAOA;cACxCpE,gBAAgB1E,QAAQgJ,SAAR;cAElBtE,eAAe;4BACFA,cAAcgB,UAAUmD,eAAe3E,OAAvC;;cAGX+E,gBAAgBJ;cAChBE,MAAMF,cAAcE;wBACZrH,QAAUoH,OAAO5E,QAAQ4E,OAAvC,MAA8CC;iBAEvCE;WAdI;;AD1Cb,UAAMC,OAAO;AAIb,UAAMpC,YAAsE;gBAClE;eAED,gCAAA9C,OAAU6E,eAA6B3E,SAAhD;cACQiF,iBAAiBN;yBACRO,OAAOD,eAAeJ;yBACtBA,MAAMhT;cAEjB,CAACmO,QAAQ+B,aAAa,CAACkD,eAAeC,QAAQ,CAACD,eAAeC,KAAKnI,MAAMiI,IAA1B,IAAkC;2BACrE9M,QAAQ+M,eAAe/M,SAAS;;iBAGzC+M;WATA;mBAYI,gCAAAzD,WAAUyD,gBAA+BjF,SAAtD;cACQ2E,gBAAgBM;wBAERJ,OAAOI,eAAeC,QAAQ,IAAI7S,YAA5B;iBACbsS;WAJI;;ADxBb7I,cAAQgH,QAAK7F,MAAb,IAAuB6F;AAGvBhH,cAAQqJ,UAAMlI,MAAd,IAAwBkI;AAGxBrJ,cAAQoH,UAAGjG,MAAX,IAAqBiG;AAGrBpH,cAAQsJ,UAAInI,MAAZ,IAAsBmI;AAGtBtJ,cAAQuJ,UAAOpI,MAAf,IAAyBoI;AAGzBvJ,cAAQwJ,UAAIrI,MAAZ,IAAsBqI;AAGtBxJ,cAAQoJ,UAAKjI,MAAb,IAAuBiI;;;;;;;;;;;;;;;;;;;;;;;AarBvB,QAAA,MAAA;AAGE,QAAY,OAAO;AAErB,IAAAK,SAAA,UAAe;;;;;;;;;;ACuBf,QAAA,aAAA;AAAQ,WAAA,eAAAC,UAAA,cAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,WAAA;IAAU,EAAA,CAAA;AAKlB,QAAA,YAAA;AAAQ,WAAA,eAAAA,UAAA,KAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAC,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,OAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAG,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,aAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAS,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,OAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAG,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,QAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAI,EAAA,CAAA;AAAQ,WAAA,eAAAA,UAAA,WAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAO,EAAA,CAAA;AAsBnD,QAAA,qBAAA;AACA,QAAA,cAAA;AACA,QAAA,UAAA;AACA,QAAA,YAAA;AACA,QAAA,YAAA;AACA,QAAA,YAAA;AACA,QAAA,aAAA;AACA,QAAA,SAAA;AACA,QAAA,iBAAA;AAEA,QAAA,QAAA;AAEA,QAAM,gBAA8B,wBAAC,KAAK,UAAU,IAAI,OAAO,KAAK,KAAK,GAArC;AACpC,kBAAc,OAAO;AAErB,QAAM,sBAAyC,CAAC,oBAAoB,eAAe,aAAa;AAChG,QAAM,kBAAkB,oBAAI,IAAI;MAC9B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;KACD;AAyGD,QAAM,iBAA8C;MAClD,eAAe;MACf,QAAQ;MACR,UAAU;MACV,cAAc;MACd,YAAY;MACZ,aAAa;MACb,aAAa;MACb,YAAY;MACZ,gBAAgB;MAChB,gBAAgB;MAChB,aAAa;MACb,gBAAgB;MAChB,OAAO;MACP,WAAW;MACX,WAAW;;AAGb,QAAM,oBAAoD;MACxD,uBAAuB;MACvB,kBAAkB;MAClB,SAAS;;AA0BX,QAAM,iBAAiB;AAGvB,aAAS,gBAAgB,GAAU;;AACjC,YAAM,IAAI,EAAE;AACZ,YAAM,SAAQ,KAAA,EAAE,UAAI,QAAA,OAAA,SAAA,SAAA,GAAE;AACtB,YAAM,WAAW,UAAU,QAAQ,UAAU,SAAY,IAAI,SAAS;AACtE,YAAM,UAAS,MAAA,KAAA,EAAE,UAAI,QAAA,OAAA,SAAA,SAAA,GAAE,YAAM,QAAA,OAAA,SAAA,KAAI;AACjC,YAAM,eAAc,KAAA,EAAE,iBAAW,QAAA,OAAA,SAAA,KAAI,MAAA;AACrC,aAAO;QACL,eAAc,MAAA,KAAA,EAAE,kBAAY,QAAA,OAAA,SAAA,KAAI,OAAC,QAAA,OAAA,SAAA,KAAI;QACrC,gBAAe,MAAA,KAAA,EAAE,mBAAa,QAAA,OAAA,SAAA,KAAI,OAAC,QAAA,OAAA,SAAA,KAAI;QACvC,cAAa,MAAA,KAAA,EAAE,iBAAW,QAAA,OAAA,SAAA,KAAI,OAAC,QAAA,OAAA,SAAA,KAAI;QACnC,eAAc,MAAA,KAAA,EAAE,kBAAY,QAAA,OAAA,SAAA,KAAI,OAAC,QAAA,OAAA,SAAA,KAAI;QACrC,iBAAgB,MAAA,KAAA,EAAE,oBAAc,QAAA,OAAA,SAAA,KAAI,OAAC,QAAA,OAAA,SAAA,KAAI;QACzC,MAAM,EAAE,OAAO,EAAC,GAAG,EAAE,MAAM,UAAU,OAAM,IAAI,EAAC,UAAU,OAAM;QAChE,eAAc,KAAA,EAAE,kBAAY,QAAA,OAAA,SAAA,KAAI;QAChC,WAAU,KAAA,EAAE,cAAQ,QAAA,OAAA,SAAA,KAAI;QACxB,OAAM,KAAA,EAAE,UAAI,QAAA,OAAA,SAAA,KAAI;QAChB,WAAU,KAAA,EAAE,cAAQ,QAAA,OAAA,SAAA,KAAI;QACxB,aAAY,KAAA,EAAE,gBAAU,QAAA,OAAA,SAAA,KAAI;QAC5B,WAAU,KAAA,EAAE,cAAQ,QAAA,OAAA,SAAA,KAAI;QACxB,gBAAe,KAAA,EAAE,mBAAa,QAAA,OAAA,SAAA,KAAI;QAClC,iBAAgB,KAAA,EAAE,oBAAc,QAAA,OAAA,SAAA,KAAI;QACpC,kBAAiB,KAAA,EAAE,qBAAe,QAAA,OAAA,SAAA,KAAI;QACtC,gBAAe,KAAA,EAAE,mBAAa,QAAA,OAAA,SAAA,KAAI;QAClC,aAAY,KAAA,EAAE,gBAAU,QAAA,OAAA,SAAA,KAAI;QAC5B;;IAEJ;AA1BS;AAkCT,QAAqB,MAArB,MAAwB;aAAA;;;MAkBtB,YAAY,OAAgB,CAAA,GAAE;AAZrB,aAAA,UAAyC,CAAA;AACzC,aAAA,OAA+C,CAAA;AAC/C,aAAA,UAA4C,CAAA;AAE5C,aAAA,gBAAgC,oBAAI,IAAG;AAC/B,aAAA,WAAyD,CAAA;AACzD,aAAA,SAAoC,oBAAI,IAAG;AAO1D,eAAO,KAAK,OAAO,EAAC,GAAG,MAAM,GAAG,gBAAgB,IAAI,EAAC;AACrD,cAAM,EAAC,KAAK,MAAK,IAAI,KAAK,KAAK;AAE/B,aAAK,QAAQ,IAAI,UAAA,WAAW,EAAC,OAAO,CAAA,GAAI,UAAU,iBAAiB,KAAK,MAAK,CAAC;AAC9E,aAAK,SAAS,UAAU,KAAK,MAAM;AACnC,cAAM,YAAY,KAAK;AACvB,aAAK,kBAAkB;AAEvB,aAAK,SAAQ,GAAA,QAAA,UAAQ;AACrB,qBAAa,KAAK,MAAM,gBAAgB,MAAM,eAAe;AAC7D,qBAAa,KAAK,MAAM,mBAAmB,MAAM,cAAc,MAAM;AACrE,aAAK,YAAY,qBAAqB,KAAK,IAAI;AAE/C,YAAI,KAAK;AAAS,4BAAkB,KAAK,IAAI;AAC7C,aAAK,iBAAgB;AACrB,aAAK,sBAAqB;AAC1B,YAAI,KAAK;AAAU,6BAAmB,KAAK,MAAM,KAAK,QAAQ;AAC9D,YAAI,OAAO,KAAK,QAAQ;AAAU,eAAK,cAAc,KAAK,IAAI;AAC9D,0BAAkB,KAAK,IAAI;AAC3B,aAAK,kBAAkB;MACzB;MAEA,mBAAgB;AACd,aAAK,WAAW,QAAQ;MAC1B;MAEA,wBAAqB;AACnB,cAAM,EAAC,OAAO,MAAM,SAAQ,IAAI,KAAK;AACrC,YAAI,iBAA+B;AACnC,YAAI,aAAa,MAAM;AACrB,2BAAiB,EAAC,GAAG,eAAc;AACnC,yBAAe,KAAK,eAAe;AACnC,iBAAO,eAAe;;AAExB,YAAI,QAAQ;AAAO,eAAK,cAAc,gBAAgB,eAAe,QAAQ,GAAG,KAAK;MACvF;MAEA,cAAW;AACT,cAAM,EAAC,MAAM,SAAQ,IAAI,KAAK;AAC9B,eAAQ,KAAK,KAAK,cAAc,OAAO,QAAQ,WAAW,KAAK,QAAQ,KAAK,OAAO;MACrF;MAkBA,SACE,cACA;AAEA,YAAI;AACJ,YAAI,OAAO,gBAAgB,UAAU;AACnC,cAAI,KAAK,UAAa,YAAY;AAClC,cAAI,CAAC;AAAG,kBAAM,IAAI,MAAM,8BAA8B,YAAY,GAAG;eAChE;AACL,cAAI,KAAK,QAAW,YAAY;;AAGlC,cAAM,QAAQ,EAAE,IAAI;AACpB,YAAI,EAAE,YAAY;AAAI,eAAK,SAAS,EAAE;AACtC,eAAO;MACT;MAgBA,QAAqB,QAAmB,OAAe;AACrD,cAAM,MAAM,KAAK,WAAW,QAAQ,KAAK;AACzC,eAAQ,IAAI,YAAY,KAAK,kBAAkB,GAAG;MACpD;MAmBA,aACE,QACA,MAAc;AAEd,YAAI,OAAO,KAAK,KAAK,cAAc,YAAY;AAC7C,gBAAM,IAAI,MAAM,yCAAyC;;AAE3D,cAAM,EAAC,WAAU,IAAI,KAAK;AAC1B,eAAO,gBAAgB,KAAK,MAAM,QAAQ,IAAI;AAE9C,uBAAe,gBAEb,SACA,OAAe;AAEf,gBAAM,eAAe,KAAK,MAAM,QAAQ,OAAO;AAC/C,gBAAM,MAAM,KAAK,WAAW,SAAS,KAAK;AAC1C,iBAAO,IAAI,YAAY,cAAc,KAAK,MAAM,GAAG;QACrD;AARe;AAUf,uBAAe,eAA0B,MAAa;AACpD,cAAI,QAAQ,CAAC,KAAK,UAAU,IAAI,GAAG;AACjC,kBAAM,gBAAgB,KAAK,MAAM,EAAC,KAAI,GAAG,IAAI;;QAEjD;AAJe;AAMf,uBAAe,cAAyB,KAAc;AACpD,cAAI;AACF,mBAAO,KAAK,kBAAkB,GAAG;mBAC1B,GAAG;AACV,gBAAI,EAAE,aAAa,YAAA;AAAkB,oBAAM;AAC3C,wBAAY,KAAK,MAAM,CAAC;AACxB,kBAAM,kBAAkB,KAAK,MAAM,EAAE,aAAa;AAClD,mBAAO,cAAc,KAAK,MAAM,GAAG;;QAEvC;AATe;AAWf,iBAAS,YAAuB,EAAC,eAAe,KAAK,WAAU,GAAkB;AAC/E,cAAI,KAAK,KAAK,GAAG,GAAG;AAClB,kBAAM,IAAI,MAAM,aAAa,GAAG,kBAAkB,UAAU,qBAAqB;;QAErF;AAJS;AAMT,uBAAe,kBAA6B,KAAW;AACrD,gBAAM,UAAU,MAAM,YAAY,KAAK,MAAM,GAAG;AAChD,cAAI,CAAC,KAAK,KAAK,GAAG;AAAG,kBAAM,eAAe,KAAK,MAAM,QAAQ,OAAO;AACpE,cAAI,CAAC,KAAK,KAAK,GAAG;AAAG,iBAAK,UAAU,SAAS,KAAK,IAAI;QACxD;AAJe;AAMf,uBAAe,YAAuB,KAAW;AAC/C,gBAAM,IAAI,KAAK,SAAS,GAAG;AAC3B,cAAI;AAAG,mBAAO;AACd,cAAI;AACF,mBAAO,OAAO,KAAK,SAAS,GAAG,IAAI,WAAW,GAAG;;AAEjD,mBAAO,KAAK,SAAS,GAAG;;QAE5B;AARe;MASjB;;MAGA,UACE,QACA,KACA,OACA,kBAAkB,KAAK,KAAK;AAE5B,YAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,qBAAW,OAAO;AAAQ,iBAAK,UAAU,KAAK,QAAW,OAAO,eAAe;AAC/E,iBAAO;;AAET,YAAI;AACJ,YAAI,OAAO,WAAW,UAAU;AAC9B,gBAAM,EAAC,SAAQ,IAAI,KAAK;AACxB,eAAK,OAAO,QAAQ;AACpB,cAAI,OAAO,UAAa,OAAO,MAAM,UAAU;AAC7C,kBAAM,IAAI,MAAM,UAAU,QAAQ,iBAAiB;;;AAGvD,eAAM,GAAA,UAAA,aAAY,OAAO,EAAE;AAC3B,aAAK,aAAa,GAAG;AACrB,aAAK,QAAQ,GAAG,IAAI,KAAK,WAAW,QAAQ,OAAO,KAAK,iBAAiB,IAAI;AAC7E,eAAO;MACT;;;MAIA,cACE,QACA,KACA,kBAAkB,KAAK,KAAK;AAE5B,aAAK,UAAU,QAAQ,KAAK,MAAM,eAAe;AACjD,eAAO;MACT;;MAGA,eAAe,QAAmB,iBAAyB;AACzD,YAAI,OAAO,UAAU;AAAW,iBAAO;AACvC,YAAI;AACJ,kBAAU,OAAO;AACjB,YAAI,YAAY,UAAa,OAAO,WAAW,UAAU;AACvD,gBAAM,IAAI,MAAM,0BAA0B;;AAE5C,kBAAU,WAAW,KAAK,KAAK,eAAe,KAAK,YAAW;AAC9D,YAAI,CAAC,SAAS;AACZ,eAAK,OAAO,KAAK,2BAA2B;AAC5C,eAAK,SAAS;AACd,iBAAO;;AAET,cAAM,QAAQ,KAAK,SAAS,SAAS,MAAM;AAC3C,YAAI,CAAC,SAAS,iBAAiB;AAC7B,gBAAM,UAAU,wBAAwB,KAAK,WAAU;AACvD,cAAI,KAAK,KAAK,mBAAmB;AAAO,iBAAK,OAAO,MAAM,OAAO;;AAC5D,kBAAM,IAAI,MAAM,OAAO;;AAE9B,eAAO;MACT;;;MAIA,UAAuB,QAAc;AACnC,YAAI;AACJ,eAAO,QAAQ,MAAM,UAAU,KAAK,MAAM,MAAM,MAAM;AAAU,mBAAS;AACzE,YAAI,QAAQ,QAAW;AACrB,gBAAM,EAAC,SAAQ,IAAI,KAAK;AACxB,gBAAM,OAAO,IAAI,UAAA,UAAU,EAAC,QAAQ,CAAA,GAAI,SAAQ,CAAC;AACjD,gBAAM,UAAA,cAAc,KAAK,MAAM,MAAM,MAAM;AAC3C,cAAI,CAAC;AAAK;AACV,eAAK,KAAK,MAAM,IAAI;;AAEtB,eAAQ,IAAI,YAAY,KAAK,kBAAkB,GAAG;MACpD;;;;;MAMA,aAAa,cAA0C;AACrD,YAAI,wBAAwB,QAAQ;AAClC,eAAK,kBAAkB,KAAK,SAAS,YAAY;AACjD,eAAK,kBAAkB,KAAK,MAAM,YAAY;AAC9C,iBAAO;;AAET,gBAAQ,OAAO,cAAc;UAC3B,KAAK;AACH,iBAAK,kBAAkB,KAAK,OAAO;AACnC,iBAAK,kBAAkB,KAAK,IAAI;AAChC,iBAAK,OAAO,MAAK;AACjB,mBAAO;UACT,KAAK,UAAU;AACb,kBAAM,MAAM,UAAU,KAAK,MAAM,YAAY;AAC7C,gBAAI,OAAO,OAAO;AAAU,mBAAK,OAAO,OAAO,IAAI,MAAM;AACzD,mBAAO,KAAK,QAAQ,YAAY;AAChC,mBAAO,KAAK,KAAK,YAAY;AAC7B,mBAAO;;UAET,KAAK,UAAU;AACb,kBAAM,WAAW;AACjB,iBAAK,OAAO,OAAO,QAAQ;AAC3B,gBAAI,KAAK,aAAa,KAAK,KAAK,QAAQ;AACxC,gBAAI,IAAI;AACN,oBAAK,GAAA,UAAA,aAAY,EAAE;AACnB,qBAAO,KAAK,QAAQ,EAAE;AACtB,qBAAO,KAAK,KAAK,EAAE;;AAErB,mBAAO;;UAET;AACE,kBAAM,IAAI,MAAM,qCAAqC;;MAE3D;;MAGA,cAAc,aAAuB;AACnC,mBAAW,OAAO;AAAa,eAAK,WAAW,GAAG;AAClD,eAAO;MACT;MAEA,WACE,UACA;AAEA,YAAI;AACJ,YAAI,OAAO,YAAY,UAAU;AAC/B,oBAAU;AACV,cAAI,OAAO,OAAO,UAAU;AAC1B,iBAAK,OAAO,KAAK,0DAA0D;AAC3E,gBAAI,UAAU;;mBAEP,OAAO,YAAY,YAAY,QAAQ,QAAW;AAC3D,gBAAM;AACN,oBAAU,IAAI;AACd,cAAI,MAAM,QAAQ,OAAO,KAAK,CAAC,QAAQ,QAAQ;AAC7C,kBAAM,IAAI,MAAM,wDAAwD;;eAErE;AACL,gBAAM,IAAI,MAAM,gCAAgC;;AAGlD,qBAAa,KAAK,MAAM,SAAS,GAAG;AACpC,YAAI,CAAC,KAAK;AACR,WAAA,GAAA,OAAA,UAAS,SAAS,CAAC,QAAQ,QAAQ,KAAK,MAAM,GAAG,CAAC;AAClD,iBAAO;;AAET,0BAAkB,KAAK,MAAM,GAAG;AAChC,cAAM,aAAqC;UACzC,GAAG;UACH,OAAM,GAAA,WAAA,cAAa,IAAI,IAAI;UAC3B,aAAY,GAAA,WAAA,cAAa,IAAI,UAAU;;AAEzC,SAAA,GAAA,OAAA,UACE,SACA,WAAW,KAAK,WAAW,IACvB,CAAC,MAAM,QAAQ,KAAK,MAAM,GAAG,UAAU,IACvC,CAAC,MAAM,WAAW,KAAK,QAAQ,CAAC,MAAM,QAAQ,KAAK,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC;AAEjF,eAAO;MACT;MAEA,WAAW,SAAe;AACxB,cAAM,OAAO,KAAK,MAAM,IAAI,OAAO;AACnC,eAAO,OAAO,QAAQ,WAAW,KAAK,aAAa,CAAC,CAAC;MACvD;;MAGA,cAAc,SAAe;AAE3B,cAAM,EAAC,MAAK,IAAI;AAChB,eAAO,MAAM,SAAS,OAAO;AAC7B,eAAO,MAAM,IAAI,OAAO;AACxB,mBAAW,SAAS,MAAM,OAAO;AAC/B,gBAAM,IAAI,MAAM,MAAM,UAAU,CAAC,SAAS,KAAK,YAAY,OAAO;AAClE,cAAI,KAAK;AAAG,kBAAM,MAAM,OAAO,GAAG,CAAC;;AAErC,eAAO;MACT;;MAGA,UAAU,MAAc,QAAc;AACpC,YAAI,OAAO,UAAU;AAAU,mBAAS,IAAI,OAAO,MAAM;AACzD,aAAK,QAAQ,IAAI,IAAI;AACrB,eAAO;MACT;MAEA,WACE,SAA2C,KAAK,QAChD,EAAC,YAAY,MAAM,UAAU,OAAM,IAAuB,CAAA;AAE1D,YAAI,CAAC,UAAU,OAAO,WAAW;AAAG,iBAAO;AAC3C,eAAO,OACJ,IAAI,CAAC,MAAM,GAAG,OAAO,GAAG,EAAE,YAAY,IAAI,EAAE,OAAO,EAAE,EACrD,OAAO,CAAC,MAAM,QAAQ,OAAO,YAAY,GAAG;MACjD;MAEA,gBAAgB,YAA6B,sBAA8B;AACzE,cAAM,QAAQ,KAAK,MAAM;AACzB,qBAAa,KAAK,MAAM,KAAK,UAAU,UAAU,CAAC;AAClD,mBAAW,eAAe,sBAAsB;AAC9C,gBAAM,WAAW,YAAY,MAAM,GAAG,EAAE,MAAM,CAAC;AAC/C,cAAI,WAAW;AACf,qBAAW,OAAO;AAAU,uBAAW,SAAS,GAAG;AAEnD,qBAAW,OAAO,OAAO;AACvB,kBAAM,OAAO,MAAM,GAAG;AACtB,gBAAI,OAAO,QAAQ;AAAU;AAC7B,kBAAM,EAAC,MAAK,IAAI,KAAK;AACrB,kBAAM,SAAS,SAAS,GAAG;AAC3B,gBAAI,SAAS;AAAQ,uBAAS,GAAG,IAAI,aAAa,MAAM;;;AAI5D,eAAO;MACT;MAEQ,kBAAkB,SAAiD,OAAc;AACvF,mBAAW,UAAU,SAAS;AAC5B,gBAAM,MAAM,QAAQ,MAAM;AAC1B,cAAI,CAAC,SAAS,MAAM,KAAK,MAAM,GAAG;AAChC,gBAAI,OAAO,OAAO,UAAU;AAC1B,qBAAO,QAAQ,MAAM;uBACZ,OAAO,CAAC,IAAI,MAAM;AAC3B,mBAAK,OAAO,OAAO,IAAI,MAAM;AAC7B,qBAAO,QAAQ,MAAM;;;;MAI7B;MAEA,WACE,QACA,MACA,QACA,iBAAiB,KAAK,KAAK,gBAC3B,YAAY,KAAK,KAAK,eAAa;AAEnC,YAAI;AACJ,cAAM,EAAC,SAAQ,IAAI,KAAK;AACxB,YAAI,OAAO,UAAU,UAAU;AAC7B,eAAK,OAAO,QAAQ;eACf;AACL,cAAI,KAAK,KAAK;AAAK,kBAAM,IAAI,MAAM,uBAAuB;mBACjD,OAAO,UAAU;AAAW,kBAAM,IAAI,MAAM,kCAAkC;;AAEzF,YAAI,MAAM,KAAK,OAAO,IAAI,MAAM;AAChC,YAAI,QAAQ;AAAW,iBAAO;AAE9B,kBAAS,GAAA,UAAA,aAAY,MAAM,MAAM;AACjC,cAAM,YAAY,UAAA,cAAc,KAAK,MAAM,QAAQ,MAAM;AACzD,cAAM,IAAI,UAAA,UAAU,EAAC,QAAQ,UAAU,MAAM,QAAQ,UAAS,CAAC;AAC/D,aAAK,OAAO,IAAI,IAAI,QAAQ,GAAG;AAC/B,YAAI,aAAa,CAAC,OAAO,WAAW,GAAG,GAAG;AAExC,cAAI;AAAQ,iBAAK,aAAa,MAAM;AACpC,eAAK,KAAK,MAAM,IAAI;;AAEtB,YAAI;AAAgB,eAAK,eAAe,QAAQ,IAAI;AACpD,eAAO;MACT;MAEQ,aAAa,IAAU;AAC7B,YAAI,KAAK,QAAQ,EAAE,KAAK,KAAK,KAAK,EAAE,GAAG;AACrC,gBAAM,IAAI,MAAM,0BAA0B,EAAE,kBAAkB;;MAElE;MAEQ,kBAAkB,KAAc;AACtC,YAAI,IAAI;AAAM,eAAK,mBAAmB,GAAG;;AACpC,oBAAA,cAAc,KAAK,MAAM,GAAG;AAGjC,YAAI,CAAC,IAAI;AAAU,gBAAM,IAAI,MAAM,0BAA0B;AAC7D,eAAO,IAAI;MACb;MAEQ,mBAAmB,KAAc;AACvC,cAAM,cAAc,KAAK;AACzB,aAAK,OAAO,KAAK;AACjB,YAAI;AACF,oBAAA,cAAc,KAAK,MAAM,GAAG;;AAE5B,eAAK,OAAO;;MAEhB;;AAzdF,IAAAA,SAAA,UAAA;AAeS,QAAA,kBAAkB,mBAAA;AAClB,QAAA,kBAAkB,YAAA;AAid3B,aAAS,aAEP,WACA,SACA,KACA,MAAwB,SAAO;AAE/B,iBAAW,OAAO,WAAW;AAC3B,cAAM,MAAM;AACZ,YAAI,OAAO;AAAS,eAAK,OAAO,GAAG,EAAE,GAAG,GAAG,YAAY,GAAG,KAAK,UAAU,GAAG,CAAC,EAAE;;IAEnF;AAXS;AAaT,aAAS,UAAqB,QAAc;AAC1C,gBAAS,GAAA,UAAA,aAAY,MAAM;AAC3B,aAAO,KAAK,QAAQ,MAAM,KAAK,KAAK,KAAK,MAAM;IACjD;AAHS;AAKT,aAAS,oBAAiB;AACxB,YAAM,cAAc,KAAK,KAAK;AAC9B,UAAI,CAAC;AAAa;AAClB,UAAI,MAAM,QAAQ,WAAW;AAAG,aAAK,UAAU,WAAW;;AACrD,mBAAW,OAAO;AAAa,eAAK,UAAU,YAAY,GAAG,GAAgB,GAAG;IACvF;AALS;AAOT,aAAS,oBAAiB;AACxB,iBAAW,QAAQ,KAAK,KAAK,SAAS;AACpC,cAAM,SAAS,KAAK,KAAK,QAAQ,IAAI;AACrC,YAAI;AAAQ,eAAK,UAAU,MAAM,MAAM;;IAE3C;AALS;AAOT,aAAS,mBAEP,MAAsD;AAEtD,UAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,aAAK,cAAc,IAAI;AACvB;;AAEF,WAAK,OAAO,KAAK,kDAAkD;AACnE,iBAAW,WAAW,MAAM;AAC1B,cAAM,MAAM,KAAK,OAAO;AACxB,YAAI,CAAC,IAAI;AAAS,cAAI,UAAU;AAChC,aAAK,WAAW,GAAG;;IAEvB;AAdS;AAgBT,aAAS,uBAAoB;AAC3B,YAAM,WAAW,EAAC,GAAG,KAAK,KAAI;AAC9B,iBAAW,OAAO;AAAqB,eAAO,SAAS,GAAG;AAC1D,aAAO;IACT;AAJS;AAMT,QAAM,SAAS,EAAC,MAAG;IAAI,GAAG,OAAI;IAAI,GAAG,QAAK;IAAI,EAAC;AAE/C,aAAS,UAAU,QAAgC;AACjD,UAAI,WAAW;AAAO,eAAO;AAC7B,UAAI,WAAW;AAAW,eAAO;AACjC,UAAI,OAAO,OAAO,OAAO,QAAQ,OAAO;AAAO,eAAO;AACtD,YAAM,IAAI,MAAM,mDAAmD;IACrE;AALS;AAOT,QAAM,eAAe;AAErB,aAAS,aAAwB,SAA4B,KAAuB;AAClF,YAAM,EAAC,MAAK,IAAI;AAChB,OAAA,GAAA,OAAA,UAAS,SAAS,CAAC,QAAO;AACxB,YAAI,MAAM,SAAS,GAAG;AAAG,gBAAM,IAAI,MAAM,WAAW,GAAG,qBAAqB;AAC5E,YAAI,CAAC,aAAa,KAAK,GAAG;AAAG,gBAAM,IAAI,MAAM,WAAW,GAAG,mBAAmB;MAChF,CAAC;AACD,UAAI,CAAC;AAAK;AACV,UAAI,IAAI,SAAS,EAAE,UAAU,OAAO,cAAc,MAAM;AACtD,cAAM,IAAI,MAAM,uDAAuD;;IAE3E;AAVS;AAYT,aAAS,QAEP,SACA,YACA,UAAmB;;AAEnB,YAAM,OAAO,eAAU,QAAV,eAAU,SAAA,SAAV,WAAY;AACzB,UAAI,YAAY;AAAM,cAAM,IAAI,MAAM,6CAA6C;AACnF,YAAM,EAAC,MAAK,IAAI;AAChB,UAAI,YAAY,OAAO,MAAM,OAAO,MAAM,MAAM,KAAK,CAAC,EAAC,MAAM,EAAC,MAAM,MAAM,QAAQ;AAClF,UAAI,CAAC,WAAW;AACd,oBAAY,EAAC,MAAM,UAAU,OAAO,CAAA,EAAE;AACtC,cAAM,MAAM,KAAK,SAAS;;AAE5B,YAAM,SAAS,OAAO,IAAI;AAC1B,UAAI,CAAC;AAAY;AAEjB,YAAM,OAAa;QACjB;QACA,YAAY;UACV,GAAG;UACH,OAAM,GAAA,WAAA,cAAa,WAAW,IAAI;UAClC,aAAY,GAAA,WAAA,cAAa,WAAW,UAAU;;;AAGlD,UAAI,WAAW;AAAQ,sBAAc,KAAK,MAAM,WAAW,MAAM,WAAW,MAAM;;AAC7E,kBAAU,MAAM,KAAK,IAAI;AAC9B,YAAM,IAAI,OAAO,IAAI;AACrB,OAAA,KAAA,WAAW,gBAAU,QAAA,OAAA,SAAA,SAAA,GAAE,QAAQ,CAAC,QAAQ,KAAK,WAAW,GAAG,CAAC;IAC9D;AA7BS;AA+BT,aAAS,cAAyB,WAAsB,MAAY,QAAc;AAChF,YAAM,IAAI,UAAU,MAAM,UAAU,CAAC,UAAU,MAAM,YAAY,MAAM;AACvE,UAAI,KAAK,GAAG;AACV,kBAAU,MAAM,OAAO,GAAG,GAAG,IAAI;aAC5B;AACL,kBAAU,MAAM,KAAK,IAAI;AACzB,aAAK,OAAO,KAAK,QAAQ,MAAM,iBAAiB;;IAEpD;AARS;AAUT,aAAS,kBAA6B,KAAsB;AAC1D,UAAI,EAAC,WAAU,IAAI;AACnB,UAAI,eAAe;AAAW;AAC9B,UAAI,IAAI,SAAS,KAAK,KAAK;AAAO,qBAAa,aAAa,UAAU;AACtE,UAAI,iBAAiB,KAAK,QAAQ,YAAY,IAAI;IACpD;AALS;AAOT,QAAM,WAAW;MACf,MAAM;;AAGR,aAAS,aAAa,QAAiB;AACrC,aAAO,EAAC,OAAO,CAAC,QAAQ,QAAQ,EAAC;IACnC;AAFS;;;;;;;;;ACl3BT,QAAM,MAA6B;MACjC,SAAS;MACT,OAAI;AACF,cAAM,IAAI,MAAM,sDAAsD;MACxE;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;;ACPf,QAAA,cAAA;AACA,QAAA,SAAA;AACA,QAAA,YAAA;AACA,QAAA,UAAA;AACA,QAAA,YAAA;AACA,QAAA,SAAA;AAEA,QAAM,MAA6B;MACjC,SAAS;MACT,YAAY;MACZ,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,QAAQ,MAAM,GAAE,IAAI;AAChC,cAAM,EAAC,QAAQ,WAAW,KAAK,cAAc,MAAM,KAAI,IAAI;AAC3D,cAAM,EAAC,KAAI,IAAI;AACf,aAAK,SAAS,OAAO,SAAS,SAAS,WAAW,KAAK;AAAQ,iBAAO,YAAW;AACjF,cAAM,WAAW,UAAA,WAAW,KAAK,MAAM,MAAM,QAAQ,IAAI;AACzD,YAAI,aAAa;AAAW,gBAAM,IAAI,YAAA,QAAgB,GAAG,KAAK,aAAa,QAAQ,IAAI;AACvF,YAAI,oBAAoB,UAAA;AAAW,iBAAO,aAAa,QAAQ;AAC/D,eAAO,gBAAgB,QAAQ;AAE/B,iBAAS,cAAW;AAClB,cAAI,QAAQ;AAAM,mBAAO,QAAQ,KAAK,cAAc,KAAK,IAAI,MAAM;AACnE,gBAAM,WAAW,IAAI,WAAW,QAAQ,EAAC,KAAK,KAAI,CAAC;AACnD,iBAAO,QAAQ,MAAK,GAAA,UAAA,KAAI,QAAQ,aAAa,MAAM,KAAK,MAAM;QAChE;AAJS;AAMT,iBAAS,aAAa,KAAc;AAClC,gBAAM,IAAI,YAAY,KAAK,GAAG;AAC9B,kBAAQ,KAAK,GAAG,KAAK,IAAI,MAAM;QACjC;AAHS;AAKT,iBAAS,gBAAgB,KAAc;AACrC,gBAAM,UAAU,IAAI,WAClB,UACA,KAAK,KAAK,WAAW,OAAO,EAAC,KAAK,KAAK,OAAM,GAAA,UAAA,WAAU,GAAG,EAAC,IAAI,EAAC,KAAK,IAAG,CAAC;AAE3E,gBAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,gBAAM,SAAS,IAAI,UACjB;YACE,QAAQ;YACR,WAAW,CAAA;YACX,YAAY,UAAA;YACZ,cAAc;YACd,eAAe;aAEjB,KAAK;AAEP,cAAI,eAAe,MAAM;AACzB,cAAI,GAAG,KAAK;QACd;AAlBS;MAmBX;;AAGF,aAAgB,YAAY,KAAiB,KAAc;AACzD,YAAM,EAAC,IAAG,IAAI;AACd,aAAO,IAAI,WACP,IAAI,WAAW,YAAY,EAAC,KAAK,IAAI,SAAQ,CAAC,KAC9C,GAAA,UAAA,KAAI,IAAI,WAAW,WAAW,EAAC,KAAK,IAAG,CAAC,CAAC;IAC/C;AALgB;AAAhB,IAAAC,SAAA,cAAA;AAOA,aAAgB,QAAQ,KAAiB,GAAS,KAAiB,QAAgB;AACjF,YAAM,EAAC,KAAK,GAAE,IAAI;AAClB,YAAM,EAAC,WAAW,WAAW,KAAK,KAAI,IAAI;AAC1C,YAAM,UAAU,KAAK,cAAc,QAAA,QAAE,OAAO,UAAA;AAC5C,UAAI;AAAQ,qBAAY;;AACnB,oBAAW;AAEhB,eAAS,eAAY;AACnB,YAAI,CAAC,IAAI;AAAQ,gBAAM,IAAI,MAAM,wCAAwC;AACzE,cAAM,QAAQ,IAAI,IAAI,OAAO;AAC7B,YAAI,IACF,MAAK;AACH,cAAI,MAAK,GAAA,UAAA,YAAU,GAAA,OAAA,kBAAiB,KAAK,GAAG,OAAO,CAAC,EAAE;AACtD,2BAAiB,CAAC;AAClB,cAAI,CAAC;AAAW,gBAAI,OAAO,OAAO,IAAI;QACxC,GACA,CAAC,MAAK;AACJ,cAAI,IAAG,GAAA,UAAA,OAAM,CAAC,eAAe,GAAG,eAAuB,KAAK,MAAM,IAAI,MAAM,CAAC,CAAC;AAC9E,wBAAc,CAAC;AACf,cAAI,CAAC;AAAW,gBAAI,OAAO,OAAO,KAAK;QACzC,CAAC;AAEH,YAAI,GAAG,KAAK;MACd;AAhBS;AAkBT,eAAS,cAAW;AAClB,YAAI,QACF,GAAA,OAAA,kBAAiB,KAAK,GAAG,OAAO,GAChC,MAAM,iBAAiB,CAAC,GACxB,MAAM,cAAc,CAAC,CAAC;MAE1B;AANS;AAQT,eAAS,cAAc,QAAY;AACjC,cAAM,QAAO,GAAA,UAAA,KAAI,MAAM;AACvB,YAAI,OAAO,QAAA,QAAE,UAAS,GAAA,UAAA,KAAI,QAAA,QAAE,OAAO,eAAe,IAAI,MAAM,QAAA,QAAE,OAAO,WAAW,IAAI,GAAG;AACvF,YAAI,OAAO,QAAA,QAAE,SAAQ,GAAA,UAAA,KAAI,QAAA,QAAE,OAAO,SAAS;MAC7C;AAJS;AAMT,eAAS,iBAAiB,QAAY;;AACpC,YAAI,CAAC,GAAG,KAAK;AAAa;AAC1B,cAAM,gBAAe,KAAA,QAAG,QAAH,QAAG,SAAA,SAAH,IAAK,cAAQ,QAAA,OAAA,SAAA,SAAA,GAAE;AAEpC,YAAI,GAAG,UAAU,MAAM;AACrB,cAAI,gBAAgB,CAAC,aAAa,cAAc;AAC9C,gBAAI,aAAa,UAAU,QAAW;AACpC,iBAAG,QAAQ,OAAA,eAAe,MAAM,KAAK,aAAa,OAAO,GAAG,KAAK;;iBAE9D;AACL,kBAAM,QAAQ,IAAI,IAAI,UAAS,GAAA,UAAA,KAAI,MAAM,kBAAkB;AAC3D,eAAG,QAAQ,OAAA,eAAe,MAAM,KAAK,OAAO,GAAG,OAAO,UAAA,IAAI;;;AAG9D,YAAI,GAAG,UAAU,MAAM;AACrB,cAAI,gBAAgB,CAAC,aAAa,cAAc;AAC9C,gBAAI,aAAa,UAAU,QAAW;AACpC,iBAAG,QAAQ,OAAA,eAAe,MAAM,KAAK,aAAa,OAAO,GAAG,KAAK;;iBAE9D;AACL,kBAAM,QAAQ,IAAI,IAAI,UAAS,GAAA,UAAA,KAAI,MAAM,kBAAkB;AAC3D,eAAG,QAAQ,OAAA,eAAe,MAAM,KAAK,OAAO,GAAG,OAAO,UAAA,IAAI;;;MAGhE;AAxBS;IAyBX;AAhEgB;AAAhB,IAAAA,SAAA,UAAA;AAkEA,IAAAA,SAAA,UAAe;;;;;;;;;AC/Hf,QAAA,OAAA;AACA,QAAA,QAAA;AAEA,QAAM,OAAmB;MACvB;MACA;MACA;MACA;MACA,EAAC,SAAS,WAAU;MACpB;MACA,KAAA;MACA,MAAA;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACbf,QAAA,YAAA;AAEA,QAAM,MAAM,UAAA;AAMZ,QAAM,OAAgE;MACpE,SAAS,EAAC,OAAO,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,GAAE;MAChD,SAAS,EAAC,OAAO,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,GAAE;MAChD,kBAAkB,EAAC,OAAO,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI,IAAG;MACxD,kBAAkB,EAAC,OAAO,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI,IAAG;;AAS1D,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,SAAS,WAAU,OAAM,GAAA,UAAA,eAAc,KAAK,OAAc,EAAE,KAAK,IAAI,UAAU;MAC1F,QAAQ,CAAC,EAAC,SAAS,WAAU,OAC3B,GAAA,UAAA,kBAAiB,KAAK,OAAc,EAAE,KAAK,YAAY,UAAU;;AAGrE,QAAM,MAA6B;MACjC,SAAS,OAAO,KAAK,IAAI;MACzB,MAAM;MACN,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,SAAS,MAAM,WAAU,IAAI;AACpC,YAAI,WAAU,GAAA,UAAA,KAAI,IAAI,IAAI,KAAK,OAAc,EAAE,IAAI,IAAI,UAAU,aAAa,IAAI,GAAG;MACvF;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACvCf,QAAA,YAAA;AAQA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,2BAA0B,UAAU;MAC/D,QAAQ,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,kBAAiB,UAAU;;AAGvD,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,MAAM,YAAY,GAAE,IAAI;AAEpC,cAAM,OAAO,GAAG,KAAK;AACrB,cAAM,MAAM,IAAI,IAAI,KAAK;AACzB,cAAM,UAAU,QACZ,GAAA,UAAA,yBAAwB,GAAG,OAAO,GAAG,UAAU,IAAI,MACnD,GAAA,UAAA,KAAI,GAAG,iBAAiB,GAAG;AAC/B,YAAI,WAAU,GAAA,UAAA,MAAK,UAAU,cAAc,GAAG,MAAM,IAAI,IAAI,UAAU,KAAK,OAAO,IAAI;MACxF;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;AC/Bf,aAAwB,WAAW,KAAW;AAC5C,YAAM,MAAM,IAAI;AAChB,UAAI,SAAS;AACb,UAAI,MAAM;AACV,UAAI;AACJ,aAAO,MAAM,KAAK;AAChB;AACA,gBAAQ,IAAI,WAAW,KAAK;AAC5B,YAAI,SAAS,SAAU,SAAS,SAAU,MAAM,KAAK;AAEnD,kBAAQ,IAAI,WAAW,GAAG;AAC1B,eAAK,QAAQ,WAAY;AAAQ;;;AAGrC,aAAO;IACT;AAfwB;AAAxB,IAAAC,SAAA,UAAA;AAiBA,eAAW,OAAO;;;;;;;;;ACjBlB,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,eAAA;AAEA,QAAM,QAAgC;MACpC,QAAQ,EAAC,SAAS,WAAU,GAAC;AAC3B,cAAM,OAAO,YAAY,cAAc,SAAS;AAChD,gBAAO,GAAA,UAAA,qBAAoB,IAAI,SAAS,UAAU;MACpD;MACA,QAAQ,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,aAAY,UAAU;;AAGlD,QAAM,MAA6B;MACjC,SAAS,CAAC,aAAa,WAAW;MAClC,MAAM;MACN,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,SAAS,MAAM,YAAY,GAAE,IAAI;AACxC,cAAM,KAAK,YAAY,cAAc,UAAA,UAAU,KAAK,UAAA,UAAU;AAC9D,cAAM,MACJ,GAAG,KAAK,YAAY,SAAQ,GAAA,UAAA,KAAI,IAAI,aAAY,GAAA,UAAA,MAAI,GAAA,OAAA,SAAQ,IAAI,KAAK,aAAA,OAAU,CAAC,IAAI,IAAI;AAC1F,YAAI,WAAU,GAAA,UAAA,KAAI,GAAG,IAAI,EAAE,IAAI,UAAU,EAAE;MAC7C;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;AC3Bf,QAAA,SAAA;AACA,QAAA,YAAA;AAIA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,2BAA0B,UAAU;MAC/D,QAAQ,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,eAAc,UAAU;;AAGpD,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,MAAM,OAAO,QAAQ,YAAY,GAAE,IAAI;AAE9C,cAAM,IAAI,GAAG,KAAK,gBAAgB,MAAM;AACxC,cAAM,SAAS,SAAQ,GAAA,UAAA,iBAAgB,UAAU,KAAK,CAAC,QAAO,GAAA,OAAA,YAAW,KAAK,MAAM;AACpF,YAAI,WAAU,GAAA,UAAA,MAAK,MAAM,SAAS,IAAI,GAAG;MAC3C;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACzBf,QAAA,YAAA;AAEA,QAAM,QAAgC;MACpC,QAAQ,EAAC,SAAS,WAAU,GAAC;AAC3B,cAAM,OAAO,YAAY,kBAAkB,SAAS;AACpD,gBAAO,GAAA,UAAA,qBAAoB,IAAI,SAAS,UAAU;MACpD;MACA,QAAQ,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,aAAY,UAAU;;AAGlD,QAAM,MAA6B;MACjC,SAAS,CAAC,iBAAiB,eAAe;MAC1C,MAAM;MACN,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,SAAS,MAAM,WAAU,IAAI;AACpC,cAAM,KAAK,YAAY,kBAAkB,UAAA,UAAU,KAAK,UAAA,UAAU;AAClE,YAAI,WAAU,GAAA,UAAA,iBAAgB,IAAI,YAAY,EAAE,IAAI,UAAU,EAAE;MAClE;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACvBf,QAAA,SAAA;AAOA,QAAA,YAAA;AACA,QAAA,SAAA;AAQA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,QAAQ,EAAC,gBAAe,EAAC,OAAM,GAAA,UAAA,oCAAmC,eAAe;MAC5F,QAAQ,CAAC,EAAC,QAAQ,EAAC,gBAAe,EAAC,OAAM,GAAA,UAAA,uBAAsB,eAAe;;AAGhF,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,QAAQ,YAAY,MAAM,OAAO,GAAE,IAAI;AACnD,cAAM,EAAC,KAAI,IAAI;AACf,YAAI,CAAC,SAAS,OAAO,WAAW;AAAG;AACnC,cAAM,UAAU,OAAO,UAAU,KAAK;AACtC,YAAI,GAAG;AAAW,wBAAa;;AAC1B,0BAAe;AAEpB,YAAI,KAAK,gBAAgB;AACvB,gBAAM,QAAQ,IAAI,aAAa;AAC/B,gBAAM,EAAC,kBAAiB,IAAI,IAAI;AAChC,qBAAW,eAAe,QAAQ;AAChC,iBAAI,UAAK,QAAL,UAAK,SAAA,SAAL,MAAQ,WAAW,OAAM,UAAa,CAAC,kBAAkB,IAAI,WAAW,GAAG;AAC7E,oBAAM,aAAa,GAAG,UAAU,SAAS,GAAG;AAC5C,oBAAM,MAAM,sBAAsB,WAAW,wBAAwB,UAAU;AAC/E,eAAA,GAAA,OAAA,iBAAgB,IAAI,KAAK,GAAG,KAAK,cAAc;;;;AAKrD,iBAAS,gBAAa;AACpB,cAAI,WAAW,OAAO;AACpB,gBAAI,WAAW,UAAA,KAAK,eAAe;iBAC9B;AACL,uBAAW,QAAQ,QAAQ;AACzB,eAAA,GAAA,OAAA,wBAAuB,KAAK,IAAI;;;QAGtC;AARS;AAUT,iBAAS,kBAAe;AACtB,gBAAM,UAAU,IAAI,IAAI,SAAS;AACjC,cAAI,WAAW,OAAO;AACpB,kBAAM,QAAQ,IAAI,IAAI,SAAS,IAAI;AACnC,gBAAI,WAAW,OAAO,MAAM,iBAAiB,SAAS,KAAK,CAAC;AAC5D,gBAAI,GAAG,KAAK;iBACP;AACL,gBAAI,IAAG,GAAA,OAAA,kBAAiB,KAAK,QAAQ,OAAO,CAAC;AAC7C,aAAA,GAAA,OAAA,mBAAkB,KAAK,OAAO;AAC9B,gBAAI,KAAI;;QAEZ;AAXS;AAaT,iBAAS,kBAAe;AACtB,cAAI,MAAM,QAAQ,YAAoB,CAAC,SAAQ;AAC7C,gBAAI,UAAU,EAAC,iBAAiB,KAAI,CAAC;AACrC,gBAAI,IAAG,GAAA,OAAA,kBAAiB,KAAK,MAAM,MAAM,KAAK,aAAa,GAAG,MAAM,IAAI,MAAK,CAAE;UACjF,CAAC;QACH;AALS;AAOT,iBAAS,iBAAiB,SAAe,OAAW;AAClD,cAAI,UAAU,EAAC,iBAAiB,QAAO,CAAC;AACxC,cAAI,MACF,SACA,YACA,MAAK;AACH,gBAAI,OAAO,QAAO,GAAA,OAAA,gBAAe,KAAK,MAAM,SAAS,KAAK,aAAa,CAAC;AACxE,gBAAI,IAAG,GAAA,UAAA,KAAI,KAAK,GAAG,MAAK;AACtB,kBAAI,MAAK;AACT,kBAAI,MAAK;YACX,CAAC;UACH,GACA,UAAA,GAAG;QAEP;AAdS;MAeX;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;AC/Ff,QAAA,YAAA;AAEA,QAAM,QAAgC;MACpC,QAAQ,EAAC,SAAS,WAAU,GAAC;AAC3B,cAAM,OAAO,YAAY,aAAa,SAAS;AAC/C,gBAAO,GAAA,UAAA,qBAAoB,IAAI,SAAS,UAAU;MACpD;MACA,QAAQ,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,aAAY,UAAU;;AAGlD,QAAM,MAA6B;MACjC,SAAS,CAAC,YAAY,UAAU;MAChC,MAAM;MACN,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,SAAS,MAAM,WAAU,IAAI;AACpC,cAAM,KAAK,YAAY,aAAa,UAAA,UAAU,KAAK,UAAA,UAAU;AAC7D,YAAI,WAAU,GAAA,UAAA,KAAI,IAAI,WAAW,EAAE,IAAI,UAAU,EAAE;MACrD;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACxBf,QAAA,QAAA;AAGE,UAAgB,OAAO;AAEzB,IAAAC,SAAA,UAAe;;;;;;;;;ACJf,QAAA,aAAA;AACA,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,UAAA;AAQA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,QAAQ,EAAC,GAAG,EAAC,EAAC,OACvB,GAAA,UAAA,+CAA8C,CAAC,QAAQ,CAAC;MAC1D,QAAQ,CAAC,EAAC,QAAQ,EAAC,GAAG,EAAC,EAAC,OAAM,GAAA,UAAA,SAAQ,CAAC,QAAQ,CAAC;;AAGlD,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,MAAM,OAAO,QAAQ,cAAc,YAAY,GAAE,IAAI;AACjE,YAAI,CAAC,SAAS,CAAC;AAAQ;AACvB,cAAM,QAAQ,IAAI,IAAI,OAAO;AAC7B,cAAM,YAAY,aAAa,SAAQ,GAAA,WAAA,gBAAe,aAAa,KAAK,IAAI,CAAA;AAC5E,YAAI,WAAW,OAAO,sBAAqB,GAAA,UAAA,KAAI,UAAU,YAAY;AACrE,YAAI,GAAG,KAAK;AAEZ,iBAAS,sBAAmB;AAC1B,gBAAM,IAAI,IAAI,IAAI,MAAK,GAAA,UAAA,KAAI,IAAI,SAAS;AACxC,gBAAM,IAAI,IAAI,IAAI,GAAG;AACrB,cAAI,UAAU,EAAC,GAAG,EAAC,CAAC;AACpB,cAAI,OAAO,OAAO,IAAI;AACtB,cAAI,IAAG,GAAA,UAAA,KAAI,CAAC,QAAQ,OAAO,YAAW,IAAK,QAAQ,QAAQ,GAAG,CAAC,CAAC;QAClE;AANS;AAQT,iBAAS,cAAW;AAClB,iBAAO,UAAU,SAAS,KAAK,CAAC,UAAU,KAAK,CAAC,MAAM,MAAM,YAAY,MAAM,OAAO;QACvF;AAFS;AAIT,iBAAS,MAAM,GAAS,GAAO;AAC7B,gBAAM,OAAO,IAAI,KAAK,MAAM;AAC5B,gBAAM,aAAY,GAAA,WAAA,gBAAe,WAAW,MAAM,GAAG,KAAK,eAAe,WAAA,SAAS,KAAK;AACvF,gBAAM,UAAU,IAAI,MAAM,YAAW,GAAA,UAAA,MAAK;AAC1C,cAAI,KAAI,GAAA,UAAA,MAAK,CAAC,OAAO,MAAK;AACxB,gBAAI,IAAI,OAAM,GAAA,UAAA,KAAI,IAAI,IAAI,CAAC,GAAG;AAC9B,gBAAI,GAAG,YAAW,GAAA,UAAA,YAAW;AAC7B,gBAAI,UAAU,SAAS;AAAG,kBAAI,IAAG,GAAA,UAAA,YAAW,IAAI,iBAAgB,GAAA,UAAA,KAAI,IAAI,SAAS;AACjF,gBACG,IAAG,GAAA,UAAA,YAAW,OAAO,IAAI,IAAI,iBAAiB,MAAK;AAClD,kBAAI,OAAO,IAAG,GAAA,UAAA,KAAI,OAAO,IAAI,IAAI,GAAG;AACpC,kBAAI,MAAK;AACT,kBAAI,OAAO,OAAO,KAAK,EAAE,MAAK;YAChC,CAAC,EACA,MAAK,GAAA,UAAA,KAAI,OAAO,IAAI,IAAI,OAAO,CAAC,EAAE;UACvC,CAAC;QACH;AAhBS;AAkBT,iBAAS,OAAO,GAAS,GAAO;AAC9B,gBAAM,OAAM,GAAA,OAAA,SAAQ,KAAK,QAAA,OAAK;AAC9B,gBAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,cAAI,MAAM,KAAK,EAAE,KAAI,GAAA,UAAA,MAAK,CAAC,OAAO,MAChC,IAAI,KAAI,GAAA,UAAA,KAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,MAC/B,IAAI,IAAG,GAAA,UAAA,KAAI,GAAG,IAAI,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,MAAK;AACnD,gBAAI,MAAK;AACT,gBAAI,OAAO,OAAO,KAAK,EAAE,MAAM,KAAK;UACtC,CAAC,CAAC,CACH;QAEL;AAXS;MAYX;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;AC5Ef,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,UAAA;AAIA,QAAM,QAAgC;MACpC,SAAS;MACT,QAAQ,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,oBAAmB,UAAU;;AAGzD,QAAM,MAA6B;MACjC,SAAS;MACT,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,MAAM,OAAO,YAAY,OAAM,IAAI;AAC/C,YAAI,SAAU,UAAU,OAAO,UAAU,UAAW;AAClD,cAAI,WAAU,GAAA,UAAA,OAAK,GAAA,OAAA,SAAQ,KAAK,QAAA,OAAK,CAAC,IAAI,IAAI,KAAK,UAAU,GAAG;eAC3D;AACL,cAAI,MAAK,GAAA,UAAA,KAAI,MAAM,QAAQ,IAAI,EAAE;;MAErC;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACzBf,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,UAAA;AAIA,QAAM,QAAgC;MACpC,SAAS;MACT,QAAQ,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,qBAAoB,UAAU;;AAG1D,QAAM,MAA6B;MACjC,SAAS;MACT,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,MAAM,OAAO,QAAQ,YAAY,GAAE,IAAI;AACnD,YAAI,CAAC,SAAS,OAAO,WAAW;AAAG,gBAAM,IAAI,MAAM,gCAAgC;AACnF,cAAM,UAAU,OAAO,UAAU,GAAG,KAAK;AACzC,YAAI;AACJ,cAAM,SAAS,6BAAa,QAAG,QAAH,QAAG,SAAH,MAAA,OAAQ,GAAA,OAAA,SAAQ,KAAK,QAAA,OAAK,GAAvC;AAEf,YAAI;AACJ,YAAI,WAAW,OAAO;AACpB,kBAAQ,IAAI,IAAI,OAAO;AACvB,cAAI,WAAW,OAAO,QAAQ;eACzB;AAEL,cAAI,CAAC,MAAM,QAAQ,MAAM;AAAG,kBAAM,IAAI,MAAM,0BAA0B;AACtE,gBAAM,UAAU,IAAI,MAAM,WAAW,UAAU;AAC/C,mBAAQ,GAAA,UAAA,IAAG,GAAG,OAAO,IAAI,CAAC,IAAa,MAAc,UAAU,SAAS,CAAC,CAAC,CAAC;;AAE7E,YAAI,KAAK,KAAK;AAEd,iBAAS,WAAQ;AACf,cAAI,OAAO,OAAO,KAAK;AACvB,cAAI,MAAM,KAAK,YAAoB,CAAC,MAClC,IAAI,IAAG,GAAA,UAAA,KAAI,OAAM,CAAE,IAAI,IAAI,KAAK,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,IAAI,EAAE,MAAK,CAAE,CAAC;QAEhF;AALS;AAOT,iBAAS,UAAU,SAAe,GAAS;AACzC,gBAAM,MAAM,OAAO,CAAC;AACpB,iBAAO,OAAO,QAAQ,YAAY,QAAQ,QACtC,GAAA,UAAA,KAAI,OAAM,CAAE,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,QACrC,GAAA,UAAA,KAAI,IAAI,QAAQ,GAAG;QACzB;AALS;MAMX;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACpDf,QAAA,gBAAA;AACA,QAAA,eAAA;AACA,QAAA,gBAAA;AACA,QAAA,YAAA;AACA,QAAA,oBAAA;AACA,QAAA,aAAA;AACA,QAAA,eAAA;AACA,QAAA,gBAAA;AACA,QAAA,UAAA;AACA,QAAA,SAAA;AAEA,QAAM,aAAyB;;MAE7B,cAAA;MACA,aAAA;;MAEA,cAAA;MACA,UAAA;;MAEA,kBAAA;MACA,WAAA;;MAEA,aAAA;MACA,cAAA;;MAEA,EAAC,SAAS,QAAQ,YAAY,CAAC,UAAU,OAAO,EAAC;MACjD,EAAC,SAAS,YAAY,YAAY,UAAS;MAC3C,QAAA;MACA,OAAA;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;;ACzBf,QAAA,YAAA;AACA,QAAA,SAAA;AAIA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,QAAQ,EAAC,IAAG,EAAC,OAAM,GAAA,UAAA,+BAA8B,GAAG;MAC/D,QAAQ,CAAC,EAAC,QAAQ,EAAC,IAAG,EAAC,OAAM,GAAA,UAAA,aAAY,GAAG;;AAG9C,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY,CAAC,WAAW,QAAQ;MAChC,QAAQ;MACR;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,cAAc,GAAE,IAAI;AAC3B,cAAM,EAAC,MAAK,IAAI;AAChB,YAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,WAAA,GAAA,OAAA,iBAAgB,IAAI,sEAAsE;AAC1F;;AAEF,gCAAwB,KAAK,KAAK;MACpC;;AAGF,aAAgB,wBAAwB,KAAiB,OAAkB;AACzE,YAAM,EAAC,KAAK,QAAQ,MAAM,SAAS,GAAE,IAAI;AACzC,SAAG,QAAQ;AACX,YAAM,MAAM,IAAI,MAAM,QAAO,GAAA,UAAA,KAAI,IAAI,SAAS;AAC9C,UAAI,WAAW,OAAO;AACpB,YAAI,UAAU,EAAC,KAAK,MAAM,OAAM,CAAC;AACjC,YAAI,MAAK,GAAA,UAAA,KAAI,GAAG,OAAO,MAAM,MAAM,EAAE;iBAC5B,OAAO,UAAU,YAAY,EAAC,GAAA,OAAA,mBAAkB,IAAI,MAAM,GAAG;AACtE,cAAM,QAAQ,IAAI,IAAI,UAAS,GAAA,UAAA,KAAI,GAAG,OAAO,MAAM,MAAM,EAAE;AAC3D,YAAI,IAAG,GAAA,UAAA,KAAI,KAAK,GAAG,MAAM,cAAc,KAAK,CAAC;AAC7C,YAAI,GAAG,KAAK;;AAGd,eAAS,cAAc,OAAW;AAChC,YAAI,SAAS,KAAK,MAAM,QAAQ,KAAK,CAAC,MAAK;AACzC,cAAI,UAAU,EAAC,SAAS,UAAU,GAAG,cAAc,OAAA,KAAK,IAAG,GAAG,KAAK;AACnE,cAAI,CAAC,GAAG;AAAW,gBAAI,IAAG,GAAA,UAAA,KAAI,KAAK,GAAG,MAAM,IAAI,MAAK,CAAE;QACzD,CAAC;MACH;AALS;IAMX;AAnBgB;AAAhB,IAAAC,SAAA,0BAAA;AAqBA,IAAAA,SAAA,UAAe;;;;;;;;;;ACrDf,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,SAAA;AAEA,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY,CAAC,UAAU,SAAS,SAAS;MACzC,QAAQ;MACR,KAAK,KAAe;AAClB,cAAM,EAAC,QAAQ,GAAE,IAAI;AACrB,YAAI,MAAM,QAAQ,MAAM;AAAG,iBAAO,cAAc,KAAK,mBAAmB,MAAM;AAC9E,WAAG,QAAQ;AACX,aAAI,GAAA,OAAA,mBAAkB,IAAI,MAAM;AAAG;AACnC,YAAI,IAAG,GAAA,OAAA,eAAc,GAAG,CAAC;MAC3B;;AAGF,aAAgB,cACd,KACA,YACA,SAAsB,IAAI,QAAM;AAEhC,YAAM,EAAC,KAAK,cAAc,MAAM,SAAS,GAAE,IAAI;AAC/C,uBAAiB,YAAY;AAC7B,UAAI,GAAG,KAAK,eAAe,OAAO,UAAU,GAAG,UAAU,MAAM;AAC7D,WAAG,QAAQ,OAAA,eAAe,MAAM,KAAK,OAAO,QAAQ,GAAG,KAAK;;AAE9D,YAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,YAAM,MAAM,IAAI,MAAM,QAAO,GAAA,UAAA,KAAI,IAAI,SAAS;AAC9C,aAAO,QAAQ,CAAC,KAAgB,MAAa;AAC3C,aAAI,GAAA,OAAA,mBAAkB,IAAI,GAAG;AAAG;AAChC,YAAI,IAAG,GAAA,UAAA,KAAI,GAAG,MAAM,CAAC,IAAI,MACvB,IAAI,UACF;UACE;UACA,YAAY;UACZ,UAAU;WAEZ,KAAK,CACN;AAEH,YAAI,GAAG,KAAK;MACd,CAAC;AAED,eAAS,iBAAiB,KAAoB;AAC5C,cAAM,EAAC,MAAM,cAAa,IAAI;AAC9B,cAAM,IAAI,OAAO;AACjB,cAAM,YAAY,MAAM,IAAI,aAAa,MAAM,IAAI,YAAY,IAAI,UAAU,MAAM;AACnF,YAAI,KAAK,gBAAgB,CAAC,WAAW;AACnC,gBAAM,MAAM,IAAI,OAAO,QAAQ,CAAC,oCAAoC,UAAU,4CAA4C,aAAa;AACvI,WAAA,GAAA,OAAA,iBAAgB,IAAI,KAAK,KAAK,YAAY;;MAE9C;AARS;IASX;AApCgB;AAAhB,IAAAC,SAAA,gBAAA;AAsCA,IAAAA,SAAA,UAAe;;;;;;;;;ACzDf,QAAA,UAAA;AAEA,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY,CAAC,OAAO;MACpB,QAAQ;MACR,MAAM,CAAC,SAAQ,GAAA,QAAA,eAAc,KAAK,OAAO;;AAG3C,IAAAC,SAAA,UAAe;;;;;;;;;ACJf,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,SAAA;AACA,QAAA,oBAAA;AAIA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,QAAQ,EAAC,IAAG,EAAC,OAAM,GAAA,UAAA,+BAA8B,GAAG;MAC/D,QAAQ,CAAC,EAAC,QAAQ,EAAC,IAAG,EAAC,OAAM,GAAA,UAAA,aAAY,GAAG;;AAG9C,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY,CAAC,UAAU,SAAS;MAChC,QAAQ;MACR;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,QAAQ,cAAc,GAAE,IAAI;AACnC,cAAM,EAAC,YAAW,IAAI;AACtB,WAAG,QAAQ;AACX,aAAI,GAAA,OAAA,mBAAkB,IAAI,MAAM;AAAG;AACnC,YAAI;AAAa,WAAA,GAAA,kBAAA,yBAAwB,KAAK,WAAW;;AACpD,cAAI,IAAG,GAAA,OAAA,eAAc,GAAG,CAAC;MAChC;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;AC5Bf,QAAA,YAAA;AACA,QAAA,SAAA;AAQA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,QAAQ,EAAC,KAAK,IAAG,EAAC,MAC3B,QAAQ,UACJ,GAAA,UAAA,6BAA4B,GAAG,oBAC/B,GAAA,UAAA,6BAA4B,GAAG,qBAAqB,GAAG;MAC7D,QAAQ,CAAC,EAAC,QAAQ,EAAC,KAAK,IAAG,EAAC,MAC1B,QAAQ,UAAY,GAAA,UAAA,mBAAkB,GAAG,OAAM,GAAA,UAAA,mBAAkB,GAAG,kBAAkB,GAAG;;AAG7F,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY,CAAC,UAAU,SAAS;MAChC,QAAQ;MACR,aAAa;MACb;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,QAAQ,cAAc,MAAM,GAAE,IAAI;AAC9C,YAAI;AACJ,YAAI;AACJ,cAAM,EAAC,aAAa,YAAW,IAAI;AACnC,YAAI,GAAG,KAAK,MAAM;AAChB,gBAAM,gBAAgB,SAAY,IAAI;AACtC,gBAAM;eACD;AACL,gBAAM;;AAER,cAAM,MAAM,IAAI,MAAM,QAAO,GAAA,UAAA,KAAI,IAAI,SAAS;AAC9C,YAAI,UAAU,EAAC,KAAK,IAAG,CAAC;AACxB,YAAI,QAAQ,UAAa,QAAQ,GAAG;AAClC,WAAA,GAAA,OAAA,iBAAgB,IAAI,sEAAsE;AAC1F;;AAEF,YAAI,QAAQ,UAAa,MAAM,KAAK;AAClC,WAAA,GAAA,OAAA,iBAAgB,IAAI,iDAAiD;AACrE,cAAI,KAAI;AACR;;AAEF,aAAI,GAAA,OAAA,mBAAkB,IAAI,MAAM,GAAG;AACjC,cAAI,QAAO,GAAA,UAAA,KAAI,GAAG,OAAO,GAAG;AAC5B,cAAI,QAAQ;AAAW,oBAAO,GAAA,UAAA,KAAI,IAAI,OAAO,GAAG,OAAO,GAAG;AAC1D,cAAI,KAAK,IAAI;AACb;;AAGF,WAAG,QAAQ;AACX,cAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,YAAI,QAAQ,UAAa,QAAQ,GAAG;AAClC,wBAAc,OAAO,MAAM,IAAI,GAAG,OAAO,MAAM,IAAI,MAAK,CAAE,CAAC;mBAClD,QAAQ,GAAG;AACpB,cAAI,IAAI,OAAO,IAAI;AACnB,cAAI,QAAQ;AAAW,gBAAI,IAAG,GAAA,UAAA,KAAI,IAAI,eAAe,sBAAsB;eACtE;AACL,cAAI,IAAI,OAAO,KAAK;AACpB,iCAAsB;;AAExB,YAAI,OAAO,OAAO,MAAM,IAAI,MAAK,CAAE;AAEnC,iBAAS,yBAAsB;AAC7B,gBAAM,WAAW,IAAI,KAAK,QAAQ;AAClC,gBAAM,QAAQ,IAAI,IAAI,SAAS,CAAC;AAChC,wBAAc,UAAU,MAAM,IAAI,GAAG,UAAU,MAAM,YAAY,KAAK,CAAC,CAAC;QAC1E;AAJS;AAMT,iBAAS,cAAc,QAAc,OAAiB;AACpD,cAAI,SAAS,KAAK,GAAG,KAAK,CAAC,MAAK;AAC9B,gBAAI,UACF;cACE,SAAS;cACT,UAAU;cACV,cAAc,OAAA,KAAK;cACnB,eAAe;eAEjB,MAAM;AAER,kBAAK;UACP,CAAC;QACH;AAbS;AAeT,iBAAS,YAAY,OAAW;AAC9B,cAAI,MAAK,GAAA,UAAA,KAAI,KAAK,IAAI;AACtB,cAAI,QAAQ,QAAW;AACrB,gBAAI,IAAG,GAAA,UAAA,KAAI,KAAK,OAAO,GAAG,IAAI,MAAM,IAAI,OAAO,OAAO,IAAI,EAAE,MAAK,CAAE;iBAC9D;AACL,gBAAI,IAAG,GAAA,UAAA,KAAI,KAAK,MAAM,GAAG,IAAI,MAAM,IAAI,OAAO,OAAO,KAAK,EAAE,MAAK,CAAE;AACnE,gBAAI,QAAQ;AAAG,kBAAI,OAAO,OAAO,IAAI;;AAChC,kBAAI,IAAG,GAAA,UAAA,KAAI,KAAK,OAAO,GAAG,IAAI,MAAM,IAAI,OAAO,OAAO,IAAI,CAAC;;QAEpE;AATS;MAUX;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;;ACpGf,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,SAAA;AAmBa,IAAAC,SAAA,QAAgC;MAC3C,SAAS,CAAC,EAAC,QAAQ,EAAC,UAAU,WAAW,KAAI,EAAC,MAAK;AACjD,cAAM,eAAe,cAAc,IAAI,aAAa;AACpD,gBAAO,GAAA,UAAA,iBAAgB,YAAY,IAAI,IAAI,kBAAkB,QAAQ;MACvE;MACA,QAAQ,CAAC,EAAC,QAAQ,EAAC,UAAU,WAAW,MAAM,gBAAe,EAAC,OAC5D,GAAA,UAAA,gBAAe,QAAQ;uBACJ,eAAe;iBACrB,SAAS;YACd,IAAI;;;AAGhB,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY;MACZ,OAAAA,SAAA;MACA,KAAK,KAAe;AAClB,cAAM,CAAC,UAAU,OAAO,IAAI,kBAAkB,GAAG;AACjD,6BAAqB,KAAK,QAAQ;AAClC,2BAAmB,KAAK,OAAO;MACjC;;AAGF,aAAS,kBAAkB,EAAC,OAAM,GAAa;AAC7C,YAAM,eAAqC,CAAA;AAC3C,YAAM,aAAiC,CAAA;AACvC,iBAAW,OAAO,QAAQ;AACxB,YAAI,QAAQ;AAAa;AACzB,cAAM,OAAO,MAAM,QAAQ,OAAO,GAAG,CAAC,IAAI,eAAe;AACzD,aAAK,GAAG,IAAI,OAAO,GAAG;;AAExB,aAAO,CAAC,cAAc,UAAU;IAClC;AATS;AAWT,aAAgB,qBACd,KACA,eAA2C,IAAI,QAAM;AAErD,YAAM,EAAC,KAAK,MAAM,GAAE,IAAI;AACxB,UAAI,OAAO,KAAK,YAAY,EAAE,WAAW;AAAG;AAC5C,YAAM,UAAU,IAAI,IAAI,SAAS;AACjC,iBAAW,QAAQ,cAAc;AAC/B,cAAM,OAAO,aAAa,IAAI;AAC9B,YAAI,KAAK,WAAW;AAAG;AACvB,cAAM,eAAc,GAAA,OAAA,gBAAe,KAAK,MAAM,MAAM,GAAG,KAAK,aAAa;AACzE,YAAI,UAAU;UACZ,UAAU;UACV,WAAW,KAAK;UAChB,MAAM,KAAK,KAAK,IAAI;SACrB;AACD,YAAI,GAAG,WAAW;AAChB,cAAI,GAAG,aAAa,MAAK;AACvB,uBAAW,WAAW,MAAM;AAC1B,eAAA,GAAA,OAAA,wBAAuB,KAAK,OAAO;;UAEvC,CAAC;eACI;AACL,cAAI,IAAG,GAAA,UAAA,KAAI,WAAW,SAAQ,GAAA,OAAA,kBAAiB,KAAK,MAAM,OAAO,CAAC,GAAG;AACrE,WAAA,GAAA,OAAA,mBAAkB,KAAK,OAAO;AAC9B,cAAI,KAAI;;;IAGd;AA5BgB;AAAhB,IAAAA,SAAA,uBAAA;AA8BA,aAAgB,mBAAmB,KAAiB,aAAwB,IAAI,QAAM;AACpF,YAAM,EAAC,KAAK,MAAM,SAAS,GAAE,IAAI;AACjC,YAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,iBAAW,QAAQ,YAAY;AAC7B,aAAI,GAAA,OAAA,mBAAkB,IAAI,WAAW,IAAI,CAAc;AAAG;AAC1D,YAAI;WACF,GAAA,OAAA,gBAAe,KAAK,MAAM,MAAM,GAAG,KAAK,aAAa;UACrD,MAAK;AACH,kBAAM,SAAS,IAAI,UAAU,EAAC,SAAS,YAAY,KAAI,GAAG,KAAK;AAC/D,gBAAI,oBAAoB,QAAQ,KAAK;UACvC;UACA,MAAM,IAAI,IAAI,OAAO,IAAI;;;AAE3B,YAAI,GAAG,KAAK;;IAEhB;AAfgB;AAAhB,IAAAA,SAAA,qBAAA;AAiBA,IAAAA,SAAA,UAAe;;;;;;;;;ACxGf,QAAA,YAAA;AACA,QAAA,SAAA;AAIA,QAAM,QAAgC;MACpC,SAAS;MACT,QAAQ,CAAC,EAAC,OAAM,OAAM,GAAA,UAAA,oBAAmB,OAAO,YAAY;;AAG9D,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY,CAAC,UAAU,SAAS;MAChC;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,QAAQ,MAAM,GAAE,IAAI;AAChC,aAAI,GAAA,OAAA,mBAAkB,IAAI,MAAM;AAAG;AACnC,cAAM,QAAQ,IAAI,KAAK,OAAO;AAE9B,YAAI,MAAM,OAAO,MAAM,CAAC,QAAO;AAC7B,cAAI,UAAU,EAAC,cAAc,IAAG,CAAC;AACjC,cAAI,UACF;YACE,SAAS;YACT,MAAM;YACN,WAAW,CAAC,QAAQ;YACpB,cAAc;YACd,eAAe;aAEjB,KAAK;AAEP,cAAI,IAAG,GAAA,UAAA,KAAI,KAAK,GAAG,MAAK;AACtB,gBAAI,MAAM,IAAI;AACd,gBAAI,CAAC,GAAG;AAAW,kBAAI,MAAK;UAC9B,CAAC;QACH,CAAC;AAED,YAAI,GAAG,KAAK;MACd;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;AC1Cf,QAAA,SAAA;AACA,QAAA,YAAA;AACA,QAAA,UAAA;AAEA,QAAA,SAAA;AAQA,QAAM,QAAgC;MACpC,SAAS;MACT,QAAQ,CAAC,EAAC,OAAM,OAAM,GAAA,UAAA,0BAAyB,OAAO,kBAAkB;;AAG1E,QAAM,MAAsD;MAC1D,SAAS;MACT,MAAM,CAAC,QAAQ;MACf,YAAY,CAAC,WAAW,QAAQ;MAChC,gBAAgB;MAChB,aAAa;MACb;MACA,KAAK,KAAG;AACN,cAAM,EAAC,KAAK,QAAQ,cAAc,MAAM,WAAW,GAAE,IAAI;AAEzD,YAAI,CAAC;AAAW,gBAAM,IAAI,MAAM,0BAA0B;AAC1D,cAAM,EAAC,WAAW,KAAI,IAAI;AAC1B,WAAG,QAAQ;AACX,YAAI,KAAK,qBAAqB,UAAS,GAAA,OAAA,mBAAkB,IAAI,MAAM;AAAG;AACtE,cAAM,SAAQ,GAAA,OAAA,qBAAoB,aAAa,UAAU;AACzD,cAAM,YAAW,GAAA,OAAA,qBAAoB,aAAa,iBAAiB;AACnE,kCAAyB;AACzB,YAAI,IAAG,GAAA,UAAA,KAAI,SAAS,QAAQ,QAAA,QAAE,MAAM,EAAE;AAEtC,iBAAS,4BAAyB;AAChC,cAAI,MAAM,OAAO,MAAM,CAAC,QAAa;AACnC,gBAAI,CAAC,MAAM,UAAU,CAAC,SAAS;AAAQ,qCAAuB,GAAG;;AAC5D,kBAAI,GAAG,aAAa,GAAG,GAAG,MAAM,uBAAuB,GAAG,CAAC;UAClE,CAAC;QACH;AALS;AAOT,iBAAS,aAAa,KAAS;AAC7B,cAAI;AACJ,cAAI,MAAM,SAAS,GAAG;AAEpB,kBAAM,eAAc,GAAA,OAAA,gBAAe,IAAI,aAAa,YAAY,YAAY;AAC5E,2BAAc,GAAA,OAAA,eAAc,KAAK,aAAqB,GAAG;qBAChD,MAAM,QAAQ;AACvB,2BAAc,GAAA,UAAA,IAAG,GAAG,MAAM,IAAI,CAAC,OAAM,GAAA,UAAA,KAAI,GAAG,QAAQ,CAAC,EAAE,CAAC;iBACnD;AACL,0BAAc,UAAA;;AAEhB,cAAI,SAAS,QAAQ;AACnB,2BAAc,GAAA,UAAA,IAAG,aAAa,GAAG,SAAS,IAAI,CAAC,OAAM,GAAA,UAAA,MAAI,GAAA,OAAA,YAAW,KAAK,CAAC,CAAC,SAAS,GAAG,GAAG,CAAC;;AAE7F,kBAAO,GAAA,UAAA,KAAI,WAAW;QACxB;AAfS;AAiBT,iBAAS,iBAAiB,KAAS;AACjC,cAAI,MAAK,GAAA,UAAA,YAAW,IAAI,IAAI,GAAG,GAAG;QACpC;AAFS;AAIT,iBAAS,uBAAuB,KAAS;AACvC,cAAI,KAAK,qBAAqB,SAAU,KAAK,oBAAoB,WAAW,OAAQ;AAClF,6BAAiB,GAAG;AACpB;;AAGF,cAAI,WAAW,OAAO;AACpB,gBAAI,UAAU,EAAC,oBAAoB,IAAG,CAAC;AACvC,gBAAI,MAAK;AACT,gBAAI,CAAC;AAAW,kBAAI,MAAK;AACzB;;AAGF,cAAI,OAAO,UAAU,YAAY,EAAC,GAAA,OAAA,mBAAkB,IAAI,MAAM,GAAG;AAC/D,kBAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,gBAAI,KAAK,qBAAqB,WAAW;AACvC,oCAAsB,KAAK,OAAO,KAAK;AACvC,kBAAI,IAAG,GAAA,UAAA,KAAI,KAAK,GAAG,MAAK;AACtB,oBAAI,MAAK;AACT,iCAAiB,GAAG;cACtB,CAAC;mBACI;AACL,oCAAsB,KAAK,KAAK;AAChC,kBAAI,CAAC;AAAW,oBAAI,IAAG,GAAA,UAAA,KAAI,KAAK,GAAG,MAAM,IAAI,MAAK,CAAE;;;QAG1D;AA1BS;AA4BT,iBAAS,sBAAsB,KAAW,OAAa,QAAc;AACnE,gBAAM,YAA2B;YAC/B,SAAS;YACT,UAAU;YACV,cAAc,OAAA,KAAK;;AAErB,cAAI,WAAW,OAAO;AACpB,mBAAO,OAAO,WAAW;cACvB,eAAe;cACf,cAAc;cACd,WAAW;aACZ;;AAEH,cAAI,UAAU,WAAW,KAAK;QAChC;AAdS;MAeX;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACpHf,QAAA,aAAA;AACA,QAAA,SAAA;AACA,QAAA,SAAA;AACA,QAAA,yBAAA;AAEA,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY;MACZ,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,QAAQ,cAAc,MAAM,GAAE,IAAI;AAC9C,YAAI,GAAG,KAAK,qBAAqB,SAAS,aAAa,yBAAyB,QAAW;AACzF,iCAAA,QAAM,KAAK,IAAI,WAAA,WAAW,IAAI,uBAAA,SAAO,sBAAsB,CAAC;;AAE9D,cAAM,YAAW,GAAA,OAAA,qBAAoB,MAAM;AAC3C,mBAAW,QAAQ,UAAU;AAC3B,aAAG,kBAAkB,IAAI,IAAI;;AAE/B,YAAI,GAAG,KAAK,eAAe,SAAS,UAAU,GAAG,UAAU,MAAM;AAC/D,aAAG,QAAQ,OAAA,eAAe,MAAM,MAAK,GAAA,OAAA,QAAO,QAAQ,GAAG,GAAG,KAAK;;AAEjE,cAAM,aAAa,SAAS,OAAO,CAAC,MAAM,EAAC,GAAA,OAAA,mBAAkB,IAAI,OAAO,CAAC,CAAC,CAAC;AAC3E,YAAI,WAAW,WAAW;AAAG;AAC7B,cAAM,QAAQ,IAAI,KAAK,OAAO;AAE9B,mBAAW,QAAQ,YAAY;AAC7B,cAAI,WAAW,IAAI,GAAG;AACpB,gCAAoB,IAAI;iBACnB;AACL,gBAAI,IAAG,GAAA,OAAA,gBAAe,KAAK,MAAM,MAAM,GAAG,KAAK,aAAa,CAAC;AAC7D,gCAAoB,IAAI;AACxB,gBAAI,CAAC,GAAG;AAAW,kBAAI,KAAI,EAAG,IAAI,OAAO,IAAI;AAC7C,gBAAI,MAAK;;AAEX,cAAI,GAAG,kBAAkB,IAAI,IAAI;AACjC,cAAI,GAAG,KAAK;;AAGd,iBAAS,WAAW,MAAY;AAC9B,iBAAO,GAAG,KAAK,eAAe,CAAC,GAAG,iBAAiB,OAAO,IAAI,EAAE,YAAY;QAC9E;AAFS;AAIT,iBAAS,oBAAoB,MAAY;AACvC,cAAI,UACF;YACE,SAAS;YACT,YAAY;YACZ,UAAU;aAEZ,KAAK;QAET;AATS;MAUX;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACtDf,QAAA,SAAA;AACA,QAAA,YAAA;AACA,QAAA,SAAA;AACA,QAAA,SAAA;AAGA,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY;MACZ,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,QAAQ,MAAM,cAAc,GAAE,IAAI;AAC9C,cAAM,EAAC,KAAI,IAAI;AACf,cAAM,YAAW,GAAA,OAAA,qBAAoB,MAAM;AAC3C,cAAM,sBAAsB,SAAS,OAAO,CAAC,OAC3C,GAAA,OAAA,mBAAkB,IAAI,OAAO,CAAC,CAAc,CAAC;AAG/C,YACE,SAAS,WAAW,KACnB,oBAAoB,WAAW,SAAS,WACtC,CAAC,GAAG,KAAK,eAAe,GAAG,UAAU,OACxC;AACA;;AAGF,cAAM,kBACJ,KAAK,gBAAgB,CAAC,KAAK,2BAA2B,aAAa;AACrE,cAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,YAAI,GAAG,UAAU,QAAQ,EAAE,GAAG,iBAAiB,UAAA,OAAO;AACpD,aAAG,SAAQ,GAAA,OAAA,sBAAqB,KAAK,GAAG,KAAK;;AAE/C,cAAM,EAAC,MAAK,IAAI;AAChB,kCAAyB;AAEzB,iBAAS,4BAAyB;AAChC,qBAAW,OAAO,UAAU;AAC1B,gBAAI;AAAiB,sCAAwB,GAAG;AAChD,gBAAI,GAAG,WAAW;AAChB,iCAAmB,GAAG;mBACjB;AACL,kBAAI,IAAI,OAAO,IAAI;AACnB,iCAAmB,GAAG;AACtB,kBAAI,GAAG,KAAK;;;QAGlB;AAXS;AAaT,iBAAS,wBAAwB,KAAW;AAC1C,qBAAW,QAAQ,iBAAiB;AAClC,gBAAI,IAAI,OAAO,GAAG,EAAE,KAAK,IAAI,GAAG;AAC9B,eAAA,GAAA,OAAA,iBACE,IACA,YAAY,IAAI,oBAAoB,GAAG,gCAAgC;;;QAI/E;AATS;AAWT,iBAAS,mBAAmB,KAAW;AACrC,cAAI,MAAM,OAAO,MAAM,CAAC,QAAO;AAC7B,gBAAI,IAAG,GAAA,UAAA,MAAI,GAAA,OAAA,YAAW,KAAK,GAAG,CAAC,SAAS,GAAG,KAAK,MAAK;AACnD,oBAAM,cAAc,oBAAoB,SAAS,GAAG;AACpD,kBAAI,CAAC,aAAa;AAChB,oBAAI,UACF;kBACE,SAAS;kBACT,YAAY;kBACZ,UAAU;kBACV,cAAc,OAAA,KAAK;mBAErB,KAAK;;AAIT,kBAAI,GAAG,KAAK,eAAe,UAAU,MAAM;AACzC,oBAAI,QAAO,GAAA,UAAA,KAAI,KAAK,IAAI,GAAG,KAAK,IAAI;yBAC3B,CAAC,eAAe,CAAC,GAAG,WAAW;AAGxC,oBAAI,IAAG,GAAA,UAAA,KAAI,KAAK,GAAG,MAAM,IAAI,MAAK,CAAE;;YAExC,CAAC;UACH,CAAC;QACH;AAzBS;MA0BX;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACxFf,QAAA,SAAA;AAIA,QAAM,MAA6B;MACjC,SAAS;MACT,YAAY,CAAC,UAAU,SAAS;MAChC,aAAa;MACb,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,QAAQ,GAAE,IAAI;AAC1B,aAAI,GAAA,OAAA,mBAAkB,IAAI,MAAM,GAAG;AACjC,cAAI,KAAI;AACR;;AAGF,cAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,YAAI,UACF;UACE,SAAS;UACT,eAAe;UACf,cAAc;UACd,WAAW;WAEb,KAAK;AAGP,YAAI,WACF,OACA,MAAM,IAAI,MAAK,GACf,MAAM,IAAI,MAAK,CAAE;MAErB;MACA,OAAO,EAAC,SAAS,oBAAmB;;AAGtC,IAAAC,SAAA,UAAe;;;;;;;;;ACpCf,QAAA,SAAA;AAIA,QAAM,MAA6B;MACjC,SAAS;MACT,YAAY;MACZ,aAAa;MACb,MAAM,OAAA;MACN,OAAO,EAAC,SAAS,+BAA8B;;AAGjD,IAAAC,SAAA,UAAe;;;;;;;;;ACNf,QAAA,YAAA;AACA,QAAA,SAAA;AASA,QAAM,QAAgC;MACpC,SAAS;MACT,QAAQ,CAAC,EAAC,OAAM,OAAM,GAAA,UAAA,sBAAqB,OAAO,OAAO;;AAG3D,QAAM,MAA6B;MACjC,SAAS;MACT,YAAY;MACZ,aAAa;MACb;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,QAAQ,cAAc,GAAE,IAAI;AAExC,YAAI,CAAC,MAAM,QAAQ,MAAM;AAAG,gBAAM,IAAI,MAAM,0BAA0B;AACtE,YAAI,GAAG,KAAK,iBAAiB,aAAa;AAAe;AACzD,cAAM,SAAsB;AAC5B,cAAM,QAAQ,IAAI,IAAI,SAAS,KAAK;AACpC,cAAM,UAAU,IAAI,IAAI,WAAW,IAAI;AACvC,cAAM,WAAW,IAAI,KAAK,QAAQ;AAClC,YAAI,UAAU,EAAC,QAAO,CAAC;AAGvB,YAAI,MAAM,aAAa;AAEvB,YAAI,OACF,OACA,MAAM,IAAI,MAAK,GACf,MAAM,IAAI,MAAM,IAAI,CAAC;AAGvB,iBAAS,gBAAa;AACpB,iBAAO,QAAQ,CAAC,KAAgB,MAAa;AAC3C,gBAAI;AACJ,iBAAI,GAAA,OAAA,mBAAkB,IAAI,GAAG,GAAG;AAC9B,kBAAI,IAAI,UAAU,IAAI;mBACjB;AACL,uBAAS,IAAI,UACX;gBACE,SAAS;gBACT,YAAY;gBACZ,eAAe;iBAEjB,QAAQ;;AAIZ,gBAAI,IAAI,GAAG;AACT,kBACG,IAAG,GAAA,UAAA,KAAI,QAAQ,OAAO,KAAK,EAAE,EAC7B,OAAO,OAAO,KAAK,EACnB,OAAO,UAAS,GAAA,UAAA,MAAK,OAAO,KAAK,CAAC,GAAG,EACrC,KAAI;;AAGT,gBAAI,GAAG,UAAU,MAAK;AACpB,kBAAI,OAAO,OAAO,IAAI;AACtB,kBAAI,OAAO,SAAS,CAAC;AACrB,kBAAI;AAAQ,oBAAI,eAAe,QAAQ,UAAA,IAAI;YAC7C,CAAC;UACH,CAAC;QACH;AA9BS;MA+BX;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;AC/Ef,QAAA,SAAA;AAEA,QAAM,MAA6B;MACjC,SAAS;MACT,YAAY;MACZ,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,QAAQ,GAAE,IAAI;AAE1B,YAAI,CAAC,MAAM,QAAQ,MAAM;AAAG,gBAAM,IAAI,MAAM,0BAA0B;AACtE,cAAM,QAAQ,IAAI,KAAK,OAAO;AAC9B,eAAO,QAAQ,CAAC,KAAgB,MAAa;AAC3C,eAAI,GAAA,OAAA,mBAAkB,IAAI,GAAG;AAAG;AAChC,gBAAM,SAAS,IAAI,UAAU,EAAC,SAAS,SAAS,YAAY,EAAC,GAAG,KAAK;AACrE,cAAI,GAAG,KAAK;AACZ,cAAI,eAAe,MAAM;QAC3B,CAAC;MACH;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACbf,QAAA,YAAA;AACA,QAAA,SAAA;AAIA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,OAAM,OAAM,GAAA,UAAA,mBAAkB,OAAO,QAAQ;MACxD,QAAQ,CAAC,EAAC,OAAM,OAAM,GAAA,UAAA,sBAAqB,OAAO,QAAQ;;AAG5D,QAAM,MAA6B;MACjC,SAAS;MACT,YAAY,CAAC,UAAU,SAAS;MAChC,aAAa;MACb;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,cAAc,GAAE,IAAI;AAChC,YAAI,aAAa,SAAS,UAAa,aAAa,SAAS,QAAW;AACtE,WAAA,GAAA,OAAA,iBAAgB,IAAI,2CAA2C;;AAEjE,cAAM,UAAU,UAAU,IAAI,MAAM;AACpC,cAAM,UAAU,UAAU,IAAI,MAAM;AACpC,YAAI,CAAC,WAAW,CAAC;AAAS;AAE1B,cAAM,QAAQ,IAAI,IAAI,SAAS,IAAI;AACnC,cAAM,WAAW,IAAI,KAAK,QAAQ;AAClC,mBAAU;AACV,YAAI,MAAK;AAET,YAAI,WAAW,SAAS;AACtB,gBAAM,WAAW,IAAI,IAAI,UAAU;AACnC,cAAI,UAAU,EAAC,SAAQ,CAAC;AACxB,cAAI,GAAG,UAAU,eAAe,QAAQ,QAAQ,GAAG,eAAe,QAAQ,QAAQ,CAAC;mBAC1E,SAAS;AAClB,cAAI,GAAG,UAAU,eAAe,MAAM,CAAC;eAClC;AACL,cAAI,IAAG,GAAA,UAAA,KAAI,QAAQ,GAAG,eAAe,MAAM,CAAC;;AAG9C,YAAI,KAAK,OAAO,MAAM,IAAI,MAAM,IAAI,CAAC;AAErC,iBAAS,aAAU;AACjB,gBAAM,SAAS,IAAI,UACjB;YACE,SAAS;YACT,eAAe;YACf,cAAc;YACd,WAAW;aAEb,QAAQ;AAEV,cAAI,eAAe,MAAM;QAC3B;AAXS;AAaT,iBAAS,eAAe,SAAiB,UAAe;AACtD,iBAAO,MAAK;AACV,kBAAM,SAAS,IAAI,UAAU,EAAC,QAAO,GAAG,QAAQ;AAChD,gBAAI,OAAO,OAAO,QAAQ;AAC1B,gBAAI,oBAAoB,QAAQ,KAAK;AACrC,gBAAI;AAAU,kBAAI,OAAO,WAAU,GAAA,UAAA,KAAI,OAAO,EAAE;;AAC3C,kBAAI,UAAU,EAAC,UAAU,QAAO,CAAC;UACxC;QACF;AARS;MASX;;AAGF,aAAS,UAAU,IAAkB,SAAe;AAClD,YAAM,SAAS,GAAG,OAAO,OAAO;AAChC,aAAO,WAAW,UAAa,EAAC,GAAA,OAAA,mBAAkB,IAAI,MAAM;IAC9D;AAHS;AAKT,IAAAC,SAAA,UAAe;;;;;;;;;AC7Ef,QAAA,SAAA;AAEA,QAAM,MAA6B;MACjC,SAAS,CAAC,QAAQ,MAAM;MACxB,YAAY,CAAC,UAAU,SAAS;MAChC,KAAK,EAAC,SAAS,cAAc,GAAE,GAAa;AAC1C,YAAI,aAAa,OAAO;AAAW,WAAA,GAAA,OAAA,iBAAgB,IAAI,IAAI,OAAO,2BAA2B;MAC/F;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACXf,QAAA,oBAAA;AACA,QAAA,gBAAA;AACA,QAAA,UAAA;AACA,QAAA,cAAA;AACA,QAAA,aAAA;AACA,QAAA,iBAAA;AACA,QAAA,kBAAA;AACA,QAAA,yBAAA;AACA,QAAA,eAAA;AACA,QAAA,sBAAA;AACA,QAAA,QAAA;AACA,QAAA,UAAA;AACA,QAAA,UAAA;AACA,QAAA,UAAA;AACA,QAAA,OAAA;AACA,QAAA,aAAA;AAEA,aAAwB,cAAc,YAAY,OAAK;AACrD,YAAM,aAAa;;QAEjB,MAAA;QACA,QAAA;QACA,QAAA;QACA,QAAA;QACA,KAAA;QACA,WAAA;;QAEA,gBAAA;QACA,uBAAA;QACA,eAAA;QACA,aAAA;QACA,oBAAA;;AAGF,UAAI;AAAW,mBAAW,KAAK,cAAA,SAAa,YAAA,OAAS;;AAChD,mBAAW,KAAK,kBAAA,SAAiB,QAAA,OAAK;AAC3C,iBAAW,KAAK,WAAA,OAAQ;AACxB,aAAO;IACT;AArBwB;AAAxB,IAAAC,SAAA,UAAA;;;;;;;;;ACTA,QAAA,YAAA;AAaA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,0BAAyB,UAAU;MAC9D,QAAQ,CAAC,EAAC,WAAU,OAAM,GAAA,UAAA,cAAa,UAAU;;AAGnD,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM,CAAC,UAAU,QAAQ;MACzB,YAAY;MACZ,OAAO;MACP;MACA,KAAK,KAAiB,UAAiB;AACrC,cAAM,EAAC,KAAK,MAAM,OAAO,QAAQ,YAAY,GAAE,IAAI;AACnD,cAAM,EAAC,MAAM,eAAe,WAAW,KAAI,IAAI;AAC/C,YAAI,CAAC,KAAK;AAAiB;AAE3B,YAAI;AAAO,8BAAmB;;AACzB,yBAAc;AAEnB,iBAAS,sBAAmB;AAC1B,gBAAM,OAAO,IAAI,WAAW,WAAW;YACrC,KAAK,KAAK;YACV,MAAM,KAAK,KAAK;WACjB;AACD,gBAAM,OAAO,IAAI,MAAM,SAAQ,GAAA,UAAA,KAAI,IAAI,IAAI,UAAU,GAAG;AACxD,gBAAM,QAAQ,IAAI,IAAI,OAAO;AAC7B,gBAAM,SAAS,IAAI,IAAI,QAAQ;AAE/B,cAAI,IACF,GAAA,UAAA,YAAW,IAAI,qBAAqB,IAAI,uBACxC,MAAM,IAAI,OAAO,QAAO,GAAA,UAAA,KAAI,IAAI,mBAAmB,EAAE,OAAO,SAAQ,GAAA,UAAA,KAAI,IAAI,WAAW,GACvF,MAAM,IAAI,OAAO,QAAO,GAAA,UAAA,YAAW,EAAE,OAAO,QAAQ,IAAI,CAAC;AAE3D,cAAI,WAAU,GAAA,UAAA,IAAG,WAAU,GAAI,WAAU,CAAE,CAAC;AAE5C,mBAAS,aAAU;AACjB,gBAAI,KAAK,iBAAiB;AAAO,qBAAO,UAAA;AACxC,oBAAO,GAAA,UAAA,KAAI,UAAU,QAAQ,MAAM;UACrC;AAHS;AAKT,mBAAS,aAAU;AACjB,kBAAM,aAAa,UAAU,UACzB,GAAA,UAAA,MAAK,IAAI,kBAAkB,MAAM,IAAI,IAAI,OAAO,MAAM,IAAI,IAAI,QAC9D,GAAA,UAAA,KAAI,MAAM,IAAI,IAAI;AACtB,kBAAM,aAAY,GAAA,UAAA,aAAY,MAAM,oBAAoB,UAAU,MAAM,MAAM,SAAS,IAAI;AAC3F,oBAAO,GAAA,UAAA,KAAI,MAAM,OAAO,MAAM,gBAAgB,KAAK,QAAQ,QAAQ,QAAQ,SAAS;UACtF;AANS;QAOX;AA5BS;AA8BT,iBAAS,iBAAc;AACrB,gBAAM,YAAqC,KAAK,QAAQ,MAAM;AAC9D,cAAI,CAAC,WAAW;AACd,0BAAa;AACb;;AAEF,cAAI,cAAc;AAAM;AACxB,gBAAM,CAAC,SAAS,QAAQ,MAAM,IAAI,UAAU,SAAS;AACrD,cAAI,YAAY;AAAU,gBAAI,KAAK,eAAc,CAAE;AAEnD,mBAAS,gBAAa;AACpB,gBAAI,KAAK,iBAAiB,OAAO;AAC/B,mBAAK,OAAO,KAAK,WAAU,CAAE;AAC7B;;AAEF,kBAAM,IAAI,MAAM,WAAU,CAAE;AAE5B,qBAAS,aAAU;AACjB,qBAAO,mBAAmB,MAAgB,gCAAgC,aAAa;YACzF;AAFS;UAGX;AAVS;AAYT,mBAAS,UAAU,QAAmB;AACpC,kBAAM,OACJ,kBAAkB,UACd,GAAA,UAAA,YAAW,MAAM,IACjB,KAAK,KAAK,WACV,GAAA,UAAA,KAAI,KAAK,KAAK,OAAO,IAAG,GAAA,UAAA,aAAY,MAAM,CAAC,KAC3C;AACN,kBAAM,MAAM,IAAI,WAAW,WAAW,EAAC,KAAK,QAAQ,KAAK,QAAQ,KAAI,CAAC;AACtE,gBAAI,OAAO,UAAU,YAAY,EAAE,kBAAkB,SAAS;AAC5D,qBAAO,CAAC,OAAO,QAAQ,UAAU,OAAO,WAAU,GAAA,UAAA,KAAI,GAAG,WAAW;;AAGtE,mBAAO,CAAC,UAAU,QAAQ,GAAG;UAC/B;AAbS;AAeT,mBAAS,iBAAc;AACrB,gBAAI,OAAO,aAAa,YAAY,EAAE,qBAAqB,WAAW,UAAU,OAAO;AACrF,kBAAI,CAAC,UAAU;AAAQ,sBAAM,IAAI,MAAM,6BAA6B;AACpE,sBAAO,GAAA,UAAA,WAAU,MAAM,IAAI,IAAI;;AAEjC,mBAAO,OAAO,UAAU,cAAa,GAAA,UAAA,KAAI,MAAM,IAAI,IAAI,OAAM,GAAA,UAAA,KAAI,MAAM,SAAS,IAAI;UACtF;AANS;QAOX;AA5CS;MA6CX;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;ACtHf,QAAA,WAAA;AAEA,QAAM,SAAqB,CAAC,SAAA,OAAa;AAEzC,IAAAC,SAAA,UAAe;;;;;;;;;;ACHF,IAAAC,SAAA,qBAAiC;MAC5C;MACA;MACA;MACA;MACA;MACA;MACA;;AAGW,IAAAA,SAAA,oBAAgC;MAC3C;MACA;MACA;;;;;;;;;;ACdF,QAAA,SAAA;AACA,QAAA,eAAA;AACA,QAAA,eAAA;AACA,QAAA,WAAA;AACA,QAAA,aAAA;AAEA,QAAM,qBAAmC;MACvC,OAAA;MACA,aAAA;OACA,GAAA,aAAA,SAAuB;MACvB,SAAA;MACA,WAAA;MACA,WAAA;;AAGF,IAAAC,SAAA,UAAe;;;;;;;;;;ACdf,QAAY;AAAZ,KAAA,SAAYC,aAAU;AACpB,MAAAA,YAAA,KAAA,IAAA;AACA,MAAAA,YAAA,SAAA,IAAA;IACF,GAHY,aAAAC,SAAA,eAAAA,SAAA,aAAU,CAAA,EAAA;;;;;;;;;ACAtB,QAAA,YAAA;AACA,QAAA,UAAA;AACA,QAAA,YAAA;AACA,QAAA,SAAA;AAIA,QAAM,QAAgC;MACpC,SAAS,CAAC,EAAC,QAAQ,EAAC,YAAY,QAAO,EAAC,MACtC,eAAe,QAAA,WAAW,MACtB,QAAQ,OAAO,qBACf,iBAAiB,OAAO;MAC9B,QAAQ,CAAC,EAAC,QAAQ,EAAC,YAAY,KAAK,QAAO,EAAC,OAC1C,GAAA,UAAA,aAAY,UAAU,UAAU,OAAO,eAAe,GAAG;;AAG7D,QAAM,MAA6B;MACjC,SAAS;MACT,MAAM;MACN,YAAY;MACZ;MACA,KAAK,KAAe;AAClB,cAAM,EAAC,KAAK,MAAM,QAAQ,cAAc,GAAE,IAAI;AAC9C,cAAM,EAAC,MAAK,IAAI;AAChB,YAAI,CAAC,GAAG,KAAK,eAAe;AAC1B,gBAAM,IAAI,MAAM,8CAA8C;;AAEhE,cAAM,UAAU,OAAO;AACvB,YAAI,OAAO,WAAW;AAAU,gBAAM,IAAI,MAAM,sCAAsC;AACtF,YAAI,OAAO;AAAS,gBAAM,IAAI,MAAM,yCAAyC;AAC7E,YAAI,CAAC;AAAO,gBAAM,IAAI,MAAM,uCAAuC;AACnE,cAAM,QAAQ,IAAI,IAAI,SAAS,KAAK;AACpC,cAAM,MAAM,IAAI,MAAM,QAAO,GAAA,UAAA,KAAI,IAAI,IAAG,GAAA,UAAA,aAAY,OAAO,CAAC,EAAE;AAC9D,YAAI,IACF,GAAA,UAAA,YAAW,GAAG,gBACd,MAAM,gBAAe,GACrB,MAAM,IAAI,MAAM,OAAO,EAAC,YAAY,QAAA,WAAW,KAAK,KAAK,QAAO,CAAC,CAAC;AAEpE,YAAI,GAAG,KAAK;AAEZ,iBAAS,kBAAe;AACtB,gBAAM,UAAU,WAAU;AAC1B,cAAI,GAAG,KAAK;AACZ,qBAAW,YAAY,SAAS;AAC9B,gBAAI,QAAO,GAAA,UAAA,KAAI,GAAG,QAAQ,QAAQ,EAAE;AACpC,gBAAI,OAAO,OAAO,eAAe,QAAQ,QAAQ,CAAC,CAAC;;AAErD,cAAI,KAAI;AACR,cAAI,MAAM,OAAO,EAAC,YAAY,QAAA,WAAW,SAAS,KAAK,QAAO,CAAC;AAC/D,cAAI,MAAK;QACX;AAVS;AAYT,iBAAS,eAAe,YAAmB;AACzC,gBAAM,SAAS,IAAI,KAAK,OAAO;AAC/B,gBAAM,SAAS,IAAI,UAAU,EAAC,SAAS,SAAS,WAAU,GAAG,MAAM;AACnE,cAAI,eAAe,QAAQ,UAAA,IAAI;AAC/B,iBAAO;QACT;AALS;AAOT,iBAAS,aAAU;;AACjB,gBAAM,eAAyC,CAAA;AAC/C,gBAAM,cAAc,YAAY,YAAY;AAC5C,cAAI,cAAc;AAClB,mBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,gBAAI,MAAM,MAAM,CAAC;AACjB,iBAAI,QAAG,QAAH,QAAG,SAAA,SAAH,IAAK,SAAQ,EAAC,GAAA,OAAA,sBAAqB,KAAK,GAAG,KAAK,KAAK,GAAG;AAC1D,oBAAM,UAAA,WAAW,KAAK,GAAG,MAAM,GAAG,UAAU,MAAM,GAAG,QAAQ,QAAG,QAAH,QAAG,SAAA,SAAH,IAAK,IAAI;AACtE,kBAAI,eAAe,UAAA;AAAW,sBAAM,IAAI;;AAE1C,kBAAM,WAAU,KAAA,QAAG,QAAH,QAAG,SAAA,SAAH,IAAK,gBAAU,QAAA,OAAA,SAAA,SAAA,GAAG,OAAO;AACzC,gBAAI,OAAO,WAAW,UAAU;AAC9B,oBAAM,IAAI,MACR,iFAAiF,OAAO,GAAG;;AAG/F,0BAAc,gBAAgB,eAAe,YAAY,GAAG;AAC5D,wBAAY,SAAS,CAAC;;AAExB,cAAI,CAAC;AAAa,kBAAM,IAAI,MAAM,mBAAmB,OAAO,oBAAoB;AAChF,iBAAO;AAEP,mBAAS,YAAY,EAAC,SAAQ,GAAkB;AAC9C,mBAAO,MAAM,QAAQ,QAAQ,KAAK,SAAS,SAAS,OAAO;UAC7D;AAFS;AAIT,mBAAS,YAAY,KAAsB,GAAS;AAClD,gBAAI,IAAI,OAAO;AACb,yBAAW,IAAI,OAAO,CAAC;uBACd,IAAI,MAAM;AACnB,yBAAW,YAAY,IAAI,MAAM;AAC/B,2BAAW,UAAU,CAAC;;mBAEnB;AACL,oBAAM,IAAI,MAAM,8BAA8B,OAAO,+BAA+B;;UAExF;AAVS;AAYT,mBAAS,WAAW,UAAmB,GAAS;AAC9C,gBAAI,OAAO,YAAY,YAAY,YAAY,cAAc;AAC3D,oBAAM,IAAI,MAAM,mBAAmB,OAAO,iCAAiC;;AAE7E,yBAAa,QAAQ,IAAI;UAC3B;AALS;QAMX;AA5CS;MA6CX;;AAGF,IAAAC,SAAA,UAAe;;;;;AC7Gf;AAAA,0IAAAC,UAAAC,SAAA;AAAA,IAAAA,QAAA;AAAA,MACE,SAAW;AAAA,MACX,KAAO;AAAA,MACP,OAAS;AAAA,MACT,aAAe;AAAA,QACb,aAAe;AAAA,UACb,MAAQ;AAAA,UACR,UAAY;AAAA,UACZ,OAAS,EAAC,MAAQ,IAAG;AAAA,QACvB;AAAA,QACA,oBAAsB;AAAA,UACpB,MAAQ;AAAA,UACR,SAAW;AAAA,QACb;AAAA,QACA,4BAA8B;AAAA,UAC5B,OAAS,CAAC,EAAC,MAAQ,mCAAkC,GAAG,EAAC,SAAW,EAAC,CAAC;AAAA,QACxE;AAAA,QACA,aAAe;AAAA,UACb,MAAQ,CAAC,SAAS,WAAW,WAAW,QAAQ,UAAU,UAAU,QAAQ;AAAA,QAC9E;AAAA,QACA,aAAe;AAAA,UACb,MAAQ;AAAA,UACR,OAAS,EAAC,MAAQ,SAAQ;AAAA,UAC1B,aAAe;AAAA,UACf,SAAW,CAAC;AAAA,QACd;AAAA,MACF;AAAA,MACA,MAAQ,CAAC,UAAU,SAAS;AAAA,MAC5B,YAAc;AAAA,QACZ,KAAO;AAAA,UACL,MAAQ;AAAA,UACR,QAAU;AAAA,QACZ;AAAA,QACA,SAAW;AAAA,UACT,MAAQ;AAAA,UACR,QAAU;AAAA,QACZ;AAAA,QACA,MAAQ;AAAA,UACN,MAAQ;AAAA,UACR,QAAU;AAAA,QACZ;AAAA,QACA,UAAY;AAAA,UACV,MAAQ;AAAA,QACV;AAAA,QACA,OAAS;AAAA,UACP,MAAQ;AAAA,QACV;AAAA,QACA,aAAe;AAAA,UACb,MAAQ;AAAA,QACV;AAAA,QACA,SAAW;AAAA,QACX,UAAY;AAAA,UACV,MAAQ;AAAA,UACR,SAAW;AAAA,QACb;AAAA,QACA,UAAY;AAAA,UACV,MAAQ;AAAA,UACR,OAAS;AAAA,QACX;AAAA,QACA,YAAc;AAAA,UACZ,MAAQ;AAAA,UACR,kBAAoB;AAAA,QACtB;AAAA,QACA,SAAW;AAAA,UACT,MAAQ;AAAA,QACV;AAAA,QACA,kBAAoB;AAAA,UAClB,MAAQ;AAAA,QACV;AAAA,QACA,SAAW;AAAA,UACT,MAAQ;AAAA,QACV;AAAA,QACA,kBAAoB;AAAA,UAClB,MAAQ;AAAA,QACV;AAAA,QACA,WAAa,EAAC,MAAQ,mCAAkC;AAAA,QACxD,WAAa,EAAC,MAAQ,2CAA0C;AAAA,QAChE,SAAW;AAAA,UACT,MAAQ;AAAA,UACR,QAAU;AAAA,QACZ;AAAA,QACA,iBAAmB,EAAC,MAAQ,IAAG;AAAA,QAC/B,OAAS;AAAA,UACP,OAAS,CAAC,EAAC,MAAQ,IAAG,GAAG,EAAC,MAAQ,4BAA2B,CAAC;AAAA,UAC9D,SAAW;AAAA,QACb;AAAA,QACA,UAAY,EAAC,MAAQ,mCAAkC;AAAA,QACvD,UAAY,EAAC,MAAQ,2CAA0C;AAAA,QAC/D,aAAe;AAAA,UACb,MAAQ;AAAA,UACR,SAAW;AAAA,QACb;AAAA,QACA,UAAY,EAAC,MAAQ,IAAG;AAAA,QACxB,eAAiB,EAAC,MAAQ,mCAAkC;AAAA,QAC5D,eAAiB,EAAC,MAAQ,2CAA0C;AAAA,QACpE,UAAY,EAAC,MAAQ,4BAA2B;AAAA,QAChD,sBAAwB,EAAC,MAAQ,IAAG;AAAA,QACpC,aAAe;AAAA,UACb,MAAQ;AAAA,UACR,sBAAwB,EAAC,MAAQ,IAAG;AAAA,UACpC,SAAW,CAAC;AAAA,QACd;AAAA,QACA,YAAc;AAAA,UACZ,MAAQ;AAAA,UACR,sBAAwB,EAAC,MAAQ,IAAG;AAAA,UACpC,SAAW,CAAC;AAAA,QACd;AAAA,QACA,mBAAqB;AAAA,UACnB,MAAQ;AAAA,UACR,sBAAwB,EAAC,MAAQ,IAAG;AAAA,UACpC,eAAiB,EAAC,QAAU,QAAO;AAAA,UACnC,SAAW,CAAC;AAAA,QACd;AAAA,QACA,cAAgB;AAAA,UACd,MAAQ;AAAA,UACR,sBAAwB;AAAA,YACtB,OAAS,CAAC,EAAC,MAAQ,IAAG,GAAG,EAAC,MAAQ,4BAA2B,CAAC;AAAA,UAChE;AAAA,QACF;AAAA,QACA,eAAiB,EAAC,MAAQ,IAAG;AAAA,QAC7B,OAAS;AAAA,QACT,MAAQ;AAAA,UACN,MAAQ;AAAA,UACR,OAAS;AAAA,UACT,UAAY;AAAA,UACZ,aAAe;AAAA,QACjB;AAAA,QACA,MAAQ;AAAA,UACN,OAAS;AAAA,YACP,EAAC,MAAQ,4BAA2B;AAAA,YACpC;AAAA,cACE,MAAQ;AAAA,cACR,OAAS,EAAC,MAAQ,4BAA2B;AAAA,cAC7C,UAAY;AAAA,cACZ,aAAe;AAAA,YACjB;AAAA,UACF;AAAA,QACF;AAAA,QACA,QAAU,EAAC,MAAQ,SAAQ;AAAA,QAC3B,kBAAoB,EAAC,MAAQ,SAAQ;AAAA,QACrC,iBAAmB,EAAC,MAAQ,SAAQ;AAAA,QACpC,IAAM,EAAC,MAAQ,IAAG;AAAA,QAClB,MAAQ,EAAC,MAAQ,IAAG;AAAA,QACpB,MAAQ,EAAC,MAAQ,IAAG;AAAA,QACpB,OAAS,EAAC,MAAQ,4BAA2B;AAAA,QAC7C,OAAS,EAAC,MAAQ,4BAA2B;AAAA,QAC7C,OAAS,EAAC,MAAQ,4BAA2B;AAAA,QAC7C,KAAO,EAAC,MAAQ,IAAG;AAAA,MACrB;AAAA,MACA,SAAW;AAAA,IACb;AAAA;AAAA;;;;;;;;ACrJA,QAAA,SAAA;AACA,QAAA,WAAA;AACA,QAAA,kBAAA;AACA,QAAA,mBAAA;AAEA,QAAM,oBAAoB,CAAC,aAAa;AAExC,QAAM,iBAAiB;AAEvB,QAAM,MAAN,cAAkB,OAAA,QAAO;aAAA;;;MACvB,mBAAgB;AACd,cAAM,iBAAgB;AACtB,iBAAA,QAAmB,QAAQ,CAAC,MAAM,KAAK,cAAc,CAAC,CAAC;AACvD,YAAI,KAAK,KAAK;AAAe,eAAK,WAAW,gBAAA,OAAa;MAC5D;MAEA,wBAAqB;AACnB,cAAM,sBAAqB;AAC3B,YAAI,CAAC,KAAK,KAAK;AAAM;AACrB,cAAM,aAAa,KAAK,KAAK,QACzB,KAAK,gBAAgB,kBAAkB,iBAAiB,IACxD;AACJ,aAAK,cAAc,YAAY,gBAAgB,KAAK;AACpD,aAAK,KAAK,+BAA+B,IAAI;MAC/C;MAEA,cAAW;AACT,eAAQ,KAAK,KAAK,cAChB,MAAM,YAAW,MAAO,KAAK,UAAU,cAAc,IAAI,iBAAiB;MAC9E;;AAGF,IAAAC,QAAO,UAAUC,WAAU;AAC3B,WAAO,eAAeA,UAAS,cAAc,EAAC,OAAO,KAAI,CAAC;AAE1D,IAAAA,SAAA,UAAe;AA0Bf,QAAA,aAAA;AAAQ,WAAA,eAAAA,UAAA,cAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,WAAA;IAAU,EAAA,CAAA;AAIlB,QAAA,YAAA;AAAQ,WAAA,eAAAA,UAAA,KAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAC,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,OAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAG,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,aAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAS,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,OAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAG,EAAA,CAAA;AAAE,WAAA,eAAAA,UAAA,QAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAI,EAAA,CAAA;AAAQ,WAAA,eAAAA,UAAA,WAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,UAAA;IAAO,EAAA,CAAA;AACnD,QAAA,qBAAA;AAAQ,WAAA,eAAAA,UAAA,mBAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,mBAAA;IAAO,EAAA,CAAA;AACf,QAAA,cAAA;AAAQ,WAAA,eAAAA,UAAA,mBAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,YAAA;IAAO,EAAA,CAAA;;;;;ACpEf;AAAA,qHAAAC,UAAAC,SAAA;AAAA,IAAAA,QAAO,UAAW,WAAW;AAO3B,eAAS,aAAa,OAAO,QAAQ;AACnC,iBAAS,OAAO;AAAE,eAAK,cAAc;AAAA,QAAO;AAAnC;AACT,aAAK,YAAY,OAAO;AACxB,cAAM,YAAY,IAAI,KAAK;AAAA,MAC7B;AAJS;AAMT,eAAS,YAAY,SAAS,UAAU,OAAO,QAAQ,MAAM,QAAQ;AACnE,aAAK,UAAW;AAChB,aAAK,WAAW;AAChB,aAAK,QAAW;AAChB,aAAK,SAAW;AAChB,aAAK,OAAW;AAChB,aAAK,SAAW;AAEhB,aAAK,OAAW;AAAA,MAClB;AATS;AAWT,mBAAa,aAAa,KAAK;AAE/B,eAAS,MAAM,OAAO;AACpB,YAAI,UAAU,UAAU,SAAS,IAAI,UAAU,CAAC,IAAI,CAAC,GAEjD,aAAa,CAAC,GAEd,yBAAyB,EAAE,OAAO,eAAe,GACjD,wBAAyB,gBAEzB,SAAS,CAAC,GACV,SAAS,kCAAW;AAAE,iBAAO;AAAA,QAAM,GAA1B,WACT,SAAS,YACT,SAAS,KACT,SAAS,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC7D,SAAS,QACT,SAAS,EAAE,MAAM,OAAO,aAAa,gBAAgB,GACrD,SAAS,KACT,SAAS,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC7D,SAAS,KACT,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,gCAAS,MAAM;AAAE,kBAAQ,KAAK,cAAc,MAAM,MAAM,MAAM,CAAC;AAAA,QAAE,GAAjE,YACV,UAAU,gCAAS,MAAM;AAAE,kBAAQ,KAAK,aAAa,MAAM,MAAM,MAAM,CAAC;AAAA,QAAE,GAAhE,YACV,UAAU,gCAAS,OAAO,MAAM;AAAE,iBAAO,MAAM,OAAO,IAAI;AAAA,QAAE,GAAlD,YACV,UAAU,gCAAS,MAAM;AAAE,iBAAO,CAAC,IAAI;AAAA,QAAE,GAA/B,YACV,UAAU,gCAAS,MAAM;AAAE,iBAAO;AAAA,QAAK,GAA7B,YACV,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,gCAAS,KAAK,OAAO;AAAE,kBAAQ,KAAK,UAAU,OAAO,MAAM,QAAQ,GAAG,CAAC;AAAA,QAAE,GAAzE,YACV,UAAU,gCAAS,OAAO;AAAE,iBAAO,MAAM,KAAK,EAAE;AAAA,QAAE,GAAxC,YACV,UAAU,gCAASC,OAAM;AAAE,iBAAOA,MAAK;AAAA,QAAM,GAAnC,YACV,UAAU,OACV,UAAU,EAAE,MAAM,WAAW,OAAO,OAAU,aAAa,cAAmB,GAC9E,UAAU,MACV,UAAU,gCAAS,OAAO;AAAE,iBAAO,KAAK,UAAU,MAAM,KAAK,EAAE,GAAG,MAAM,MAAM;AAAA,QAAE,GAAtE,YACV,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAM,aAAa,QAAW,GAClE,UAAU,OACV,UAAU,EAAE,MAAM,WAAW,OAAO,OAAO,aAAa,QAAU,GAClE,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,gCAAS,MAAM;AAAE,iBAAO;AAAA,QAAK,GAA7B,YACV,UAAU,gCAAS,MAAM;AAAE,iBAAO;AAAA,QAAI,GAA5B,YACV,UAAU,MACV,UAAU,EAAE,MAAM,WAAW,OAAO,MAAM,aAAa,SAAW,GAClE,UAAU,kCAAW;AAAE,iBAAO;AAAA,QAAG,GAAvB,YACV,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,gCAAS,MAAM,OAAO;AAAE,iBAAO,KAAK,SAAS,WAAW,OAAO,MAAM,KAAK,GAAG,MAAM,MAAM;AAAA,QAAE,GAA3F,YACV,UAAU,gCAASC,OAAM;AAAE,iBAAO,KAAK,SAAS,WAAWA,KAAI,GAAG,MAAM,MAAM;AAAA,QAAE,GAAtE,YACV,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,gCAAS,QAAQ;AAAE,iBAAO,OAAO,KAAK,EAAE;AAAA,QAAE,GAA1C,YACV,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,gCAAS,QAAQ;AAAE,iBAAO,MAAM,OAAO,KAAK,EAAE;AAAA,QAAE,GAAhD,YACV,UAAU,gCAASA,OAAM;AAAE,iBAAO,KAAK,WAAW,SAASA,OAAM,EAAE,GAAG,MAAM,MAAM;AAAA,QAAE,GAA1E,YACV,UAAU,QACV,UAAU,EAAE,MAAM,WAAW,OAAO,QAAQ,aAAa,SAAW,GACpE,UAAU,kCAAW;AAAE,iBAAO,KAAK,WAAW,MAAM,MAAM,MAAM;AAAA,QAAE,GAAxD,YACV,UAAU,SACV,UAAU,EAAE,MAAM,WAAW,OAAO,SAAS,aAAa,UAAY,GACtE,UAAU,kCAAW;AAAE,iBAAO,KAAK,WAAW,OAAO,MAAM,MAAM;AAAA,QAAE,GAAzD,YACV,UAAU,kCAAW;AAAE,iBAAO,KAAK,SAAS,CAAC,GAAG,MAAM,MAAM;AAAA,QAAE,GAApD,YACV,UAAU,gCAAS,OAAO;AAAE,iBAAO,KAAK,SAAS,QAAQ,CAAC,KAAK,IAAI,CAAC,GAAG,MAAM,MAAM;AAAA,QAAE,GAA3E,YACV,UAAU,gCAAS,QAAQ;AAAE,iBAAO,KAAK,SAAS,QAAQ,MAAM,MAAM;AAAA,QAAE,GAA9D,YACV,UAAU,gCAAS,QAAQ,OAAO;AAAE,iBAAO,KAAK,SAAS,OAAO,OAAO,KAAK,GAAG,MAAM,MAAM;AAAA,QAAE,GAAnF,YACV,UAAU,gCAAS,OAAO;AAAE,iBAAO;AAAA,QAAM,GAA/B,YACV,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,gCAAS,QAAQ;AAAE,iBAAO,KAAK,eAAe,QAAQ,MAAM,MAAM;AAAA,QAAE,GAApE,YACV,UAAU,gCAAS,KAAK,OAAO;AAAE,iBAAO,KAAK,oBAAoB,OAAO,MAAM,QAAQ,GAAG;AAAA,QAAE,GAAjF,YACV,UAAU,gCAAS,QAAQ;AAAE,iBAAO,MAAM;AAAA,QAAO,GAAvC,YACV,UAAU,gCAAS,MAAM;AAAE,iBAAQ,KAAK,KAAK,EAAE;AAAA,QAAE,GAAvC,YACV,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,gCAAS,MAAM;AAAE,iBAAO,KAAK,KAAK,EAAE;AAAA,QAAE,GAAtC,YACV,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,gCAAS,MAAM,MAAM;AAAE,iBAAO,KAAK,QAAQ,oBAAI,KAAK,OAAO,MAAM,OAAO,GAAG,GAAG,MAAM,MAAM;AAAA,QAAE,GAA5F,YACV,UAAU,gCAAS,MAAM,MAAM;AAAE,iBAAO,KAAK,QAAQ,oBAAI,KAAK,OAAO,MAAM,IAAI,GAAG,MAAM,MAAM;AAAA,QAAE,GAAtF,YACV,UAAU,UACV,UAAU,EAAE,MAAM,SAAS,OAAO,UAAU,aAAa,SAAS,GAClE,UAAU,MACV,UAAU,EAAE,MAAM,WAAW,OAAO,MAAM,aAAa,QAAU,GACjE,UAAU,MACV,UAAU,EAAE,MAAM,WAAW,OAAO,MAAM,aAAa,QAAU,GACjE,UAAU,cACV,UAAU,EAAE,MAAM,SAAS,OAAO,aAAa,aAAa,YAAY,GACxE,UAAU,UACV,UAAU,EAAE,MAAM,SAAS,OAAO,SAAS,aAAa,QAAQ,GAChE,UAAU,KACV,UAAU,EAAE,MAAM,WAAW,OAAO,KAAK,aAAa,MAAQ,GAC9D,UAAU,kCAAW;AAAE,iBAAO;AAAA,QAAG,GAAvB,YACV,UAAU,mBACV,UAAU,EAAE,MAAM,SAAS,OAAO,mBAAmB,aAAa,kBAAkB,GACpF,UAAU,gCAAS,GAAG;AAAE,iBAAO,EAAE,KAAK,EAAE;AAAA,QAAE,GAAhC,YACV,UAAU,OACV,UAAU,EAAE,MAAM,WAAW,OAAO,OAAQ,aAAa,YAAe,GACxE,UAAU,kCAAW;AAAE,iBAAO;AAAA,QAAK,GAAzB,YACV,WAAW,QACX,WAAW,EAAE,MAAM,WAAW,OAAO,QAAQ,aAAa,aAAe,GACzE,WAAW,kCAAW;AAAE,iBAAO;AAAA,QAAK,GAAzB,aACX,WAAW,OACX,WAAW,EAAE,MAAM,WAAW,OAAO,OAAO,aAAa,UAAY,GACrE,WAAW,kCAAW;AAAE,iBAAO;AAAA,QAAK,GAAzB,aACX,WAAW,OACX,WAAW,EAAE,MAAM,WAAW,OAAO,OAAO,aAAa,UAAY,GACrE,WAAW,kCAAW;AAAE,iBAAO;AAAA,QAAK,GAAzB,aACX,WAAW,OACX,WAAW,EAAE,MAAM,WAAW,OAAO,OAAO,aAAa,UAAY,GACrE,WAAW,kCAAW;AAAE,iBAAO;AAAA,QAAK,GAAzB,aACX,WAAW,OACX,WAAW,EAAE,MAAM,WAAW,OAAO,OAAO,aAAa,UAAY,GACrE,WAAW,kCAAW;AAAE,iBAAO;AAAA,QAAK,GAAzB,aACX,WAAW,OACX,WAAW,EAAE,MAAM,WAAW,OAAO,OAAO,aAAa,UAAY,GACrE,WAAW,kCAAW;AAAE,iBAAO;AAAA,QAAK,GAAzB,aACX,WAAW,OACX,WAAW,EAAE,MAAM,WAAW,OAAO,OAAO,aAAa,UAAY,GACrE,WAAW,gCAAS,QAAQ;AAAE,iBAAO,iBAAiB,OAAO,KAAK,EAAE,CAAC;AAAA,QAAE,GAA5D,aACX,WAAW,OACX,WAAW,EAAE,MAAM,WAAW,OAAO,OAAO,aAAa,UAAY,GAErE,cAAuB,GACvB,kBAAuB,GACvB,gBAAuB,GACvB,uBAAuB,EAAE,MAAM,GAAG,QAAQ,GAAG,QAAQ,MAAM,GAC3D,iBAAuB,GACvB,sBAAuB,CAAC,GACxB,kBAAuB,GAEvB,YAAY,CAAC,GACb;AAEJ,YAAI,eAAe,SAAS;AAC1B,cAAI,EAAE,QAAQ,aAAa,yBAAyB;AAClD,kBAAM,IAAI,MAAM,oCAAqC,QAAQ,YAAY,IAAK;AAAA,UAChF;AAEA,kCAAwB,uBAAuB,QAAQ,SAAS;AAAA,QAClE;AAEA,iBAAS,OAAO;AACd,iBAAO,MAAM,UAAU,iBAAiB,WAAW;AAAA,QACrD;AAFS;AAIT,iBAAS,SAAS;AAChB,iBAAO;AAAA,QACT;AAFS;AAIT,iBAAS,OAAO;AACd,iBAAO,sBAAsB,eAAe,EAAE;AAAA,QAChD;AAFS;AAIT,iBAAS,SAAS;AAChB,iBAAO,sBAAsB,eAAe,EAAE;AAAA,QAChD;AAFS;AAIT,iBAAS,SAAS,aAAa;AAC7B,gBAAM;AAAA,YACJ;AAAA,YACA,CAAC,EAAE,MAAM,SAAS,YAAyB,CAAC;AAAA,YAC5C;AAAA,UACF;AAAA,QACF;AANS;AAQT,iBAAS,MAAM,SAAS;AACtB,gBAAM,mBAAmB,SAAS,MAAM,eAAe;AAAA,QACzD;AAFS;AAIT,iBAAS,sBAAsB,KAAK;AAClC,mBAAS,QAAQ,SAAS,UAAU,QAAQ;AAC1C,gBAAI,GAAG;AAEP,iBAAK,IAAI,UAAU,IAAI,QAAQ,KAAK;AAClC,mBAAK,MAAM,OAAO,CAAC;AACnB,kBAAI,OAAO,MAAM;AACf,oBAAI,CAAC,QAAQ,QAAQ;AAAE,0BAAQ;AAAA,gBAAQ;AACvC,wBAAQ,SAAS;AACjB,wBAAQ,SAAS;AAAA,cACnB,WAAW,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AAC5D,wBAAQ;AACR,wBAAQ,SAAS;AACjB,wBAAQ,SAAS;AAAA,cACnB,OAAO;AACL,wBAAQ;AACR,wBAAQ,SAAS;AAAA,cACnB;AAAA,YACF;AAAA,UACF;AAlBS;AAoBT,cAAI,kBAAkB,KAAK;AACzB,gBAAI,gBAAgB,KAAK;AACvB,8BAAgB;AAChB,qCAAuB,EAAE,MAAM,GAAG,QAAQ,GAAG,QAAQ,MAAM;AAAA,YAC7D;AACA,oBAAQ,sBAAsB,eAAe,GAAG;AAChD,4BAAgB;AAAA,UAClB;AAEA,iBAAO;AAAA,QACT;AA/BS;AAiCT,iBAAS,SAASC,WAAU;AAC1B,cAAI,cAAc,gBAAgB;AAAE;AAAA,UAAQ;AAE5C,cAAI,cAAc,gBAAgB;AAChC,6BAAiB;AACjB,kCAAsB,CAAC;AAAA,UACzB;AAEA,8BAAoB,KAAKA,SAAQ;AAAA,QACnC;AATS;AAWT,iBAAS,mBAAmB,SAASA,WAAU,KAAK;AAClD,mBAAS,gBAAgBA,WAAU;AACjC,gBAAI,IAAI;AAER,YAAAA,UAAS,KAAK,SAAS,GAAG,GAAG;AAC3B,kBAAI,EAAE,cAAc,EAAE,aAAa;AACjC,uBAAO;AAAA,cACT,WAAW,EAAE,cAAc,EAAE,aAAa;AACxC,uBAAO;AAAA,cACT,OAAO;AACL,uBAAO;AAAA,cACT;AAAA,YACF,CAAC;AAED,mBAAO,IAAIA,UAAS,QAAQ;AAC1B,kBAAIA,UAAS,IAAI,CAAC,MAAMA,UAAS,CAAC,GAAG;AACnC,gBAAAA,UAAS,OAAO,GAAG,CAAC;AAAA,cACtB,OAAO;AACL;AAAA,cACF;AAAA,YACF;AAAA,UACF;AApBS;AAsBT,mBAAS,aAAaA,WAAUC,QAAO;AACrC,qBAAS,aAAa,GAAG;AACvB,uBAAS,IAAI,IAAI;AAAE,uBAAO,GAAG,WAAW,CAAC,EAAE,SAAS,EAAE,EAAE,YAAY;AAAA,cAAG;AAA9D;AAET,qBAAO,EACJ,QAAQ,OAAS,MAAM,EACvB,QAAQ,MAAS,KAAK,EACtB,QAAQ,SAAS,KAAK,EACtB,QAAQ,OAAS,KAAK,EACtB,QAAQ,OAAS,KAAK,EACtB,QAAQ,OAAS,KAAK,EACtB,QAAQ,OAAS,KAAK,EACtB,QAAQ,4BAA4B,SAAS,IAAI;AAAE,uBAAO,SAAS,IAAI,EAAE;AAAA,cAAG,CAAC,EAC7E,QAAQ,yBAA4B,SAAS,IAAI;AAAE,uBAAO,QAAS,IAAI,EAAE;AAAA,cAAG,CAAC,EAC7E,QAAQ,oBAA4B,SAAS,IAAI;AAAE,uBAAO,SAAS,IAAI,EAAE;AAAA,cAAG,CAAC,EAC7E,QAAQ,oBAA4B,SAAS,IAAI;AAAE,uBAAO,QAAS,IAAI,EAAE;AAAA,cAAG,CAAC;AAAA,YAClF;AAfS;AAiBT,gBAAI,gBAAgB,IAAI,MAAMD,UAAS,MAAM,GACzC,cAAc,WAAW;AAE7B,iBAAK,IAAI,GAAG,IAAIA,UAAS,QAAQ,KAAK;AACpC,4BAAc,CAAC,IAAIA,UAAS,CAAC,EAAE;AAAA,YACjC;AAEA,2BAAeA,UAAS,SAAS,IAC7B,cAAc,MAAM,GAAG,EAAE,EAAE,KAAK,IAAI,IAChC,SACA,cAAcA,UAAS,SAAS,CAAC,IACrC,cAAc,CAAC;AAEnB,wBAAYC,SAAQ,MAAO,aAAaA,MAAK,IAAI,MAAO;AAExD,mBAAO,cAAc,eAAe,UAAU,YAAY;AAAA,UAC5D;AAlCS;AAoCT,cAAI,aAAa,sBAAsB,GAAG,GACtC,QAAa,MAAM,MAAM,SAAS,MAAM,OAAO,GAAG,IAAI;AAE1D,cAAID,cAAa,MAAM;AACrB,4BAAgBA,SAAQ;AAAA,UAC1B;AAEA,iBAAO,IAAI;AAAA,YACT,YAAY,OAAO,UAAU,aAAaA,WAAU,KAAK;AAAA,YACzDA;AAAA,YACA;AAAA,YACA;AAAA,YACA,WAAW;AAAA,YACX,WAAW;AAAA,UACb;AAAA,QACF;AA1ES;AA4ET,iBAAS,iBAAiB;AACxB,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,cAAc;AACnB,iBAAO,OAAO,YAAY;AACxB,eAAG,KAAK,EAAE;AACV,iBAAK,cAAc;AAAA,UACrB;AACA,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,OAAO;AAAA,UACd;AACA,eAAK;AAEL,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA3BS;AA6BT,iBAAS,gBAAgB;AACvB,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAE5B,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,WAAW;AAChB,iBAAO,OAAO,YAAY;AACxB,eAAG,KAAK,EAAE;AACV,iBAAK,WAAW;AAAA,UAClB;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,oBAAoB;AACzB,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,WAAW;AAChB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,WAAW;AAAA,cAClB;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC;AACN,qBAAK,iBAAiB;AACtB,uBAAO,OAAO,YAAY;AACxB,qBAAG,KAAK,EAAE;AACV,uBAAK,iBAAiB;AAAA,gBACxB;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK,CAAC;AACN,uBAAK,YAAY;AACjB,sBAAI,OAAO,YAAY;AACrB,2BAAO,OAAO,YAAY;AACxB,yBAAG,KAAK,EAAE;AACV,2BAAK,YAAY;AAAA,oBACnB;AAAA,kBACF,OAAO;AACL,yBAAK;AAAA,kBACP;AACA,sBAAI,OAAO,YAAY;AACrB,yBAAK,aAAa;AAAA,kBACpB;AACA,sBAAI,OAAO,YAAY;AACrB,yBAAK,CAAC,IAAI,IAAI,IAAI,IAAI,EAAE;AACxB,yBAAK;AAAA,kBACP,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,CAAC;AACN,iBAAK,WAAW;AAChB,gBAAI,OAAO,YAAY;AACrB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,WAAW;AAAA,cAClB;AAAA,YACF,OAAO;AACL,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,YAAY;AACjB,kBAAI,OAAO,YAAY;AACrB,uBAAO,OAAO,YAAY;AACxB,qBAAG,KAAK,EAAE;AACV,uBAAK,YAAY;AAAA,gBACnB;AAAA,cACF,OAAO;AACL,qBAAK;AAAA,cACP;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,aAAa;AAAA,cACpB;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC,IAAI,EAAE;AACZ,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,YAAY;AAAA,YACnB;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AApHS;AAsHT,iBAAS,sBAAsB;AAC7B,cAAI;AAEJ,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK,iBAAiB;AACtB,cAAI,OAAO,YAAY;AACrB,iBAAK,cAAc;AACnB,gBAAI,OAAO,YAAY;AACrB,mBAAK,oBAAoB;AACzB,kBAAI,OAAO,YAAY;AACrB,qBAAK,oBAAoB;AAAA,cAC3B;AAAA,YACF;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAzBS;AA2BT,iBAAS,mBAAmB;AAC1B,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAExB,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,MAAM;AAAA,YAAG;AAAA,UACjD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,CAAC;AACN,iBAAK;AACL,iBAAK;AACL;AACA,iBAAK,YAAY;AACjB,gBAAI,OAAO,YAAY;AACrB,mBAAK,aAAa;AAAA,YACpB;AACA;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK;AAAA,YACP,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,SAAS,aAAa;AAC9B,qBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,MAAM;AAAA,gBAAG;AAAA,cACjD;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC,IAAI,EAAE;AACZ,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AACA,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK;AACL,mBAAK;AACL;AACA,mBAAK,YAAY;AACjB,kBAAI,OAAO,YAAY;AACrB,qBAAK,aAAa;AAAA,cACpB;AACA;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AACA,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,SAAS,aAAa;AAC9B,uBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,MAAM;AAAA,kBAAG;AAAA,gBACjD;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK,CAAC,IAAI,EAAE;AACZ,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC,IAAI,EAAE;AACZ,mBAAK;AAAA,YACP,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAzGS;AA2GT,iBAAS,gBAAgB;AACvB,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAExB,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,MAAM;AAAA,YAAG;AAAA,UACjD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,CAAC;AACN,iBAAK,WAAW;AAChB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,WAAW;AAAA,YAClB;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,mBAAmB;AACxB,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC;AACN,qBAAK,WAAW;AAChB,uBAAO,OAAO,YAAY;AACxB,qBAAG,KAAK,EAAE;AACV,uBAAK,WAAW;AAAA,gBAClB;AACA,oBAAI,OAAO,YAAY;AACrB,sBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,yBAAK;AACL;AAAA,kBACF,OAAO;AACL,yBAAK;AACL,wBAAI,oBAAoB,GAAG;AAAE,+BAAS,OAAO;AAAA,oBAAG;AAAA,kBAClD;AACA,sBAAI,OAAO,YAAY;AACrB,sCAAkB;AAClB,yBAAK,QAAQ,EAAE;AACf,yBAAK;AAAA,kBACP,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAvES;AAyET,iBAAS,sBAAsB;AAC7B,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAEhC,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,MAAM;AAAA,YAAG;AAAA,UACjD;AACA,cAAI,OAAO,YAAY;AACrB,gBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,mBAAK;AACL;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,MAAM;AAAA,cAAG;AAAA,YACjD;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,WAAW;AAChB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,WAAW;AAAA,cAClB;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,mBAAmB;AACxB,oBAAI,OAAO,YAAY;AACrB,uBAAK,CAAC;AACN,uBAAK,WAAW;AAChB,yBAAO,OAAO,YAAY;AACxB,uBAAG,KAAK,EAAE;AACV,yBAAK,WAAW;AAAA,kBAClB;AACA,sBAAI,OAAO,YAAY;AACrB,wBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,2BAAK;AACL;AAAA,oBACF,OAAO;AACL,2BAAK;AACL,0BAAI,oBAAoB,GAAG;AAAE,iCAAS,OAAO;AAAA,sBAAG;AAAA,oBAClD;AACA,wBAAI,OAAO,YAAY;AACrB,0BAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,6BAAK;AACL;AAAA,sBACF,OAAO;AACL,6BAAK;AACL,4BAAI,oBAAoB,GAAG;AAAE,mCAAS,OAAO;AAAA,wBAAG;AAAA,sBAClD;AACA,0BAAI,OAAO,YAAY;AACrB,0CAAkB;AAClB,6BAAK,QAAQ,EAAE;AACf,6BAAK;AAAA,sBACP,OAAO;AACL,sCAAc;AACd,6BAAK;AAAA,sBACP;AAAA,oBACF,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA/FS;AAiGT,iBAAS,qBAAqB;AAC5B,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,kCAAkC;AACvC,cAAI,OAAO,YAAY;AACrB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,kCAAkC;AAAA,YACzC;AAAA,UACF,OAAO;AACL,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,wBAAwB;AAC7B,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ,IAAI,EAAE;AACnB,mBAAK;AAAA,YACP,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,wBAAwB;AAC7B,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ,EAAE;AAAA,YACjB;AACA,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAjDS;AAmDT,iBAAS,0BAA0B;AACjC,cAAI,IAAI,IAAI,IAAI,IAAI;AAEpB,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,WAAW;AAChB,iBAAO,OAAO,YAAY;AACxB,eAAG,KAAK,EAAE;AACV,iBAAK,WAAW;AAAA,UAClB;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,aAAa;AAClB,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,WAAW;AAChB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,WAAW;AAAA,cAClB;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ,EAAE;AACf,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,CAAC;AACN,iBAAK,WAAW;AAChB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,WAAW;AAAA,YAClB;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,oBAAoB;AACzB,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC;AACN,qBAAK,WAAW;AAChB,uBAAO,OAAO,YAAY;AACxB,qBAAG,KAAK,EAAE;AACV,uBAAK,WAAW;AAAA,gBAClB;AACA,oBAAI,OAAO,YAAY;AACrB,oCAAkB;AAClB,uBAAK,QAAQ,EAAE;AACf,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAjFS;AAmFT,iBAAS,oCAAoC;AAC3C,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAE5B,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,WAAW;AAChB,iBAAO,OAAO,YAAY;AACxB,eAAG,KAAK,EAAE;AACV,iBAAK,WAAW;AAAA,UAClB;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,aAAa;AAClB,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,WAAW;AAChB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,WAAW;AAAA,cAClB;AACA,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,uBAAK;AACL;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK,CAAC;AACN,uBAAK,WAAW;AAChB,yBAAO,OAAO,YAAY;AACxB,uBAAG,KAAK,EAAE;AACV,yBAAK,WAAW;AAAA,kBAClB;AACA,sBAAI,OAAO,YAAY;AACrB,sCAAkB;AAClB,yBAAK,QAAQ,EAAE;AACf,yBAAK;AAAA,kBACP,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,CAAC;AACN,iBAAK,WAAW;AAChB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,WAAW;AAAA,YAClB;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,oBAAoB;AACzB,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC;AACN,qBAAK,WAAW;AAChB,uBAAO,OAAO,YAAY;AACxB,qBAAG,KAAK,EAAE;AACV,uBAAK,WAAW;AAAA,gBAClB;AACA,oBAAI,OAAO,YAAY;AACrB,sBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,yBAAK;AACL;AAAA,kBACF,OAAO;AACL,yBAAK;AACL,wBAAI,oBAAoB,GAAG;AAAE,+BAAS,OAAO;AAAA,oBAAG;AAAA,kBAClD;AACA,sBAAI,OAAO,YAAY;AACrB,yBAAK,CAAC;AACN,yBAAK,WAAW;AAChB,2BAAO,OAAO,YAAY;AACxB,yBAAG,KAAK,EAAE;AACV,2BAAK,WAAW;AAAA,oBAClB;AACA,wBAAI,OAAO,YAAY;AACrB,wCAAkB;AAClB,2BAAK,QAAQ,EAAE;AACf,2BAAK;AAAA,oBACP,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA/HS;AAiIT,iBAAS,sBAAsB;AAC7B,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAExB,cAAI,MAAS,cAAc,KAAK,GAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,aAAa;AAClB,cAAI,OAAO,YAAY;AACrB,iBAAK,CAAC;AACN,iBAAK,WAAW;AAChB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,WAAW;AAAA,YAClB;AACA,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC;AACN,qBAAK,WAAW;AAChB,uBAAO,OAAO,YAAY;AACxB,qBAAG,KAAK,EAAE;AACV,uBAAK,WAAW;AAAA,gBAClB;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK,eAAe;AACpB,sBAAI,OAAO,YAAY;AACrB,sCAAkB;AAClB,yBAAK,QAAQ,IAAI,EAAE;AACnB,yBAAK;AAAA,kBACP,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,oBAAoB;AACzB,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,WAAW;AAChB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,WAAW;AAAA,cAClB;AACA,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,uBAAK;AACL;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK,CAAC;AACN,uBAAK,WAAW;AAChB,yBAAO,OAAO,YAAY;AACxB,uBAAG,KAAK,EAAE;AACV,yBAAK,WAAW;AAAA,kBAClB;AACA,sBAAI,OAAO,YAAY;AACrB,yBAAK,eAAe;AACpB,wBAAI,OAAO,YAAY;AACrB,wCAAkB;AAClB,2BAAK,QAAQ,IAAI,EAAE;AACnB,2BAAK;AAAA,oBACP,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AArHS;AAuHT,iBAAS,eAAe;AACtB,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,qBAAqB;AAC1B,cAAI,OAAO,YAAY;AACrB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,qBAAqB;AAAA,YAC5B;AAAA,UACF,OAAO;AACL,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,QAAQ,EAAE;AAAA,UACjB;AACA,eAAK;AAEL,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA/BS;AAiCT,iBAAS,sBAAsB;AAC7B,cAAI,IAAI;AAER,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,0CAA0C;AAC/C,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,QAAQ,EAAE;AAAA,UACjB;AACA,eAAK;AACL,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,0CAA0C;AAC/C,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ,EAAE;AAAA,YACjB;AACA,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA/BS;AAiCT,iBAAS,iBAAiB;AACxB,cAAI;AAEJ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK,gBAAgB;AACrB,cAAI,OAAO,YAAY;AACrB,iBAAK,kBAAkB;AACvB,gBAAI,OAAO,YAAY;AACrB,mBAAK,eAAe;AACpB,kBAAI,OAAO,YAAY;AACrB,qBAAK,iBAAiB;AACtB,oBAAI,OAAO,YAAY;AACrB,uBAAK,iBAAiB;AACtB,sBAAI,OAAO,YAAY;AACrB,yBAAK,eAAe;AACpB,wBAAI,OAAO,YAAY;AACrB,2BAAK,sBAAsB;AAAA,oBAC7B;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAlCS;AAoCT,iBAAS,kBAAkB;AACzB,cAAI;AAEJ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK,wCAAwC;AAC7C,cAAI,OAAO,YAAY;AACrB,iBAAK,0CAA0C;AAC/C,gBAAI,OAAO,YAAY;AACrB,mBAAK,wCAAwC;AAC7C,kBAAI,OAAO,YAAY;AACrB,qBAAK,0CAA0C;AAAA,cACjD;AAAA,YACF;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAzBS;AA2BT,iBAAS,0CAA0C;AACjD,cAAI,IAAI,IAAI,IAAI,IAAI;AAEpB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,OAAO,aAAa,CAAC,MAAM,SAAS;AAC5C,iBAAK;AACL,2BAAe;AAAA,UACjB,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,YAAY;AACjB,gBAAI,OAAO,YAAY;AACrB,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,+BAA+B;AACpC,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,+BAA+B;AAAA,cACtC;AACA,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,SAAS;AAC5C,uBAAK;AACL,iCAAe;AAAA,gBACjB,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA,oBAAI,OAAO,YAAY;AACrB,oCAAkB;AAClB,uBAAK,QAAQ,EAAE;AACf,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA/DS;AAiET,iBAAS,4CAA4C;AACnD,cAAI,IAAI,IAAI,IAAI;AAEhB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,CAAC;AACN,iBAAK,qBAAqB;AAC1B,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,qBAAqB;AAAA,YAC5B;AACA,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ,EAAE;AACf,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAtDS;AAwDT,iBAAS,0CAA0C;AACjD,cAAI,IAAI,IAAI,IAAI,IAAI;AAEpB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,OAAO,aAAa,CAAC,MAAM,SAAS;AAC5C,iBAAK;AACL,2BAAe;AAAA,UACjB,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,YAAY;AACjB,gBAAI,OAAO,YAAY;AACrB,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,gCAAgC;AACrC,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,gCAAgC;AAAA,cACvC;AACA,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,SAAS;AAC5C,uBAAK;AACL,iCAAe;AAAA,gBACjB,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA,oBAAI,OAAO,YAAY;AACrB,oCAAkB;AAClB,uBAAK,QAAQ,EAAE;AACf,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA/DS;AAiET,iBAAS,4CAA4C;AACnD,cAAI,IAAI,IAAI,IAAI;AAEhB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,CAAC;AACN,iBAAK,sBAAsB;AAC3B,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,sBAAsB;AAAA,YAC7B;AACA,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ,EAAE;AACf,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAtDS;AAwDT,iBAAS,uBAAuB;AAC9B,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK,iBAAiB;AACtB,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK;AACL;AACA,gBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,mBAAK;AACL;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,OAAO;AAAA,cAAG;AAAA,YAClD;AACA;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK;AAAA,YACP,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,SAAS,aAAa;AAC9B,qBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,MAAM;AAAA,gBAAG;AAAA,cACjD;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ,EAAE;AACf,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAvDS;AAyDT,iBAAS,wBAAwB;AAC/B,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK;AACL;AACA,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AAAA,UACP,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,gBAAI,MAAM,SAAS,aAAa;AAC9B,mBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,MAAM;AAAA,cAAG;AAAA,YACjD;AACA,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ,EAAE;AACf,mBAAK;AAAA,YACP,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AApDS;AAsDT,iBAAS,iCAAiC;AACxC,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK,iBAAiB;AACtB,cAAI,OAAO,YAAY;AACrB,iBAAK,gCAAgC;AACrC,gBAAI,OAAO,YAAY;AACrB,mBAAK;AACL,mBAAK;AACL;AACA,kBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,SAAS;AAC5C,qBAAK;AACL,+BAAe;AAAA,cACjB,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AACA,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,SAAS,aAAa;AAC9B,uBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,MAAM;AAAA,kBAAG;AAAA,gBACjD;AACA,oBAAI,OAAO,YAAY;AACrB,oCAAkB;AAClB,uBAAK,QAAQ,EAAE;AACf,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA1DS;AA4DT,iBAAS,kCAAkC;AACzC,cAAI,IAAI,IAAI,IAAI,IAAI;AAEpB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,YAAY;AACjB,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,aAAa;AAClB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,aAAa;AAAA,cACpB;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ;AACb,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAhDS;AAkDT,iBAAS,kCAAkC;AACzC,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK;AACL;AACA,cAAI,MAAM,OAAO,aAAa,CAAC,MAAM,SAAS;AAC5C,iBAAK;AACL,2BAAe;AAAA,UACjB,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AAAA,UACP,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,gBAAI,MAAM,SAAS,aAAa;AAC9B,mBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,MAAM;AAAA,cAAG;AAAA,YACjD;AACA,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ,EAAE;AACf,mBAAK;AAAA,YACP,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AApDS;AAsDT,iBAAS,iBAAiB;AACxB,cAAI,IAAI,IAAI,IAAI;AAEhB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,oBAAoB;AACzB,cAAI,OAAO,YAAY;AACrB,iBAAK,sBAAsB;AAAA,UAC7B;AACA,cAAI,OAAO,YAAY;AACrB,gBAAI,MAAM,WAAW,WAAW,MAAM,KAAK;AACzC,mBAAK;AACL;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,OAAO;AAAA,cAAG;AAAA,YAClD;AACA,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AAAA,YACF;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,sBAAsB;AAC3B,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ,IAAI,EAAE;AACnB,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,oBAAoB;AACzB,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ,EAAE;AAAA,YACjB;AACA,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAhES;AAkET,iBAAS,sBAAsB;AAC7B,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAExB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,gBAAgB;AACrB,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,gBAAgB;AACrB,oBAAI,OAAO,YAAY;AACrB,uBAAK,CAAC,IAAI,IAAI,EAAE;AAChB,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ,EAAE;AACf,mBAAK;AAAA,YACP,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,gBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,mBAAK;AACL;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,OAAO;AAAA,cAAG;AAAA,YAClD;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK;AACL,mBAAK,gBAAgB;AACrB,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,uBAAK;AACL;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK,gBAAgB;AACrB,sBAAI,OAAO,YAAY;AACrB,yBAAK,CAAC,IAAI,IAAI,EAAE;AAChB,yBAAK;AAAA,kBACP,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ,EAAE;AACf,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AApHS;AAsHT,iBAAS,mBAAmB;AAC1B,cAAI,IAAI;AAER,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,sBAAsB;AAC3B,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,QAAQ,EAAE;AAAA,UACjB;AACA,eAAK;AAEL,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAtBS;AAwBT,iBAAS,wBAAwB;AAC/B,cAAI,IAAI,IAAI,IAAI,IAAI;AAEpB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,CAAC;AACN,iBAAK,wBAAwB;AAC7B,gBAAI,OAAO,YAAY;AACrB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,wBAAwB;AAAA,cAC/B;AAAA,YACF,OAAO;AACL,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK;AACL;AACA,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ,EAAE;AACf,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,gBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,mBAAK;AACL;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,OAAO;AAAA,cAAG;AAAA,YAClD;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,wBAAwB;AAC7B,kBAAI,OAAO,YAAY;AACrB,uBAAO,OAAO,YAAY;AACxB,qBAAG,KAAK,EAAE;AACV,uBAAK,wBAAwB;AAAA,gBAC/B;AAAA,cACF,OAAO;AACL,qBAAK;AAAA,cACP;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK;AACL;AACA,oBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,uBAAK;AACL;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AACA,oBAAI,OAAO,YAAY;AACrB,oCAAkB;AAClB,uBAAK,QAAQ,EAAE;AACf,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA5HS;AA8HT,iBAAS,mBAAmB;AAC1B,cAAI,IAAI;AAER,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,OAAO,aAAa,CAAC,MAAM,SAAS;AAC5C,iBAAK;AACL,2BAAe;AAAA,UACjB,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,QAAQ;AAAA,UACf;AACA,eAAK;AACL,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,gBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,SAAS;AAC5C,mBAAK;AACL,6BAAe;AAAA,YACjB,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,OAAO;AAAA,cAAG;AAAA,YAClD;AACA,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ;AAAA,YACf;AACA,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA3CS;AA6CT,iBAAS,iBAAiB;AACxB,cAAI,IAAI,IAAI,IAAI,IAAI;AAEpB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,MAAM;AAAA,YAAG;AAAA,UACjD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,CAAC;AACN,iBAAK,mBAAmB;AACxB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,mBAAmB;AAAA,YAC1B;AACA,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ;AACb,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,gBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,mBAAK;AACL;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,MAAM;AAAA,cAAG;AAAA,YACjD;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,qBAAqB;AAC1B,kBAAI,OAAO,YAAY;AACrB,qBAAK;AAAA,cACP;AACA,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,uBAAK;AACL;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA,oBAAI,OAAO,YAAY;AACrB,oCAAkB;AAClB,uBAAK,QAAQ,EAAE;AACf,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK;AACL,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,MAAM;AAAA,gBAAG;AAAA,cACjD;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC;AACN,qBAAK,0BAA0B;AAC/B,oBAAI,OAAO,YAAY;AACrB,yBAAO,OAAO,YAAY;AACxB,uBAAG,KAAK,EAAE;AACV,yBAAK,0BAA0B;AAAA,kBACjC;AAAA,gBACF,OAAO;AACL,uBAAK;AAAA,gBACP;AACA,oBAAI,OAAO,YAAY;AACrB,sBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,yBAAK;AACL;AAAA,kBACF,OAAO;AACL,yBAAK;AACL,wBAAI,oBAAoB,GAAG;AAAE,+BAAS,OAAO;AAAA,oBAAG;AAAA,kBAClD;AACA,sBAAI,OAAO,YAAY;AACrB,sCAAkB;AAClB,yBAAK,QAAQ,EAAE;AACf,yBAAK;AAAA,kBACP,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK;AACL,oBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,uBAAK;AACL;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,MAAM;AAAA,kBAAG;AAAA,gBACjD;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK,CAAC;AACN,uBAAK,0BAA0B;AAC/B,sBAAI,OAAO,YAAY;AACrB,2BAAO,OAAO,YAAY;AACxB,yBAAG,KAAK,EAAE;AACV,2BAAK,0BAA0B;AAAA,oBACjC;AAAA,kBACF,OAAO;AACL,yBAAK;AAAA,kBACP;AACA,sBAAI,OAAO,YAAY;AACrB,yBAAK,qBAAqB;AAC1B,wBAAI,OAAO,YAAY;AACrB,0BAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,6BAAK;AACL;AAAA,sBACF,OAAO;AACL,6BAAK;AACL,4BAAI,oBAAoB,GAAG;AAAE,mCAAS,OAAO;AAAA,wBAAG;AAAA,sBAClD;AACA,0BAAI,OAAO,YAAY;AACrB,0CAAkB;AAClB,6BAAK,QAAQ,IAAI,EAAE;AACnB,6BAAK;AAAA,sBACP,OAAO;AACL,sCAAc;AACd,6BAAK;AAAA,sBACP;AAAA,oBACF,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA7LS;AA+LT,iBAAS,uBAAuB;AAC9B,cAAI,IAAI,IAAI,IAAI,IAAI;AAEpB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,mBAAmB;AACxB,iBAAO,OAAO,YAAY;AACxB,eAAG,KAAK,EAAE;AACV,iBAAK,mBAAmB;AAAA,UAC1B;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,eAAe;AACpB,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,mBAAmB;AACxB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,mBAAmB;AAAA,cAC1B;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,QAAQ,EAAE;AACf,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA/CS;AAiDT,iBAAS,4BAA4B;AACnC,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAE5B,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,mBAAmB;AACxB,iBAAO,OAAO,YAAY;AACxB,eAAG,KAAK,EAAE;AACV,iBAAK,mBAAmB;AAAA,UAC1B;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,eAAe;AACpB,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,mBAAmB;AACxB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,mBAAmB;AAAA,cAC1B;AACA,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,uBAAK;AACL;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK,CAAC;AACN,uBAAK,mBAAmB;AACxB,yBAAO,OAAO,YAAY;AACxB,uBAAG,KAAK,EAAE;AACV,yBAAK,mBAAmB;AAAA,kBAC1B;AACA,sBAAI,OAAO,YAAY;AACrB,sCAAkB;AAClB,yBAAK,QAAQ,EAAE;AACf,yBAAK;AAAA,kBACP,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAtES;AAwET,iBAAS,qBAAqB;AAC5B,cAAI;AAEJ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK,WAAW;AAChB,cAAI,OAAO,YAAY;AACrB,iBAAK,YAAY;AACjB,gBAAI,OAAO,YAAY;AACrB,mBAAK,iBAAiB;AAAA,YACxB;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAtBS;AAwBT,iBAAS,wBAAwB;AAC/B,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAExB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,KAAK;AACzC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,CAAC;AACN,iBAAK,WAAW;AAChB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,WAAW;AAAA,YAClB;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,iCAAiC;AACtC,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,iCAAiC;AAAA,cACxC;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC;AACN,qBAAK,WAAW;AAChB,uBAAO,OAAO,YAAY;AACxB,qBAAG,KAAK,EAAE;AACV,uBAAK,WAAW;AAAA,gBAClB;AACA,oBAAI,OAAO,YAAY;AACrB,sBAAI,MAAM,WAAW,WAAW,MAAM,KAAK;AACzC,yBAAK;AACL;AAAA,kBACF,OAAO;AACL,yBAAK;AACL,wBAAI,oBAAoB,GAAG;AAAE,+BAAS,OAAO;AAAA,oBAAG;AAAA,kBAClD;AACA,sBAAI,OAAO,YAAY;AACrB,sCAAkB;AAClB,yBAAK,QAAQ,EAAE;AACf,yBAAK;AAAA,kBACP,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA5ES;AA8ET,iBAAS,mCAAmC;AAC1C,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAE5C,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,WAAW;AAChB,iBAAO,OAAO,YAAY;AACxB,eAAG,KAAK,EAAE;AACV,iBAAK,WAAW;AAAA,UAClB;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,aAAa;AAClB,gBAAI,OAAO,YAAY;AACrB,mBAAK,CAAC;AACN,mBAAK,WAAW;AAChB,qBAAO,OAAO,YAAY;AACxB,mBAAG,KAAK,EAAE;AACV,qBAAK,WAAW;AAAA,cAClB;AACA,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,uBAAK;AACL;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA,oBAAI,OAAO,YAAY;AACrB,uBAAK,CAAC;AACN,uBAAK,WAAW;AAChB,yBAAO,OAAO,YAAY;AACxB,uBAAG,KAAK,EAAE;AACV,yBAAK,WAAW;AAAA,kBAClB;AACA,sBAAI,OAAO,YAAY;AACrB,yBAAK,eAAe;AACpB,wBAAI,OAAO,YAAY;AACrB,2BAAK,CAAC;AACN,2BAAK,WAAW;AAChB,6BAAO,OAAO,YAAY;AACxB,2BAAG,KAAK,EAAE;AACV,6BAAK,WAAW;AAAA,sBAClB;AACA,0BAAI,OAAO,YAAY;AACrB,4BAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,+BAAK;AACL;AAAA,wBACF,OAAO;AACL,+BAAK;AACL,8BAAI,oBAAoB,GAAG;AAAE,qCAAS,OAAO;AAAA,0BAAG;AAAA,wBAClD;AACA,4BAAI,OAAO,YAAY;AACrB,+BAAK,CAAC;AACN,gCAAM,WAAW;AACjB,iCAAO,QAAQ,YAAY;AACzB,+BAAG,KAAK,GAAG;AACX,kCAAM,WAAW;AAAA,0BACnB;AACA,8BAAI,OAAO,YAAY;AACrB,8CAAkB;AAClB,iCAAK,QAAQ,IAAI,EAAE;AACnB,iCAAK;AAAA,0BACP,OAAO;AACL,0CAAc;AACd,iCAAK;AAAA,0BACP;AAAA,wBACF,OAAO;AACL,wCAAc;AACd,+BAAK;AAAA,wBACP;AAAA,sBACF,OAAO;AACL,sCAAc;AACd,6BAAK;AAAA,sBACP;AAAA,oBACF,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,CAAC;AACN,iBAAK,WAAW;AAChB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,WAAW;AAAA,YAClB;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,aAAa;AAClB,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC;AACN,qBAAK,WAAW;AAChB,uBAAO,OAAO,YAAY;AACxB,qBAAG,KAAK,EAAE;AACV,uBAAK,WAAW;AAAA,gBAClB;AACA,oBAAI,OAAO,YAAY;AACrB,sBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,yBAAK;AACL;AAAA,kBACF,OAAO;AACL,yBAAK;AACL,wBAAI,oBAAoB,GAAG;AAAE,+BAAS,OAAO;AAAA,oBAAG;AAAA,kBAClD;AACA,sBAAI,OAAO,YAAY;AACrB,yBAAK,CAAC;AACN,yBAAK,WAAW;AAChB,2BAAO,OAAO,YAAY;AACxB,yBAAG,KAAK,EAAE;AACV,2BAAK,WAAW;AAAA,oBAClB;AACA,wBAAI,OAAO,YAAY;AACrB,2BAAK,eAAe;AACpB,0BAAI,OAAO,YAAY;AACrB,0CAAkB;AAClB,6BAAK,QAAQ,IAAI,EAAE;AACnB,6BAAK;AAAA,sBACP,OAAO;AACL,sCAAc;AACd,6BAAK;AAAA,sBACP;AAAA,oBACF,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA7KS;AA+KT,iBAAS,uBAAuB;AAC9B,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK,gBAAgB;AACrB,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ,EAAE;AACf,mBAAK;AAAA,YACP,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AArCS;AAuCT,iBAAS,gBAAgB;AACvB,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK;AAEjD,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK;AACL,eAAK,wBAAwB;AAC7B,cAAI,OAAO,YAAY;AACrB,iBAAK,wBAAwB;AAC7B,gBAAI,OAAO,YAAY;AACrB,mBAAK,wBAAwB;AAC7B,kBAAI,OAAO,YAAY;AACrB,qBAAK,wBAAwB;AAC7B,oBAAI,OAAO,YAAY;AACrB,sBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,yBAAK;AACL;AAAA,kBACF,OAAO;AACL,yBAAK;AACL,wBAAI,oBAAoB,GAAG;AAAE,+BAAS,OAAO;AAAA,oBAAG;AAAA,kBAClD;AACA,sBAAI,OAAO,YAAY;AACrB,yBAAK,wBAAwB;AAC7B,wBAAI,OAAO,YAAY;AACrB,2BAAK,wBAAwB;AAC7B,0BAAI,OAAO,YAAY;AACrB,4BAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,+BAAK;AACL;AAAA,wBACF,OAAO;AACL,+BAAK;AACL,8BAAI,oBAAoB,GAAG;AAAE,qCAAS,OAAO;AAAA,0BAAG;AAAA,wBAClD;AACA,4BAAI,OAAO,YAAY;AACrB,gCAAM,wBAAwB;AAC9B,8BAAI,QAAQ,YAAY;AACtB,kCAAM,wBAAwB;AAC9B,gCAAI,QAAQ,YAAY;AACtB,mCAAK,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,GAAG;AAC9C,mCAAK;AAAA,4BACP,OAAO;AACL,4CAAc;AACd,mCAAK;AAAA,4BACP;AAAA,0BACF,OAAO;AACL,0CAAc;AACd,iCAAK;AAAA,0BACP;AAAA,wBACF,OAAO;AACL,wCAAc;AACd,+BAAK;AAAA,wBACP;AAAA,sBACF,OAAO;AACL,sCAAc;AACd,6BAAK;AAAA,sBACP;AAAA,oBACF,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,QAAQ,EAAE;AAAA,UACjB;AACA,eAAK;AAEL,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAhGS;AAkGT,iBAAS,gBAAgB;AACvB,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAE5C,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK;AACL,eAAK,wBAAwB;AAC7B,cAAI,OAAO,YAAY;AACrB,iBAAK,wBAAwB;AAC7B,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,wBAAwB;AAC7B,oBAAI,OAAO,YAAY;AACrB,uBAAK,wBAAwB;AAC7B,sBAAI,OAAO,YAAY;AACrB,wBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,2BAAK;AACL;AAAA,oBACF,OAAO;AACL,2BAAK;AACL,0BAAI,oBAAoB,GAAG;AAAE,iCAAS,OAAO;AAAA,sBAAG;AAAA,oBAClD;AACA,wBAAI,OAAO,YAAY;AACrB,2BAAK,wBAAwB;AAC7B,0BAAI,OAAO,YAAY;AACrB,6BAAK,wBAAwB;AAC7B,4BAAI,OAAO,YAAY;AACrB,gCAAM,qBAAqB;AAC3B,8BAAI,QAAQ,YAAY;AACtB,kCAAM;AAAA,0BACR;AACA,8BAAI,QAAQ,YAAY;AACtB,iCAAK,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG;AACzC,iCAAK;AAAA,0BACP,OAAO;AACL,0CAAc;AACd,iCAAK;AAAA,0BACP;AAAA,wBACF,OAAO;AACL,wCAAc;AACd,+BAAK;AAAA,wBACP;AAAA,sBACF,OAAO;AACL,sCAAc;AACd,6BAAK;AAAA,sBACP;AAAA,oBACF,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,QAAQ,EAAE;AAAA,UACjB;AACA,eAAK;AAEL,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA7FS;AA+FT,iBAAS,4BAA4B;AACnC,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK;AAE1E,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK;AACL,eAAK,wBAAwB;AAC7B,cAAI,OAAO,YAAY;AACrB,iBAAK,wBAAwB;AAC7B,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,wBAAwB;AAC7B,oBAAI,OAAO,YAAY;AACrB,uBAAK,wBAAwB;AAC7B,sBAAI,OAAO,YAAY;AACrB,wBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,2BAAK;AACL;AAAA,oBACF,OAAO;AACL,2BAAK;AACL,0BAAI,oBAAoB,GAAG;AAAE,iCAAS,OAAO;AAAA,sBAAG;AAAA,oBAClD;AACA,wBAAI,OAAO,YAAY;AACrB,2BAAK,wBAAwB;AAC7B,0BAAI,OAAO,YAAY;AACrB,6BAAK,wBAAwB;AAC7B,4BAAI,OAAO,YAAY;AACrB,gCAAM,qBAAqB;AAC3B,8BAAI,QAAQ,YAAY;AACtB,kCAAM;AAAA,0BACR;AACA,8BAAI,QAAQ,YAAY;AACtB,gCAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,oCAAM;AACN;AAAA,4BACF,OAAO;AACL,oCAAM;AACN,kCAAI,oBAAoB,GAAG;AAAE,yCAAS,OAAO;AAAA,8BAAG;AAAA,4BAClD;AACA,gCAAI,QAAQ,YAAY;AACtB,kCAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,sCAAM;AACN;AAAA,8BACF,OAAO;AACL,sCAAM;AACN,oCAAI,oBAAoB,GAAG;AAAE,2CAAS,OAAO;AAAA,gCAAG;AAAA,8BAClD;AAAA,4BACF;AACA,gCAAI,QAAQ,YAAY;AACtB,oCAAM,wBAAwB;AAC9B,kCAAI,QAAQ,YAAY;AACtB,sCAAM,wBAAwB;AAC9B,oCAAI,QAAQ,YAAY;AACtB,sCAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,0CAAM;AACN;AAAA,kCACF,OAAO;AACL,0CAAM;AACN,wCAAI,oBAAoB,GAAG;AAAE,+CAAS,OAAO;AAAA,oCAAG;AAAA,kCAClD;AACA,sCAAI,QAAQ,YAAY;AACtB,0CAAM,wBAAwB;AAC9B,wCAAI,QAAQ,YAAY;AACtB,4CAAM,wBAAwB;AAC9B,0CAAI,QAAQ,YAAY;AACtB,6CAAK,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;AACvE,6CAAK;AAAA,sCACP,OAAO;AACL,sDAAc;AACd,6CAAK;AAAA,sCACP;AAAA,oCACF,OAAO;AACL,oDAAc;AACd,2CAAK;AAAA,oCACP;AAAA,kCACF,OAAO;AACL,kDAAc;AACd,yCAAK;AAAA,kCACP;AAAA,gCACF,OAAO;AACL,gDAAc;AACd,uCAAK;AAAA,gCACP;AAAA,8BACF,OAAO;AACL,8CAAc;AACd,qCAAK;AAAA,8BACP;AAAA,4BACF,OAAO;AACL,4CAAc;AACd,mCAAK;AAAA,4BACP;AAAA,0BACF,OAAO;AACL,0CAAc;AACd,iCAAK;AAAA,0BACP;AAAA,wBACF,OAAO;AACL,wCAAc;AACd,+BAAK;AAAA,wBACP;AAAA,sBACF,OAAO;AACL,sCAAc;AACd,6BAAK;AAAA,sBACP;AAAA,oBACF,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,QAAQ,EAAE;AAAA,UACjB;AACA,eAAK;AAEL,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAtJS;AAwJT,iBAAS,oBAAoB;AAC3B,cAAI,IAAI,IAAI,IAAI,IAAI;AAEpB,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,cAAc;AACnB,cAAI,OAAO,YAAY;AACrB,gBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,mBAAK;AACL;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,OAAO;AAAA,cAAG;AAAA,YAClD;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK,cAAc;AACnB,kBAAI,OAAO,YAAY;AACrB,oBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,uBAAK;AACL;AAAA,gBACF,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,OAAO;AAAA,kBAAG;AAAA,gBAClD;AACA,oBAAI,OAAO,YAAY;AACrB,oCAAkB;AAClB,uBAAK,QAAQ,IAAI,EAAE;AACnB,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,cAAc;AACnB,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,0BAA0B;AAC/B,oBAAI,OAAO,YAAY;AACrB,oCAAkB;AAClB,uBAAK,QAAQ,IAAI,EAAE;AACnB,uBAAK;AAAA,gBACP,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AArFS;AAuFT,iBAAS,aAAa;AACpB,cAAI;AAEJ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,cAAI,QAAQ,KAAK,MAAM,OAAO,WAAW,CAAC,GAAG;AAC3C,iBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAtBS;AAwBT,iBAAS,cAAc;AACrB,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,cAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,iBAAK;AACL;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,gBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,mBAAK;AACL;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,OAAO;AAAA,cAAG;AAAA,YAClD;AACA,gBAAI,OAAO,YAAY;AACrB,kBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,qBAAK;AACL;AAAA,cACF,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,OAAO;AAAA,gBAAG;AAAA,cAClD;AACA,kBAAI,OAAO,YAAY;AACrB,qBAAK,CAAC,IAAI,EAAE;AACZ,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAnDS;AAqDT,iBAAS,eAAe;AACtB,cAAI;AAEJ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK,YAAY;AACjB,cAAI,OAAO,YAAY;AACrB,iBAAK,WAAW;AAAA,UAClB;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAnBS;AAqBT,iBAAS,eAAe;AACtB,cAAI,IAAI;AAER,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL;AACA,cAAI,MAAM,SAAS,aAAa;AAC9B,iBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,MAAM;AAAA,YAAG;AAAA,UACjD;AACA;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AAAA,UACP,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA/BS;AAiCT,iBAAS,eAAe;AACtB,cAAI;AAEJ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,cAAI,QAAQ,KAAK,MAAM,OAAO,WAAW,CAAC,GAAG;AAC3C,iBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAtBS;AAwBT,iBAAS,0BAA0B;AACjC,cAAI,IAAI;AAER,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,cAAI,QAAQ,KAAK,MAAM,OAAO,WAAW,CAAC,GAAG;AAC3C,iBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,gBAAI,MAAM,WAAW,WAAW,MAAM,IAAI;AACxC,mBAAK;AACL;AAAA,YACF,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,OAAO;AAAA,cAAG;AAAA,YAClD;AACA,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,QAAQ;AAAA,YACf;AACA,iBAAK;AAAA,UACP;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AArCS;AAuCT,iBAAS,uBAAuB;AAC9B,cAAI;AAEJ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,cAAI,QAAQ,KAAK,MAAM,OAAO,WAAW,CAAC,GAAG;AAC3C,iBAAK,MAAM,OAAO,WAAW;AAC7B;AAAA,UACF,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAtBS;AAwBT,iBAAS,kBAAkB;AACzB,cAAI,IAAI,IAAI;AAEZ,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,eAAK,CAAC;AACN,eAAK,wBAAwB;AAC7B,cAAI,OAAO,YAAY;AACrB,mBAAO,OAAO,YAAY;AACxB,iBAAG,KAAK,EAAE;AACV,mBAAK,wBAAwB;AAAA,YAC/B;AAAA,UACF,OAAO;AACL,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,QAAQ,EAAE;AAAA,UACjB;AACA,eAAK;AAEL,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AA/BS;AAiCT,iBAAS,mBAAmB;AAC1B,cAAI,IAAI;AAER,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,OAAO,aAAa,CAAC,MAAM,SAAS;AAC5C,iBAAK;AACL,2BAAe;AAAA,UACjB,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,OAAO;AAAA,YAAG;AAAA,UAClD;AACA,cAAI,OAAO,YAAY;AACrB,8BAAkB;AAClB,iBAAK,QAAQ;AAAA,UACf;AACA,eAAK;AACL,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,gBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,UAAU;AAC7C,mBAAK;AACL,6BAAe;AAAA,YACjB,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,QAAQ;AAAA,cAAG;AAAA,YACnD;AACA,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,SAAS;AAAA,YAChB;AACA,iBAAK;AACL,gBAAI,OAAO,YAAY;AACrB,mBAAK;AACL,kBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,UAAU;AAC7C,qBAAK;AACL,+BAAe;AAAA,cACjB,OAAO;AACL,qBAAK;AACL,oBAAI,oBAAoB,GAAG;AAAE,2BAAS,QAAQ;AAAA,gBAAG;AAAA,cACnD;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,SAAS;AAAA,cAChB;AACA,mBAAK;AACL,kBAAI,OAAO,YAAY;AACrB,qBAAK;AACL,oBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,UAAU;AAC7C,uBAAK;AACL,iCAAe;AAAA,gBACjB,OAAO;AACL,uBAAK;AACL,sBAAI,oBAAoB,GAAG;AAAE,6BAAS,QAAQ;AAAA,kBAAG;AAAA,gBACnD;AACA,oBAAI,OAAO,YAAY;AACrB,oCAAkB;AAClB,uBAAK,SAAS;AAAA,gBAChB;AACA,qBAAK;AACL,oBAAI,OAAO,YAAY;AACrB,uBAAK;AACL,sBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,UAAU;AAC7C,yBAAK;AACL,mCAAe;AAAA,kBACjB,OAAO;AACL,yBAAK;AACL,wBAAI,oBAAoB,GAAG;AAAE,+BAAS,QAAQ;AAAA,oBAAG;AAAA,kBACnD;AACA,sBAAI,OAAO,YAAY;AACrB,sCAAkB;AAClB,yBAAK,SAAS;AAAA,kBAChB;AACA,uBAAK;AACL,sBAAI,OAAO,YAAY;AACrB,yBAAK;AACL,wBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,UAAU;AAC7C,2BAAK;AACL,qCAAe;AAAA,oBACjB,OAAO;AACL,2BAAK;AACL,0BAAI,oBAAoB,GAAG;AAAE,iCAAS,QAAQ;AAAA,sBAAG;AAAA,oBACnD;AACA,wBAAI,OAAO,YAAY;AACrB,wCAAkB;AAClB,2BAAK,SAAS;AAAA,oBAChB;AACA,yBAAK;AACL,wBAAI,OAAO,YAAY;AACrB,2BAAK;AACL,0BAAI,MAAM,OAAO,aAAa,CAAC,MAAM,UAAU;AAC7C,6BAAK;AACL,uCAAe;AAAA,sBACjB,OAAO;AACL,6BAAK;AACL,4BAAI,oBAAoB,GAAG;AAAE,mCAAS,QAAQ;AAAA,wBAAG;AAAA,sBACnD;AACA,0BAAI,OAAO,YAAY;AACrB,0CAAkB;AAClB,6BAAK,SAAS;AAAA,sBAChB;AACA,2BAAK;AACL,0BAAI,OAAO,YAAY;AACrB,6BAAK,yBAAyB;AAAA,sBAChC;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAzHS;AA2HT,iBAAS,2BAA2B;AAClC,cAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAE5C,cAAI,MAAS,cAAc,KAAK,IAC5B,SAAS,UAAU,GAAG;AAE1B,cAAI,QAAQ;AACV,0BAAc,OAAO;AACrB,mBAAO,OAAO;AAAA,UAChB;AAEA,eAAK;AACL,cAAI,MAAM,OAAO,aAAa,CAAC,MAAM,UAAU;AAC7C,iBAAK;AACL,2BAAe;AAAA,UACjB,OAAO;AACL,iBAAK;AACL,gBAAI,oBAAoB,GAAG;AAAE,uBAAS,QAAQ;AAAA,YAAG;AAAA,UACnD;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,iBAAK,aAAa;AAClB,gBAAI,OAAO,YAAY;AACrB,mBAAK,aAAa;AAClB,kBAAI,OAAO,YAAY;AACrB,qBAAK,aAAa;AAClB,oBAAI,OAAO,YAAY;AACrB,uBAAK,aAAa;AAClB,sBAAI,OAAO,YAAY;AACrB,yBAAK,aAAa;AAClB,wBAAI,OAAO,YAAY;AACrB,2BAAK,aAAa;AAClB,0BAAI,OAAO,YAAY;AACrB,6BAAK,aAAa;AAClB,4BAAI,OAAO,YAAY;AACrB,gCAAM,aAAa;AACnB,8BAAI,QAAQ,YAAY;AACtB,iCAAK,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG;AACrC,iCAAK;AAAA,0BACP,OAAO;AACL,0CAAc;AACd,iCAAK;AAAA,0BACP;AAAA,wBACF,OAAO;AACL,wCAAc;AACd,+BAAK;AAAA,wBACP;AAAA,sBACF,OAAO;AACL,sCAAc;AACd,6BAAK;AAAA,sBACP;AAAA,oBACF,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AACA,gBAAI,OAAO,YAAY;AACrB,gCAAkB;AAClB,mBAAK,SAAS,EAAE;AAChB,mBAAK;AAAA,YACP,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF,OAAO;AACL,0BAAc;AACd,iBAAK;AAAA,UACP;AACA,cAAI,OAAO,YAAY;AACrB,iBAAK;AACL,gBAAI,MAAM,OAAO,aAAa,CAAC,MAAM,UAAU;AAC7C,mBAAK;AACL,6BAAe;AAAA,YACjB,OAAO;AACL,mBAAK;AACL,kBAAI,oBAAoB,GAAG;AAAE,yBAAS,QAAQ;AAAA,cAAG;AAAA,YACnD;AACA,gBAAI,OAAO,YAAY;AACrB,mBAAK;AACL,mBAAK,aAAa;AAClB,kBAAI,OAAO,YAAY;AACrB,qBAAK,aAAa;AAClB,oBAAI,OAAO,YAAY;AACrB,uBAAK,aAAa;AAClB,sBAAI,OAAO,YAAY;AACrB,yBAAK,aAAa;AAClB,wBAAI,OAAO,YAAY;AACrB,2BAAK,CAAC,IAAI,IAAI,IAAI,EAAE;AACpB,2BAAK;AAAA,oBACP,OAAO;AACL,oCAAc;AACd,2BAAK;AAAA,oBACP;AAAA,kBACF,OAAO;AACL,kCAAc;AACd,yBAAK;AAAA,kBACP;AAAA,gBACF,OAAO;AACL,gCAAc;AACd,uBAAK;AAAA,gBACP;AAAA,cACF,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AACA,kBAAI,OAAO,YAAY;AACrB,kCAAkB;AAClB,qBAAK,SAAS,EAAE;AAChB,qBAAK;AAAA,cACP,OAAO;AACL,8BAAc;AACd,qBAAK;AAAA,cACP;AAAA,YACF,OAAO;AACL,4BAAc;AACd,mBAAK;AAAA,YACP;AAAA,UACF;AAEA,oBAAU,GAAG,IAAI,EAAE,SAAS,aAAa,QAAQ,GAAG;AAEpD,iBAAO;AAAA,QACT;AAzIS;AA4IP,YAAI,QAAQ,CAAC;AAEb,iBAAS,SAAS,KAAKE,OAAM,KAAK;AAChC,cAAI,KAAK,IAAI,MAAM,GAAG;AACtB,aAAG,OAAOA;AACV,aAAG,SAAS;AACZ,gBAAM;AAAA,QACR;AALS;AAOT,iBAAS,QAAQJ,OAAM;AACrB,gBAAM,KAAKA,KAAI;AAAA,QACjB;AAFS;AAIT,iBAAS,KAAK,MAAM,OAAOI,OAAMC,SAAQ,KAAK;AAC5C,cAAI,MAAM,EAAE,MAAY,OAAc,MAAMD,MAAK,GAAG,QAAQC,QAAO,EAAE;AACrE,cAAI;AAAK,gBAAI,MAAM;AACnB,iBAAO;AAAA,QACT;AAJS;AAMT,iBAAS,iBAAiB,KAAKD,OAAM,KAAK;AACxC,cAAI,MAAM,SAAS,OAAO,GAAG;AAE7B,cACE,CAAC,SAAS,GAAG,KACb,KAAK,MAAM,GAAG,KAAK,OACnB,MAAM,KACN,MAAM,WACL,MAAM,SAAU,MAAM,OACvB;AACA,qBAAS,kCAAkC,KAAKA,OAAM,GAAG;AAAA,UAC3D,OAAO;AACL,mBAAO,cAAc,GAAG;AAAA,UAC1B;AAAA,QACF;AAdS;AAgBT,iBAAS,gBAAgB;AACvB,cAAI,WAAW;AACf,cAAI,YAAY,CAAC;AACjB,cAAI;AACJ,cAAI;AACJ,cAAI,QAAQ;AACZ,cAAI,SAAS,UAAU;AACvB,cAAI,CAAC,QAAQ;AACX,mBAAO;AAAA,UACT;AACA,cAAI,SAAS;AACb,iBAAO,EAAE,QAAQ,QAAQ;AACvB,gBAAI,YAAY,OAAO,UAAU,KAAK,CAAC;AACvC,gBAAI,aAAa,OAAQ;AACvB,wBAAU,KAAK,SAAS;AAAA,YAC1B,OAAO;AAEL,2BAAa;AACb,+BAAiB,aAAa,MAAM;AACpC,6BAAgB,YAAY,OAAS;AACrC,wBAAU,KAAK,eAAe,YAAY;AAAA,YAC5C;AACA,gBAAI,QAAQ,KAAK,UAAU,UAAU,SAAS,UAAU;AACtD,wBAAU,OAAO,aAAa,MAAM,MAAM,SAAS;AACnD,wBAAU,SAAS;AAAA,YACrB;AAAA,UACF;AACA,iBAAO;AAAA,QACT;AA5BS;AA+BX,qBAAa,sBAAsB;AAEnC,YAAI,eAAe,cAAc,gBAAgB,MAAM,QAAQ;AAC7D,iBAAO;AAAA,QACT,OAAO;AACL,cAAI,eAAe,cAAc,cAAc,MAAM,QAAQ;AAC3D,qBAAS,EAAE,MAAM,OAAO,aAAa,eAAe,CAAC;AAAA,UACvD;AAEA,gBAAM,mBAAmB,MAAM,qBAAqB,cAAc;AAAA,QACpE;AAAA,MACF;AAhuHS;AAkuHT,aAAO;AAAA,QACL;AAAA,QACA;AAAA,MACF;AAAA,IACF,EAAG;AAAA;AAAA;;;AChwHH;AAAA,uHAAAE,UAAAC,SAAA;AAAA;AACA,aAAS,QAAQ,OAAO;AACtB,UAAI,gBAAgB,CAAC;AACrB,UAAI,mBAAmB,CAAC;AACxB,UAAI,cAAc;AAClB,UAAI,OAAO,uBAAO,OAAO,IAAI;AAC7B,UAAI,UAAU;AACd,UAAI,YAAY;AAEhB,aAAO,OAAO,KAAK;AAEnB,eAAS,OAAOC,QAAO;AACrB,YAAI;AACJ,iBAAS,IAAI,GAAG,IAAIA,OAAM,QAAQ,KAAK;AACrC,iBAAOA,OAAM,CAAC;AACd,kBAAQ,KAAK,MAAM;AAAA,YACnB,KAAK;AACH,qBAAO,IAAI;AACX;AAAA,YACF,KAAK;AACH,sBAAQ,IAAI;AACZ;AAAA,YACF,KAAK;AACH,4BAAc,IAAI;AAClB;AAAA,UACF;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAlBS;AAoBT,eAAS,SAAS,KAAK,MAAM,KAAK;AAChC,YAAI,KAAK,IAAI,MAAM,GAAG;AACtB,WAAG,OAAO;AACV,WAAG,SAAS;AACZ,cAAM;AAAA,MACR;AALS;AAOT,eAAS,OAAO,MAAM;AACpB,YAAI,MAAM,KAAK;AACf,YAAI,QAAQ,KAAK;AACjB,YAAI,OAAO,KAAK;AAChB,YAAI,SAAS,KAAK;AAElB,YAAI;AACJ,YAAI,aAAa;AACf,qBAAW,cAAc,MAAM;AAAA,QACjC,OAAO;AACL,qBAAW;AAAA,QACb;AACA,YAAI,OAAO,QAAQ,GAAG,MAAM,aAAa;AACvC,mBAAS,mCAAmC,WAAW,MAAM,MAAM,MAAM;AAAA,QAC3E;AAEA,gBAAQ,GAAG,IAAI,gBAAgB,KAAK;AAEpC,YAAI,CAAC,aAAa,QAAQ,GAAG;AAC3B,wBAAc,KAAK,QAAQ;AAC3B,2BAAiB,KAAK,QAAQ;AAAA,QAChC;AAAA,MACF;AAtBS;AAyBT,eAAS,aAAa,MAAM;AAC1B,eAAO,cAAc,QAAQ,IAAI,MAAM;AAAA,MACzC;AAFS;AAIT,eAAS,gBAAgB,MAAM;AAC7B,YAAI,KAAK,SAAS,SAAS;AACzB,iBAAO,4BAA4B,KAAK,KAAK;AAAA,QAC/C,WAAW,KAAK,SAAS,eAAe;AACtC,iBAAO,sBAAsB,KAAK,KAAK;AAAA,QACzC,OAAO;AACL,iBAAO,KAAK;AAAA,QACd;AAAA,MACF;AARS;AAUT,eAAS,sBAAsB,QAAQ;AACrC,YAAI,MAAM,uBAAO,OAAO,IAAI;AAC5B,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,cAAI,MAAM,OAAO,CAAC;AAClB,cAAI,IAAI,MAAM,SAAS,eAAe;AACpC,gBAAI,IAAI,GAAG,IAAI,sBAAsB,IAAI,MAAM,KAAK;AAAA,UACtD,WAAW,IAAI,SAAS,oBAAoB;AAC1C,gBAAI,IAAI,GAAG,IAAI,gBAAgB,IAAI,KAAK;AAAA,UAC1C;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAZS;AAcT,eAAS,QAAQ,MAAM;AACrB,YAAI,OAAO,KAAK;AAChB,YAAI,aAAa,KAAK,IAAI,iBAAiB,EAAE,KAAK,GAAG;AACrD,YAAI,OAAO,KAAK;AAChB,YAAI,SAAS,KAAK;AAElB,YAAI,aAAa,UAAU,GAAG;AAC5B,mBAAS,mCAAmC,OAAO,MAAM,MAAM,MAAM;AAAA,QACvE;AACA,sBAAc,KAAK,UAAU;AAC7B,kBAAU,QAAQ,MAAM,MAAM,uBAAO,OAAO,IAAI,GAAG,MAAM,MAAM;AAC/D,sBAAc;AAAA,MAChB;AAZS;AAcT,eAAS,cAAc,MAAM;AAC3B,YAAI,OAAO,KAAK;AAChB,YAAI,aAAa,KAAK,IAAI,iBAAiB,EAAE,KAAK,GAAG;AACrD,YAAI,OAAO,KAAK;AAChB,YAAI,SAAS,KAAK;AAElB,YAAI,CAAC,aAAa,UAAU,GAAG;AAC7B,wBAAc,KAAK,UAAU;AAAA,QAC/B;AACA,wBAAgB,cAAc,OAAO,SAAS,GAAG;AAC/C,iBAAO,EAAE,QAAQ,UAAU,MAAM;AAAA,QACnC,CAAC;AACD,sBAAc,KAAK,UAAU;AAC7B,kBAAU,QAAQ,MAAM,MAAM,CAAC,GAAG,MAAM,MAAM;AAC9C,sBAAc;AAEd,YAAI,mBAAmB,OAAO;AAC5B,cAAI,SAAS,uBAAO,OAAO,IAAI;AAC/B,kBAAQ,KAAK,MAAM;AACnB,oBAAU;AAAA,QACZ,OAAO;AACL,mBAAS,mCAAmC,OAAO,MAAM,MAAM,MAAM;AAAA,QACvE;AAAA,MACF;AAvBS;AA6BT,eAAS,QAAQ,OAAO,MAAM,OAAO,MAAM,QAAQ;AACjD,YAAI,YAAY,CAAC;AACjB,YAAI,gBAAgB;AACpB,YAAI,OAAO,KAAK,KAAK,GAAG;AACxB,YAAI,MAAM;AAEV,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,cAAI,MAAM,KAAK,CAAC;AAChB,oBAAU,KAAK,GAAG;AAClB,0BAAgB,UAAU,KAAK,GAAG;AAClC,cAAI,OAAO,IAAI,GAAG,MAAM,aAAa;AACnC,gBAAI,MAAM,KAAK,SAAS,GAAG;AACzB,kBAAI,GAAG,IAAI;AAAA,YACb,OAAO;AACL,kBAAI,GAAG,IAAI,uBAAO,OAAO,IAAI;AAAA,YAC/B;AAAA,UACF,WAAW,MAAM,KAAK,SAAS,KAAK,iBAAiB,QAAQ,aAAa,IAAI,IAAI;AAEhF,qBAAS,mCAAmC,gBAAgB,MAAM,MAAM,MAAM;AAAA,UAChF;AAEA,gBAAM,IAAI,GAAG;AACb,cAAI,eAAe,SAAS,IAAI,UAAU,IAAI,KAAK,SAAS,GAAG;AAC7D,kBAAM,IAAI,IAAI,SAAS,CAAC;AAAA,UAC1B;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AA5BS;AA8BT,eAAS,4BAA4B,OAAO;AAE1C,YAAI,YAAY;AAChB,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,cAAI,OAAO,MAAM,CAAC;AAClB,cAAI,cAAc,MAAM;AACtB,wBAAY,KAAK;AAAA,UACnB,OAAO;AACL,gBAAI,KAAK,SAAS,WAAW;AAC3B,uBAAS,8BAA8B,KAAK,OAAO,uBACjD,YAAY,KAAK,KAAK,MAAM,KAAK,MAAM;AAAA,YAC3C;AAAA,UACF;AAAA,QACF;AAGA,eAAO,MAAM,IAAI,eAAe;AAAA,MAClC;AAjBS;AAmBT,eAAS,kBAAkB,KAAK;AAC9B,YAAI,IAAI,QAAQ,GAAG,IAAI,IAAI;AACzB,iBAAO,MAAO,MAAM;AAAA,QACtB,OAAO;AACL,iBAAO;AAAA,QACT;AAAA,MACF;AANS;AAAA,IAOX;AA7LS;AA+LT,IAAAD,QAAO,UAAU;AAAA,MACf;AAAA,IACF;AAAA;AAAA;;;AClMA;AAAA,gHAAAE,UAAAC,SAAA;AAAA,QAAI,SAAS;AACb,QAAI,WAAW;AAEf,IAAAA,QAAO,UAAU;AAAA,MACf,OAAO,SAAS,OAAO;AACrB,YAAI,QAAQ,OAAO,MAAM,MAAM,SAAS,CAAC;AACzC,eAAO,SAAS,QAAQ,KAAK;AAAA,MAC/B;AAAA,IACF;AAAA;AAAA;;;ACRA;AAAA,8HAAAC,UAAA;AAAA;AAEA,QAAM,QAAQ,OAAO,IAAI,YAAY;AACrC,QAAM,MAAM,OAAO,IAAI,eAAe;AACtC,QAAM,MAAM,OAAO,IAAI,UAAU;AACjC,QAAM,OAAO,OAAO,IAAI,WAAW;AACnC,QAAM,SAAS,OAAO,IAAI,aAAa;AACvC,QAAM,MAAM,OAAO,IAAI,UAAU;AACjC,QAAM,YAAY,OAAO,IAAI,gBAAgB;AAC7C,QAAM,UAAU,wBAAC,SAAS,CAAC,CAAC,QAAQ,OAAO,SAAS,YAAY,KAAK,SAAS,MAAM,OAApE;AAChB,QAAM,aAAa,wBAAC,SAAS,CAAC,CAAC,QAAQ,OAAO,SAAS,YAAY,KAAK,SAAS,MAAM,KAApE;AACnB,QAAM,QAAQ,wBAAC,SAAS,CAAC,CAAC,QAAQ,OAAO,SAAS,YAAY,KAAK,SAAS,MAAM,KAApE;AACd,QAAM,SAAS,wBAAC,SAAS,CAAC,CAAC,QAAQ,OAAO,SAAS,YAAY,KAAK,SAAS,MAAM,MAApE;AACf,QAAM,WAAW,wBAAC,SAAS,CAAC,CAAC,QAAQ,OAAO,SAAS,YAAY,KAAK,SAAS,MAAM,QAApE;AACjB,QAAM,QAAQ,wBAAC,SAAS,CAAC,CAAC,QAAQ,OAAO,SAAS,YAAY,KAAK,SAAS,MAAM,KAApE;AACd,aAAS,aAAa,MAAM;AACxB,UAAI,QAAQ,OAAO,SAAS;AACxB,gBAAQ,KAAK,SAAS,GAAG;AAAA,UACrB,KAAK;AAAA,UACL,KAAK;AACD,mBAAO;AAAA,QACf;AACJ,aAAO;AAAA,IACX;AARS;AAST,aAAS,OAAO,MAAM;AAClB,UAAI,QAAQ,OAAO,SAAS;AACxB,gBAAQ,KAAK,SAAS,GAAG;AAAA,UACrB,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD,mBAAO;AAAA,QACf;AACJ,aAAO;AAAA,IACX;AAVS;AAWT,QAAM,YAAY,wBAAC,UAAU,SAAS,IAAI,KAAK,aAAa,IAAI,MAAM,CAAC,CAAC,KAAK,QAA3D;AAElB,IAAAA,SAAQ,QAAQ;AAChB,IAAAA,SAAQ,MAAM;AACd,IAAAA,SAAQ,MAAM;AACd,IAAAA,SAAQ,YAAY;AACpB,IAAAA,SAAQ,OAAO;AACf,IAAAA,SAAQ,SAAS;AACjB,IAAAA,SAAQ,MAAM;AACd,IAAAA,SAAQ,YAAY;AACpB,IAAAA,SAAQ,UAAU;AAClB,IAAAA,SAAQ,eAAe;AACvB,IAAAA,SAAQ,aAAa;AACrB,IAAAA,SAAQ,QAAQ;AAChB,IAAAA,SAAQ,SAAS;AACjB,IAAAA,SAAQ,SAAS;AACjB,IAAAA,SAAQ,WAAW;AACnB,IAAAA,SAAQ,QAAQ;AAAA;AAAA;;;ACpDhB;AAAA,qHAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AAEf,QAAM,QAAQ,OAAO,aAAa;AAClC,QAAM,OAAO,OAAO,eAAe;AACnC,QAAM,SAAS,OAAO,aAAa;AA+BnC,aAAS,MAAM,MAAM,SAAS;AAC1B,YAAM,WAAW,YAAY,OAAO;AACpC,UAAI,SAAS,WAAW,IAAI,GAAG;AAC3B,cAAM,KAAK,OAAO,MAAM,KAAK,UAAU,UAAU,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC;AACtE,YAAI,OAAO;AACP,eAAK,WAAW;AAAA,MACxB;AAEI,eAAO,MAAM,MAAM,UAAU,OAAO,OAAO,CAAC,CAAC,CAAC;AAAA,IACtD;AATS;AAcT,UAAM,QAAQ;AAEd,UAAM,OAAO;AAEb,UAAM,SAAS;AACf,aAAS,OAAO,KAAK,MAAM,SAAS,MAAM;AACtC,YAAM,OAAO,YAAY,KAAK,MAAM,SAAS,IAAI;AACjD,UAAI,SAAS,OAAO,IAAI,KAAK,SAAS,OAAO,IAAI,GAAG;AAChD,oBAAY,KAAK,MAAM,IAAI;AAC3B,eAAO,OAAO,KAAK,MAAM,SAAS,IAAI;AAAA,MAC1C;AACA,UAAI,OAAO,SAAS,UAAU;AAC1B,YAAI,SAAS,aAAa,IAAI,GAAG;AAC7B,iBAAO,OAAO,OAAO,KAAK,OAAO,IAAI,CAAC;AACtC,mBAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,EAAE,GAAG;AACxC,kBAAM,KAAK,OAAO,GAAG,KAAK,MAAM,CAAC,GAAG,SAAS,IAAI;AACjD,gBAAI,OAAO,OAAO;AACd,kBAAI,KAAK;AAAA,qBACJ,OAAO;AACZ,qBAAO;AAAA,qBACF,OAAO,QAAQ;AACpB,mBAAK,MAAM,OAAO,GAAG,CAAC;AACtB,mBAAK;AAAA,YACT;AAAA,UACJ;AAAA,QACJ,WACS,SAAS,OAAO,IAAI,GAAG;AAC5B,iBAAO,OAAO,OAAO,KAAK,OAAO,IAAI,CAAC;AACtC,gBAAM,KAAK,OAAO,OAAO,KAAK,KAAK,SAAS,IAAI;AAChD,cAAI,OAAO;AACP,mBAAO;AAAA,mBACF,OAAO;AACZ,iBAAK,MAAM;AACf,gBAAM,KAAK,OAAO,SAAS,KAAK,OAAO,SAAS,IAAI;AACpD,cAAI,OAAO;AACP,mBAAO;AAAA,mBACF,OAAO;AACZ,iBAAK,QAAQ;AAAA,QACrB;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AApCS;AAoET,mBAAe,WAAW,MAAM,SAAS;AACrC,YAAM,WAAW,YAAY,OAAO;AACpC,UAAI,SAAS,WAAW,IAAI,GAAG;AAC3B,cAAM,KAAK,MAAM,YAAY,MAAM,KAAK,UAAU,UAAU,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC;AACjF,YAAI,OAAO;AACP,eAAK,WAAW;AAAA,MACxB;AAEI,cAAM,YAAY,MAAM,MAAM,UAAU,OAAO,OAAO,CAAC,CAAC,CAAC;AAAA,IACjE;AATe;AAcf,eAAW,QAAQ;AAEnB,eAAW,OAAO;AAElB,eAAW,SAAS;AACpB,mBAAe,YAAY,KAAK,MAAM,SAAS,MAAM;AACjD,YAAM,OAAO,MAAM,YAAY,KAAK,MAAM,SAAS,IAAI;AACvD,UAAI,SAAS,OAAO,IAAI,KAAK,SAAS,OAAO,IAAI,GAAG;AAChD,oBAAY,KAAK,MAAM,IAAI;AAC3B,eAAO,YAAY,KAAK,MAAM,SAAS,IAAI;AAAA,MAC/C;AACA,UAAI,OAAO,SAAS,UAAU;AAC1B,YAAI,SAAS,aAAa,IAAI,GAAG;AAC7B,iBAAO,OAAO,OAAO,KAAK,OAAO,IAAI,CAAC;AACtC,mBAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,EAAE,GAAG;AACxC,kBAAM,KAAK,MAAM,YAAY,GAAG,KAAK,MAAM,CAAC,GAAG,SAAS,IAAI;AAC5D,gBAAI,OAAO,OAAO;AACd,kBAAI,KAAK;AAAA,qBACJ,OAAO;AACZ,qBAAO;AAAA,qBACF,OAAO,QAAQ;AACpB,mBAAK,MAAM,OAAO,GAAG,CAAC;AACtB,mBAAK;AAAA,YACT;AAAA,UACJ;AAAA,QACJ,WACS,SAAS,OAAO,IAAI,GAAG;AAC5B,iBAAO,OAAO,OAAO,KAAK,OAAO,IAAI,CAAC;AACtC,gBAAM,KAAK,MAAM,YAAY,OAAO,KAAK,KAAK,SAAS,IAAI;AAC3D,cAAI,OAAO;AACP,mBAAO;AAAA,mBACF,OAAO;AACZ,iBAAK,MAAM;AACf,gBAAM,KAAK,MAAM,YAAY,SAAS,KAAK,OAAO,SAAS,IAAI;AAC/D,cAAI,OAAO;AACP,mBAAO;AAAA,mBACF,OAAO;AACZ,iBAAK,QAAQ;AAAA,QACrB;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AApCe;AAqCf,aAAS,YAAY,SAAS;AAC1B,UAAI,OAAO,YAAY,aAClB,QAAQ,cAAc,QAAQ,QAAQ,QAAQ,QAAQ;AACvD,eAAO,OAAO,OAAO;AAAA,UACjB,OAAO,QAAQ;AAAA,UACf,KAAK,QAAQ;AAAA,UACb,QAAQ,QAAQ;AAAA,UAChB,KAAK,QAAQ;AAAA,QACjB,GAAG,QAAQ,SAAS;AAAA,UAChB,KAAK,QAAQ;AAAA,UACb,QAAQ,QAAQ;AAAA,UAChB,KAAK,QAAQ;AAAA,QACjB,GAAG,QAAQ,cAAc;AAAA,UACrB,KAAK,QAAQ;AAAA,UACb,KAAK,QAAQ;AAAA,QACjB,GAAG,OAAO;AAAA,MACd;AACA,aAAO;AAAA,IACX;AAlBS;AAmBT,aAAS,YAAY,KAAK,MAAM,SAAS,MAAM;AAC3C,UAAI,OAAO,YAAY;AACnB,eAAO,QAAQ,KAAK,MAAM,IAAI;AAClC,UAAI,SAAS,MAAM,IAAI;AACnB,eAAO,QAAQ,MAAM,KAAK,MAAM,IAAI;AACxC,UAAI,SAAS,MAAM,IAAI;AACnB,eAAO,QAAQ,MAAM,KAAK,MAAM,IAAI;AACxC,UAAI,SAAS,OAAO,IAAI;AACpB,eAAO,QAAQ,OAAO,KAAK,MAAM,IAAI;AACzC,UAAI,SAAS,SAAS,IAAI;AACtB,eAAO,QAAQ,SAAS,KAAK,MAAM,IAAI;AAC3C,UAAI,SAAS,QAAQ,IAAI;AACrB,eAAO,QAAQ,QAAQ,KAAK,MAAM,IAAI;AAC1C,aAAO;AAAA,IACX;AAdS;AAeT,aAAS,YAAY,KAAK,MAAM,MAAM;AAClC,YAAM,SAAS,KAAK,KAAK,SAAS,CAAC;AACnC,UAAI,SAAS,aAAa,MAAM,GAAG;AAC/B,eAAO,MAAM,GAAG,IAAI;AAAA,MACxB,WACS,SAAS,OAAO,MAAM,GAAG;AAC9B,YAAI,QAAQ;AACR,iBAAO,MAAM;AAAA;AAEb,iBAAO,QAAQ;AAAA,MACvB,WACS,SAAS,WAAW,MAAM,GAAG;AAClC,eAAO,WAAW;AAAA,MACtB,OACK;AACD,cAAM,KAAK,SAAS,QAAQ,MAAM,IAAI,UAAU;AAChD,cAAM,IAAI,MAAM,4BAA4B,EAAE,SAAS;AAAA,MAC3D;AAAA,IACJ;AAlBS;AAoBT,IAAAA,SAAQ,QAAQ;AAChB,IAAAA,SAAQ,aAAa;AAAA;AAAA;;;AC3OrB;AAAA,8HAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,QAAQ;AAEZ,QAAM,cAAc;AAAA,MAChB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACT;AACA,QAAM,gBAAgB,wBAAC,OAAO,GAAG,QAAQ,cAAc,QAAM,YAAY,EAAE,CAAC,GAAtD;AACtB,QAAM,aAAN,MAAM,YAAW;AAAA,MAdjB,OAciB;AAAA;AAAA;AAAA,MACb,YAAY,MAAM,MAAM;AAKpB,aAAK,WAAW;AAEhB,aAAK,SAAS;AACd,aAAK,OAAO,OAAO,OAAO,CAAC,GAAG,YAAW,aAAa,IAAI;AAC1D,aAAK,OAAO,OAAO,OAAO,CAAC,GAAG,YAAW,aAAa,IAAI;AAAA,MAC9D;AAAA,MACA,QAAQ;AACJ,cAAM,OAAO,IAAI,YAAW,KAAK,MAAM,KAAK,IAAI;AAChD,aAAK,WAAW,KAAK;AACrB,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,aAAa;AACT,cAAM,MAAM,IAAI,YAAW,KAAK,MAAM,KAAK,IAAI;AAC/C,gBAAQ,KAAK,KAAK,SAAS;AAAA,UACvB,KAAK;AACD,iBAAK,iBAAiB;AACtB;AAAA,UACJ,KAAK;AACD,iBAAK,iBAAiB;AACtB,iBAAK,OAAO;AAAA,cACR,UAAU,YAAW,YAAY;AAAA,cACjC,SAAS;AAAA,YACb;AACA,iBAAK,OAAO,OAAO,OAAO,CAAC,GAAG,YAAW,WAAW;AACpD;AAAA,QACR;AACA,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,IAAI,MAAM,SAAS;AACf,YAAI,KAAK,gBAAgB;AACrB,eAAK,OAAO,EAAE,UAAU,YAAW,YAAY,UAAU,SAAS,MAAM;AACxE,eAAK,OAAO,OAAO,OAAO,CAAC,GAAG,YAAW,WAAW;AACpD,eAAK,iBAAiB;AAAA,QAC1B;AACA,cAAM,QAAQ,KAAK,KAAK,EAAE,MAAM,QAAQ;AACxC,cAAM,OAAO,MAAM,MAAM;AACzB,gBAAQ,MAAM;AAAA,UACV,KAAK,QAAQ;AACT,gBAAI,MAAM,WAAW,GAAG;AACpB,sBAAQ,GAAG,iDAAiD;AAC5D,kBAAI,MAAM,SAAS;AACf,uBAAO;AAAA,YACf;AACA,kBAAM,CAAC,QAAQ,MAAM,IAAI;AACzB,iBAAK,KAAK,MAAM,IAAI;AACpB,mBAAO;AAAA,UACX;AAAA,UACA,KAAK,SAAS;AACV,iBAAK,KAAK,WAAW;AACrB,gBAAI,MAAM,WAAW,GAAG;AACpB,sBAAQ,GAAG,iDAAiD;AAC5D,qBAAO;AAAA,YACX;AACA,kBAAM,CAAC,OAAO,IAAI;AAClB,gBAAI,YAAY,SAAS,YAAY,OAAO;AACxC,mBAAK,KAAK,UAAU;AACpB,qBAAO;AAAA,YACX,OACK;AACD,oBAAM,UAAU,aAAa,KAAK,OAAO;AACzC,sBAAQ,GAAG,4BAA4B,OAAO,IAAI,OAAO;AACzD,qBAAO;AAAA,YACX;AAAA,UACJ;AAAA,UACA;AACI,oBAAQ,GAAG,qBAAqB,IAAI,IAAI,IAAI;AAC5C,mBAAO;AAAA,QACf;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,QAAQ,QAAQ,SAAS;AACrB,YAAI,WAAW;AACX,iBAAO;AACX,YAAI,OAAO,CAAC,MAAM,KAAK;AACnB,kBAAQ,oBAAoB,MAAM,EAAE;AACpC,iBAAO;AAAA,QACX;AACA,YAAI,OAAO,CAAC,MAAM,KAAK;AACnB,gBAAM,WAAW,OAAO,MAAM,GAAG,EAAE;AACnC,cAAI,aAAa,OAAO,aAAa,MAAM;AACvC,oBAAQ,qCAAqC,MAAM,cAAc;AACjE,mBAAO;AAAA,UACX;AACA,cAAI,OAAO,OAAO,SAAS,CAAC,MAAM;AAC9B,oBAAQ,iCAAiC;AAC7C,iBAAO;AAAA,QACX;AACA,cAAM,CAAC,EAAE,QAAQ,MAAM,IAAI,OAAO,MAAM,gBAAgB;AACxD,YAAI,CAAC;AACD,kBAAQ,OAAO,MAAM,oBAAoB;AAC7C,cAAM,SAAS,KAAK,KAAK,MAAM;AAC/B,YAAI;AACA,iBAAO,SAAS,mBAAmB,MAAM;AAC7C,YAAI,WAAW;AACX,iBAAO;AACX,gBAAQ,0BAA0B,MAAM,EAAE;AAC1C,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,UAAU,KAAK;AACX,mBAAW,CAAC,QAAQ,MAAM,KAAK,OAAO,QAAQ,KAAK,IAAI,GAAG;AACtD,cAAI,IAAI,WAAW,MAAM;AACrB,mBAAO,SAAS,cAAc,IAAI,UAAU,OAAO,MAAM,CAAC;AAAA,QAClE;AACA,eAAO,IAAI,CAAC,MAAM,MAAM,MAAM,KAAK,GAAG;AAAA,MAC1C;AAAA,MACA,SAAS,KAAK;AACV,cAAM,QAAQ,KAAK,KAAK,WAClB,CAAC,SAAS,KAAK,KAAK,WAAW,KAAK,EAAE,IACtC,CAAC;AACP,cAAM,aAAa,OAAO,QAAQ,KAAK,IAAI;AAC3C,YAAI;AACJ,YAAI,OAAO,WAAW,SAAS,KAAK,SAAS,OAAO,IAAI,QAAQ,GAAG;AAC/D,gBAAM,OAAO,CAAC;AACd,gBAAM,MAAM,IAAI,UAAU,CAAC,MAAM,SAAS;AACtC,gBAAI,SAAS,OAAO,IAAI,KAAK,KAAK;AAC9B,mBAAK,KAAK,GAAG,IAAI;AAAA,UACzB,CAAC;AACD,qBAAW,OAAO,KAAK,IAAI;AAAA,QAC/B;AAEI,qBAAW,CAAC;AAChB,mBAAW,CAAC,QAAQ,MAAM,KAAK,YAAY;AACvC,cAAI,WAAW,QAAQ,WAAW;AAC9B;AACJ,cAAI,CAAC,OAAO,SAAS,KAAK,QAAM,GAAG,WAAW,MAAM,CAAC;AACjD,kBAAM,KAAK,QAAQ,MAAM,IAAI,MAAM,EAAE;AAAA,QAC7C;AACA,eAAO,MAAM,KAAK,IAAI;AAAA,MAC1B;AAAA,IACJ;AACA,eAAW,cAAc,EAAE,UAAU,OAAO,SAAS,MAAM;AAC3D,eAAW,cAAc,EAAE,MAAM,qBAAqB;AAEtD,IAAAA,SAAQ,aAAa;AAAA;AAAA;;;AC1KrB;AAAA,2HAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,QAAQ;AAOZ,aAAS,cAAc,QAAQ;AAC3B,UAAI,sBAAsB,KAAK,MAAM,GAAG;AACpC,cAAM,KAAK,KAAK,UAAU,MAAM;AAChC,cAAM,MAAM,6DAA6D,EAAE;AAC3E,cAAM,IAAI,MAAM,GAAG;AAAA,MACvB;AACA,aAAO;AAAA,IACX;AAPS;AAQT,aAAS,YAAY,MAAM;AACvB,YAAM,UAAU,oBAAI,IAAI;AACxB,YAAM,MAAM,MAAM;AAAA,QACd,MAAM,MAAM,MAAM;AACd,cAAI,KAAK;AACL,oBAAQ,IAAI,KAAK,MAAM;AAAA,QAC/B;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AATS;AAWT,aAAS,cAAc,QAAQ,SAAS;AACpC,eAAS,IAAI,GAAG,MAAM,EAAE,GAAG;AACvB,cAAM,OAAO,GAAG,MAAM,GAAG,CAAC;AAC1B,YAAI,CAAC,QAAQ,IAAI,IAAI;AACjB,iBAAO;AAAA,MACf;AAAA,IACJ;AANS;AAOT,aAAS,kBAAkB,KAAK,QAAQ;AACpC,YAAM,eAAe,CAAC;AACtB,YAAM,gBAAgB,oBAAI,IAAI;AAC9B,UAAI,cAAc;AAClB,aAAO;AAAA,QACH,UAAU,CAAC,WAAW;AAClB,uBAAa,KAAK,MAAM;AACxB,cAAI,CAAC;AACD,0BAAc,YAAY,GAAG;AACjC,gBAAM,SAAS,cAAc,QAAQ,WAAW;AAChD,sBAAY,IAAI,MAAM;AACtB,iBAAO;AAAA,QACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAMA,YAAY,MAAM;AACd,qBAAW,UAAU,cAAc;AAC/B,kBAAM,MAAM,cAAc,IAAI,MAAM;AACpC,gBAAI,OAAO,QAAQ,YACf,IAAI,WACH,SAAS,SAAS,IAAI,IAAI,KAAK,SAAS,aAAa,IAAI,IAAI,IAAI;AAClE,kBAAI,KAAK,SAAS,IAAI;AAAA,YAC1B,OACK;AACD,oBAAM,QAAQ,IAAI,MAAM,4DAA4D;AACpF,oBAAM,SAAS;AACf,oBAAM;AAAA,YACV;AAAA,UACJ;AAAA,QACJ;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AAnCS;AAqCT,IAAAA,SAAQ,gBAAgB;AACxB,IAAAA,SAAQ,cAAc;AACtB,IAAAA,SAAQ,oBAAoB;AAC5B,IAAAA,SAAQ,gBAAgB;AAAA;AAAA;;;AC5ExB;AAAA,gIAAAC,UAAA;AAAA;AASA,aAAS,aAAa,SAAS,KAAK,KAAK,KAAK;AAC1C,UAAI,OAAO,OAAO,QAAQ,UAAU;AAChC,YAAI,MAAM,QAAQ,GAAG,GAAG;AACpB,mBAAS,IAAI,GAAG,MAAM,IAAI,QAAQ,IAAI,KAAK,EAAE,GAAG;AAC5C,kBAAM,KAAK,IAAI,CAAC;AAChB,kBAAM,KAAK,aAAa,SAAS,KAAK,OAAO,CAAC,GAAG,EAAE;AACnD,gBAAI,OAAO;AACP,qBAAO,IAAI,CAAC;AAAA,qBACP,OAAO;AACZ,kBAAI,CAAC,IAAI;AAAA,UACjB;AAAA,QACJ,WACS,eAAe,KAAK;AACzB,qBAAW,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC,GAAG;AACpC,kBAAM,KAAK,IAAI,IAAI,CAAC;AACpB,kBAAM,KAAK,aAAa,SAAS,KAAK,GAAG,EAAE;AAC3C,gBAAI,OAAO;AACP,kBAAI,OAAO,CAAC;AAAA,qBACP,OAAO;AACZ,kBAAI,IAAI,GAAG,EAAE;AAAA,UACrB;AAAA,QACJ,WACS,eAAe,KAAK;AACzB,qBAAW,MAAM,MAAM,KAAK,GAAG,GAAG;AAC9B,kBAAM,KAAK,aAAa,SAAS,KAAK,IAAI,EAAE;AAC5C,gBAAI,OAAO;AACP,kBAAI,OAAO,EAAE;AAAA,qBACR,OAAO,IAAI;AAChB,kBAAI,OAAO,EAAE;AACb,kBAAI,IAAI,EAAE;AAAA,YACd;AAAA,UACJ;AAAA,QACJ,OACK;AACD,qBAAW,CAAC,GAAG,EAAE,KAAK,OAAO,QAAQ,GAAG,GAAG;AACvC,kBAAM,KAAK,aAAa,SAAS,KAAK,GAAG,EAAE;AAC3C,gBAAI,OAAO;AACP,qBAAO,IAAI,CAAC;AAAA,qBACP,OAAO;AACZ,kBAAI,CAAC,IAAI;AAAA,UACjB;AAAA,QACJ;AAAA,MACJ;AACA,aAAO,QAAQ,KAAK,KAAK,KAAK,GAAG;AAAA,IACrC;AA5CS;AA8CT,IAAAA,SAAQ,eAAe;AAAA;AAAA;;;ACvDvB;AAAA,0HAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AAYf,aAAS,KAAK,OAAO,KAAK,KAAK;AAE3B,UAAI,MAAM,QAAQ,KAAK;AACnB,eAAO,MAAM,IAAI,CAAC,GAAG,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,GAAG,CAAC;AACtD,UAAI,SAAS,OAAO,MAAM,WAAW,YAAY;AAE7C,YAAI,CAAC,OAAO,CAAC,SAAS,UAAU,KAAK;AACjC,iBAAO,MAAM,OAAO,KAAK,GAAG;AAChC,cAAM,OAAO,EAAE,YAAY,GAAG,OAAO,GAAG,KAAK,OAAU;AACvD,YAAI,QAAQ,IAAI,OAAO,IAAI;AAC3B,YAAI,WAAW,CAAAC,SAAO;AAClB,eAAK,MAAMA;AACX,iBAAO,IAAI;AAAA,QACf;AACA,cAAM,MAAM,MAAM,OAAO,KAAK,GAAG;AACjC,YAAI,IAAI;AACJ,cAAI,SAAS,GAAG;AACpB,eAAO;AAAA,MACX;AACA,UAAI,OAAO,UAAU,YAAY,CAAC,KAAK;AACnC,eAAO,OAAO,KAAK;AACvB,aAAO;AAAA,IACX;AAtBS;AAwBT,IAAAD,SAAQ,OAAO;AAAA;AAAA;;;ACtCf;AAAA,0HAAAE,UAAA;AAAA;AAEA,QAAI,eAAe;AACnB,QAAI,WAAW;AACf,QAAI,OAAO;AAEX,QAAM,WAAN,MAAe;AAAA,MANf,OAMe;AAAA;AAAA;AAAA,MACX,YAAY,MAAM;AACd,eAAO,eAAe,MAAM,SAAS,WAAW,EAAE,OAAO,KAAK,CAAC;AAAA,MACnE;AAAA;AAAA,MAEA,QAAQ;AACJ,cAAM,OAAO,OAAO,OAAO,OAAO,eAAe,IAAI,GAAG,OAAO,0BAA0B,IAAI,CAAC;AAC9F,YAAI,KAAK;AACL,eAAK,QAAQ,KAAK,MAAM,MAAM;AAClC,eAAO;AAAA,MACX;AAAA;AAAA,MAEA,KAAK,KAAK,EAAE,UAAU,eAAe,UAAU,QAAQ,IAAI,CAAC,GAAG;AAC3D,YAAI,CAAC,SAAS,WAAW,GAAG;AACxB,gBAAM,IAAI,UAAU,iCAAiC;AACzD,cAAM,MAAM;AAAA,UACR,SAAS,oBAAI,IAAI;AAAA,UACjB;AAAA,UACA,MAAM;AAAA,UACN,UAAU,aAAa;AAAA,UACvB,cAAc;AAAA,UACd,eAAe,OAAO,kBAAkB,WAAW,gBAAgB;AAAA,QACvE;AACA,cAAM,MAAM,KAAK,KAAK,MAAM,IAAI,GAAG;AACnC,YAAI,OAAO,aAAa;AACpB,qBAAW,EAAE,OAAO,KAAAC,KAAI,KAAK,IAAI,QAAQ,OAAO;AAC5C,qBAASA,MAAK,KAAK;AAC3B,eAAO,OAAO,YAAY,aACpB,aAAa,aAAa,SAAS,EAAE,IAAI,IAAI,GAAG,IAAI,GAAG,IACvD;AAAA,MACV;AAAA,IACJ;AAEA,IAAAD,SAAQ,WAAW;AAAA;AAAA;;;ACvCnB;AAAA,2HAAAE,UAAA;AAAA;AAEA,QAAI,UAAU;AACd,QAAI,QAAQ;AACZ,QAAI,WAAW;AACf,QAAI,OAAO;AACX,QAAI,OAAO;AAEX,QAAM,QAAN,cAAoB,KAAK,SAAS;AAAA,MARlC,OAQkC;AAAA;AAAA;AAAA,MAC9B,YAAY,QAAQ;AAChB,cAAM,SAAS,KAAK;AACpB,aAAK,SAAS;AACd,eAAO,eAAe,MAAM,OAAO;AAAA,UAC/B,MAAM;AACF,kBAAM,IAAI,MAAM,8BAA8B;AAAA,UAClD;AAAA,QACJ,CAAC;AAAA,MACL;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,QAAQ,KAAK;AACT,YAAI,QAAQ;AACZ,cAAM,MAAM,KAAK;AAAA,UACb,MAAM,CAAC,MAAM,SAAS;AAClB,gBAAI,SAAS;AACT,qBAAO,MAAM,MAAM;AACvB,gBAAI,KAAK,WAAW,KAAK;AACrB,sBAAQ;AAAA,UAChB;AAAA,QACJ,CAAC;AACD,eAAO;AAAA,MACX;AAAA,MACA,OAAO,MAAM,KAAK;AACd,YAAI,CAAC;AACD,iBAAO,EAAE,QAAQ,KAAK,OAAO;AACjC,cAAM,EAAE,SAAAC,UAAS,KAAK,cAAc,IAAI;AACxC,cAAM,SAAS,KAAK,QAAQ,GAAG;AAC/B,YAAI,CAAC,QAAQ;AACT,gBAAM,MAAM,+DAA+D,KAAK,MAAM;AACtF,gBAAM,IAAI,eAAe,GAAG;AAAA,QAChC;AACA,YAAI,OAAOA,SAAQ,IAAI,MAAM;AAC7B,YAAI,CAAC,MAAM;AAEP,eAAK,KAAK,QAAQ,MAAM,GAAG;AAC3B,iBAAOA,SAAQ,IAAI,MAAM;AAAA,QAC7B;AAEA,YAAI,CAAC,QAAQ,KAAK,QAAQ,QAAW;AACjC,gBAAM,MAAM;AACZ,gBAAM,IAAI,eAAe,GAAG;AAAA,QAChC;AACA,YAAI,iBAAiB,GAAG;AACpB,eAAK,SAAS;AACd,cAAI,KAAK,eAAe;AACpB,iBAAK,aAAa,cAAc,KAAK,QAAQA,QAAO;AACxD,cAAI,KAAK,QAAQ,KAAK,aAAa,eAAe;AAC9C,kBAAM,MAAM;AACZ,kBAAM,IAAI,eAAe,GAAG;AAAA,UAChC;AAAA,QACJ;AACA,eAAO,KAAK;AAAA,MAChB;AAAA,MACA,SAAS,KAAK,YAAY,cAAc;AACpC,cAAM,MAAM,IAAI,KAAK,MAAM;AAC3B,YAAI,KAAK;AACL,kBAAQ,cAAc,KAAK,MAAM;AACjC,cAAI,IAAI,QAAQ,oBAAoB,CAAC,IAAI,QAAQ,IAAI,KAAK,MAAM,GAAG;AAC/D,kBAAM,MAAM,+DAA+D,KAAK,MAAM;AACtF,kBAAM,IAAI,MAAM,GAAG;AAAA,UACvB;AACA,cAAI,IAAI;AACJ,mBAAO,GAAG,GAAG;AAAA,QACrB;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AACA,aAAS,cAAc,KAAK,MAAMA,UAAS;AACvC,UAAI,SAAS,QAAQ,IAAI,GAAG;AACxB,cAAM,SAAS,KAAK,QAAQ,GAAG;AAC/B,cAAM,SAASA,YAAW,UAAUA,SAAQ,IAAI,MAAM;AACtD,eAAO,SAAS,OAAO,QAAQ,OAAO,aAAa;AAAA,MACvD,WACS,SAAS,aAAa,IAAI,GAAG;AAClC,YAAI,QAAQ;AACZ,mBAAW,QAAQ,KAAK,OAAO;AAC3B,gBAAM,IAAI,cAAc,KAAK,MAAMA,QAAO;AAC1C,cAAI,IAAI;AACJ,oBAAQ;AAAA,QAChB;AACA,eAAO;AAAA,MACX,WACS,SAAS,OAAO,IAAI,GAAG;AAC5B,cAAM,KAAK,cAAc,KAAK,KAAK,KAAKA,QAAO;AAC/C,cAAM,KAAK,cAAc,KAAK,KAAK,OAAOA,QAAO;AACjD,eAAO,KAAK,IAAI,IAAI,EAAE;AAAA,MAC1B;AACA,aAAO;AAAA,IACX;AArBS;AAuBT,IAAAD,SAAQ,QAAQ;AAAA;AAAA;;;ACtGhB;AAAA,4HAAAE,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,OAAO;AACX,QAAI,OAAO;AAEX,QAAM,gBAAgB,wBAAC,UAAU,CAAC,SAAU,OAAO,UAAU,cAAc,OAAO,UAAU,UAAtE;AACtB,QAAM,SAAN,cAAqB,KAAK,SAAS;AAAA,MAPnC,OAOmC;AAAA;AAAA;AAAA,MAC/B,YAAY,OAAO;AACf,cAAM,SAAS,MAAM;AACrB,aAAK,QAAQ;AAAA,MACjB;AAAA,MACA,OAAO,KAAK,KAAK;AACb,eAAO,KAAK,OAAO,KAAK,QAAQ,KAAK,KAAK,KAAK,OAAO,KAAK,GAAG;AAAA,MAClE;AAAA,MACA,WAAW;AACP,eAAO,OAAO,KAAK,KAAK;AAAA,MAC5B;AAAA,IACJ;AACA,WAAO,eAAe;AACtB,WAAO,gBAAgB;AACvB,WAAO,QAAQ;AACf,WAAO,eAAe;AACtB,WAAO,eAAe;AAEtB,IAAAA,SAAQ,SAAS;AACjB,IAAAA,SAAQ,gBAAgB;AAAA;AAAA;;;AC1BxB;AAAA,8HAAAC,UAAA;AAAA;AAEA,QAAI,QAAQ;AACZ,QAAI,WAAW;AACf,QAAI,SAAS;AAEb,QAAM,mBAAmB;AACzB,aAAS,cAAc,OAAO,SAAS,MAAM;AACzC,UAAI,SAAS;AACT,cAAM,QAAQ,KAAK,OAAO,OAAK,EAAE,QAAQ,OAAO;AAChD,cAAM,SAAS,MAAM,KAAK,OAAK,CAAC,EAAE,MAAM,KAAK,MAAM,CAAC;AACpD,YAAI,CAAC;AACD,gBAAM,IAAI,MAAM,OAAO,OAAO,YAAY;AAC9C,eAAO;AAAA,MACX;AACA,aAAO,KAAK,KAAK,OAAK,EAAE,WAAW,KAAK,KAAK,CAAC,EAAE,MAAM;AAAA,IAC1D;AATS;AAUT,aAAS,WAAW,OAAO,SAAS,KAAK;AACrC,UAAI,SAAS,WAAW,KAAK;AACzB,gBAAQ,MAAM;AAClB,UAAI,SAAS,OAAO,KAAK;AACrB,eAAO;AACX,UAAI,SAAS,OAAO,KAAK,GAAG;AACxB,cAAM,MAAM,IAAI,OAAO,SAAS,GAAG,EAAE,aAAa,IAAI,QAAQ,MAAM,GAAG;AACvE,YAAI,MAAM,KAAK,KAAK;AACpB,eAAO;AAAA,MACX;AACA,UAAI,iBAAiB,UACjB,iBAAiB,UACjB,iBAAiB,WAChB,OAAO,WAAW,eAAe,iBAAiB,QACrD;AAEE,gBAAQ,MAAM,QAAQ;AAAA,MAC1B;AACA,YAAM,EAAE,uBAAuB,UAAU,UAAU,QAAQ,cAAc,IAAI;AAG7E,UAAI,MAAM;AACV,UAAI,yBAAyB,SAAS,OAAO,UAAU,UAAU;AAC7D,cAAM,cAAc,IAAI,KAAK;AAC7B,YAAI,KAAK;AACL,cAAI,CAAC,IAAI;AACL,gBAAI,SAAS,SAAS,KAAK;AAC/B,iBAAO,IAAI,MAAM,MAAM,IAAI,MAAM;AAAA,QACrC,OACK;AACD,gBAAM,EAAE,QAAQ,MAAM,MAAM,KAAK;AACjC,wBAAc,IAAI,OAAO,GAAG;AAAA,QAChC;AAAA,MACJ;AACA,UAAI,SAAS,WAAW,IAAI;AACxB,kBAAU,mBAAmB,QAAQ,MAAM,CAAC;AAChD,UAAI,SAAS,cAAc,OAAO,SAAS,OAAO,IAAI;AACtD,UAAI,CAAC,QAAQ;AACT,YAAI,SAAS,OAAO,MAAM,WAAW,YAAY;AAE7C,kBAAQ,MAAM,OAAO;AAAA,QACzB;AACA,YAAI,CAAC,SAAS,OAAO,UAAU,UAAU;AACrC,gBAAMC,QAAO,IAAI,OAAO,OAAO,KAAK;AACpC,cAAI;AACA,gBAAI,OAAOA;AACf,iBAAOA;AAAA,QACX;AACA,iBACI,iBAAiB,MACX,OAAO,SAAS,GAAG,IACnB,OAAO,YAAY,OAAO,KAAK,IAC3B,OAAO,SAAS,GAAG,IACnB,OAAO,SAAS,GAAG;AAAA,MACrC;AACA,UAAI,UAAU;AACV,iBAAS,MAAM;AACf,eAAO,IAAI;AAAA,MACf;AACA,YAAM,OAAO,QAAQ,aACf,OAAO,WAAW,IAAI,QAAQ,OAAO,GAAG,IACxC,OAAO,QAAQ,WAAW,SAAS,aAC/B,OAAO,UAAU,KAAK,IAAI,QAAQ,OAAO,GAAG,IAC5C,IAAI,OAAO,OAAO,KAAK;AACjC,UAAI;AACA,aAAK,MAAM;AAAA,eACN,CAAC,OAAO;AACb,aAAK,MAAM,OAAO;AACtB,UAAI;AACA,YAAI,OAAO;AACf,aAAO;AAAA,IACX;AAvES;AAyET,IAAAD,SAAQ,aAAa;AAAA;AAAA;;;AC1FrB;AAAA,gIAAAE,UAAA;AAAA;AAEA,QAAI,aAAa;AACjB,QAAI,WAAW;AACf,QAAI,OAAO;AAEX,aAAS,mBAAmB,QAAQ,MAAM,OAAO;AAC7C,UAAI,IAAI;AACR,eAAS,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACvC,cAAM,IAAI,KAAK,CAAC;AAChB,YAAI,OAAO,MAAM,YAAY,OAAO,UAAU,CAAC,KAAK,KAAK,GAAG;AACxD,gBAAM,IAAI,CAAC;AACX,YAAE,CAAC,IAAI;AACP,cAAI;AAAA,QACR,OACK;AACD,cAAI,oBAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAAA,QACxB;AAAA,MACJ;AACA,aAAO,WAAW,WAAW,GAAG,QAAW;AAAA,QACvC,uBAAuB;AAAA,QACvB,eAAe;AAAA,QACf,UAAU,MAAM;AACZ,gBAAM,IAAI,MAAM,8CAA8C;AAAA,QAClE;AAAA,QACA;AAAA,QACA,eAAe,oBAAI,IAAI;AAAA,MAC3B,CAAC;AAAA,IACL;AAtBS;AAyBT,QAAM,cAAc,wBAAC,SAAS,QAAQ,QACjC,OAAO,SAAS,YAAY,CAAC,CAAC,KAAK,OAAO,QAAQ,EAAE,EAAE,KAAK,EAAE,MAD9C;AAEpB,QAAM,aAAN,cAAyB,KAAK,SAAS;AAAA,MAjCvC,OAiCuC;AAAA;AAAA;AAAA,MACnC,YAAY,MAAM,QAAQ;AACtB,cAAM,IAAI;AACV,eAAO,eAAe,MAAM,UAAU;AAAA,UAClC,OAAO;AAAA,UACP,cAAc;AAAA,UACd,YAAY;AAAA,UACZ,UAAU;AAAA,QACd,CAAC;AAAA,MACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,MAAM,QAAQ;AACV,cAAM,OAAO,OAAO,OAAO,OAAO,eAAe,IAAI,GAAG,OAAO,0BAA0B,IAAI,CAAC;AAC9F,YAAI;AACA,eAAK,SAAS;AAClB,aAAK,QAAQ,KAAK,MAAM,IAAI,QAAM,SAAS,OAAO,EAAE,KAAK,SAAS,OAAO,EAAE,IAAI,GAAG,MAAM,MAAM,IAAI,EAAE;AACpG,YAAI,KAAK;AACL,eAAK,QAAQ,KAAK,MAAM,MAAM;AAClC,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,MAAM,MAAM,OAAO;AACf,YAAI,YAAY,IAAI;AAChB,eAAK,IAAI,KAAK;AAAA,aACb;AACD,gBAAM,CAAC,KAAK,GAAG,IAAI,IAAI;AACvB,gBAAM,OAAO,KAAK,IAAI,KAAK,IAAI;AAC/B,cAAI,SAAS,aAAa,IAAI;AAC1B,iBAAK,MAAM,MAAM,KAAK;AAAA,mBACjB,SAAS,UAAa,KAAK;AAChC,iBAAK,IAAI,KAAK,mBAAmB,KAAK,QAAQ,MAAM,KAAK,CAAC;AAAA;AAE1D,kBAAM,IAAI,MAAM,+BAA+B,GAAG,qBAAqB,IAAI,EAAE;AAAA,QACrF;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,SAAS,MAAM;AACX,cAAM,CAAC,KAAK,GAAG,IAAI,IAAI;AACvB,YAAI,KAAK,WAAW;AAChB,iBAAO,KAAK,OAAO,GAAG;AAC1B,cAAM,OAAO,KAAK,IAAI,KAAK,IAAI;AAC/B,YAAI,SAAS,aAAa,IAAI;AAC1B,iBAAO,KAAK,SAAS,IAAI;AAAA;AAEzB,gBAAM,IAAI,MAAM,+BAA+B,GAAG,qBAAqB,IAAI,EAAE;AAAA,MACrF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,MAAM,MAAM,YAAY;AACpB,cAAM,CAAC,KAAK,GAAG,IAAI,IAAI;AACvB,cAAM,OAAO,KAAK,IAAI,KAAK,IAAI;AAC/B,YAAI,KAAK,WAAW;AAChB,iBAAO,CAAC,cAAc,SAAS,SAAS,IAAI,IAAI,KAAK,QAAQ;AAAA;AAE7D,iBAAO,SAAS,aAAa,IAAI,IAAI,KAAK,MAAM,MAAM,UAAU,IAAI;AAAA,MAC5E;AAAA,MACA,iBAAiB,aAAa;AAC1B,eAAO,KAAK,MAAM,MAAM,UAAQ;AAC5B,cAAI,CAAC,SAAS,OAAO,IAAI;AACrB,mBAAO;AACX,gBAAM,IAAI,KAAK;AACf,iBAAQ,KAAK,QACR,eACG,SAAS,SAAS,CAAC,KACnB,EAAE,SAAS,QACX,CAAC,EAAE,iBACH,CAAC,EAAE,WACH,CAAC,EAAE;AAAA,QACf,CAAC;AAAA,MACL;AAAA;AAAA;AAAA;AAAA,MAIA,MAAM,MAAM;AACR,cAAM,CAAC,KAAK,GAAG,IAAI,IAAI;AACvB,YAAI,KAAK,WAAW;AAChB,iBAAO,KAAK,IAAI,GAAG;AACvB,cAAM,OAAO,KAAK,IAAI,KAAK,IAAI;AAC/B,eAAO,SAAS,aAAa,IAAI,IAAI,KAAK,MAAM,IAAI,IAAI;AAAA,MAC5D;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,MAAM,OAAO;AACf,cAAM,CAAC,KAAK,GAAG,IAAI,IAAI;AACvB,YAAI,KAAK,WAAW,GAAG;AACnB,eAAK,IAAI,KAAK,KAAK;AAAA,QACvB,OACK;AACD,gBAAM,OAAO,KAAK,IAAI,KAAK,IAAI;AAC/B,cAAI,SAAS,aAAa,IAAI;AAC1B,iBAAK,MAAM,MAAM,KAAK;AAAA,mBACjB,SAAS,UAAa,KAAK;AAChC,iBAAK,IAAI,KAAK,mBAAmB,KAAK,QAAQ,MAAM,KAAK,CAAC;AAAA;AAE1D,kBAAM,IAAI,MAAM,+BAA+B,GAAG,qBAAqB,IAAI,EAAE;AAAA,QACrF;AAAA,MACJ;AAAA,IACJ;AACA,eAAW,gCAAgC;AAE3C,IAAAA,SAAQ,aAAa;AACrB,IAAAA,SAAQ,qBAAqB;AAC7B,IAAAA,SAAQ,cAAc;AAAA;AAAA;;;ACvJtB;AAAA,0IAAAC,UAAA;AAAA;AASA,QAAM,mBAAmB,wBAAC,QAAQ,IAAI,QAAQ,mBAAmB,GAAG,GAA3C;AACzB,aAAS,cAAc,SAAS,QAAQ;AACpC,UAAI,QAAQ,KAAK,OAAO;AACpB,eAAO,QAAQ,UAAU,CAAC;AAC9B,aAAO,SAAS,QAAQ,QAAQ,cAAc,MAAM,IAAI;AAAA,IAC5D;AAJS;AAKT,QAAM,cAAc,wBAAC,KAAK,QAAQ,YAAY,IAAI,SAAS,IAAI,IACzD,cAAc,SAAS,MAAM,IAC7B,QAAQ,SAAS,IAAI,IACjB,OAAO,cAAc,SAAS,MAAM,KACnC,IAAI,SAAS,GAAG,IAAI,KAAK,OAAO,SAJvB;AAMpB,IAAAA,SAAQ,gBAAgB;AACxB,IAAAA,SAAQ,cAAc;AACtB,IAAAA,SAAQ,mBAAmB;AAAA;AAAA;;;ACvB3B;AAAA,uIAAAC,UAAA;AAAA;AAEA,QAAM,YAAY;AAClB,QAAM,aAAa;AACnB,QAAM,cAAc;AAMpB,aAAS,cAAc,MAAM,QAAQ,OAAO,QAAQ,EAAE,eAAe,YAAY,IAAI,kBAAkB,IAAI,QAAQ,WAAW,IAAI,CAAC,GAAG;AAClI,UAAI,CAAC,aAAa,YAAY;AAC1B,eAAO;AACX,YAAM,UAAU,KAAK,IAAI,IAAI,iBAAiB,IAAI,YAAY,OAAO,MAAM;AAC3E,UAAI,KAAK,UAAU;AACf,eAAO;AACX,YAAM,QAAQ,CAAC;AACf,YAAM,eAAe,CAAC;AACtB,UAAI,MAAM,YAAY,OAAO;AAC7B,UAAI,OAAO,kBAAkB,UAAU;AACnC,YAAI,gBAAgB,YAAY,KAAK,IAAI,GAAG,eAAe;AACvD,gBAAM,KAAK,CAAC;AAAA;AAEZ,gBAAM,YAAY;AAAA,MAC1B;AACA,UAAI,QAAQ;AACZ,UAAI,OAAO;AACX,UAAI,WAAW;AACf,UAAI,IAAI;AACR,UAAI,WAAW;AACf,UAAI,SAAS;AACb,UAAI,SAAS,YAAY;AACrB,YAAI,yBAAyB,MAAM,CAAC;AACpC,YAAI,MAAM;AACN,gBAAM,IAAI;AAAA,MAClB;AACA,eAAS,IAAK,KAAK,KAAM,KAAK,CAAE,KAAK;AACjC,YAAI,SAAS,eAAe,OAAO,MAAM;AACrC,qBAAW;AACX,kBAAQ,KAAK,IAAI,CAAC,GAAG;AAAA,YACjB,KAAK;AACD,mBAAK;AACL;AAAA,YACJ,KAAK;AACD,mBAAK;AACL;AAAA,YACJ,KAAK;AACD,mBAAK;AACL;AAAA,YACJ;AACI,mBAAK;AAAA,UACb;AACA,mBAAS;AAAA,QACb;AACA,YAAI,OAAO,MAAM;AACb,cAAI,SAAS;AACT,gBAAI,yBAAyB,MAAM,CAAC;AACxC,gBAAM,IAAI;AACV,kBAAQ;AAAA,QACZ,OACK;AACD,cAAI,OAAO,OACP,QACA,SAAS,OACT,SAAS,QACT,SAAS,KAAM;AAEf,kBAAM,OAAO,KAAK,IAAI,CAAC;AACvB,gBAAI,QAAQ,SAAS,OAAO,SAAS,QAAQ,SAAS;AAClD,sBAAQ;AAAA,UAChB;AACA,cAAI,KAAK,KAAK;AACV,gBAAI,OAAO;AACP,oBAAM,KAAK,KAAK;AAChB,oBAAM,QAAQ;AACd,sBAAQ;AAAA,YACZ,WACS,SAAS,aAAa;AAE3B,qBAAO,SAAS,OAAO,SAAS,KAAM;AAClC,uBAAO;AACP,qBAAK,KAAM,KAAK,CAAE;AAClB,2BAAW;AAAA,cACf;AAEA,oBAAM,IAAI,IAAI,SAAS,IAAI,IAAI,IAAI,WAAW;AAE9C,kBAAI,aAAa,CAAC;AACd,uBAAO;AACX,oBAAM,KAAK,CAAC;AACZ,2BAAa,CAAC,IAAI;AAClB,oBAAM,IAAI;AACV,sBAAQ;AAAA,YACZ,OACK;AACD,yBAAW;AAAA,YACf;AAAA,UACJ;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AACA,UAAI,YAAY;AACZ,mBAAW;AACf,UAAI,MAAM,WAAW;AACjB,eAAO;AACX,UAAI;AACA,eAAO;AACX,UAAI,MAAM,KAAK,MAAM,GAAG,MAAM,CAAC,CAAC;AAChC,eAASC,KAAI,GAAGA,KAAI,MAAM,QAAQ,EAAEA,IAAG;AACnC,cAAM,OAAO,MAAMA,EAAC;AACpB,cAAMC,OAAM,MAAMD,KAAI,CAAC,KAAK,KAAK;AACjC,YAAI,SAAS;AACT,gBAAM;AAAA,EAAK,MAAM,GAAG,KAAK,MAAM,GAAGC,IAAG,CAAC;AAAA,aACrC;AACD,cAAI,SAAS,eAAe,aAAa,IAAI;AACzC,mBAAO,GAAG,KAAK,IAAI,CAAC;AACxB,iBAAO;AAAA,EAAK,MAAM,GAAG,KAAK,MAAM,OAAO,GAAGA,IAAG,CAAC;AAAA,QAClD;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AA9GS;AAmHT,aAAS,yBAAyB,MAAM,GAAG;AACvC,UAAI,KAAK,KAAK,IAAI,CAAC;AACnB,aAAO,OAAO,OAAO,OAAO,KAAM;AAC9B,WAAG;AACC,eAAK,KAAM,KAAK,CAAE;AAAA,QACtB,SAAS,MAAM,OAAO;AACtB,aAAK,KAAK,IAAI,CAAC;AAAA,MACnB;AACA,aAAO;AAAA,IACX;AATS;AAWT,IAAAF,SAAQ,aAAa;AACrB,IAAAA,SAAQ,YAAY;AACpB,IAAAA,SAAQ,cAAc;AACtB,IAAAA,SAAQ,gBAAgB;AAAA;AAAA;;;AC3IxB;AAAA,yIAAAG,UAAA;AAAA;AAEA,QAAI,SAAS;AACb,QAAI,gBAAgB;AAEpB,QAAM,iBAAiB,wBAAC,KAAK,aAAa;AAAA,MACtC,eAAe,UAAU,IAAI,OAAO,SAAS,IAAI;AAAA,MACjD,WAAW,IAAI,QAAQ;AAAA,MACvB,iBAAiB,IAAI,QAAQ;AAAA,IACjC,IAJuB;AAOvB,QAAM,yBAAyB,wBAAC,QAAQ,mBAAmB,KAAK,GAAG,GAApC;AAC/B,aAAS,oBAAoB,KAAK,WAAW,cAAc;AACvD,UAAI,CAAC,aAAa,YAAY;AAC1B,eAAO;AACX,YAAM,QAAQ,YAAY;AAC1B,YAAM,SAAS,IAAI;AACnB,UAAI,UAAU;AACV,eAAO;AACX,eAAS,IAAI,GAAG,QAAQ,GAAG,IAAI,QAAQ,EAAE,GAAG;AACxC,YAAI,IAAI,CAAC,MAAM,MAAM;AACjB,cAAI,IAAI,QAAQ;AACZ,mBAAO;AACX,kBAAQ,IAAI;AACZ,cAAI,SAAS,SAAS;AAClB,mBAAO;AAAA,QACf;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAjBS;AAkBT,aAAS,mBAAmB,OAAO,KAAK;AACpC,YAAM,OAAO,KAAK,UAAU,KAAK;AACjC,UAAI,IAAI,QAAQ;AACZ,eAAO;AACX,YAAM,EAAE,YAAY,IAAI;AACxB,YAAM,qBAAqB,IAAI,QAAQ;AACvC,YAAM,SAAS,IAAI,WAAW,uBAAuB,KAAK,IAAI,OAAO;AACrE,UAAI,MAAM;AACV,UAAI,QAAQ;AACZ,eAAS,IAAI,GAAG,KAAK,KAAK,CAAC,GAAG,IAAI,KAAK,KAAK,EAAE,CAAC,GAAG;AAC9C,YAAI,OAAO,OAAO,KAAK,IAAI,CAAC,MAAM,QAAQ,KAAK,IAAI,CAAC,MAAM,KAAK;AAE3D,iBAAO,KAAK,MAAM,OAAO,CAAC,IAAI;AAC9B,eAAK;AACL,kBAAQ;AACR,eAAK;AAAA,QACT;AACA,YAAI,OAAO;AACP,kBAAQ,KAAK,IAAI,CAAC,GAAG;AAAA,YACjB,KAAK;AACD;AACI,uBAAO,KAAK,MAAM,OAAO,CAAC;AAC1B,sBAAM,OAAO,KAAK,OAAO,IAAI,GAAG,CAAC;AACjC,wBAAQ,MAAM;AAAA,kBACV,KAAK;AACD,2BAAO;AACP;AAAA,kBACJ,KAAK;AACD,2BAAO;AACP;AAAA,kBACJ,KAAK;AACD,2BAAO;AACP;AAAA,kBACJ,KAAK;AACD,2BAAO;AACP;AAAA,kBACJ,KAAK;AACD,2BAAO;AACP;AAAA,kBACJ,KAAK;AACD,2BAAO;AACP;AAAA,kBACJ,KAAK;AACD,2BAAO;AACP;AAAA,kBACJ,KAAK;AACD,2BAAO;AACP;AAAA,kBACJ;AACI,wBAAI,KAAK,OAAO,GAAG,CAAC,MAAM;AACtB,6BAAO,QAAQ,KAAK,OAAO,CAAC;AAAA;AAE5B,6BAAO,KAAK,OAAO,GAAG,CAAC;AAAA,gBACnC;AACA,qBAAK;AACL,wBAAQ,IAAI;AAAA,cAChB;AACA;AAAA,YACJ,KAAK;AACD,kBAAI,eACA,KAAK,IAAI,CAAC,MAAM,OAChB,KAAK,SAAS,oBAAoB;AAClC,qBAAK;AAAA,cACT,OACK;AAED,uBAAO,KAAK,MAAM,OAAO,CAAC,IAAI;AAC9B,uBAAO,KAAK,IAAI,CAAC,MAAM,QACnB,KAAK,IAAI,CAAC,MAAM,OAChB,KAAK,IAAI,CAAC,MAAM,KAAK;AACrB,yBAAO;AACP,uBAAK;AAAA,gBACT;AACA,uBAAO;AAEP,oBAAI,KAAK,IAAI,CAAC,MAAM;AAChB,yBAAO;AACX,qBAAK;AACL,wBAAQ,IAAI;AAAA,cAChB;AACA;AAAA,YACJ;AACI,mBAAK;AAAA,UACb;AAAA,MACR;AACA,YAAM,QAAQ,MAAM,KAAK,MAAM,KAAK,IAAI;AACxC,aAAO,cACD,MACA,cAAc,cAAc,KAAK,QAAQ,cAAc,aAAa,eAAe,KAAK,KAAK,CAAC;AAAA,IACxG;AAzFS;AA0FT,aAAS,mBAAmB,OAAO,KAAK;AACpC,UAAI,IAAI,QAAQ,gBAAgB,SAC3B,IAAI,eAAe,MAAM,SAAS,IAAI,KACvC,kBAAkB,KAAK,KAAK;AAE5B,eAAO,mBAAmB,OAAO,GAAG;AACxC,YAAM,SAAS,IAAI,WAAW,uBAAuB,KAAK,IAAI,OAAO;AACrE,YAAM,MAAM,MAAM,MAAM,QAAQ,MAAM,IAAI,EAAE,QAAQ,QAAQ;AAAA,EAAO,MAAM,EAAE,IAAI;AAC/E,aAAO,IAAI,cACL,MACA,cAAc,cAAc,KAAK,QAAQ,cAAc,WAAW,eAAe,KAAK,KAAK,CAAC;AAAA,IACtG;AAXS;AAYT,aAAS,aAAa,OAAO,KAAK;AAC9B,YAAM,EAAE,YAAY,IAAI,IAAI;AAC5B,UAAI;AACJ,UAAI,gBAAgB;AAChB,aAAK;AAAA,WACJ;AACD,cAAM,YAAY,MAAM,SAAS,GAAG;AACpC,cAAM,YAAY,MAAM,SAAS,GAAG;AACpC,YAAI,aAAa,CAAC;AACd,eAAK;AAAA,iBACA,aAAa,CAAC;AACnB,eAAK;AAAA;AAEL,eAAK,cAAc,qBAAqB;AAAA,MAChD;AACA,aAAO,GAAG,OAAO,GAAG;AAAA,IACxB;AAhBS;AAmBT,QAAI;AACJ,QAAI;AACA,yBAAmB,IAAI,OAAO,0BAA0B,GAAG;AAAA,IAC/D,QACM;AACF,yBAAmB;AAAA,IACvB;AACA,aAAS,YAAY,EAAE,SAAS,MAAM,MAAM,GAAG,KAAK,WAAW,aAAa;AACxE,YAAM,EAAE,YAAY,eAAe,UAAU,IAAI,IAAI;AAGrD,UAAI,CAAC,cAAc,YAAY,KAAK,KAAK,KAAK,QAAQ,KAAK,KAAK,GAAG;AAC/D,eAAO,aAAa,OAAO,GAAG;AAAA,MAClC;AACA,YAAM,SAAS,IAAI,WACd,IAAI,oBAAoB,uBAAuB,KAAK,IAAI,OAAO;AACpE,YAAM,UAAU,eAAe,YACzB,OACA,eAAe,YAAY,SAAS,OAAO,OAAO,eAC9C,QACA,SAAS,OAAO,OAAO,gBACnB,OACA,CAAC,oBAAoB,OAAO,WAAW,OAAO,MAAM;AAClE,UAAI,CAAC;AACD,eAAO,UAAU,QAAQ;AAE7B,UAAI;AACJ,UAAI;AACJ,WAAK,WAAW,MAAM,QAAQ,WAAW,GAAG,EAAE,UAAU;AACpD,cAAM,KAAK,MAAM,WAAW,CAAC;AAC7B,YAAI,OAAO,QAAQ,OAAO,OAAQ,OAAO;AACrC;AAAA,MACR;AACA,UAAI,MAAM,MAAM,UAAU,QAAQ;AAClC,YAAM,WAAW,IAAI,QAAQ,IAAI;AACjC,UAAI,aAAa,IAAI;AACjB,gBAAQ;AAAA,MACZ,WACS,UAAU,OAAO,aAAa,IAAI,SAAS,GAAG;AACnD,gBAAQ;AACR,YAAI;AACA,sBAAY;AAAA,MACpB,OACK;AACD,gBAAQ;AAAA,MACZ;AACA,UAAI,KAAK;AACL,gBAAQ,MAAM,MAAM,GAAG,CAAC,IAAI,MAAM;AAClC,YAAI,IAAI,IAAI,SAAS,CAAC,MAAM;AACxB,gBAAM,IAAI,MAAM,GAAG,EAAE;AACzB,cAAM,IAAI,QAAQ,kBAAkB,KAAK,MAAM,EAAE;AAAA,MACrD;AAEA,UAAI,iBAAiB;AACrB,UAAI;AACJ,UAAI,aAAa;AACjB,WAAK,WAAW,GAAG,WAAW,MAAM,QAAQ,EAAE,UAAU;AACpD,cAAM,KAAK,MAAM,QAAQ;AACzB,YAAI,OAAO;AACP,2BAAiB;AAAA,iBACZ,OAAO;AACZ,uBAAa;AAAA;AAEb;AAAA,MACR;AACA,UAAI,QAAQ,MAAM,UAAU,GAAG,aAAa,WAAW,aAAa,IAAI,QAAQ;AAChF,UAAI,OAAO;AACP,gBAAQ,MAAM,UAAU,MAAM,MAAM;AACpC,gBAAQ,MAAM,QAAQ,QAAQ,KAAK,MAAM,EAAE;AAAA,MAC/C;AACA,YAAM,aAAa,SAAS,MAAM;AAClC,UAAI,UAAU,UAAU,MAAM,QAAQ,iBAAiB,aAAa,MAAM;AAC1E,UAAI,SAAS;AACT,kBAAU,MAAM,cAAc,QAAQ,QAAQ,cAAc,GAAG,CAAC;AAChE,YAAI;AACA,oBAAU;AAAA,MAClB;AACA,UAAI,SAAS;AACT,gBAAQ,MAAM,QAAQ,QAAQ,KAAK,MAAM,EAAE;AAC3C,eAAO,GAAG,MAAM;AAAA,EAAK,MAAM,GAAG,KAAK,GAAG,KAAK,GAAG,GAAG;AAAA,MACrD;AACA,cAAQ,MACH,QAAQ,QAAQ,MAAM,EACtB,QAAQ,kDAAkD,MAAM,EAEhE,QAAQ,QAAQ,KAAK,MAAM,EAAE;AAClC,YAAM,OAAO,cAAc,cAAc,GAAG,KAAK,GAAG,KAAK,GAAG,GAAG,IAAI,QAAQ,cAAc,YAAY,eAAe,KAAK,IAAI,CAAC;AAC9H,aAAO,GAAG,MAAM;AAAA,EAAK,MAAM,GAAG,IAAI;AAAA,IACtC;AAjFS;AAkFT,aAAS,YAAY,MAAM,KAAK,WAAW,aAAa;AACpD,YAAM,EAAE,MAAM,MAAM,IAAI;AACxB,YAAM,EAAE,cAAc,aAAa,QAAQ,YAAY,OAAO,IAAI;AAClE,UAAK,eAAe,MAAM,SAAS,IAAI,KAClC,UAAU,WAAW,KAAK,KAAK,GAAI;AACpC,eAAO,aAAa,OAAO,GAAG;AAAA,MAClC;AACA,UAAI,CAAC,SACD,oFAAoF,KAAK,KAAK,GAAG;AAOjG,eAAO,eAAe,UAAU,CAAC,MAAM,SAAS,IAAI,IAC9C,aAAa,OAAO,GAAG,IACvB,YAAY,MAAM,KAAK,WAAW,WAAW;AAAA,MACvD;AACA,UAAI,CAAC,eACD,CAAC,UACD,SAAS,OAAO,OAAO,SACvB,MAAM,SAAS,IAAI,GAAG;AAEtB,eAAO,YAAY,MAAM,KAAK,WAAW,WAAW;AAAA,MACxD;AACA,UAAI,uBAAuB,KAAK,GAAG;AAC/B,YAAI,WAAW,IAAI;AACf,cAAI,mBAAmB;AACvB,iBAAO,YAAY,MAAM,KAAK,WAAW,WAAW;AAAA,QACxD,WACS,eAAe,WAAW,YAAY;AAC3C,iBAAO,aAAa,OAAO,GAAG;AAAA,QAClC;AAAA,MACJ;AACA,YAAM,MAAM,MAAM,QAAQ,QAAQ;AAAA,EAAO,MAAM,EAAE;AAIjD,UAAI,cAAc;AACd,cAAM,OAAO,wBAAC,QAAQ,IAAI,WAAW,IAAI,QAAQ,2BAA2B,IAAI,MAAM,KAAK,GAAG,GAAjF;AACb,cAAM,EAAE,QAAQ,KAAK,IAAI,IAAI,IAAI;AACjC,YAAI,KAAK,KAAK,IAAI,KAAK,QAAQ,KAAK,IAAI;AACpC,iBAAO,aAAa,OAAO,GAAG;AAAA,MACtC;AACA,aAAO,cACD,MACA,cAAc,cAAc,KAAK,QAAQ,cAAc,WAAW,eAAe,KAAK,KAAK,CAAC;AAAA,IACtG;AAhDS;AAiDT,aAAS,gBAAgB,MAAM,KAAK,WAAW,aAAa;AACxD,YAAM,EAAE,aAAa,OAAO,IAAI;AAChC,YAAM,KAAK,OAAO,KAAK,UAAU,WAC3B,OACA,OAAO,OAAO,CAAC,GAAG,MAAM,EAAE,OAAO,OAAO,KAAK,KAAK,EAAE,CAAC;AAC3D,UAAI,EAAE,KAAK,IAAI;AACf,UAAI,SAAS,OAAO,OAAO,cAAc;AAErC,YAAI,kDAAkD,KAAK,GAAG,KAAK;AAC/D,iBAAO,OAAO,OAAO;AAAA,MAC7B;AACA,YAAM,aAAa,wBAAC,UAAU;AAC1B,gBAAQ,OAAO;AAAA,UACX,KAAK,OAAO,OAAO;AAAA,UACnB,KAAK,OAAO,OAAO;AACf,mBAAO,eAAe,SAChB,aAAa,GAAG,OAAO,GAAG,IAC1B,YAAY,IAAI,KAAK,WAAW,WAAW;AAAA,UACrD,KAAK,OAAO,OAAO;AACf,mBAAO,mBAAmB,GAAG,OAAO,GAAG;AAAA,UAC3C,KAAK,OAAO,OAAO;AACf,mBAAO,mBAAmB,GAAG,OAAO,GAAG;AAAA,UAC3C,KAAK,OAAO,OAAO;AACf,mBAAO,YAAY,IAAI,KAAK,WAAW,WAAW;AAAA,UACtD;AACI,mBAAO;AAAA,QACf;AAAA,MACJ,GAhBmB;AAiBnB,UAAI,MAAM,WAAW,IAAI;AACzB,UAAI,QAAQ,MAAM;AACd,cAAM,EAAE,gBAAgB,kBAAkB,IAAI,IAAI;AAClD,cAAM,IAAK,eAAe,kBAAmB;AAC7C,cAAM,WAAW,CAAC;AAClB,YAAI,QAAQ;AACR,gBAAM,IAAI,MAAM,mCAAmC,CAAC,EAAE;AAAA,MAC9D;AACA,aAAO;AAAA,IACX;AArCS;AAuCT,IAAAA,SAAQ,kBAAkB;AAAA;AAAA;;;ACzU1B;AAAA,mIAAAC,UAAA;AAAA;AAEA,QAAI,UAAU;AACd,QAAI,WAAW;AACf,QAAI,mBAAmB;AACvB,QAAI,kBAAkB;AAEtB,aAAS,uBAAuB,KAAK,SAAS;AAC1C,YAAM,MAAM,OAAO,OAAO;AAAA,QACtB,YAAY;AAAA,QACZ,eAAe,iBAAiB;AAAA,QAChC,gBAAgB;AAAA,QAChB,mBAAmB;AAAA,QACnB,YAAY;AAAA,QACZ,oBAAoB;AAAA,QACpB,gCAAgC;AAAA,QAChC,UAAU;AAAA,QACV,uBAAuB;AAAA,QACvB,WAAW;AAAA,QACX,WAAW;AAAA,QACX,iBAAiB;AAAA,QACjB,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,aAAa;AAAA,QACb,SAAS;AAAA,QACT,kBAAkB;AAAA,MACtB,GAAG,IAAI,OAAO,iBAAiB,OAAO;AACtC,UAAI;AACJ,cAAQ,IAAI,iBAAiB;AAAA,QACzB,KAAK;AACD,mBAAS;AACT;AAAA,QACJ,KAAK;AACD,mBAAS;AACT;AAAA,QACJ;AACI,mBAAS;AAAA,MACjB;AACA,aAAO;AAAA,QACH,SAAS,oBAAI,IAAI;AAAA,QACjB;AAAA,QACA,uBAAuB,IAAI,wBAAwB,MAAM;AAAA,QACzD,QAAQ;AAAA,QACR,YAAY,OAAO,IAAI,WAAW,WAAW,IAAI,OAAO,IAAI,MAAM,IAAI;AAAA,QACtE;AAAA,QACA,SAAS;AAAA,MACb;AAAA,IACJ;AAxCS;AAyCT,aAAS,aAAa,MAAM,MAAM;AAC9B,UAAI,KAAK,KAAK;AACV,cAAM,QAAQ,KAAK,OAAO,OAAK,EAAE,QAAQ,KAAK,GAAG;AACjD,YAAI,MAAM,SAAS;AACf,iBAAO,MAAM,KAAK,OAAK,EAAE,WAAW,KAAK,MAAM,KAAK,MAAM,CAAC;AAAA,MACnE;AACA,UAAI,SAAS;AACb,UAAI;AACJ,UAAI,SAAS,SAAS,IAAI,GAAG;AACzB,cAAM,KAAK;AACX,cAAM,QAAQ,KAAK,OAAO,OAAK,EAAE,WAAW,GAAG,CAAC;AAChD,iBACI,MAAM,KAAK,OAAK,EAAE,WAAW,KAAK,MAAM,KAAK,MAAM,KAAK,OAAK,CAAC,EAAE,MAAM;AAAA,MAC9E,OACK;AACD,cAAM;AACN,iBAAS,KAAK,KAAK,OAAK,EAAE,aAAa,eAAe,EAAE,SAAS;AAAA,MACrE;AACA,UAAI,CAAC,QAAQ;AACT,cAAM,OAAO,KAAK,aAAa,QAAQ,OAAO;AAC9C,cAAM,IAAI,MAAM,wBAAwB,IAAI,QAAQ;AAAA,MACxD;AACA,aAAO;AAAA,IACX;AAvBS;AAyBT,aAAS,eAAe,MAAM,QAAQ,EAAE,SAAS,WAAW,IAAI,GAAG;AAC/D,UAAI,CAAC,IAAI;AACL,eAAO;AACX,YAAM,QAAQ,CAAC;AACf,YAAM,UAAU,SAAS,SAAS,IAAI,KAAK,SAAS,aAAa,IAAI,MAAM,KAAK;AAChF,UAAI,UAAU,QAAQ,cAAc,MAAM,GAAG;AACzC,kBAAU,IAAI,MAAM;AACpB,cAAM,KAAK,IAAI,MAAM,EAAE;AAAA,MAC3B;AACA,YAAM,MAAM,KAAK,MAAM,KAAK,MAAM,OAAO,UAAU,OAAO,OAAO;AACjE,UAAI;AACA,cAAM,KAAK,IAAI,WAAW,UAAU,GAAG,CAAC;AAC5C,aAAO,MAAM,KAAK,GAAG;AAAA,IACzB;AAbS;AAcT,aAAS,UAAU,MAAM,KAAK,WAAW,aAAa;AAClD,UAAI,SAAS,OAAO,IAAI;AACpB,eAAO,KAAK,SAAS,KAAK,WAAW,WAAW;AACpD,UAAI,SAAS,QAAQ,IAAI,GAAG;AACxB,YAAI,IAAI,IAAI;AACR,iBAAO,KAAK,SAAS,GAAG;AAC5B,YAAI,IAAI,iBAAiB,IAAI,IAAI,GAAG;AAChC,gBAAM,IAAI,UAAU,yDAAyD;AAAA,QACjF,OACK;AACD,cAAI,IAAI;AACJ,gBAAI,gBAAgB,IAAI,IAAI;AAAA;AAE5B,gBAAI,kBAAkB,oBAAI,IAAI,CAAC,IAAI,CAAC;AACxC,iBAAO,KAAK,QAAQ,IAAI,GAAG;AAAA,QAC/B;AAAA,MACJ;AACA,UAAI,SAAS;AACb,YAAM,OAAO,SAAS,OAAO,IAAI,IAC3B,OACA,IAAI,IAAI,WAAW,MAAM,EAAE,UAAU,OAAM,SAAS,EAAG,CAAC;AAC9D,UAAI,CAAC;AACD,iBAAS,aAAa,IAAI,IAAI,OAAO,MAAM,IAAI;AACnD,YAAM,QAAQ,eAAe,MAAM,QAAQ,GAAG;AAC9C,UAAI,MAAM,SAAS;AACf,YAAI,iBAAiB,IAAI,iBAAiB,KAAK,MAAM,SAAS;AAClE,YAAM,MAAM,OAAO,OAAO,cAAc,aAClC,OAAO,UAAU,MAAM,KAAK,WAAW,WAAW,IAClD,SAAS,SAAS,IAAI,IAClB,gBAAgB,gBAAgB,MAAM,KAAK,WAAW,WAAW,IACjE,KAAK,SAAS,KAAK,WAAW,WAAW;AACnD,UAAI,CAAC;AACD,eAAO;AACX,aAAO,SAAS,SAAS,IAAI,KAAK,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,MACzD,GAAG,KAAK,IAAI,GAAG,KACf,GAAG,KAAK;AAAA,EAAK,IAAI,MAAM,GAAG,GAAG;AAAA,IACvC;AApCS;AAsCT,IAAAA,SAAQ,yBAAyB;AACjC,IAAAA,SAAQ,YAAY;AAAA;AAAA;;;AC9HpB;AAAA,uIAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,YAAY;AAChB,QAAI,mBAAmB;AAEvB,aAAS,cAAc,EAAE,KAAK,MAAM,GAAG,KAAK,WAAW,aAAa;AAChE,YAAM,EAAE,eAAe,KAAK,QAAQ,YAAY,SAAS,EAAE,eAAe,WAAW,WAAW,EAAE,IAAI;AACtG,UAAI,aAAc,SAAS,OAAO,GAAG,KAAK,IAAI,WAAY;AAC1D,UAAI,YAAY;AACZ,YAAI,YAAY;AACZ,gBAAM,IAAI,MAAM,kDAAkD;AAAA,QACtE;AACA,YAAI,SAAS,aAAa,GAAG,GAAG;AAC5B,gBAAM,MAAM;AACZ,gBAAM,IAAI,MAAM,GAAG;AAAA,QACvB;AAAA,MACJ;AACA,UAAI,cAAc,CAAC,eACd,CAAC,OACG,cAAc,SAAS,QAAQ,CAAC,IAAI,UACrC,SAAS,aAAa,GAAG,MACxB,SAAS,SAAS,GAAG,IAChB,IAAI,SAAS,OAAO,OAAO,gBAAgB,IAAI,SAAS,OAAO,OAAO,gBACtE,OAAO,QAAQ;AAC7B,YAAM,OAAO,OAAO,CAAC,GAAG,KAAK;AAAA,QACzB,eAAe;AAAA,QACf,aAAa,CAAC,gBAAgB,cAAc,CAAC;AAAA,QAC7C,QAAQ,SAAS;AAAA,MACrB,CAAC;AACD,UAAI,iBAAiB;AACrB,UAAI,YAAY;AAChB,UAAI,MAAM,UAAU,UAAU,KAAK,KAAK,MAAO,iBAAiB,MAAO,MAAO,YAAY,IAAK;AAC/F,UAAI,CAAC,eAAe,CAAC,IAAI,UAAU,IAAI,SAAS,MAAM;AAClD,YAAI;AACA,gBAAM,IAAI,MAAM,8EAA8E;AAClG,sBAAc;AAAA,MAClB;AACA,UAAI,IAAI,QAAQ;AACZ,YAAI,iBAAiB,SAAS,MAAM;AAChC,cAAI,kBAAkB;AAClB,sBAAU;AACd,iBAAO,QAAQ,KAAK,MAAM,cAAc,KAAK,GAAG,KAAK;AAAA,QACzD;AAAA,MACJ,WACU,iBAAiB,CAAC,cAAgB,SAAS,QAAQ,aAAc;AACvE,cAAM,KAAK,GAAG;AACd,YAAI,cAAc,CAAC,gBAAgB;AAC/B,iBAAO,iBAAiB,YAAY,KAAK,IAAI,QAAQ,cAAc,UAAU,CAAC;AAAA,QAClF,WACS,aAAa;AAClB,sBAAY;AAChB,eAAO;AAAA,MACX;AACA,UAAI;AACA,qBAAa;AACjB,UAAI,aAAa;AACb,YAAI;AACA,iBAAO,iBAAiB,YAAY,KAAK,IAAI,QAAQ,cAAc,UAAU,CAAC;AAClF,cAAM,KAAK,GAAG;AAAA,EAAK,MAAM;AAAA,MAC7B,OACK;AACD,cAAM,GAAG,GAAG;AACZ,YAAI;AACA,iBAAO,iBAAiB,YAAY,KAAK,IAAI,QAAQ,cAAc,UAAU,CAAC;AAAA,MACtF;AACA,UAAI,KAAK,KAAK;AACd,UAAI,SAAS,OAAO,KAAK,GAAG;AACxB,cAAM,CAAC,CAAC,MAAM;AACd,cAAM,MAAM;AACZ,uBAAe,MAAM;AAAA,MACzB,OACK;AACD,cAAM;AACN,cAAM;AACN,uBAAe;AACf,YAAI,SAAS,OAAO,UAAU;AAC1B,kBAAQ,IAAI,WAAW,KAAK;AAAA,MACpC;AACA,UAAI,cAAc;AAClB,UAAI,CAAC,eAAe,CAAC,cAAc,SAAS,SAAS,KAAK;AACtD,YAAI,gBAAgB,IAAI,SAAS;AACrC,kBAAY;AACZ,UAAI,CAAC,aACD,WAAW,UAAU,KACrB,CAAC,IAAI,UACL,CAAC,eACD,SAAS,MAAM,KAAK,KACpB,CAAC,MAAM,QACP,CAAC,MAAM,OACP,CAAC,MAAM,QAAQ;AAEf,YAAI,SAAS,IAAI,OAAO,UAAU,CAAC;AAAA,MACvC;AACA,UAAI,mBAAmB;AACvB,YAAM,WAAW,UAAU,UAAU,OAAO,KAAK,MAAO,mBAAmB,MAAO,MAAO,YAAY,IAAK;AAC1G,UAAI,KAAK;AACT,UAAI,cAAc,OAAO,KAAK;AAC1B,aAAK,MAAM,OAAO;AAClB,YAAI,KAAK;AACL,gBAAM,KAAK,cAAc,GAAG;AAC5B,gBAAM;AAAA,EAAK,iBAAiB,cAAc,IAAI,IAAI,MAAM,CAAC;AAAA,QAC7D;AACA,YAAI,aAAa,MAAM,CAAC,IAAI,QAAQ;AAChC,cAAI,OAAO;AACP,iBAAK;AAAA,QACb,OACK;AACD,gBAAM;AAAA,EAAK,IAAI,MAAM;AAAA,QACzB;AAAA,MACJ,WACS,CAAC,eAAe,SAAS,aAAa,KAAK,GAAG;AACnD,cAAM,MAAM,SAAS,CAAC;AACtB,cAAM,MAAM,SAAS,QAAQ,IAAI;AACjC,cAAM,aAAa,QAAQ;AAC3B,cAAM,OAAO,IAAI,UAAU,MAAM,QAAQ,MAAM,MAAM,WAAW;AAChE,YAAI,cAAc,CAAC,MAAM;AACrB,cAAI,eAAe;AACnB,cAAI,eAAe,QAAQ,OAAO,QAAQ,MAAM;AAC5C,gBAAI,MAAM,SAAS,QAAQ,GAAG;AAC9B,gBAAI,QAAQ,OACR,QAAQ,MACR,MAAM,OACN,SAAS,MAAM,CAAC,MAAM,KAAK;AAC3B,oBAAM,SAAS,QAAQ,KAAK,MAAM,CAAC;AAAA,YACvC;AACA,gBAAI,QAAQ,MAAM,MAAM;AACpB,6BAAe;AAAA,UACvB;AACA,cAAI,CAAC;AACD,iBAAK;AAAA,EAAK,IAAI,MAAM;AAAA,QAC5B;AAAA,MACJ,WACS,aAAa,MAAM,SAAS,CAAC,MAAM,MAAM;AAC9C,aAAK;AAAA,MACT;AACA,aAAO,KAAK;AACZ,UAAI,IAAI,QAAQ;AACZ,YAAI,oBAAoB;AACpB,oBAAU;AAAA,MAClB,WACS,gBAAgB,CAAC,kBAAkB;AACxC,eAAO,iBAAiB,YAAY,KAAK,IAAI,QAAQ,cAAc,YAAY,CAAC;AAAA,MACpF,WACS,aAAa,aAAa;AAC/B,oBAAY;AAAA,MAChB;AACA,aAAO;AAAA,IACX;AA9IS;AAgJT,IAAAA,SAAQ,gBAAgB;AAAA;AAAA;;;ACvJxB;AAAA,mHAAAC,UAAA;AAAA;AAEA,aAAS,MAAM,aAAa,UAAU;AAClC,UAAI,aAAa;AACb,gBAAQ,IAAI,GAAG,QAAQ;AAAA,IAC/B;AAHS;AAIT,aAAS,KAAK,UAAU,SAAS;AAC7B,UAAI,aAAa,WAAW,aAAa,QAAQ;AAG7C,YAAI,OAAO,YAAY,eAAe,QAAQ;AAC1C,kBAAQ,YAAY,OAAO;AAAA;AAE3B,kBAAQ,KAAK,OAAO;AAAA,MAC5B;AAAA,IACJ;AATS;AAWT,IAAAA,SAAQ,QAAQ;AAChB,IAAAA,SAAQ,OAAO;AAAA;AAAA;;;AClBf;AAAA,oIAAAC,UAAA;AAAA;AAEA,QAAI,MAAM;AACV,QAAI,YAAY;AAChB,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,OAAO;AAEX,QAAM,YAAY;AAClB,aAAS,eAAe,KAAK,KAAK,EAAE,KAAK,MAAM,GAAG;AAC9C,UAAI,KAAK,IAAI,OAAO,SAAS,WAAW,GAAG,GAAG;AAC1C,gBAAQ,SAAS,QAAQ,KAAK,IAAI,MAAM,QAAQ,IAAI,GAAG,IAAI;AAC3D,YAAI,SAAS,MAAM,KAAK;AACpB,qBAAW,MAAM,MAAM;AACnB,yBAAa,KAAK,KAAK,EAAE;AAAA,iBACxB,MAAM,QAAQ,KAAK;AACxB,qBAAW,MAAM;AACb,yBAAa,KAAK,KAAK,EAAE;AAAA;AAE7B,uBAAa,KAAK,KAAK,KAAK;AAAA,MACpC,OACK;AACD,cAAM,QAAQ,KAAK,KAAK,KAAK,IAAI,GAAG;AACpC,YAAI,eAAe,KAAK;AACpB,cAAI,IAAI,OAAO,KAAK,KAAK,OAAO,OAAO,GAAG,CAAC;AAAA,QAC/C,WACS,eAAe,KAAK;AACzB,cAAI,IAAI,KAAK;AAAA,QACjB,OACK;AACD,gBAAM,YAAY,aAAa,KAAK,OAAO,GAAG;AAC9C,gBAAM,UAAU,KAAK,KAAK,OAAO,WAAW,GAAG;AAC/C,cAAI,aAAa;AACb,mBAAO,eAAe,KAAK,WAAW;AAAA,cAClC,OAAO;AAAA,cACP,UAAU;AAAA,cACV,YAAY;AAAA,cACZ,cAAc;AAAA,YAClB,CAAC;AAAA;AAED,gBAAI,SAAS,IAAI;AAAA,QACzB;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAnCS;AAoCT,QAAM,aAAa,wBAAC,QAAQ,QAAQ,aAC/B,SAAS,SAAS,GAAG,KAClB,IAAI,UAAU,cACb,CAAC,IAAI,QAAQ,IAAI,SAAS,OAAO,OAAO,QAH9B;AAWnB,aAAS,aAAa,KAAK,KAAK,OAAO;AACnC,YAAM,SAAS,OAAO,SAAS,QAAQ,KAAK,IAAI,MAAM,QAAQ,IAAI,GAAG,IAAI;AACzE,UAAI,CAAC,SAAS,MAAM,MAAM;AACtB,cAAM,IAAI,MAAM,2CAA2C;AAC/D,YAAM,SAAS,OAAO,OAAO,MAAM,KAAK,GAAG;AAC3C,iBAAW,CAAC,KAAKC,MAAK,KAAK,QAAQ;AAC/B,YAAI,eAAe,KAAK;AACpB,cAAI,CAAC,IAAI,IAAI,GAAG;AACZ,gBAAI,IAAI,KAAKA,MAAK;AAAA,QAC1B,WACS,eAAe,KAAK;AACzB,cAAI,IAAI,GAAG;AAAA,QACf,WACS,CAAC,OAAO,UAAU,eAAe,KAAK,KAAK,GAAG,GAAG;AACtD,iBAAO,eAAe,KAAK,KAAK;AAAA,YAC5B,OAAAA;AAAA,YACA,UAAU;AAAA,YACV,YAAY;AAAA,YACZ,cAAc;AAAA,UAClB,CAAC;AAAA,QACL;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAvBS;AAwBT,aAAS,aAAa,KAAK,OAAO,KAAK;AACnC,UAAI,UAAU;AACV,eAAO;AACX,UAAI,OAAO,UAAU;AACjB,eAAO,OAAO,KAAK;AACvB,UAAI,SAAS,OAAO,GAAG,KAAK,KAAK,KAAK;AAClC,cAAM,SAAS,UAAU,uBAAuB,IAAI,KAAK,CAAC,CAAC;AAC3D,eAAO,UAAU,oBAAI,IAAI;AACzB,mBAAW,QAAQ,IAAI,QAAQ,KAAK;AAChC,iBAAO,QAAQ,IAAI,KAAK,MAAM;AAClC,eAAO,SAAS;AAChB,eAAO,iBAAiB;AACxB,cAAM,SAAS,IAAI,SAAS,MAAM;AAClC,YAAI,CAAC,IAAI,cAAc;AACnB,cAAI,UAAU,KAAK,UAAU,MAAM;AACnC,cAAI,QAAQ,SAAS;AACjB,sBAAU,QAAQ,UAAU,GAAG,EAAE,IAAI;AACzC,cAAI,KAAK,IAAI,IAAI,QAAQ,UAAU,kFAAkF,OAAO,0CAA0C;AACtK,cAAI,eAAe;AAAA,QACvB;AACA,eAAO;AAAA,MACX;AACA,aAAO,KAAK,UAAU,KAAK;AAAA,IAC/B;AAvBS;AAyBT,IAAAD,SAAQ,iBAAiB;AAAA;AAAA;;;ACzGzB;AAAA,0HAAAE,UAAA;AAAA;AAEA,QAAI,aAAa;AACjB,QAAI,gBAAgB;AACpB,QAAI,iBAAiB;AACrB,QAAI,WAAW;AAEf,aAAS,WAAW,KAAK,OAAO,KAAK;AACjC,YAAM,IAAI,WAAW,WAAW,KAAK,QAAW,GAAG;AACnD,YAAM,IAAI,WAAW,WAAW,OAAO,QAAW,GAAG;AACrD,aAAO,IAAI,KAAK,GAAG,CAAC;AAAA,IACxB;AAJS;AAKT,QAAM,OAAN,MAAM,MAAK;AAAA,MAZX,OAYW;AAAA;AAAA;AAAA,MACP,YAAY,KAAK,QAAQ,MAAM;AAC3B,eAAO,eAAe,MAAM,SAAS,WAAW,EAAE,OAAO,SAAS,KAAK,CAAC;AACxE,aAAK,MAAM;AACX,aAAK,QAAQ;AAAA,MACjB;AAAA,MACA,MAAM,QAAQ;AACV,YAAI,EAAE,KAAK,MAAM,IAAI;AACrB,YAAI,SAAS,OAAO,GAAG;AACnB,gBAAM,IAAI,MAAM,MAAM;AAC1B,YAAI,SAAS,OAAO,KAAK;AACrB,kBAAQ,MAAM,MAAM,MAAM;AAC9B,eAAO,IAAI,MAAK,KAAK,KAAK;AAAA,MAC9B;AAAA,MACA,OAAO,GAAG,KAAK;AACX,cAAM,OAAO,KAAK,WAAW,oBAAI,IAAI,IAAI,CAAC;AAC1C,eAAO,eAAe,eAAe,KAAK,MAAM,IAAI;AAAA,MACxD;AAAA,MACA,SAAS,KAAK,WAAW,aAAa;AAClC,eAAO,KAAK,MACN,cAAc,cAAc,MAAM,KAAK,WAAW,WAAW,IAC7D,KAAK,UAAU,IAAI;AAAA,MAC7B;AAAA,IACJ;AAEA,IAAAA,SAAQ,OAAO;AACf,IAAAA,SAAQ,aAAa;AAAA;AAAA;;;ACtCrB;AAAA,6IAAAC,UAAA;AAAA;AAEA,QAAI,aAAa;AACjB,QAAI,WAAW;AACf,QAAI,YAAY;AAChB,QAAI,mBAAmB;AAEvB,aAAS,oBAAoB,YAAY,KAAK,SAAS;AACnD,YAAM,OAAO,IAAI,UAAU,WAAW;AACtC,YAAMC,aAAY,OAAO,0BAA0B;AACnD,aAAOA,WAAU,YAAY,KAAK,OAAO;AAAA,IAC7C;AAJS;AAKT,aAAS,yBAAyB,EAAE,SAAS,MAAM,GAAG,KAAK,EAAE,iBAAiB,WAAW,YAAY,aAAa,UAAU,GAAG;AAC3H,YAAM,EAAE,QAAQ,SAAS,EAAE,cAAc,EAAE,IAAI;AAC/C,YAAM,UAAU,OAAO,OAAO,CAAC,GAAG,KAAK,EAAE,QAAQ,YAAY,MAAM,KAAK,CAAC;AACzE,UAAI,YAAY;AAChB,YAAM,QAAQ,CAAC;AACf,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACnC,cAAM,OAAO,MAAM,CAAC;AACpB,YAAIC,WAAU;AACd,YAAI,SAAS,OAAO,IAAI,GAAG;AACvB,cAAI,CAAC,aAAa,KAAK;AACnB,kBAAM,KAAK,EAAE;AACjB,2BAAiB,KAAK,OAAO,KAAK,eAAe,SAAS;AAC1D,cAAI,KAAK;AACL,YAAAA,WAAU,KAAK;AAAA,QACvB,WACS,SAAS,OAAO,IAAI,GAAG;AAC5B,gBAAM,KAAK,SAAS,OAAO,KAAK,GAAG,IAAI,KAAK,MAAM;AAClD,cAAI,IAAI;AACJ,gBAAI,CAAC,aAAa,GAAG;AACjB,oBAAM,KAAK,EAAE;AACjB,6BAAiB,KAAK,OAAO,GAAG,eAAe,SAAS;AAAA,UAC5D;AAAA,QACJ;AACA,oBAAY;AACZ,YAAIC,OAAM,UAAU,UAAU,MAAM,SAAS,MAAOD,WAAU,MAAO,MAAO,YAAY,IAAK;AAC7F,YAAIA;AACA,UAAAC,QAAO,iBAAiB,YAAYA,MAAK,YAAY,cAAcD,QAAO,CAAC;AAC/E,YAAI,aAAaA;AACb,sBAAY;AAChB,cAAM,KAAK,kBAAkBC,IAAG;AAAA,MACpC;AACA,UAAI;AACJ,UAAI,MAAM,WAAW,GAAG;AACpB,cAAM,UAAU,QAAQ,UAAU;AAAA,MACtC,OACK;AACD,cAAM,MAAM,CAAC;AACb,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACnC,gBAAM,OAAO,MAAM,CAAC;AACpB,iBAAO,OAAO;AAAA,EAAK,MAAM,GAAG,IAAI,KAAK;AAAA,QACzC;AAAA,MACJ;AACA,UAAI,SAAS;AACT,eAAO,OAAO,iBAAiB,cAAc,cAAc,OAAO,GAAG,MAAM;AAC3E,YAAI;AACA,oBAAU;AAAA,MAClB,WACS,aAAa;AAClB,oBAAY;AAChB,aAAO;AAAA,IACX;AAlDS;AAmDT,aAAS,wBAAwB,EAAE,SAAS,MAAM,GAAG,KAAK,EAAE,WAAW,YAAY,UAAU,GAAG;AAC5F,YAAM,EAAE,QAAQ,YAAY,uBAAuB,WAAW,SAAS,EAAE,cAAc,EAAE,IAAI;AAC7F,oBAAc;AACd,YAAM,UAAU,OAAO,OAAO,CAAC,GAAG,KAAK;AAAA,QACnC,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,MAAM;AAAA,MACV,CAAC;AACD,UAAI,aAAa;AACjB,UAAI,eAAe;AACnB,YAAM,QAAQ,CAAC;AACf,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACnC,cAAM,OAAO,MAAM,CAAC;AACpB,YAAID,WAAU;AACd,YAAI,SAAS,OAAO,IAAI,GAAG;AACvB,cAAI,KAAK;AACL,kBAAM,KAAK,EAAE;AACjB,2BAAiB,KAAK,OAAO,KAAK,eAAe,KAAK;AACtD,cAAI,KAAK;AACL,YAAAA,WAAU,KAAK;AAAA,QACvB,WACS,SAAS,OAAO,IAAI,GAAG;AAC5B,gBAAM,KAAK,SAAS,OAAO,KAAK,GAAG,IAAI,KAAK,MAAM;AAClD,cAAI,IAAI;AACJ,gBAAI,GAAG;AACH,oBAAM,KAAK,EAAE;AACjB,6BAAiB,KAAK,OAAO,GAAG,eAAe,KAAK;AACpD,gBAAI,GAAG;AACH,2BAAa;AAAA,UACrB;AACA,gBAAM,KAAK,SAAS,OAAO,KAAK,KAAK,IAAI,KAAK,QAAQ;AACtD,cAAI,IAAI;AACJ,gBAAI,GAAG;AACH,cAAAA,WAAU,GAAG;AACjB,gBAAI,GAAG;AACH,2BAAa;AAAA,UACrB,WACS,KAAK,SAAS,QAAQ,IAAI,SAAS;AACxC,YAAAA,WAAU,GAAG;AAAA,UACjB;AAAA,QACJ;AACA,YAAIA;AACA,uBAAa;AACjB,YAAIC,OAAM,UAAU,UAAU,MAAM,SAAS,MAAOD,WAAU,IAAK;AACnE,YAAI,IAAI,MAAM,SAAS;AACnB,UAAAC,QAAO;AACX,YAAID;AACA,UAAAC,QAAO,iBAAiB,YAAYA,MAAK,YAAY,cAAcD,QAAO,CAAC;AAC/E,YAAI,CAAC,eAAe,MAAM,SAAS,gBAAgBC,KAAI,SAAS,IAAI;AAChE,uBAAa;AACjB,cAAM,KAAKA,IAAG;AACd,uBAAe,MAAM;AAAA,MACzB;AACA,UAAI;AACJ,YAAM,EAAE,OAAO,IAAI,IAAI;AACvB,UAAI,MAAM,WAAW,GAAG;AACpB,cAAM,QAAQ;AAAA,MAClB,OACK;AACD,YAAI,CAAC,YAAY;AACb,gBAAM,MAAM,MAAM,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,SAAS,GAAG,CAAC;AAChE,uBAAa,MAAM,WAAW,WAAW;AAAA,QAC7C;AACA,YAAI,YAAY;AACZ,gBAAM;AACN,qBAAW,QAAQ;AACf,mBAAO,OAAO;AAAA,EAAK,UAAU,GAAG,MAAM,GAAG,IAAI,KAAK;AACtD,iBAAO;AAAA,EAAK,MAAM,GAAG,GAAG;AAAA,QAC5B,OACK;AACD,gBAAM,GAAG,KAAK,GAAG,SAAS,GAAG,MAAM,KAAK,GAAG,CAAC,GAAG,SAAS,GAAG,GAAG;AAAA,QAClE;AAAA,MACJ;AACA,UAAI,SAAS;AACT,eAAO,iBAAiB,YAAY,KAAK,QAAQ,cAAc,OAAO,CAAC;AACvE,YAAI;AACA,oBAAU;AAAA,MAClB;AACA,aAAO;AAAA,IACX;AA/ES;AAgFT,aAAS,iBAAiB,EAAE,QAAQ,SAAS,EAAE,cAAc,EAAE,GAAG,OAAO,SAAS,WAAW;AACzF,UAAI,WAAW;AACX,kBAAU,QAAQ,QAAQ,QAAQ,EAAE;AACxC,UAAI,SAAS;AACT,cAAM,KAAK,iBAAiB,cAAc,cAAc,OAAO,GAAG,MAAM;AACxE,cAAM,KAAK,GAAG,UAAU,CAAC;AAAA,MAC7B;AAAA,IACJ;AAPS;AAST,IAAAH,SAAQ,sBAAsB;AAAA;AAAA;;;ACxJ9B;AAAA,6HAAAI,UAAA;AAAA;AAEA,QAAI,sBAAsB;AAC1B,QAAI,iBAAiB;AACrB,QAAI,aAAa;AACjB,QAAI,WAAW;AACf,QAAI,OAAO;AACX,QAAI,SAAS;AAEb,aAAS,SAAS,OAAO,KAAK;AAC1B,YAAM,IAAI,SAAS,SAAS,GAAG,IAAI,IAAI,QAAQ;AAC/C,iBAAW,MAAM,OAAO;AACpB,YAAI,SAAS,OAAO,EAAE,GAAG;AACrB,cAAI,GAAG,QAAQ,OAAO,GAAG,QAAQ;AAC7B,mBAAO;AACX,cAAI,SAAS,SAAS,GAAG,GAAG,KAAK,GAAG,IAAI,UAAU;AAC9C,mBAAO;AAAA,QACf;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAXS;AAYT,QAAM,UAAN,cAAsB,WAAW,WAAW;AAAA,MArB5C,OAqB4C;AAAA;AAAA;AAAA,MACxC,WAAW,UAAU;AACjB,eAAO;AAAA,MACX;AAAA,MACA,YAAY,QAAQ;AAChB,cAAM,SAAS,KAAK,MAAM;AAC1B,aAAK,QAAQ,CAAC;AAAA,MAClB;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,OAAO,KAAK,QAAQ,KAAK,KAAK;AAC1B,cAAM,EAAE,eAAe,SAAS,IAAI;AACpC,cAAM,MAAM,IAAI,KAAK,MAAM;AAC3B,cAAM,MAAM,wBAAC,KAAK,UAAU;AACxB,cAAI,OAAO,aAAa;AACpB,oBAAQ,SAAS,KAAK,KAAK,KAAK,KAAK;AAAA,mBAChC,MAAM,QAAQ,QAAQ,KAAK,CAAC,SAAS,SAAS,GAAG;AACtD;AACJ,cAAI,UAAU,UAAa;AACvB,gBAAI,MAAM,KAAK,KAAK,WAAW,KAAK,OAAO,GAAG,CAAC;AAAA,QACvD,GAPY;AAQZ,YAAI,eAAe,KAAK;AACpB,qBAAW,CAAC,KAAK,KAAK,KAAK;AACvB,gBAAI,KAAK,KAAK;AAAA,QACtB,WACS,OAAO,OAAO,QAAQ,UAAU;AACrC,qBAAW,OAAO,OAAO,KAAK,GAAG;AAC7B,gBAAI,KAAK,IAAI,GAAG,CAAC;AAAA,QACzB;AACA,YAAI,OAAO,OAAO,mBAAmB,YAAY;AAC7C,cAAI,MAAM,KAAK,OAAO,cAAc;AAAA,QACxC;AACA,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,IAAI,MAAM,WAAW;AACjB,YAAI;AACJ,YAAI,SAAS,OAAO,IAAI;AACpB,kBAAQ;AAAA,iBACH,CAAC,QAAQ,OAAO,SAAS,YAAY,EAAE,SAAS,OAAO;AAE5D,kBAAQ,IAAI,KAAK,KAAK,MAAM,MAAM,KAAK;AAAA,QAC3C;AAEI,kBAAQ,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK;AAC9C,cAAM,OAAO,SAAS,KAAK,OAAO,MAAM,GAAG;AAC3C,cAAM,cAAc,KAAK,QAAQ;AACjC,YAAI,MAAM;AACN,cAAI,CAAC;AACD,kBAAM,IAAI,MAAM,OAAO,MAAM,GAAG,cAAc;AAElD,cAAI,SAAS,SAAS,KAAK,KAAK,KAAK,OAAO,cAAc,MAAM,KAAK;AACjE,iBAAK,MAAM,QAAQ,MAAM;AAAA;AAEzB,iBAAK,QAAQ,MAAM;AAAA,QAC3B,WACS,aAAa;AAClB,gBAAM,IAAI,KAAK,MAAM,UAAU,UAAQ,YAAY,OAAO,IAAI,IAAI,CAAC;AACnE,cAAI,MAAM;AACN,iBAAK,MAAM,KAAK,KAAK;AAAA;AAErB,iBAAK,MAAM,OAAO,GAAG,GAAG,KAAK;AAAA,QACrC,OACK;AACD,eAAK,MAAM,KAAK,KAAK;AAAA,QACzB;AAAA,MACJ;AAAA,MACA,OAAO,KAAK;AACR,cAAM,KAAK,SAAS,KAAK,OAAO,GAAG;AACnC,YAAI,CAAC;AACD,iBAAO;AACX,cAAM,MAAM,KAAK,MAAM,OAAO,KAAK,MAAM,QAAQ,EAAE,GAAG,CAAC;AACvD,eAAO,IAAI,SAAS;AAAA,MACxB;AAAA,MACA,IAAI,KAAK,YAAY;AACjB,cAAM,KAAK,SAAS,KAAK,OAAO,GAAG;AACnC,cAAM,OAAO,IAAI;AACjB,gBAAQ,CAAC,cAAc,SAAS,SAAS,IAAI,IAAI,KAAK,QAAQ,SAAS;AAAA,MAC3E;AAAA,MACA,IAAI,KAAK;AACL,eAAO,CAAC,CAAC,SAAS,KAAK,OAAO,GAAG;AAAA,MACrC;AAAA,MACA,IAAI,KAAK,OAAO;AACZ,aAAK,IAAI,IAAI,KAAK,KAAK,KAAK,KAAK,GAAG,IAAI;AAAA,MAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,OAAO,GAAG,KAAK,MAAM;AACjB,cAAM,MAAM,OAAO,IAAI,KAAK,IAAI,KAAK,WAAW,oBAAI,IAAI,IAAI,CAAC;AAC7D,YAAI,KAAK;AACL,cAAI,SAAS,GAAG;AACpB,mBAAW,QAAQ,KAAK;AACpB,yBAAe,eAAe,KAAK,KAAK,IAAI;AAChD,eAAO;AAAA,MACX;AAAA,MACA,SAAS,KAAK,WAAW,aAAa;AAClC,YAAI,CAAC;AACD,iBAAO,KAAK,UAAU,IAAI;AAC9B,mBAAW,QAAQ,KAAK,OAAO;AAC3B,cAAI,CAAC,SAAS,OAAO,IAAI;AACrB,kBAAM,IAAI,MAAM,sCAAsC,KAAK,UAAU,IAAI,CAAC,UAAU;AAAA,QAC5F;AACA,YAAI,CAAC,IAAI,iBAAiB,KAAK,iBAAiB,KAAK;AACjD,gBAAM,OAAO,OAAO,CAAC,GAAG,KAAK,EAAE,eAAe,KAAK,CAAC;AACxD,eAAO,oBAAoB,oBAAoB,MAAM,KAAK;AAAA,UACtD,iBAAiB;AAAA,UACjB,WAAW,EAAE,OAAO,KAAK,KAAK,IAAI;AAAA,UAClC,YAAY,IAAI,UAAU;AAAA,UAC1B;AAAA,UACA;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,IAAAA,SAAQ,UAAU;AAClB,IAAAA,SAAQ,WAAW;AAAA;AAAA;;;AClJnB;AAAA,iIAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,UAAU;AAEd,QAAM,MAAM;AAAA,MACR,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,WAAW,QAAQ;AAAA,MACnB,KAAK;AAAA,MACL,QAAQC,MAAK,SAAS;AAClB,YAAI,CAAC,SAAS,MAAMA,IAAG;AACnB,kBAAQ,iCAAiC;AAC7C,eAAOA;AAAA,MACX;AAAA,MACA,YAAY,CAAC,QAAQ,KAAK,QAAQ,QAAQ,QAAQ,KAAK,QAAQ,KAAK,GAAG;AAAA,IAC3E;AAEA,IAAAD,SAAQ,MAAM;AAAA;AAAA;;;AClBd;AAAA,6HAAAE,UAAA;AAAA;AAEA,QAAI,aAAa;AACjB,QAAI,sBAAsB;AAC1B,QAAI,aAAa;AACjB,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,OAAO;AAEX,QAAM,UAAN,cAAsB,WAAW,WAAW;AAAA,MAT5C,OAS4C;AAAA;AAAA;AAAA,MACxC,WAAW,UAAU;AACjB,eAAO;AAAA,MACX;AAAA,MACA,YAAY,QAAQ;AAChB,cAAM,SAAS,KAAK,MAAM;AAC1B,aAAK,QAAQ,CAAC;AAAA,MAClB;AAAA,MACA,IAAI,OAAO;AACP,aAAK,MAAM,KAAK,KAAK;AAAA,MACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASA,OAAO,KAAK;AACR,cAAM,MAAM,YAAY,GAAG;AAC3B,YAAI,OAAO,QAAQ;AACf,iBAAO;AACX,cAAM,MAAM,KAAK,MAAM,OAAO,KAAK,CAAC;AACpC,eAAO,IAAI,SAAS;AAAA,MACxB;AAAA,MACA,IAAI,KAAK,YAAY;AACjB,cAAM,MAAM,YAAY,GAAG;AAC3B,YAAI,OAAO,QAAQ;AACf,iBAAO;AACX,cAAM,KAAK,KAAK,MAAM,GAAG;AACzB,eAAO,CAAC,cAAc,SAAS,SAAS,EAAE,IAAI,GAAG,QAAQ;AAAA,MAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,IAAI,KAAK;AACL,cAAM,MAAM,YAAY,GAAG;AAC3B,eAAO,OAAO,QAAQ,YAAY,MAAM,KAAK,MAAM;AAAA,MACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQA,IAAI,KAAK,OAAO;AACZ,cAAM,MAAM,YAAY,GAAG;AAC3B,YAAI,OAAO,QAAQ;AACf,gBAAM,IAAI,MAAM,+BAA+B,GAAG,GAAG;AACzD,cAAM,OAAO,KAAK,MAAM,GAAG;AAC3B,YAAI,SAAS,SAAS,IAAI,KAAK,OAAO,cAAc,KAAK;AACrD,eAAK,QAAQ;AAAA;AAEb,eAAK,MAAM,GAAG,IAAI;AAAA,MAC1B;AAAA,MACA,OAAO,GAAG,KAAK;AACX,cAAM,MAAM,CAAC;AACb,YAAI,KAAK;AACL,cAAI,SAAS,GAAG;AACpB,YAAI,IAAI;AACR,mBAAW,QAAQ,KAAK;AACpB,cAAI,KAAK,KAAK,KAAK,MAAM,OAAO,GAAG,GAAG,GAAG,CAAC;AAC9C,eAAO;AAAA,MACX;AAAA,MACA,SAAS,KAAK,WAAW,aAAa;AAClC,YAAI,CAAC;AACD,iBAAO,KAAK,UAAU,IAAI;AAC9B,eAAO,oBAAoB,oBAAoB,MAAM,KAAK;AAAA,UACtD,iBAAiB;AAAA,UACjB,WAAW,EAAE,OAAO,KAAK,KAAK,IAAI;AAAA,UAClC,aAAa,IAAI,UAAU,MAAM;AAAA,UACjC;AAAA,UACA;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,MACA,OAAO,KAAK,QAAQ,KAAK,KAAK;AAC1B,cAAM,EAAE,SAAS,IAAI;AACrB,cAAM,MAAM,IAAI,KAAK,MAAM;AAC3B,YAAI,OAAO,OAAO,YAAY,OAAO,GAAG,GAAG;AACvC,cAAI,IAAI;AACR,mBAAS,MAAM,KAAK;AAChB,gBAAI,OAAO,aAAa,YAAY;AAChC,oBAAM,MAAM,eAAe,MAAM,KAAK,OAAO,GAAG;AAChD,mBAAK,SAAS,KAAK,KAAK,KAAK,EAAE;AAAA,YACnC;AACA,gBAAI,MAAM,KAAK,WAAW,WAAW,IAAI,QAAW,GAAG,CAAC;AAAA,UAC5D;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AACA,aAAS,YAAY,KAAK;AACtB,UAAI,MAAM,SAAS,SAAS,GAAG,IAAI,IAAI,QAAQ;AAC/C,UAAI,OAAO,OAAO,QAAQ;AACtB,cAAM,OAAO,GAAG;AACpB,aAAO,OAAO,QAAQ,YAAY,OAAO,UAAU,GAAG,KAAK,OAAO,IAC5D,MACA;AAAA,IACV;AAPS;AAST,IAAAA,SAAQ,UAAU;AAAA;AAAA;;;AClHlB;AAAA,iIAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,UAAU;AAEd,QAAM,MAAM;AAAA,MACR,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,WAAW,QAAQ;AAAA,MACnB,KAAK;AAAA,MACL,QAAQC,MAAK,SAAS;AAClB,YAAI,CAAC,SAAS,MAAMA,IAAG;AACnB,kBAAQ,kCAAkC;AAC9C,eAAOA;AAAA,MACX;AAAA,MACA,YAAY,CAAC,QAAQ,KAAK,QAAQ,QAAQ,QAAQ,KAAK,QAAQ,KAAK,GAAG;AAAA,IAC3E;AAEA,IAAAD,SAAQ,MAAM;AAAA;AAAA;;;AClBd;AAAA,oIAAAE,UAAA;AAAA;AAEA,QAAI,kBAAkB;AAEtB,QAAM,SAAS;AAAA,MACX,UAAU,WAAS,OAAO,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,SAAS,SAAO;AAAA,MAChB,UAAU,MAAM,KAAK,WAAW,aAAa;AACzC,cAAM,OAAO,OAAO,EAAE,cAAc,KAAK,GAAG,GAAG;AAC/C,eAAO,gBAAgB,gBAAgB,MAAM,KAAK,WAAW,WAAW;AAAA,MAC5E;AAAA,IACJ;AAEA,IAAAA,SAAQ,SAAS;AAAA;AAAA;;;ACfjB;AAAA,kIAAAC,UAAA;AAAA;AAEA,QAAI,SAAS;AAEb,QAAM,UAAU;AAAA,MACZ,UAAU,WAAS,SAAS;AAAA,MAC5B,YAAY,MAAM,IAAI,OAAO,OAAO,IAAI;AAAA,MACxC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,MAAM,IAAI,OAAO,OAAO,IAAI;AAAA,MACrC,WAAW,CAAC,EAAE,OAAO,GAAG,QAAQ,OAAO,WAAW,YAAY,QAAQ,KAAK,KAAK,MAAM,IAChF,SACA,IAAI,QAAQ;AAAA,IACtB;AAEA,IAAAA,SAAQ,UAAU;AAAA;AAAA;;;AChBlB;AAAA,gIAAAC,UAAA;AAAA;AAEA,QAAI,SAAS;AAEb,QAAM,UAAU;AAAA,MACZ,UAAU,WAAS,OAAO,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,SAAO,IAAI,OAAO,OAAO,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,GAAG;AAAA,MAClE,UAAU,EAAE,QAAQ,MAAM,GAAG,KAAK;AAC9B,YAAI,UAAU,QAAQ,KAAK,KAAK,MAAM,GAAG;AACrC,gBAAM,KAAK,OAAO,CAAC,MAAM,OAAO,OAAO,CAAC,MAAM;AAC9C,cAAI,UAAU;AACV,mBAAO;AAAA,QACf;AACA,eAAO,QAAQ,IAAI,QAAQ,UAAU,IAAI,QAAQ;AAAA,MACrD;AAAA,IACJ;AAEA,IAAAA,SAAQ,UAAU;AAAA;AAAA;;;ACpBlB;AAAA,yIAAAC,UAAA;AAAA;AAEA,aAAS,gBAAgB,EAAE,QAAQ,mBAAmB,KAAK,MAAM,GAAG;AAChE,UAAI,OAAO,UAAU;AACjB,eAAO,OAAO,KAAK;AACvB,YAAM,MAAM,OAAO,UAAU,WAAW,QAAQ,OAAO,KAAK;AAC5D,UAAI,CAAC,SAAS,GAAG;AACb,eAAO,MAAM,GAAG,IAAI,SAAS,MAAM,IAAI,UAAU;AACrD,UAAI,IAAI,KAAK,UAAU,KAAK;AAC5B,UAAI,CAAC,UACD,sBACC,CAAC,OAAO,QAAQ,8BACjB,MAAM,KAAK,CAAC,GAAG;AACf,YAAI,IAAI,EAAE,QAAQ,GAAG;AACrB,YAAI,IAAI,GAAG;AACP,cAAI,EAAE;AACN,eAAK;AAAA,QACT;AACA,YAAI,IAAI,qBAAqB,EAAE,SAAS,IAAI;AAC5C,eAAO,MAAM;AACT,eAAK;AAAA,MACb;AACA,aAAO;AAAA,IACX;AArBS;AAuBT,IAAAA,SAAQ,kBAAkB;AAAA;AAAA;;;ACzB1B;AAAA,iIAAAC,UAAA;AAAA;AAEA,QAAI,SAAS;AACb,QAAI,kBAAkB;AAEtB,QAAM,WAAW;AAAA,MACb,UAAU,WAAS,OAAO,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,SAAO,IAAI,MAAM,EAAE,EAAE,YAAY,MAAM,QAC1C,MACA,IAAI,CAAC,MAAM,MACP,OAAO,oBACP,OAAO;AAAA,MACjB,WAAW,gBAAgB;AAAA,IAC/B;AACA,QAAM,WAAW;AAAA,MACb,UAAU,WAAS,OAAO,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,SAAO,WAAW,GAAG;AAAA,MAC9B,UAAU,MAAM;AACZ,cAAM,MAAM,OAAO,KAAK,KAAK;AAC7B,eAAO,SAAS,GAAG,IAAI,IAAI,cAAc,IAAI,gBAAgB,gBAAgB,IAAI;AAAA,MACrF;AAAA,IACJ;AACA,QAAM,QAAQ;AAAA,MACV,UAAU,WAAS,OAAO,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,QAAQ,KAAK;AACT,cAAM,OAAO,IAAI,OAAO,OAAO,WAAW,GAAG,CAAC;AAC9C,cAAM,MAAM,IAAI,QAAQ,GAAG;AAC3B,YAAI,QAAQ,MAAM,IAAI,IAAI,SAAS,CAAC,MAAM;AACtC,eAAK,oBAAoB,IAAI,SAAS,MAAM;AAChD,eAAO;AAAA,MACX;AAAA,MACA,WAAW,gBAAgB;AAAA,IAC/B;AAEA,IAAAA,SAAQ,QAAQ;AAChB,IAAAA,SAAQ,WAAW;AACnB,IAAAA,SAAQ,WAAW;AAAA;AAAA;;;AC9CnB;AAAA,+HAAAC,UAAA;AAAA;AAEA,QAAI,kBAAkB;AAEtB,QAAM,cAAc,wBAAC,UAAU,OAAO,UAAU,YAAY,OAAO,UAAU,KAAK,GAA9D;AACpB,QAAM,aAAa,wBAAC,KAAK,QAAQ,OAAO,EAAE,YAAY,MAAO,cAAc,OAAO,GAAG,IAAI,SAAS,IAAI,UAAU,MAAM,GAAG,KAAK,GAA3G;AACnB,aAAS,aAAa,MAAM,OAAO,QAAQ;AACvC,YAAM,EAAE,MAAM,IAAI;AAClB,UAAI,YAAY,KAAK,KAAK,SAAS;AAC/B,eAAO,SAAS,MAAM,SAAS,KAAK;AACxC,aAAO,gBAAgB,gBAAgB,IAAI;AAAA,IAC/C;AALS;AAMT,QAAM,SAAS;AAAA,MACX,UAAU,WAAS,YAAY,KAAK,KAAK,SAAS;AAAA,MAClD,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,CAAC,KAAK,UAAU,QAAQ,WAAW,KAAK,GAAG,GAAG,GAAG;AAAA,MAC1D,WAAW,UAAQ,aAAa,MAAM,GAAG,IAAI;AAAA,IACjD;AACA,QAAM,MAAM;AAAA,MACR,UAAU;AAAA,MACV,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,CAAC,KAAK,UAAU,QAAQ,WAAW,KAAK,GAAG,IAAI,GAAG;AAAA,MAC3D,WAAW,gBAAgB;AAAA,IAC/B;AACA,QAAM,SAAS;AAAA,MACX,UAAU,WAAS,YAAY,KAAK,KAAK,SAAS;AAAA,MAClD,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,CAAC,KAAK,UAAU,QAAQ,WAAW,KAAK,GAAG,IAAI,GAAG;AAAA,MAC3D,WAAW,UAAQ,aAAa,MAAM,IAAI,IAAI;AAAA,IAClD;AAEA,IAAAA,SAAQ,MAAM;AACd,IAAAA,SAAQ,SAAS;AACjB,IAAAA,SAAQ,SAAS;AAAA;AAAA;;;ACzCjB;AAAA,kIAAAC,UAAA;AAAA;AAEA,QAAI,MAAM;AACV,QAAI,QAAQ;AACZ,QAAI,MAAM;AACV,QAAI,SAAS;AACb,QAAI,OAAO;AACX,QAAI,QAAQ;AACZ,QAAI,MAAM;AAEV,QAAM,SAAS;AAAA,MACX,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ,OAAO;AAAA,MACP,MAAM;AAAA,MACN,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,IACV;AAEA,IAAAA,SAAQ,SAAS;AAAA;AAAA;;;ACxBjB,IAAAC,kBAAA;AAAA,kIAAAC,UAAA;AAAA;AAEA,QAAI,SAAS;AACb,QAAI,MAAM;AACV,QAAI,MAAM;AAEV,aAAS,YAAY,OAAO;AACxB,aAAO,OAAO,UAAU,YAAY,OAAO,UAAU,KAAK;AAAA,IAC9D;AAFS;AAGT,QAAM,gBAAgB,wBAAC,EAAE,MAAM,MAAM,KAAK,UAAU,KAAK,GAAnC;AACtB,QAAM,cAAc;AAAA,MAChB;AAAA,QACI,UAAU,WAAS,OAAO,UAAU;AAAA,QACpC,SAAS;AAAA,QACT,KAAK;AAAA,QACL,SAAS,SAAO;AAAA,QAChB,WAAW;AAAA,MACf;AAAA,MACA;AAAA,QACI,UAAU,WAAS,SAAS;AAAA,QAC5B,YAAY,MAAM,IAAI,OAAO,OAAO,IAAI;AAAA,QACxC,SAAS;AAAA,QACT,KAAK;AAAA,QACL,MAAM;AAAA,QACN,SAAS,MAAM;AAAA,QACf,WAAW;AAAA,MACf;AAAA,MACA;AAAA,QACI,UAAU,WAAS,OAAO,UAAU;AAAA,QACpC,SAAS;AAAA,QACT,KAAK;AAAA,QACL,MAAM;AAAA,QACN,SAAS,SAAO,QAAQ;AAAA,QACxB,WAAW;AAAA,MACf;AAAA,MACA;AAAA,QACI,UAAU;AAAA,QACV,SAAS;AAAA,QACT,KAAK;AAAA,QACL,MAAM;AAAA,QACN,SAAS,CAAC,KAAK,UAAU,EAAE,YAAY,MAAM,cAAc,OAAO,GAAG,IAAI,SAAS,KAAK,EAAE;AAAA,QACzF,WAAW,CAAC,EAAE,MAAM,MAAM,YAAY,KAAK,IAAI,MAAM,SAAS,IAAI,KAAK,UAAU,KAAK;AAAA,MAC1F;AAAA,MACA;AAAA,QACI,UAAU,WAAS,OAAO,UAAU;AAAA,QACpC,SAAS;AAAA,QACT,KAAK;AAAA,QACL,MAAM;AAAA,QACN,SAAS,SAAO,WAAW,GAAG;AAAA,QAC9B,WAAW;AAAA,MACf;AAAA,IACJ;AACA,QAAM,YAAY;AAAA,MACd,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,QAAQ,KAAK,SAAS;AAClB,gBAAQ,2BAA2B,KAAK,UAAU,GAAG,CAAC,EAAE;AACxD,eAAO;AAAA,MACX;AAAA,IACJ;AACA,QAAM,SAAS,CAAC,IAAI,KAAK,IAAI,GAAG,EAAE,OAAO,aAAa,SAAS;AAE/D,IAAAA,SAAQ,SAAS;AAAA;AAAA;;;AC/DjB;AAAA,sIAAAC,UAAA;AAAA;AAEA,QAAI,SAAS;AACb,QAAI,kBAAkB;AAEtB,QAAM,SAAS;AAAA,MACX,UAAU,WAAS,iBAAiB;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASL,QAAQ,KAAK,SAAS;AAClB,YAAI,OAAO,WAAW,YAAY;AAC9B,iBAAO,OAAO,KAAK,KAAK,QAAQ;AAAA,QACpC,WACS,OAAO,SAAS,YAAY;AAEjC,gBAAM,MAAM,KAAK,IAAI,QAAQ,WAAW,EAAE,CAAC;AAC3C,gBAAM,SAAS,IAAI,WAAW,IAAI,MAAM;AACxC,mBAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,EAAE;AAC9B,mBAAO,CAAC,IAAI,IAAI,WAAW,CAAC;AAChC,iBAAO;AAAA,QACX,OACK;AACD,kBAAQ,0FAA0F;AAClG,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,MACA,UAAU,EAAE,SAAS,MAAM,MAAM,GAAG,KAAK,WAAW,aAAa;AAC7D,cAAM,MAAM;AACZ,YAAI;AACJ,YAAI,OAAO,WAAW,YAAY;AAC9B,gBACI,eAAe,SACT,IAAI,SAAS,QAAQ,IACrB,OAAO,KAAK,IAAI,MAAM,EAAE,SAAS,QAAQ;AAAA,QACvD,WACS,OAAO,SAAS,YAAY;AACjC,cAAI,IAAI;AACR,mBAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,EAAE;AAC9B,iBAAK,OAAO,aAAa,IAAI,CAAC,CAAC;AACnC,gBAAM,KAAK,CAAC;AAAA,QAChB,OACK;AACD,gBAAM,IAAI,MAAM,0FAA0F;AAAA,QAC9G;AACA,YAAI,CAAC;AACD,iBAAO,OAAO,OAAO;AACzB,YAAI,SAAS,OAAO,OAAO,cAAc;AACrC,gBAAM,YAAY,KAAK,IAAI,IAAI,QAAQ,YAAY,IAAI,OAAO,QAAQ,IAAI,QAAQ,eAAe;AACjG,gBAAM,IAAI,KAAK,KAAK,IAAI,SAAS,SAAS;AAC1C,gBAAM,QAAQ,IAAI,MAAM,CAAC;AACzB,mBAAS,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG,KAAK,WAAW;AAC/C,kBAAM,CAAC,IAAI,IAAI,OAAO,GAAG,SAAS;AAAA,UACtC;AACA,gBAAM,MAAM,KAAK,SAAS,OAAO,OAAO,gBAAgB,OAAO,GAAG;AAAA,QACtE;AACA,eAAO,gBAAgB,gBAAgB,EAAE,SAAS,MAAM,OAAO,IAAI,GAAG,KAAK,WAAW,WAAW;AAAA,MACrG;AAAA,IACJ;AAEA,IAAAA,SAAQ,SAAS;AAAA;AAAA;;;ACnEjB;AAAA,qIAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,OAAO;AACX,QAAI,SAAS;AACb,QAAI,UAAU;AAEd,aAAS,aAAa,KAAK,SAAS;AAChC,UAAI,SAAS,MAAM,GAAG,GAAG;AACrB,iBAAS,IAAI,GAAG,IAAI,IAAI,MAAM,QAAQ,EAAE,GAAG;AACvC,cAAI,OAAO,IAAI,MAAM,CAAC;AACtB,cAAI,SAAS,OAAO,IAAI;AACpB;AAAA,mBACK,SAAS,MAAM,IAAI,GAAG;AAC3B,gBAAI,KAAK,MAAM,SAAS;AACpB,sBAAQ,gDAAgD;AAC5D,kBAAM,OAAO,KAAK,MAAM,CAAC,KAAK,IAAI,KAAK,KAAK,IAAI,OAAO,OAAO,IAAI,CAAC;AACnE,gBAAI,KAAK;AACL,mBAAK,IAAI,gBAAgB,KAAK,IAAI,gBAC5B,GAAG,KAAK,aAAa;AAAA,EAAK,KAAK,IAAI,aAAa,KAChD,KAAK;AACf,gBAAI,KAAK,SAAS;AACd,oBAAM,KAAK,KAAK,SAAS,KAAK;AAC9B,iBAAG,UAAU,GAAG,UACV,GAAG,KAAK,OAAO;AAAA,EAAK,GAAG,OAAO,KAC9B,KAAK;AAAA,YACf;AACA,mBAAO;AAAA,UACX;AACA,cAAI,MAAM,CAAC,IAAI,SAAS,OAAO,IAAI,IAAI,OAAO,IAAI,KAAK,KAAK,IAAI;AAAA,QACpE;AAAA,MACJ;AAEI,gBAAQ,kCAAkC;AAC9C,aAAO;AAAA,IACX;AA5BS;AA6BT,aAAS,YAAY,QAAQ,UAAU,KAAK;AACxC,YAAM,EAAE,SAAS,IAAI;AACrB,YAAMC,SAAQ,IAAI,QAAQ,QAAQ,MAAM;AACxC,MAAAA,OAAM,MAAM;AACZ,UAAI,IAAI;AACR,UAAI,YAAY,OAAO,YAAY,OAAO,QAAQ;AAC9C,iBAAS,MAAM,UAAU;AACrB,cAAI,OAAO,aAAa;AACpB,iBAAK,SAAS,KAAK,UAAU,OAAO,GAAG,GAAG,EAAE;AAChD,cAAI,KAAK;AACT,cAAI,MAAM,QAAQ,EAAE,GAAG;AACnB,gBAAI,GAAG,WAAW,GAAG;AACjB,oBAAM,GAAG,CAAC;AACV,sBAAQ,GAAG,CAAC;AAAA,YAChB;AAEI,oBAAM,IAAI,UAAU,gCAAgC,EAAE,EAAE;AAAA,UAChE,WACS,MAAM,cAAc,QAAQ;AACjC,kBAAM,OAAO,OAAO,KAAK,EAAE;AAC3B,gBAAI,KAAK,WAAW,GAAG;AACnB,oBAAM,KAAK,CAAC;AACZ,sBAAQ,GAAG,GAAG;AAAA,YAClB,OACK;AACD,oBAAM,IAAI,UAAU,oCAAoC,KAAK,MAAM,OAAO;AAAA,YAC9E;AAAA,UACJ,OACK;AACD,kBAAM;AAAA,UACV;AACA,UAAAA,OAAM,MAAM,KAAK,KAAK,WAAW,KAAK,OAAO,GAAG,CAAC;AAAA,QACrD;AACJ,aAAOA;AAAA,IACX;AAlCS;AAmCT,QAAM,QAAQ;AAAA,MACV,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,KAAK;AAAA,MACL,SAAS;AAAA,MACT,YAAY;AAAA,IAChB;AAEA,IAAAD,SAAQ,cAAc;AACtB,IAAAA,SAAQ,QAAQ;AAChB,IAAAA,SAAQ,eAAe;AAAA;AAAA;;;ACjFvB;AAAA,oIAAAE,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,OAAO;AACX,QAAI,UAAU;AACd,QAAI,UAAU;AACd,QAAI,QAAQ;AAEZ,QAAM,WAAN,MAAM,kBAAiB,QAAQ,QAAQ;AAAA,MARvC,OAQuC;AAAA;AAAA;AAAA,MACnC,cAAc;AACV,cAAM;AACN,aAAK,MAAM,QAAQ,QAAQ,UAAU,IAAI,KAAK,IAAI;AAClD,aAAK,SAAS,QAAQ,QAAQ,UAAU,OAAO,KAAK,IAAI;AACxD,aAAK,MAAM,QAAQ,QAAQ,UAAU,IAAI,KAAK,IAAI;AAClD,aAAK,MAAM,QAAQ,QAAQ,UAAU,IAAI,KAAK,IAAI;AAClD,aAAK,MAAM,QAAQ,QAAQ,UAAU,IAAI,KAAK,IAAI;AAClD,aAAK,MAAM,UAAS;AAAA,MACxB;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,OAAO,GAAG,KAAK;AACX,YAAI,CAAC;AACD,iBAAO,MAAM,OAAO,CAAC;AACzB,cAAM,MAAM,oBAAI,IAAI;AACpB,YAAI,KAAK;AACL,cAAI,SAAS,GAAG;AACpB,mBAAW,QAAQ,KAAK,OAAO;AAC3B,cAAI,KAAK;AACT,cAAI,SAAS,OAAO,IAAI,GAAG;AACvB,kBAAM,KAAK,KAAK,KAAK,KAAK,IAAI,GAAG;AACjC,oBAAQ,KAAK,KAAK,KAAK,OAAO,KAAK,GAAG;AAAA,UAC1C,OACK;AACD,kBAAM,KAAK,KAAK,MAAM,IAAI,GAAG;AAAA,UACjC;AACA,cAAI,IAAI,IAAI,GAAG;AACX,kBAAM,IAAI,MAAM,8CAA8C;AAClE,cAAI,IAAI,KAAK,KAAK;AAAA,QACtB;AACA,eAAO;AAAA,MACX;AAAA,MACA,OAAO,KAAK,QAAQ,UAAU,KAAK;AAC/B,cAAM,UAAU,MAAM,YAAY,QAAQ,UAAU,GAAG;AACvD,cAAMC,QAAO,IAAI,KAAK;AACtB,QAAAA,MAAK,QAAQ,QAAQ;AACrB,eAAOA;AAAA,MACX;AAAA,IACJ;AACA,aAAS,MAAM;AACf,QAAM,OAAO;AAAA,MACT,YAAY;AAAA,MACZ,UAAU,WAAS,iBAAiB;AAAA,MACpC,WAAW;AAAA,MACX,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ,KAAK,SAAS;AAClB,cAAM,UAAU,MAAM,aAAa,KAAK,OAAO;AAC/C,cAAM,WAAW,CAAC;AAClB,mBAAW,EAAE,IAAI,KAAK,QAAQ,OAAO;AACjC,cAAI,SAAS,SAAS,GAAG,GAAG;AACxB,gBAAI,SAAS,SAAS,IAAI,KAAK,GAAG;AAC9B,sBAAQ,iDAAiD,IAAI,KAAK,EAAE;AAAA,YACxE,OACK;AACD,uBAAS,KAAK,IAAI,KAAK;AAAA,YAC3B;AAAA,UACJ;AAAA,QACJ;AACA,eAAO,OAAO,OAAO,IAAI,SAAS,GAAG,OAAO;AAAA,MAChD;AAAA,MACA,YAAY,CAAC,QAAQ,UAAU,QAAQ,SAAS,KAAK,QAAQ,UAAU,GAAG;AAAA,IAC9E;AAEA,IAAAD,SAAQ,WAAW;AACnB,IAAAA,SAAQ,OAAO;AAAA;AAAA;;;AC5Ef,IAAAE,gBAAA;AAAA,oIAAAC,UAAA;AAAA;AAEA,QAAI,SAAS;AAEb,aAAS,cAAc,EAAE,OAAO,OAAO,GAAG,KAAK;AAC3C,YAAM,UAAU,QAAQ,UAAU;AAClC,UAAI,UAAU,QAAQ,KAAK,KAAK,MAAM;AAClC,eAAO;AACX,aAAO,QAAQ,IAAI,QAAQ,UAAU,IAAI,QAAQ;AAAA,IACrD;AALS;AAMT,QAAM,UAAU;AAAA,MACZ,UAAU,WAAS,UAAU;AAAA,MAC7B,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,MAAM,IAAI,OAAO,OAAO,IAAI;AAAA,MACrC,WAAW;AAAA,IACf;AACA,QAAM,WAAW;AAAA,MACb,UAAU,WAAS,UAAU;AAAA,MAC7B,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,MAAM,IAAI,OAAO,OAAO,KAAK;AAAA,MACtC,WAAW;AAAA,IACf;AAEA,IAAAA,SAAQ,WAAW;AACnB,IAAAA,SAAQ,UAAU;AAAA;AAAA;;;AC5BlB,IAAAC,iBAAA;AAAA,qIAAAC,UAAA;AAAA;AAEA,QAAI,SAAS;AACb,QAAI,kBAAkB;AAEtB,QAAM,WAAW;AAAA,MACb,UAAU,WAAS,OAAO,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,CAAC,QAAQ,IAAI,MAAM,EAAE,EAAE,YAAY,MAAM,QAC5C,MACA,IAAI,CAAC,MAAM,MACP,OAAO,oBACP,OAAO;AAAA,MACjB,WAAW,gBAAgB;AAAA,IAC/B;AACA,QAAM,WAAW;AAAA,MACb,UAAU,WAAS,OAAO,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,CAAC,QAAQ,WAAW,IAAI,QAAQ,MAAM,EAAE,CAAC;AAAA,MAClD,UAAU,MAAM;AACZ,cAAM,MAAM,OAAO,KAAK,KAAK;AAC7B,eAAO,SAAS,GAAG,IAAI,IAAI,cAAc,IAAI,gBAAgB,gBAAgB,IAAI;AAAA,MACrF;AAAA,IACJ;AACA,QAAM,QAAQ;AAAA,MACV,UAAU,WAAS,OAAO,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,QAAQ,KAAK;AACT,cAAM,OAAO,IAAI,OAAO,OAAO,WAAW,IAAI,QAAQ,MAAM,EAAE,CAAC,CAAC;AAChE,cAAM,MAAM,IAAI,QAAQ,GAAG;AAC3B,YAAI,QAAQ,IAAI;AACZ,gBAAM,IAAI,IAAI,UAAU,MAAM,CAAC,EAAE,QAAQ,MAAM,EAAE;AACjD,cAAI,EAAE,EAAE,SAAS,CAAC,MAAM;AACpB,iBAAK,oBAAoB,EAAE;AAAA,QACnC;AACA,eAAO;AAAA,MACX;AAAA,MACA,WAAW,gBAAgB;AAAA,IAC/B;AAEA,IAAAA,SAAQ,QAAQ;AAChB,IAAAA,SAAQ,WAAW;AACnB,IAAAA,SAAQ,WAAW;AAAA;AAAA;;;ACjDnB,IAAAC,eAAA;AAAA,mIAAAC,UAAA;AAAA;AAEA,QAAI,kBAAkB;AAEtB,QAAM,cAAc,wBAAC,UAAU,OAAO,UAAU,YAAY,OAAO,UAAU,KAAK,GAA9D;AACpB,aAAS,WAAW,KAAK,QAAQ,OAAO,EAAE,YAAY,GAAG;AACrD,YAAM,OAAO,IAAI,CAAC;AAClB,UAAI,SAAS,OAAO,SAAS;AACzB,kBAAU;AACd,YAAM,IAAI,UAAU,MAAM,EAAE,QAAQ,MAAM,EAAE;AAC5C,UAAI,aAAa;AACb,gBAAQ,OAAO;AAAA,UACX,KAAK;AACD,kBAAM,KAAK,GAAG;AACd;AAAA,UACJ,KAAK;AACD,kBAAM,KAAK,GAAG;AACd;AAAA,UACJ,KAAK;AACD,kBAAM,KAAK,GAAG;AACd;AAAA,QACR;AACA,cAAMC,KAAI,OAAO,GAAG;AACpB,eAAO,SAAS,MAAM,OAAO,EAAE,IAAIA,KAAIA;AAAA,MAC3C;AACA,YAAM,IAAI,SAAS,KAAK,KAAK;AAC7B,aAAO,SAAS,MAAM,KAAK,IAAI;AAAA,IACnC;AAtBS;AAuBT,aAAS,aAAa,MAAM,OAAO,QAAQ;AACvC,YAAM,EAAE,MAAM,IAAI;AAClB,UAAI,YAAY,KAAK,GAAG;AACpB,cAAM,MAAM,MAAM,SAAS,KAAK;AAChC,eAAO,QAAQ,IAAI,MAAM,SAAS,IAAI,OAAO,CAAC,IAAI,SAAS;AAAA,MAC/D;AACA,aAAO,gBAAgB,gBAAgB,IAAI;AAAA,IAC/C;AAPS;AAQT,QAAM,SAAS;AAAA,MACX,UAAU;AAAA,MACV,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,CAAC,KAAK,UAAU,QAAQ,WAAW,KAAK,GAAG,GAAG,GAAG;AAAA,MAC1D,WAAW,UAAQ,aAAa,MAAM,GAAG,IAAI;AAAA,IACjD;AACA,QAAM,SAAS;AAAA,MACX,UAAU;AAAA,MACV,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,CAAC,KAAK,UAAU,QAAQ,WAAW,KAAK,GAAG,GAAG,GAAG;AAAA,MAC1D,WAAW,UAAQ,aAAa,MAAM,GAAG,GAAG;AAAA,IAChD;AACA,QAAM,MAAM;AAAA,MACR,UAAU;AAAA,MACV,SAAS;AAAA,MACT,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS,CAAC,KAAK,UAAU,QAAQ,WAAW,KAAK,GAAG,IAAI,GAAG;AAAA,MAC3D,WAAW,gBAAgB;AAAA,IAC/B;AACA,QAAM,SAAS;AAAA,MACX,UAAU;AAAA,MACV,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,CAAC,KAAK,UAAU,QAAQ,WAAW,KAAK,GAAG,IAAI,GAAG;AAAA,MAC3D,WAAW,UAAQ,aAAa,MAAM,IAAI,IAAI;AAAA,IAClD;AAEA,IAAAD,SAAQ,MAAM;AACd,IAAAA,SAAQ,SAAS;AACjB,IAAAA,SAAQ,SAAS;AACjB,IAAAA,SAAQ,SAAS;AAAA;AAAA;;;AC3EjB;AAAA,mIAAAE,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,OAAO;AACX,QAAI,UAAU;AAEd,QAAM,UAAN,MAAM,iBAAgB,QAAQ,QAAQ;AAAA,MANtC,OAMsC;AAAA;AAAA;AAAA,MAClC,YAAY,QAAQ;AAChB,cAAM,MAAM;AACZ,aAAK,MAAM,SAAQ;AAAA,MACvB;AAAA,MACA,IAAI,KAAK;AACL,YAAI;AACJ,YAAI,SAAS,OAAO,GAAG;AACnB,iBAAO;AAAA,iBACF,OACL,OAAO,QAAQ,YACf,SAAS,OACT,WAAW,OACX,IAAI,UAAU;AACd,iBAAO,IAAI,KAAK,KAAK,IAAI,KAAK,IAAI;AAAA;AAElC,iBAAO,IAAI,KAAK,KAAK,KAAK,IAAI;AAClC,cAAM,OAAO,QAAQ,SAAS,KAAK,OAAO,KAAK,GAAG;AAClD,YAAI,CAAC;AACD,eAAK,MAAM,KAAK,IAAI;AAAA,MAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,IAAI,KAAK,UAAU;AACf,cAAM,OAAO,QAAQ,SAAS,KAAK,OAAO,GAAG;AAC7C,eAAO,CAAC,YAAY,SAAS,OAAO,IAAI,IAClC,SAAS,SAAS,KAAK,GAAG,IACtB,KAAK,IAAI,QACT,KAAK,MACT;AAAA,MACV;AAAA,MACA,IAAI,KAAK,OAAO;AACZ,YAAI,OAAO,UAAU;AACjB,gBAAM,IAAI,MAAM,iEAAiE,OAAO,KAAK,EAAE;AACnG,cAAM,OAAO,QAAQ,SAAS,KAAK,OAAO,GAAG;AAC7C,YAAI,QAAQ,CAAC,OAAO;AAChB,eAAK,MAAM,OAAO,KAAK,MAAM,QAAQ,IAAI,GAAG,CAAC;AAAA,QACjD,WACS,CAAC,QAAQ,OAAO;AACrB,eAAK,MAAM,KAAK,IAAI,KAAK,KAAK,GAAG,CAAC;AAAA,QACtC;AAAA,MACJ;AAAA,MACA,OAAO,GAAG,KAAK;AACX,eAAO,MAAM,OAAO,GAAG,KAAK,GAAG;AAAA,MACnC;AAAA,MACA,SAAS,KAAK,WAAW,aAAa;AAClC,YAAI,CAAC;AACD,iBAAO,KAAK,UAAU,IAAI;AAC9B,YAAI,KAAK,iBAAiB,IAAI;AAC1B,iBAAO,MAAM,SAAS,OAAO,OAAO,CAAC,GAAG,KAAK,EAAE,eAAe,KAAK,CAAC,GAAG,WAAW,WAAW;AAAA;AAE7F,gBAAM,IAAI,MAAM,qCAAqC;AAAA,MAC7D;AAAA,MACA,OAAO,KAAK,QAAQ,UAAU,KAAK;AAC/B,cAAM,EAAE,SAAS,IAAI;AACrB,cAAMC,OAAM,IAAI,KAAK,MAAM;AAC3B,YAAI,YAAY,OAAO,YAAY,OAAO,QAAQ;AAC9C,mBAAS,SAAS,UAAU;AACxB,gBAAI,OAAO,aAAa;AACpB,sBAAQ,SAAS,KAAK,UAAU,OAAO,KAAK;AAChD,YAAAA,KAAI,MAAM,KAAK,KAAK,WAAW,OAAO,MAAM,GAAG,CAAC;AAAA,UACpD;AACJ,eAAOA;AAAA,MACX;AAAA,IACJ;AACA,YAAQ,MAAM;AACd,QAAM,MAAM;AAAA,MACR,YAAY;AAAA,MACZ,UAAU,WAAS,iBAAiB;AAAA,MACpC,WAAW;AAAA,MACX,SAAS;AAAA,MACT,KAAK;AAAA,MACL,YAAY,CAAC,QAAQ,UAAU,QAAQ,QAAQ,KAAK,QAAQ,UAAU,GAAG;AAAA,MACzE,QAAQ,KAAK,SAAS;AAClB,YAAI,SAAS,MAAM,GAAG,GAAG;AACrB,cAAI,IAAI,iBAAiB,IAAI;AACzB,mBAAO,OAAO,OAAO,IAAI,QAAQ,GAAG,GAAG;AAAA;AAEvC,oBAAQ,qCAAqC;AAAA,QACrD;AAEI,kBAAQ,iCAAiC;AAC7C,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,IAAAD,SAAQ,UAAU;AAClB,IAAAA,SAAQ,MAAM;AAAA;AAAA;;;AC/Fd;AAAA,yIAAAE,UAAA;AAAA;AAEA,QAAI,kBAAkB;AAGtB,aAAS,iBAAiB,KAAK,UAAU;AACrC,YAAM,OAAO,IAAI,CAAC;AAClB,YAAM,QAAQ,SAAS,OAAO,SAAS,MAAM,IAAI,UAAU,CAAC,IAAI;AAChE,YAAM,MAAM,wBAAC,MAAM,WAAW,OAAO,CAAC,IAAI,OAAO,CAAC,GAAtC;AACZ,YAAM,MAAM,MACP,QAAQ,MAAM,EAAE,EAChB,MAAM,GAAG,EACT,OAAO,CAACC,MAAK,MAAMA,OAAM,IAAI,EAAE,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;AACtD,aAAQ,SAAS,MAAM,IAAI,EAAE,IAAI,MAAM;AAAA,IAC3C;AATS;AAeT,aAAS,qBAAqB,MAAM;AAChC,UAAI,EAAE,MAAM,IAAI;AAChB,UAAI,MAAM,wBAAC,MAAM,GAAP;AACV,UAAI,OAAO,UAAU;AACjB,cAAM,8BAAK,OAAO,CAAC,GAAb;AAAA,eACD,MAAM,KAAK,KAAK,CAAC,SAAS,KAAK;AACpC,eAAO,gBAAgB,gBAAgB,IAAI;AAC/C,UAAI,OAAO;AACX,UAAI,QAAQ,GAAG;AACX,eAAO;AACP,iBAAS,IAAI,EAAE;AAAA,MACnB;AACA,YAAM,MAAM,IAAI,EAAE;AAClB,YAAM,QAAQ,CAAC,QAAQ,GAAG;AAC1B,UAAI,QAAQ,IAAI;AACZ,cAAM,QAAQ,CAAC;AAAA,MACnB,OACK;AACD,iBAAS,QAAQ,MAAM,CAAC,KAAK;AAC7B,cAAM,QAAQ,QAAQ,GAAG;AACzB,YAAI,SAAS,IAAI;AACb,mBAAS,QAAQ,MAAM,CAAC,KAAK;AAC7B,gBAAM,QAAQ,KAAK;AAAA,QACvB;AAAA,MACJ;AACA,aAAQ,OACJ,MACK,IAAI,OAAK,OAAO,CAAC,EAAE,SAAS,GAAG,GAAG,CAAC,EACnC,KAAK,GAAG,EACR,QAAQ,cAAc,EAAE;AAAA,IAErC;AA/BS;AAgCT,QAAM,UAAU;AAAA,MACZ,UAAU,WAAS,OAAO,UAAU,YAAY,OAAO,UAAU,KAAK;AAAA,MACtE,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,CAAC,KAAK,UAAU,EAAE,YAAY,MAAM,iBAAiB,KAAK,WAAW;AAAA,MAC9E,WAAW;AAAA,IACf;AACA,QAAM,YAAY;AAAA,MACd,UAAU,WAAS,OAAO,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,SAAO,iBAAiB,KAAK,KAAK;AAAA,MAC3C,WAAW;AAAA,IACf;AACA,QAAM,YAAY;AAAA,MACd,UAAU,WAAS,iBAAiB;AAAA,MACpC,SAAS;AAAA,MACT,KAAK;AAAA;AAAA;AAAA;AAAA,MAIL,MAAM,OAAO,2JAKJ;AAAA,MACT,QAAQ,KAAK;AACT,cAAM,QAAQ,IAAI,MAAM,UAAU,IAAI;AACtC,YAAI,CAAC;AACD,gBAAM,IAAI,MAAM,sDAAsD;AAC1E,cAAM,CAAC,EAAE,MAAM,OAAO,KAAK,MAAM,QAAQ,MAAM,IAAI,MAAM,IAAI,MAAM;AACnE,cAAM,WAAW,MAAM,CAAC,IAAI,QAAQ,MAAM,CAAC,IAAI,MAAM,OAAO,GAAG,CAAC,CAAC,IAAI;AACrE,YAAI,OAAO,KAAK,IAAI,MAAM,QAAQ,GAAG,KAAK,QAAQ,GAAG,UAAU,GAAG,UAAU,GAAG,QAAQ;AACvF,cAAM,KAAK,MAAM,CAAC;AAClB,YAAI,MAAM,OAAO,KAAK;AAClB,cAAI,IAAI,iBAAiB,IAAI,KAAK;AAClC,cAAI,KAAK,IAAI,CAAC,IAAI;AACd,iBAAK;AACT,kBAAQ,MAAQ;AAAA,QACpB;AACA,eAAO,IAAI,KAAK,IAAI;AAAA,MACxB;AAAA,MACA,WAAW,CAAC,EAAE,MAAM,MAAM,MAAM,YAAY,EAAE,QAAQ,0BAA0B,EAAE;AAAA,IACtF;AAEA,IAAAD,SAAQ,YAAY;AACpB,IAAAA,SAAQ,UAAU;AAClB,IAAAA,SAAQ,YAAY;AAAA;AAAA;;;ACxGpB,IAAAE,kBAAA;AAAA,sIAAAC,UAAA;AAAA;AAEA,QAAI,MAAM;AACV,QAAI,QAAQ;AACZ,QAAI,MAAM;AACV,QAAI,SAAS;AACb,QAAI,SAAS;AACb,QAAI,OAAO;AACX,QAAI,QAAQ;AACZ,QAAI,MAAM;AACV,QAAI,OAAO;AACX,QAAI,QAAQ;AACZ,QAAI,MAAM;AACV,QAAI,YAAY;AAEhB,QAAM,SAAS;AAAA,MACX,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ,OAAO;AAAA,MACP,MAAM;AAAA,MACN,KAAK;AAAA,MACL,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,OAAO;AAAA,MACP,KAAK;AAAA,MACL,MAAM;AAAA,MACN,IAAI;AAAA,MACJ,UAAU;AAAA,MACV,UAAU;AAAA,MACV,UAAU;AAAA,IACd;AAEA,IAAAA,SAAQ,SAAS;AAAA;AAAA;;;ACtCjB;AAAA,2HAAAC,UAAA;AAAA;AAEA,QAAI,MAAM;AACV,QAAI,QAAQ;AACZ,QAAI,MAAM;AACV,QAAI,SAAS;AACb,QAAI,OAAO;AACX,QAAI,QAAQ;AACZ,QAAI,MAAM;AACV,QAAI,SAAS;AACb,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,OAAO;AACX,QAAI,QAAQ;AACZ,QAAI,WAAW;AACf,QAAI,MAAM;AACV,QAAI,YAAY;AAEhB,QAAM,UAAU,oBAAI,IAAI;AAAA,MACpB,CAAC,QAAQ,OAAO,MAAM;AAAA,MACtB,CAAC,YAAY,CAAC,IAAI,KAAK,IAAI,KAAK,OAAO,MAAM,CAAC;AAAA,MAC9C,CAAC,QAAQ,SAAS,MAAM;AAAA,MACxB,CAAC,UAAU,SAAS,MAAM;AAAA,MAC1B,CAAC,YAAY,SAAS,MAAM;AAAA,IAChC,CAAC;AACD,QAAM,aAAa;AAAA,MACf,QAAQ,OAAO;AAAA,MACf,MAAM,KAAK;AAAA,MACX,OAAO,MAAM;AAAA,MACb,UAAU,MAAM;AAAA,MAChB,UAAU,MAAM;AAAA,MAChB,WAAW,UAAU;AAAA,MACrB,KAAK,IAAI;AAAA,MACT,QAAQ,IAAI;AAAA,MACZ,QAAQ,IAAI;AAAA,MACZ,SAAS,UAAU;AAAA,MACnB,KAAK,IAAI;AAAA,MACT,MAAM,MAAM;AAAA,MACZ,MAAM,KAAK;AAAA,MACX,OAAO,MAAM;AAAA,MACb,KAAK,IAAI;AAAA,MACT,KAAK,IAAI;AAAA,MACT,WAAW,UAAU;AAAA,IACzB;AACA,QAAM,gBAAgB;AAAA,MAClB,4BAA4B,OAAO;AAAA,MACnC,0BAA0B,KAAK;AAAA,MAC/B,2BAA2B,MAAM;AAAA,MACjC,yBAAyB,IAAI;AAAA,MAC7B,+BAA+B,UAAU;AAAA,IAC7C;AACA,aAAS,QAAQ,YAAY,YAAY;AACrC,UAAI,OAAO,QAAQ,IAAI,UAAU;AACjC,UAAI,CAAC,MAAM;AACP,YAAI,MAAM,QAAQ,UAAU;AACxB,iBAAO,CAAC;AAAA,aACP;AACD,gBAAM,OAAO,MAAM,KAAK,QAAQ,KAAK,CAAC,EACjC,OAAO,SAAO,QAAQ,QAAQ,EAC9B,IAAI,SAAO,KAAK,UAAU,GAAG,CAAC,EAC9B,KAAK,IAAI;AACd,gBAAM,IAAI,MAAM,mBAAmB,UAAU,iBAAiB,IAAI,6BAA6B;AAAA,QACnG;AAAA,MACJ;AACA,UAAI,MAAM,QAAQ,UAAU,GAAG;AAC3B,mBAAW,OAAO;AACd,iBAAO,KAAK,OAAO,GAAG;AAAA,MAC9B,WACS,OAAO,eAAe,YAAY;AACvC,eAAO,WAAW,KAAK,MAAM,CAAC;AAAA,MAClC;AACA,aAAO,KAAK,IAAI,SAAO;AACnB,YAAI,OAAO,QAAQ;AACf,iBAAO;AACX,cAAM,SAAS,WAAW,GAAG;AAC7B,YAAI;AACA,iBAAO;AACX,cAAM,OAAO,OAAO,KAAK,UAAU,EAC9B,IAAI,SAAO,KAAK,UAAU,GAAG,CAAC,EAC9B,KAAK,IAAI;AACd,cAAM,IAAI,MAAM,uBAAuB,GAAG,iBAAiB,IAAI,EAAE;AAAA,MACrE,CAAC;AAAA,IACL;AA/BS;AAiCT,IAAAA,SAAQ,gBAAgB;AACxB,IAAAA,SAAQ,UAAU;AAAA;AAAA;;;ACrFlB;AAAA,6HAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,MAAM;AACV,QAAI,MAAM;AACV,QAAI,SAAS;AACb,QAAI,OAAO;AAEX,QAAM,sBAAsB,wBAAC,GAAG,MAAM,EAAE,MAAM,EAAE,MAAM,KAAK,EAAE,MAAM,EAAE,MAAM,IAAI,GAAnD;AAC5B,QAAM,SAAN,MAAM,QAAO;AAAA,MATb,OASa;AAAA;AAAA;AAAA,MACT,YAAY,EAAE,QAAQ,YAAY,OAAO,kBAAkB,QAAQ,gBAAgB,iBAAiB,GAAG;AACnG,aAAK,SAAS,MAAM,QAAQ,MAAM,IAC5B,KAAK,QAAQ,QAAQ,QAAQ,IAC7B,SACI,KAAK,QAAQ,MAAM,MAAM,IACzB;AACV,aAAK,QAAQ,CAAC,CAAC;AACf,aAAK,OAAQ,OAAO,WAAW,YAAY,UAAW;AACtD,aAAK,YAAY,mBAAmB,KAAK,gBAAgB,CAAC;AAC1D,aAAK,OAAO,KAAK,QAAQ,YAAY,KAAK,IAAI;AAC9C,aAAK,kBAAkB,oBAAoB;AAC3C,eAAO,eAAe,MAAM,SAAS,KAAK,EAAE,OAAO,IAAI,IAAI,CAAC;AAC5D,eAAO,eAAe,MAAM,SAAS,QAAQ,EAAE,OAAO,OAAO,OAAO,CAAC;AACrE,eAAO,eAAe,MAAM,SAAS,KAAK,EAAE,OAAO,IAAI,IAAI,CAAC;AAE5D,aAAK,iBACD,OAAO,mBAAmB,aACpB,iBACA,mBAAmB,OACf,sBACA;AAAA,MAClB;AAAA,MACA,QAAQ;AACJ,cAAM,OAAO,OAAO,OAAO,QAAO,WAAW,OAAO,0BAA0B,IAAI,CAAC;AACnF,aAAK,OAAO,KAAK,KAAK,MAAM;AAC5B,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,IAAAA,SAAQ,SAAS;AAAA;AAAA;;;ACvCjB;AAAA,2IAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,YAAY;AAChB,QAAI,mBAAmB;AAEvB,aAAS,kBAAkB,KAAK,SAAS;AACrC,YAAM,QAAQ,CAAC;AACf,UAAI,gBAAgB,QAAQ,eAAe;AAC3C,UAAI,QAAQ,eAAe,SAAS,IAAI,YAAY;AAChD,cAAM,MAAM,IAAI,WAAW,SAAS,GAAG;AACvC,YAAI,KAAK;AACL,gBAAM,KAAK,GAAG;AACd,0BAAgB;AAAA,QACpB,WACS,IAAI,WAAW;AACpB,0BAAgB;AAAA,MACxB;AACA,UAAI;AACA,cAAM,KAAK,KAAK;AACpB,YAAM,MAAM,UAAU,uBAAuB,KAAK,OAAO;AACzD,YAAM,EAAE,cAAc,IAAI,IAAI;AAC9B,UAAI,IAAI,eAAe;AACnB,YAAI,MAAM,WAAW;AACjB,gBAAM,QAAQ,EAAE;AACpB,cAAM,KAAK,cAAc,IAAI,aAAa;AAC1C,cAAM,QAAQ,iBAAiB,cAAc,IAAI,EAAE,CAAC;AAAA,MACxD;AACA,UAAI,YAAY;AAChB,UAAI,iBAAiB;AACrB,UAAI,IAAI,UAAU;AACd,YAAI,SAAS,OAAO,IAAI,QAAQ,GAAG;AAC/B,cAAI,IAAI,SAAS,eAAe;AAC5B,kBAAM,KAAK,EAAE;AACjB,cAAI,IAAI,SAAS,eAAe;AAC5B,kBAAM,KAAK,cAAc,IAAI,SAAS,aAAa;AACnD,kBAAM,KAAK,iBAAiB,cAAc,IAAI,EAAE,CAAC;AAAA,UACrD;AAEA,cAAI,mBAAmB,CAAC,CAAC,IAAI;AAC7B,2BAAiB,IAAI,SAAS;AAAA,QAClC;AACA,cAAM,cAAc,iBAAiB,SAAY,MAAO,YAAY;AACpE,YAAI,OAAO,UAAU,UAAU,IAAI,UAAU,KAAK,MAAO,iBAAiB,MAAO,WAAW;AAC5F,YAAI;AACA,kBAAQ,iBAAiB,YAAY,MAAM,IAAI,cAAc,cAAc,CAAC;AAChF,aAAK,KAAK,CAAC,MAAM,OAAO,KAAK,CAAC,MAAM,QAChC,MAAM,MAAM,SAAS,CAAC,MAAM,OAAO;AAGnC,gBAAM,MAAM,SAAS,CAAC,IAAI,OAAO,IAAI;AAAA,QACzC;AAEI,gBAAM,KAAK,IAAI;AAAA,MACvB,OACK;AACD,cAAM,KAAK,UAAU,UAAU,IAAI,UAAU,GAAG,CAAC;AAAA,MACrD;AACA,UAAI,IAAI,YAAY,QAAQ;AACxB,YAAI,IAAI,SAAS;AACb,gBAAM,KAAK,cAAc,IAAI,OAAO;AACpC,cAAI,GAAG,SAAS,IAAI,GAAG;AACnB,kBAAM,KAAK,KAAK;AAChB,kBAAM,KAAK,iBAAiB,cAAc,IAAI,EAAE,CAAC;AAAA,UACrD,OACK;AACD,kBAAM,KAAK,OAAO,EAAE,EAAE;AAAA,UAC1B;AAAA,QACJ,OACK;AACD,gBAAM,KAAK,KAAK;AAAA,QACpB;AAAA,MACJ,OACK;AACD,YAAI,KAAK,IAAI;AACb,YAAI,MAAM;AACN,eAAK,GAAG,QAAQ,QAAQ,EAAE;AAC9B,YAAI,IAAI;AACJ,eAAK,CAAC,aAAa,mBAAmB,MAAM,MAAM,SAAS,CAAC,MAAM;AAC9D,kBAAM,KAAK,EAAE;AACjB,gBAAM,KAAK,iBAAiB,cAAc,cAAc,EAAE,GAAG,EAAE,CAAC;AAAA,QACpE;AAAA,MACJ;AACA,aAAO,MAAM,KAAK,IAAI,IAAI;AAAA,IAC9B;AA9ES;AAgFT,IAAAA,SAAQ,oBAAoB;AAAA;AAAA;;;ACtF5B;AAAA,4HAAAC,UAAA;AAAA;AAEA,QAAI,QAAQ;AACZ,QAAI,aAAa;AACjB,QAAI,WAAW;AACf,QAAI,OAAO;AACX,QAAI,OAAO;AACX,QAAI,SAAS;AACb,QAAI,oBAAoB;AACxB,QAAI,UAAU;AACd,QAAI,eAAe;AACnB,QAAI,aAAa;AACjB,QAAI,aAAa;AAEjB,QAAM,WAAN,MAAM,UAAS;AAAA,MAdf,OAce;AAAA;AAAA;AAAA,MACX,YAAY,OAAO,UAAU,SAAS;AAElC,aAAK,gBAAgB;AAErB,aAAK,UAAU;AAEf,aAAK,SAAS,CAAC;AAEf,aAAK,WAAW,CAAC;AACjB,eAAO,eAAe,MAAM,SAAS,WAAW,EAAE,OAAO,SAAS,IAAI,CAAC;AACvE,YAAI,YAAY;AAChB,YAAI,OAAO,aAAa,cAAc,MAAM,QAAQ,QAAQ,GAAG;AAC3D,sBAAY;AAAA,QAChB,WACS,YAAY,UAAa,UAAU;AACxC,oBAAU;AACV,qBAAW;AAAA,QACf;AACA,cAAM,MAAM,OAAO,OAAO;AAAA,UACtB,aAAa;AAAA,UACb,kBAAkB;AAAA,UAClB,UAAU;AAAA,UACV,cAAc;AAAA,UACd,QAAQ;AAAA,UACR,YAAY;AAAA,UACZ,SAAS;AAAA,QACb,GAAG,OAAO;AACV,aAAK,UAAU;AACf,YAAI,EAAE,QAAQ,IAAI;AAClB,YAAI,SAAS,aAAa;AACtB,eAAK,aAAa,QAAQ,YAAY,WAAW;AACjD,cAAI,KAAK,WAAW,KAAK;AACrB,sBAAU,KAAK,WAAW,KAAK;AAAA,QACvC;AAEI,eAAK,aAAa,IAAI,WAAW,WAAW,EAAE,QAAQ,CAAC;AAC3D,aAAK,UAAU,SAAS,OAAO;AAE/B,aAAK,WACD,UAAU,SAAY,OAAO,KAAK,WAAW,OAAO,WAAW,OAAO;AAAA,MAC9E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,QAAQ;AACJ,cAAM,OAAO,OAAO,OAAO,UAAS,WAAW;AAAA,UAC3C,CAAC,SAAS,SAAS,GAAG,EAAE,OAAO,SAAS,IAAI;AAAA,QAChD,CAAC;AACD,aAAK,gBAAgB,KAAK;AAC1B,aAAK,UAAU,KAAK;AACpB,aAAK,SAAS,KAAK,OAAO,MAAM;AAChC,aAAK,WAAW,KAAK,SAAS,MAAM;AACpC,aAAK,UAAU,OAAO,OAAO,CAAC,GAAG,KAAK,OAAO;AAC7C,YAAI,KAAK;AACL,eAAK,aAAa,KAAK,WAAW,MAAM;AAC5C,aAAK,SAAS,KAAK,OAAO,MAAM;AAEhC,aAAK,WAAW,SAAS,OAAO,KAAK,QAAQ,IACvC,KAAK,SAAS,MAAM,KAAK,MAAM,IAC/B,KAAK;AACX,YAAI,KAAK;AACL,eAAK,QAAQ,KAAK,MAAM,MAAM;AAClC,eAAO;AAAA,MACX;AAAA;AAAA,MAEA,IAAI,OAAO;AACP,YAAI,iBAAiB,KAAK,QAAQ;AAC9B,eAAK,SAAS,IAAI,KAAK;AAAA,MAC/B;AAAA;AAAA,MAEA,MAAM,MAAM,OAAO;AACf,YAAI,iBAAiB,KAAK,QAAQ;AAC9B,eAAK,SAAS,MAAM,MAAM,KAAK;AAAA,MACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAUA,YAAY,MAAM,MAAM;AACpB,YAAI,CAAC,KAAK,QAAQ;AACd,gBAAM,OAAO,QAAQ,YAAY,IAAI;AACrC,eAAK;AAAA,UAED,CAAC,QAAQ,KAAK,IAAI,IAAI,IAAI,QAAQ,cAAc,QAAQ,KAAK,IAAI,IAAI;AAAA,QAC7E;AACA,eAAO,IAAI,MAAM,MAAM,KAAK,MAAM;AAAA,MACtC;AAAA,MACA,WAAW,OAAO,UAAU,SAAS;AACjC,YAAI,YAAY;AAChB,YAAI,OAAO,aAAa,YAAY;AAChC,kBAAQ,SAAS,KAAK,EAAE,IAAI,MAAM,GAAG,IAAI,KAAK;AAC9C,sBAAY;AAAA,QAChB,WACS,MAAM,QAAQ,QAAQ,GAAG;AAC9B,gBAAM,WAAW,wBAAC,MAAM,OAAO,MAAM,YAAY,aAAa,UAAU,aAAa,QAApE;AACjB,gBAAM,QAAQ,SAAS,OAAO,QAAQ,EAAE,IAAI,MAAM;AAClD,cAAI,MAAM,SAAS;AACf,uBAAW,SAAS,OAAO,KAAK;AACpC,sBAAY;AAAA,QAChB,WACS,YAAY,UAAa,UAAU;AACxC,oBAAU;AACV,qBAAW;AAAA,QACf;AACA,cAAM,EAAE,uBAAuB,cAAc,MAAM,eAAe,UAAU,IAAI,IAAI,WAAW,CAAC;AAChG,cAAM,EAAE,UAAU,YAAY,cAAc,IAAI,QAAQ;AAAA,UAAkB;AAAA;AAAA,UAE1E,gBAAgB;AAAA,QAAG;AACnB,cAAM,MAAM;AAAA,UACR,uBAAuB,yBAAyB;AAAA,UAChD,eAAe,iBAAiB;AAAA,UAChC;AAAA,UACA;AAAA,UACA,UAAU;AAAA,UACV,QAAQ,KAAK;AAAA,UACb;AAAA,QACJ;AACA,cAAM,OAAO,WAAW,WAAW,OAAO,KAAK,GAAG;AAClD,YAAI,QAAQ,SAAS,aAAa,IAAI;AAClC,eAAK,OAAO;AAChB,mBAAW;AACX,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,WAAW,KAAK,OAAO,UAAU,CAAC,GAAG;AACjC,cAAM,IAAI,KAAK,WAAW,KAAK,MAAM,OAAO;AAC5C,cAAM,IAAI,KAAK,WAAW,OAAO,MAAM,OAAO;AAC9C,eAAO,IAAI,KAAK,KAAK,GAAG,CAAC;AAAA,MAC7B;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,OAAO,KAAK;AACR,eAAO,iBAAiB,KAAK,QAAQ,IAAI,KAAK,SAAS,OAAO,GAAG,IAAI;AAAA,MACzE;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,SAAS,MAAM;AACX,YAAI,WAAW,YAAY,IAAI,GAAG;AAC9B,cAAI,KAAK,YAAY;AACjB,mBAAO;AAEX,eAAK,WAAW;AAChB,iBAAO;AAAA,QACX;AACA,eAAO,iBAAiB,KAAK,QAAQ,IAC/B,KAAK,SAAS,SAAS,IAAI,IAC3B;AAAA,MACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,IAAI,KAAK,YAAY;AACjB,eAAO,SAAS,aAAa,KAAK,QAAQ,IACpC,KAAK,SAAS,IAAI,KAAK,UAAU,IACjC;AAAA,MACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,MAAM,MAAM,YAAY;AACpB,YAAI,WAAW,YAAY,IAAI;AAC3B,iBAAO,CAAC,cAAc,SAAS,SAAS,KAAK,QAAQ,IAC/C,KAAK,SAAS,QACd,KAAK;AACf,eAAO,SAAS,aAAa,KAAK,QAAQ,IACpC,KAAK,SAAS,MAAM,MAAM,UAAU,IACpC;AAAA,MACV;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,KAAK;AACL,eAAO,SAAS,aAAa,KAAK,QAAQ,IAAI,KAAK,SAAS,IAAI,GAAG,IAAI;AAAA,MAC3E;AAAA;AAAA;AAAA;AAAA,MAIA,MAAM,MAAM;AACR,YAAI,WAAW,YAAY,IAAI;AAC3B,iBAAO,KAAK,aAAa;AAC7B,eAAO,SAAS,aAAa,KAAK,QAAQ,IAAI,KAAK,SAAS,MAAM,IAAI,IAAI;AAAA,MAC9E;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,IAAI,KAAK,OAAO;AACZ,YAAI,KAAK,YAAY,MAAM;AAEvB,eAAK,WAAW,WAAW,mBAAmB,KAAK,QAAQ,CAAC,GAAG,GAAG,KAAK;AAAA,QAC3E,WACS,iBAAiB,KAAK,QAAQ,GAAG;AACtC,eAAK,SAAS,IAAI,KAAK,KAAK;AAAA,QAChC;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,MAAM,OAAO;AACf,YAAI,WAAW,YAAY,IAAI,GAAG;AAE9B,eAAK,WAAW;AAAA,QACpB,WACS,KAAK,YAAY,MAAM;AAE5B,eAAK,WAAW,WAAW,mBAAmB,KAAK,QAAQ,MAAM,KAAK,IAAI,GAAG,KAAK;AAAA,QACtF,WACS,iBAAiB,KAAK,QAAQ,GAAG;AACtC,eAAK,SAAS,MAAM,MAAM,KAAK;AAAA,QACnC;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQA,UAAU,SAAS,UAAU,CAAC,GAAG;AAC7B,YAAI,OAAO,YAAY;AACnB,oBAAU,OAAO,OAAO;AAC5B,YAAI;AACJ,gBAAQ,SAAS;AAAA,UACb,KAAK;AACD,gBAAI,KAAK;AACL,mBAAK,WAAW,KAAK,UAAU;AAAA;AAE/B,mBAAK,aAAa,IAAI,WAAW,WAAW,EAAE,SAAS,MAAM,CAAC;AAClE,kBAAM,EAAE,OAAO,MAAM,kBAAkB,OAAO,QAAQ,WAAW;AACjE;AAAA,UACJ,KAAK;AAAA,UACL,KAAK;AACD,gBAAI,KAAK;AACL,mBAAK,WAAW,KAAK,UAAU;AAAA;AAE/B,mBAAK,aAAa,IAAI,WAAW,WAAW,EAAE,QAAQ,CAAC;AAC3D,kBAAM,EAAE,OAAO,OAAO,kBAAkB,MAAM,QAAQ,OAAO;AAC7D;AAAA,UACJ,KAAK;AACD,gBAAI,KAAK;AACL,qBAAO,KAAK;AAChB,kBAAM;AACN;AAAA,UACJ,SAAS;AACL,kBAAM,KAAK,KAAK,UAAU,OAAO;AACjC,kBAAM,IAAI,MAAM,+DAA+D,EAAE,EAAE;AAAA,UACvF;AAAA,QACJ;AAEA,YAAI,QAAQ,kBAAkB;AAC1B,eAAK,SAAS,QAAQ;AAAA,iBACjB;AACL,eAAK,SAAS,IAAI,OAAO,OAAO,OAAO,OAAO,KAAK,OAAO,CAAC;AAAA;AAE3D,gBAAM,IAAI,MAAM,qEAAqE;AAAA,MAC7F;AAAA;AAAA,MAEA,KAAK,EAAE,MAAM,SAAS,UAAU,eAAe,UAAU,QAAQ,IAAI,CAAC,GAAG;AACrE,cAAM,MAAM;AAAA,UACR,SAAS,oBAAI,IAAI;AAAA,UACjB,KAAK;AAAA,UACL,MAAM,CAAC;AAAA,UACP,UAAU,aAAa;AAAA,UACvB,cAAc;AAAA,UACd,eAAe,OAAO,kBAAkB,WAAW,gBAAgB;AAAA,QACvE;AACA,cAAM,MAAM,KAAK,KAAK,KAAK,UAAU,WAAW,IAAI,GAAG;AACvD,YAAI,OAAO,aAAa;AACpB,qBAAW,EAAE,OAAO,KAAAC,KAAI,KAAK,IAAI,QAAQ,OAAO;AAC5C,qBAASA,MAAK,KAAK;AAC3B,eAAO,OAAO,YAAY,aACpB,aAAa,aAAa,SAAS,EAAE,IAAI,IAAI,GAAG,IAAI,GAAG,IACvD;AAAA,MACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,OAAO,SAAS,UAAU;AACtB,eAAO,KAAK,KAAK,EAAE,MAAM,MAAM,SAAS,UAAU,OAAO,SAAS,CAAC;AAAA,MACvE;AAAA;AAAA,MAEA,SAAS,UAAU,CAAC,GAAG;AACnB,YAAI,KAAK,OAAO,SAAS;AACrB,gBAAM,IAAI,MAAM,4CAA4C;AAChE,YAAI,YAAY,YACX,CAAC,OAAO,UAAU,QAAQ,MAAM,KAAK,OAAO,QAAQ,MAAM,KAAK,IAAI;AACpE,gBAAM,IAAI,KAAK,UAAU,QAAQ,MAAM;AACvC,gBAAM,IAAI,MAAM,mDAAmD,CAAC,EAAE;AAAA,QAC1E;AACA,eAAO,kBAAkB,kBAAkB,MAAM,OAAO;AAAA,MAC5D;AAAA,IACJ;AACA,aAAS,iBAAiB,UAAU;AAChC,UAAI,SAAS,aAAa,QAAQ;AAC9B,eAAO;AACX,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACrE;AAJS;AAMT,IAAAD,SAAQ,WAAW;AAAA;AAAA;;;AC/UnB,IAAAE,kBAAA;AAAA,sHAAAC,UAAA;AAAA;AAEA,QAAM,YAAN,cAAwB,MAAM;AAAA,MAF9B,OAE8B;AAAA;AAAA;AAAA,MAC1B,YAAY,MAAM,KAAK,MAAM,SAAS;AAClC,cAAM;AACN,aAAK,OAAO;AACZ,aAAK,OAAO;AACZ,aAAK,UAAU;AACf,aAAK,MAAM;AAAA,MACf;AAAA,IACJ;AACA,QAAM,iBAAN,cAA6B,UAAU;AAAA,MAXvC,OAWuC;AAAA;AAAA;AAAA,MACnC,YAAY,KAAK,MAAM,SAAS;AAC5B,cAAM,kBAAkB,KAAK,MAAM,OAAO;AAAA,MAC9C;AAAA,IACJ;AACA,QAAM,cAAN,cAA0B,UAAU;AAAA,MAhBpC,OAgBoC;AAAA;AAAA;AAAA,MAChC,YAAY,KAAK,MAAM,SAAS;AAC5B,cAAM,eAAe,KAAK,MAAM,OAAO;AAAA,MAC3C;AAAA,IACJ;AACA,QAAM,gBAAgB,wBAAC,KAAK,OAAO,CAAC,UAAU;AAC1C,UAAI,MAAM,IAAI,CAAC,MAAM;AACjB;AACJ,YAAM,UAAU,MAAM,IAAI,IAAI,SAAO,GAAG,QAAQ,GAAG,CAAC;AACpD,YAAM,EAAE,MAAM,IAAI,IAAI,MAAM,QAAQ,CAAC;AACrC,YAAM,WAAW,YAAY,IAAI,YAAY,GAAG;AAChD,UAAI,KAAK,MAAM;AACf,UAAI,UAAU,IACT,UAAU,GAAG,WAAW,OAAO,CAAC,GAAG,GAAG,WAAW,IAAI,CAAC,EACtD,QAAQ,YAAY,EAAE;AAE3B,UAAI,MAAM,MAAM,QAAQ,SAAS,IAAI;AACjC,cAAM,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,SAAS,EAAE;AACvD,kBAAU,WAAM,QAAQ,UAAU,SAAS;AAC3C,cAAM,YAAY;AAAA,MACtB;AACA,UAAI,QAAQ,SAAS;AACjB,kBAAU,QAAQ,UAAU,GAAG,EAAE,IAAI;AAEzC,UAAI,OAAO,KAAK,OAAO,KAAK,QAAQ,UAAU,GAAG,EAAE,CAAC,GAAG;AAEnD,YAAI,OAAO,IAAI,UAAU,GAAG,WAAW,OAAO,CAAC,GAAG,GAAG,WAAW,OAAO,CAAC,CAAC;AACzE,YAAI,KAAK,SAAS;AACd,iBAAO,KAAK,UAAU,GAAG,EAAE,IAAI;AACnC,kBAAU,OAAO;AAAA,MACrB;AACA,UAAI,OAAO,KAAK,OAAO,GAAG;AACtB,YAAI,QAAQ;AACZ,cAAM,MAAM,MAAM,QAAQ,CAAC;AAC3B,YAAI,OAAO,IAAI,SAAS,QAAQ,IAAI,MAAM,KAAK;AAC3C,kBAAQ,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,MAAM,KAAK,KAAK,EAAE,CAAC;AAAA,QACxD;AACA,cAAM,UAAU,IAAI,OAAO,EAAE,IAAI,IAAI,OAAO,KAAK;AACjD,cAAM,WAAW;AAAA;AAAA,EAAQ,OAAO;AAAA,EAAK,OAAO;AAAA;AAAA,MAChD;AAAA,IACJ,GAnCsB;AAqCtB,IAAAA,SAAQ,YAAY;AACpB,IAAAA,SAAQ,iBAAiB;AACzB,IAAAA,SAAQ,cAAc;AACtB,IAAAA,SAAQ,gBAAgB;AAAA;AAAA;;;AC7DxB;AAAA,qIAAAC,UAAA;AAAA;AAEA,aAAS,aAAa,QAAQ,EAAE,MAAM,WAAW,MAAM,QAAQ,SAAS,eAAe,GAAG;AACtF,UAAI,cAAc;AAClB,UAAI,YAAY;AAChB,UAAI,WAAW;AACf,UAAI,UAAU;AACd,UAAI,aAAa;AACjB,UAAI,aAAa;AACjB,UAAI,sBAAsB;AAC1B,UAAI,WAAW;AACf,UAAI,SAAS;AACb,UAAI,MAAM;AACV,UAAI,QAAQ;AACZ,UAAI,QAAQ;AACZ,UAAI,QAAQ;AACZ,iBAAW,SAAS,QAAQ;AACxB,YAAI,UAAU;AACV,cAAI,MAAM,SAAS,WACf,MAAM,SAAS,aACf,MAAM,SAAS;AACf,oBAAQ,MAAM,QAAQ,gBAAgB,uEAAuE;AACjH,qBAAW;AAAA,QACf;AACA,gBAAQ,MAAM,MAAM;AAAA,UAChB,KAAK;AAID,gBAAI,CAAC,QACD,aACA,cAAc,eACd,MAAM,OAAO,CAAC,MAAM;AACpB,sBAAQ,OAAO,iBAAiB,qCAAqC;AACzE,uBAAW;AACX;AAAA,UACJ,KAAK,WAAW;AACZ,gBAAI,CAAC;AACD,sBAAQ,OAAO,gBAAgB,wEAAwE;AAC3G,kBAAM,KAAK,MAAM,OAAO,UAAU,CAAC,KAAK;AACxC,gBAAI,CAAC;AACD,wBAAU;AAAA;AAEV,yBAAW,aAAa;AAC5B,yBAAa;AACb,wBAAY;AACZ;AAAA,UACJ;AAAA,UACA,KAAK;AACD,gBAAI,WAAW;AACX,kBAAI;AACA,2BAAW,MAAM;AAAA;AAEjB,8BAAc;AAAA,YACtB;AAEI,4BAAc,MAAM;AACxB,wBAAY;AACZ,yBAAa;AACb,gBAAI,UAAU;AACV,oCAAsB;AAC1B,uBAAW;AACX;AAAA,UACJ,KAAK;AACD,gBAAI;AACA,sBAAQ,OAAO,oBAAoB,oCAAoC;AAC3E,gBAAI,MAAM,OAAO,SAAS,GAAG;AACzB,sBAAQ,MAAM,SAAS,MAAM,OAAO,SAAS,GAAG,aAAa,mCAAmC,IAAI;AACxG,qBAAS;AACT,gBAAI,UAAU;AACV,sBAAQ,MAAM;AAClB,wBAAY;AACZ,uBAAW;AACX,uBAAW;AACX;AAAA,UACJ,KAAK,OAAO;AACR,gBAAI;AACA,sBAAQ,OAAO,iBAAiB,iCAAiC;AACrE,kBAAM;AACN,gBAAI,UAAU;AACV,sBAAQ,MAAM;AAClB,wBAAY;AACZ,uBAAW;AACX,uBAAW;AACX;AAAA,UACJ;AAAA,UACA,KAAK;AAED,gBAAI,UAAU;AACV,sBAAQ,OAAO,kBAAkB,sCAAsC,MAAM,MAAM,YAAY;AACnG,gBAAI;AACA,sBAAQ,OAAO,oBAAoB,cAAc,MAAM,MAAM,OAAO,QAAQ,YAAY,EAAE;AAC9F,oBAAQ;AACR,wBAAY;AACZ,uBAAW;AACX;AAAA,UACJ,KAAK;AACD,gBAAI,MAAM;AACN,kBAAI;AACA,wBAAQ,OAAO,oBAAoB,mBAAmB,IAAI,EAAE;AAChE,sBAAQ;AACR,0BAAY;AACZ,yBAAW;AACX;AAAA,YACJ;AAAA,UAEJ;AACI,oBAAQ,OAAO,oBAAoB,cAAc,MAAM,IAAI,QAAQ;AACnE,wBAAY;AACZ,uBAAW;AAAA,QACnB;AAAA,MACJ;AACA,YAAM,OAAO,OAAO,OAAO,SAAS,CAAC;AACrC,YAAM,MAAM,OAAO,KAAK,SAAS,KAAK,OAAO,SAAS;AACtD,UAAI,YACA,QACA,KAAK,SAAS,WACd,KAAK,SAAS,aACd,KAAK,SAAS,YACb,KAAK,SAAS,YAAY,KAAK,WAAW;AAC3C,gBAAQ,KAAK,QAAQ,gBAAgB,uEAAuE;AAChH,aAAO;AAAA,QACH;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,OAAO,SAAS;AAAA,MACpB;AAAA,IACJ;AAnIS;AAqIT,IAAAA,SAAQ,eAAe;AAAA;AAAA;;;ACvIvB;AAAA,6IAAAC,UAAA;AAAA;AAEA,aAAS,gBAAgB,KAAK;AAC1B,UAAI,CAAC;AACD,eAAO;AACX,cAAQ,IAAI,MAAM;AAAA,QACd,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,cAAI,IAAI,OAAO,SAAS,IAAI;AACxB,mBAAO;AACX,cAAI,IAAI;AACJ,uBAAW,MAAM,IAAI;AACjB,kBAAI,GAAG,SAAS;AACZ,uBAAO;AAAA;AACnB,iBAAO;AAAA,QACX,KAAK;AACD,qBAAW,MAAM,IAAI,OAAO;AACxB,uBAAW,MAAM,GAAG;AAChB,kBAAI,GAAG,SAAS;AACZ,uBAAO;AACf,gBAAI,GAAG;AACH,yBAAW,MAAM,GAAG;AAChB,oBAAI,GAAG,SAAS;AACZ,yBAAO;AAAA;AACnB,gBAAI,gBAAgB,GAAG,GAAG,KAAK,gBAAgB,GAAG,KAAK;AACnD,qBAAO;AAAA,UACf;AACA,iBAAO;AAAA,QACX;AACI,iBAAO;AAAA,MACf;AAAA,IACJ;AA/BS;AAiCT,IAAAA,SAAQ,kBAAkB;AAAA;AAAA;;;ACnC1B;AAAA,8IAAAC,UAAA;AAAA;AAEA,QAAI,sBAAsB;AAE1B,aAAS,gBAAgB,QAAQ,IAAI,SAAS;AAC1C,UAAI,IAAI,SAAS,mBAAmB;AAChC,cAAM,MAAM,GAAG,IAAI,CAAC;AACpB,YAAI,IAAI,WAAW,WACd,IAAI,WAAW,OAAO,IAAI,WAAW,QACtC,oBAAoB,gBAAgB,EAAE,GAAG;AACzC,gBAAM,MAAM;AACZ,kBAAQ,KAAK,cAAc,KAAK,IAAI;AAAA,QACxC;AAAA,MACJ;AAAA,IACJ;AAVS;AAYT,IAAAA,SAAQ,kBAAkB;AAAA;AAAA;;;AChB1B;AAAA,yIAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AAEf,aAAS,YAAY,KAAK,OAAO,QAAQ;AACrC,YAAM,EAAE,WAAW,IAAI,IAAI;AAC3B,UAAI,eAAe;AACf,eAAO;AACX,YAAM,UAAU,OAAO,eAAe,aAChC,aACA,CAAC,GAAG,MAAM,MAAM,KACb,SAAS,SAAS,CAAC,KAChB,SAAS,SAAS,CAAC,KACnB,EAAE,UAAU,EAAE,SACd,EAAE,EAAE,UAAU,QAAQ,IAAI,OAAO;AAC7C,aAAO,MAAM,KAAK,UAAQ,QAAQ,KAAK,KAAK,MAAM,CAAC;AAAA,IACvD;AAZS;AAcT,IAAAA,SAAQ,cAAc;AAAA;AAAA;;;AClBtB;AAAA,yIAAAC,UAAA;AAAA;AAEA,QAAI,OAAO;AACX,QAAI,UAAU;AACd,QAAI,eAAe;AACnB,QAAI,sBAAsB;AAC1B,QAAI,sBAAsB;AAC1B,QAAI,kBAAkB;AAEtB,QAAM,cAAc;AACpB,aAAS,gBAAgB,EAAE,aAAa,iBAAiB,GAAG,KAAK,IAAI,SAAS,KAAK;AAC/E,YAAM,YAAY,KAAK,aAAa,QAAQ;AAC5C,YAAM,MAAM,IAAI,UAAU,IAAI,MAAM;AACpC,UAAI,IAAI;AACJ,YAAI,SAAS;AACjB,UAAI,SAAS,GAAG;AAChB,UAAI,aAAa;AACjB,iBAAW,YAAY,GAAG,OAAO;AAC7B,cAAM,EAAE,OAAO,KAAK,KAAK,MAAM,IAAI;AAEnC,cAAM,WAAW,aAAa,aAAa,OAAO;AAAA,UAC9C,WAAW;AAAA,UACX,MAAM,OAAO,MAAM,CAAC;AAAA,UACpB;AAAA,UACA;AAAA,UACA,gBAAgB;AAAA,QACpB,CAAC;AACD,cAAM,cAAc,CAAC,SAAS;AAC9B,YAAI,aAAa;AACb,cAAI,KAAK;AACL,gBAAI,IAAI,SAAS;AACb,sBAAQ,QAAQ,yBAAyB,yDAAyD;AAAA,qBAC7F,YAAY,OAAO,IAAI,WAAW,GAAG;AAC1C,sBAAQ,QAAQ,cAAc,WAAW;AAAA,UACjD;AACA,cAAI,CAAC,SAAS,UAAU,CAAC,SAAS,OAAO,CAAC,KAAK;AAC3C,yBAAa,SAAS;AACtB,gBAAI,SAAS,SAAS;AAClB,kBAAI,IAAI;AACJ,oBAAI,WAAW,OAAO,SAAS;AAAA;AAE/B,oBAAI,UAAU,SAAS;AAAA,YAC/B;AACA;AAAA,UACJ;AACA,cAAI,SAAS,uBAAuB,oBAAoB,gBAAgB,GAAG,GAAG;AAC1E,oBAAQ,OAAO,MAAM,MAAM,SAAS,CAAC,GAAG,0BAA0B,2CAA2C;AAAA,UACjH;AAAA,QACJ,WACS,SAAS,OAAO,WAAW,GAAG,QAAQ;AAC3C,kBAAQ,QAAQ,cAAc,WAAW;AAAA,QAC7C;AAEA,cAAM,WAAW,SAAS;AAC1B,cAAM,UAAU,MACV,YAAY,KAAK,KAAK,UAAU,OAAO,IACvC,iBAAiB,KAAK,UAAU,OAAO,MAAM,UAAU,OAAO;AACpE,YAAI,IAAI,OAAO;AACX,8BAAoB,gBAAgB,GAAG,QAAQ,KAAK,OAAO;AAC/D,YAAI,gBAAgB,YAAY,KAAK,IAAI,OAAO,OAAO;AACnD,kBAAQ,UAAU,iBAAiB,yBAAyB;AAEhE,cAAM,aAAa,aAAa,aAAa,OAAO,CAAC,GAAG;AAAA,UACpD,WAAW;AAAA,UACX,MAAM;AAAA,UACN,QAAQ,QAAQ,MAAM,CAAC;AAAA,UACvB;AAAA,UACA,gBAAgB,CAAC,OAAO,IAAI,SAAS;AAAA,QACzC,CAAC;AACD,iBAAS,WAAW;AACpB,YAAI,WAAW,OAAO;AAClB,cAAI,aAAa;AACb,gBAAI,OAAO,SAAS,eAAe,CAAC,WAAW;AAC3C,sBAAQ,QAAQ,yBAAyB,qDAAqD;AAClG,gBAAI,IAAI,QAAQ,UACZ,SAAS,QAAQ,WAAW,MAAM,SAAS;AAC3C,sBAAQ,QAAQ,OAAO,uBAAuB,6FAA6F;AAAA,UACnJ;AAEA,gBAAM,YAAY,QACZ,YAAY,KAAK,OAAO,YAAY,OAAO,IAC3C,iBAAiB,KAAK,QAAQ,KAAK,MAAM,YAAY,OAAO;AAClE,cAAI,IAAI,OAAO;AACX,gCAAoB,gBAAgB,GAAG,QAAQ,OAAO,OAAO;AACjE,mBAAS,UAAU,MAAM,CAAC;AAC1B,gBAAM,OAAO,IAAI,KAAK,KAAK,SAAS,SAAS;AAC7C,cAAI,IAAI,QAAQ;AACZ,iBAAK,WAAW;AACpB,cAAI,MAAM,KAAK,IAAI;AAAA,QACvB,OACK;AAED,cAAI;AACA,oBAAQ,QAAQ,OAAO,gBAAgB,qDAAqD;AAChG,cAAI,WAAW,SAAS;AACpB,gBAAI,QAAQ;AACR,sBAAQ,WAAW,OAAO,WAAW;AAAA;AAErC,sBAAQ,UAAU,WAAW;AAAA,UACrC;AACA,gBAAM,OAAO,IAAI,KAAK,KAAK,OAAO;AAClC,cAAI,IAAI,QAAQ;AACZ,iBAAK,WAAW;AACpB,cAAI,MAAM,KAAK,IAAI;AAAA,QACvB;AAAA,MACJ;AACA,UAAI,cAAc,aAAa;AAC3B,gBAAQ,YAAY,cAAc,mCAAmC;AACzE,UAAI,QAAQ,CAAC,GAAG,QAAQ,QAAQ,cAAc,MAAM;AACpD,aAAO;AAAA,IACX;AApGS;AAsGT,IAAAA,SAAQ,kBAAkB;AAAA;AAAA;;;AChH1B;AAAA,yIAAAC,UAAA;AAAA;AAEA,QAAI,UAAU;AACd,QAAI,eAAe;AACnB,QAAI,sBAAsB;AAE1B,aAAS,gBAAgB,EAAE,aAAa,iBAAiB,GAAG,KAAK,IAAI,SAAS,KAAK;AAC/E,YAAM,YAAY,KAAK,aAAa,QAAQ;AAC5C,YAAM,MAAM,IAAI,UAAU,IAAI,MAAM;AACpC,UAAI,IAAI;AACJ,YAAI,SAAS;AACjB,UAAI,SAAS,GAAG;AAChB,UAAI,aAAa;AACjB,iBAAW,EAAE,OAAO,MAAM,KAAK,GAAG,OAAO;AACrC,cAAM,QAAQ,aAAa,aAAa,OAAO;AAAA,UAC3C,WAAW;AAAA,UACX,MAAM;AAAA,UACN;AAAA,UACA;AAAA,UACA,gBAAgB;AAAA,QACpB,CAAC;AACD,YAAI,CAAC,MAAM,OAAO;AACd,cAAI,MAAM,UAAU,MAAM,OAAO,OAAO;AACpC,gBAAI,SAAS,MAAM,SAAS;AACxB,sBAAQ,MAAM,KAAK,cAAc,kDAAkD;AAAA;AAEnF,sBAAQ,QAAQ,gBAAgB,mCAAmC;AAAA,UAC3E,OACK;AACD,yBAAa,MAAM;AACnB,gBAAI,MAAM;AACN,kBAAI,UAAU,MAAM;AACxB;AAAA,UACJ;AAAA,QACJ;AACA,cAAM,OAAO,QACP,YAAY,KAAK,OAAO,OAAO,OAAO,IACtC,iBAAiB,KAAK,MAAM,KAAK,OAAO,MAAM,OAAO,OAAO;AAClE,YAAI,IAAI,OAAO;AACX,8BAAoB,gBAAgB,GAAG,QAAQ,OAAO,OAAO;AACjE,iBAAS,KAAK,MAAM,CAAC;AACrB,YAAI,MAAM,KAAK,IAAI;AAAA,MACvB;AACA,UAAI,QAAQ,CAAC,GAAG,QAAQ,QAAQ,cAAc,MAAM;AACpD,aAAO;AAAA,IACX;AAvCS;AAyCT,IAAAA,SAAQ,kBAAkB;AAAA;AAAA;;;AC/C1B;AAAA,mIAAAC,UAAA;AAAA;AAEA,aAAS,WAAW,KAAK,QAAQ,UAAU,SAAS;AAChD,UAAI,UAAU;AACd,UAAI,KAAK;AACL,YAAI,WAAW;AACf,YAAI,MAAM;AACV,mBAAW,SAAS,KAAK;AACrB,gBAAM,EAAE,QAAQ,KAAK,IAAI;AACzB,kBAAQ,MAAM;AAAA,YACV,KAAK;AACD,yBAAW;AACX;AAAA,YACJ,KAAK,WAAW;AACZ,kBAAI,YAAY,CAAC;AACb,wBAAQ,OAAO,gBAAgB,wEAAwE;AAC3G,oBAAM,KAAK,OAAO,UAAU,CAAC,KAAK;AAClC,kBAAI,CAAC;AACD,0BAAU;AAAA;AAEV,2BAAW,MAAM;AACrB,oBAAM;AACN;AAAA,YACJ;AAAA,YACA,KAAK;AACD,kBAAI;AACA,uBAAO;AACX,yBAAW;AACX;AAAA,YACJ;AACI,sBAAQ,OAAO,oBAAoB,cAAc,IAAI,cAAc;AAAA,UAC3E;AACA,oBAAU,OAAO;AAAA,QACrB;AAAA,MACJ;AACA,aAAO,EAAE,SAAS,OAAO;AAAA,IAC7B;AAlCS;AAoCT,IAAAA,SAAQ,aAAa;AAAA;AAAA;;;ACtCrB;AAAA,+IAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,OAAO;AACX,QAAI,UAAU;AACd,QAAI,UAAU;AACd,QAAI,aAAa;AACjB,QAAI,eAAe;AACnB,QAAI,sBAAsB;AAC1B,QAAI,kBAAkB;AAEtB,QAAM,WAAW;AACjB,QAAM,UAAU,wBAAC,UAAU,UAAU,MAAM,SAAS,eAAe,MAAM,SAAS,cAAlE;AAChB,aAAS,sBAAsB,EAAE,aAAa,iBAAiB,GAAG,KAAK,IAAI,SAAS,KAAK;AACrF,YAAM,QAAQ,GAAG,MAAM,WAAW;AAClC,YAAM,SAAS,QAAQ,aAAa;AACpC,YAAM,YAAa,KAAK,cAAc,QAAQ,QAAQ,UAAU,QAAQ;AACxE,YAAM,OAAO,IAAI,UAAU,IAAI,MAAM;AACrC,WAAK,OAAO;AACZ,YAAM,SAAS,IAAI;AACnB,UAAI;AACA,YAAI,SAAS;AACjB,UAAI,SAAS,GAAG,SAAS,GAAG,MAAM,OAAO;AACzC,eAAS,IAAI,GAAG,IAAI,GAAG,MAAM,QAAQ,EAAE,GAAG;AACtC,cAAM,WAAW,GAAG,MAAM,CAAC;AAC3B,cAAM,EAAE,OAAO,KAAK,KAAK,MAAM,IAAI;AACnC,cAAM,QAAQ,aAAa,aAAa,OAAO;AAAA,UAC3C,MAAM;AAAA,UACN,WAAW;AAAA,UACX,MAAM,OAAO,MAAM,CAAC;AAAA,UACpB;AAAA,UACA;AAAA,UACA,gBAAgB;AAAA,QACpB,CAAC;AACD,YAAI,CAAC,MAAM,OAAO;AACd,cAAI,CAAC,MAAM,UAAU,CAAC,MAAM,OAAO,CAAC,OAAO,CAAC,OAAO;AAC/C,gBAAI,MAAM,KAAK,MAAM;AACjB,sBAAQ,MAAM,OAAO,oBAAoB,mBAAmB,MAAM,EAAE;AAAA,qBAC/D,IAAI,GAAG,MAAM,SAAS;AAC3B,sBAAQ,MAAM,OAAO,oBAAoB,4BAA4B,MAAM,EAAE;AACjF,gBAAI,MAAM,SAAS;AACf,kBAAI,KAAK;AACL,qBAAK,WAAW,OAAO,MAAM;AAAA;AAE7B,qBAAK,UAAU,MAAM;AAAA,YAC7B;AACA,qBAAS,MAAM;AACf;AAAA,UACJ;AACA,cAAI,CAAC,SAAS,IAAI,QAAQ,UAAU,oBAAoB,gBAAgB,GAAG;AACvE;AAAA,cAAQ;AAAA;AAAA,cACR;AAAA,cAA0B;AAAA,YAAkE;AAAA,QACpG;AACA,YAAI,MAAM,GAAG;AACT,cAAI,MAAM;AACN,oBAAQ,MAAM,OAAO,oBAAoB,mBAAmB,MAAM,EAAE;AAAA,QAC5E,OACK;AACD,cAAI,CAAC,MAAM;AACP,oBAAQ,MAAM,OAAO,gBAAgB,qBAAqB,MAAM,QAAQ;AAC5E,cAAI,MAAM,SAAS;AACf,gBAAI,kBAAkB;AACtB;AAAM,yBAAW,MAAM,OAAO;AAC1B,wBAAQ,GAAG,MAAM;AAAA,kBACb,KAAK;AAAA,kBACL,KAAK;AACD;AAAA,kBACJ,KAAK;AACD,sCAAkB,GAAG,OAAO,UAAU,CAAC;AACvC,0BAAM;AAAA,kBACV;AACI,0BAAM;AAAA,gBACd;AAAA,cACJ;AACA,gBAAI,iBAAiB;AACjB,kBAAI,OAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC3C,kBAAI,SAAS,OAAO,IAAI;AACpB,uBAAO,KAAK,SAAS,KAAK;AAC9B,kBAAI,KAAK;AACL,qBAAK,WAAW,OAAO;AAAA;AAEvB,qBAAK,UAAU;AACnB,oBAAM,UAAU,MAAM,QAAQ,UAAU,gBAAgB,SAAS,CAAC;AAAA,YACtE;AAAA,UACJ;AAAA,QACJ;AACA,YAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,OAAO;AAGhC,gBAAM,YAAY,QACZ,YAAY,KAAK,OAAO,OAAO,OAAO,IACtC,iBAAiB,KAAK,MAAM,KAAK,KAAK,MAAM,OAAO,OAAO;AAChE,eAAK,MAAM,KAAK,SAAS;AACzB,mBAAS,UAAU,MAAM,CAAC;AAC1B,cAAI,QAAQ,KAAK;AACb,oBAAQ,UAAU,OAAO,iBAAiB,QAAQ;AAAA,QAC1D,OACK;AAGD,gBAAM,WAAW,MAAM;AACvB,gBAAM,UAAU,MACV,YAAY,KAAK,KAAK,OAAO,OAAO,IACpC,iBAAiB,KAAK,UAAU,OAAO,MAAM,OAAO,OAAO;AACjE,cAAI,QAAQ,GAAG;AACX,oBAAQ,QAAQ,OAAO,iBAAiB,QAAQ;AAEpD,gBAAM,aAAa,aAAa,aAAa,OAAO,CAAC,GAAG;AAAA,YACpD,MAAM;AAAA,YACN,WAAW;AAAA,YACX,MAAM;AAAA,YACN,QAAQ,QAAQ,MAAM,CAAC;AAAA,YACvB;AAAA,YACA,gBAAgB;AAAA,UACpB,CAAC;AACD,cAAI,WAAW,OAAO;AAClB,gBAAI,CAAC,SAAS,CAAC,MAAM,SAAS,IAAI,QAAQ,QAAQ;AAC9C,kBAAI;AACA,2BAAW,MAAM,KAAK;AAClB,sBAAI,OAAO,WAAW;AAClB;AACJ,sBAAI,GAAG,SAAS,WAAW;AACvB,4BAAQ,IAAI,0BAA0B,kEAAkE;AACxG;AAAA,kBACJ;AAAA,gBACJ;AACJ,kBAAI,MAAM,QAAQ,WAAW,MAAM,SAAS;AACxC,wBAAQ,WAAW,OAAO,uBAAuB,6FAA6F;AAAA,YACtJ;AAAA,UACJ,WACS,OAAO;AACZ,gBAAI,YAAY,SAAS,MAAM,UAAU,MAAM,OAAO,CAAC,MAAM;AACzD,sBAAQ,OAAO,gBAAgB,4BAA4B,MAAM,EAAE;AAAA;AAEnE,sBAAQ,WAAW,OAAO,gBAAgB,0BAA0B,MAAM,QAAQ;AAAA,UAC1F;AAEA,gBAAM,YAAY,QACZ,YAAY,KAAK,OAAO,YAAY,OAAO,IAC3C,WAAW,QACP,iBAAiB,KAAK,WAAW,KAAK,KAAK,MAAM,YAAY,OAAO,IACpE;AACV,cAAI,WAAW;AACX,gBAAI,QAAQ,KAAK;AACb,sBAAQ,UAAU,OAAO,iBAAiB,QAAQ;AAAA,UAC1D,WACS,WAAW,SAAS;AACzB,gBAAI,QAAQ;AACR,sBAAQ,WAAW,OAAO,WAAW;AAAA;AAErC,sBAAQ,UAAU,WAAW;AAAA,UACrC;AACA,gBAAM,OAAO,IAAI,KAAK,KAAK,SAAS,SAAS;AAC7C,cAAI,IAAI,QAAQ;AACZ,iBAAK,WAAW;AACpB,cAAI,OAAO;AACP,kBAAM,MAAM;AACZ,gBAAI,gBAAgB,YAAY,KAAK,IAAI,OAAO,OAAO;AACnD,sBAAQ,UAAU,iBAAiB,yBAAyB;AAChE,gBAAI,MAAM,KAAK,IAAI;AAAA,UACvB,OACK;AACD,kBAAM,MAAM,IAAI,QAAQ,QAAQ,IAAI,MAAM;AAC1C,gBAAI,OAAO;AACX,gBAAI,MAAM,KAAK,IAAI;AACnB,iBAAK,MAAM,KAAK,GAAG;AAAA,UACvB;AACA,mBAAS,YAAY,UAAU,MAAM,CAAC,IAAI,WAAW;AAAA,QACzD;AAAA,MACJ;AACA,YAAM,cAAc,QAAQ,MAAM;AAClC,YAAM,CAAC,IAAI,GAAG,EAAE,IAAI,GAAG;AACvB,UAAI,QAAQ;AACZ,UAAI,MAAM,GAAG,WAAW;AACpB,gBAAQ,GAAG,SAAS,GAAG,OAAO;AAAA,WAC7B;AACD,cAAM,OAAO,OAAO,CAAC,EAAE,YAAY,IAAI,OAAO,UAAU,CAAC;AACzD,cAAM,MAAM,SACN,GAAG,IAAI,oBAAoB,WAAW,KACtC,GAAG,IAAI,qEAAqE,WAAW;AAC7F,gBAAQ,QAAQ,SAAS,iBAAiB,cAAc,GAAG;AAC3D,YAAI,MAAM,GAAG,OAAO,WAAW;AAC3B,aAAG,QAAQ,EAAE;AAAA,MACrB;AACA,UAAI,GAAG,SAAS,GAAG;AACf,cAAM,MAAM,WAAW,WAAW,IAAI,OAAO,IAAI,QAAQ,QAAQ,OAAO;AACxE,YAAI,IAAI,SAAS;AACb,cAAI,KAAK;AACL,iBAAK,WAAW,OAAO,IAAI;AAAA;AAE3B,iBAAK,UAAU,IAAI;AAAA,QAC3B;AACA,aAAK,QAAQ,CAAC,GAAG,QAAQ,OAAO,IAAI,MAAM;AAAA,MAC9C,OACK;AACD,aAAK,QAAQ,CAAC,GAAG,QAAQ,OAAO,KAAK;AAAA,MACzC;AACA,aAAO;AAAA,IACX;AAzLS;AA2LT,IAAAA,SAAQ,wBAAwB;AAAA;AAAA;;;ACxMhC;AAAA,0IAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,UAAU;AACd,QAAI,UAAU;AACd,QAAI,kBAAkB;AACtB,QAAI,kBAAkB;AACtB,QAAI,wBAAwB;AAE5B,aAAS,kBAAkB,IAAI,KAAK,OAAO,SAAS,SAAS,KAAK;AAC9D,YAAM,OAAO,MAAM,SAAS,cACtB,gBAAgB,gBAAgB,IAAI,KAAK,OAAO,SAAS,GAAG,IAC5D,MAAM,SAAS,cACX,gBAAgB,gBAAgB,IAAI,KAAK,OAAO,SAAS,GAAG,IAC5D,sBAAsB,sBAAsB,IAAI,KAAK,OAAO,SAAS,GAAG;AAClF,YAAM,OAAO,KAAK;AAGlB,UAAI,YAAY,OAAO,YAAY,KAAK,SAAS;AAC7C,aAAK,MAAM,KAAK;AAChB,eAAO;AAAA,MACX;AACA,UAAI;AACA,aAAK,MAAM;AACf,aAAO;AAAA,IACX;AAhBS;AAiBT,aAAS,kBAAkB,IAAI,KAAK,OAAO,UAAU,SAAS;AAC1D,YAAM,UAAU,CAAC,WACX,OACA,IAAI,WAAW,QAAQ,SAAS,QAAQ,SAAO,QAAQ,UAAU,sBAAsB,GAAG,CAAC;AACjG,YAAM,UAAU,MAAM,SAAS,cACzB,QACA,MAAM,SAAS,cACX,QACA,MAAM,MAAM,WAAW,MACnB,QACA;AAGd,UAAI,CAAC,YACD,CAAC,WACD,YAAY,OACX,YAAY,QAAQ,QAAQ,WAAW,YAAY,SACnD,YAAY,QAAQ,QAAQ,WAAW,YAAY,SACpD,CAAC,SAAS;AACV,eAAO,kBAAkB,IAAI,KAAK,OAAO,SAAS,OAAO;AAAA,MAC7D;AACA,UAAI,MAAM,IAAI,OAAO,KAAK,KAAK,OAAK,EAAE,QAAQ,WAAW,EAAE,eAAe,OAAO;AACjF,UAAI,CAAC,KAAK;AACN,cAAM,KAAK,IAAI,OAAO,UAAU,OAAO;AACvC,YAAI,MAAM,GAAG,eAAe,SAAS;AACjC,cAAI,OAAO,KAAK,KAAK,OAAO,OAAO,CAAC,GAAG,IAAI,EAAE,SAAS,MAAM,CAAC,CAAC;AAC9D,gBAAM;AAAA,QACV,OACK;AACD,cAAI,IAAI,YAAY;AAChB,oBAAQ,UAAU,uBAAuB,GAAG,GAAG,GAAG,aAAa,OAAO,4BAA4B,GAAG,UAAU,IAAI,IAAI;AAAA,UAC3H,OACK;AACD,oBAAQ,UAAU,sBAAsB,mBAAmB,OAAO,IAAI,IAAI;AAAA,UAC9E;AACA,iBAAO,kBAAkB,IAAI,KAAK,OAAO,SAAS,OAAO;AAAA,QAC7D;AAAA,MACJ;AACA,YAAM,OAAO,kBAAkB,IAAI,KAAK,OAAO,SAAS,SAAS,GAAG;AACpE,YAAM,MAAM,IAAI,UAAU,MAAM,SAAO,QAAQ,UAAU,sBAAsB,GAAG,GAAG,IAAI,OAAO,KAAK;AACrG,YAAM,OAAO,SAAS,OAAO,GAAG,IAC1B,MACA,IAAI,OAAO,OAAO,GAAG;AAC3B,WAAK,QAAQ,KAAK;AAClB,WAAK,MAAM;AACX,UAAI,KAAK;AACL,aAAK,SAAS,IAAI;AACtB,aAAO;AAAA,IACX;AAhDS;AAkDT,IAAAA,SAAQ,oBAAoB;AAAA;AAAA;;;AC7E5B;AAAA,4IAAAC,UAAA;AAAA;AAEA,QAAI,SAAS;AAEb,aAAS,mBAAmB,QAAQ,QAAQ,SAAS;AACjD,YAAM,QAAQ,OAAO;AACrB,YAAM,SAAS,uBAAuB,QAAQ,QAAQ,OAAO;AAC7D,UAAI,CAAC;AACD,eAAO,EAAE,OAAO,IAAI,MAAM,MAAM,SAAS,IAAI,OAAO,CAAC,OAAO,OAAO,KAAK,EAAE;AAC9E,YAAM,OAAO,OAAO,SAAS,MAAM,OAAO,OAAO,eAAe,OAAO,OAAO;AAC9E,YAAM,QAAQ,OAAO,SAAS,WAAW,OAAO,MAAM,IAAI,CAAC;AAE3D,UAAI,aAAa,MAAM;AACvB,eAAS,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACxC,cAAM,UAAU,MAAM,CAAC,EAAE,CAAC;AAC1B,YAAI,YAAY,MAAM,YAAY;AAC9B,uBAAa;AAAA;AAEb;AAAA,MACR;AAEA,UAAI,eAAe,GAAG;AAClB,cAAMC,SAAQ,OAAO,UAAU,OAAO,MAAM,SAAS,IAC/C,KAAK,OAAO,KAAK,IAAI,GAAG,MAAM,SAAS,CAAC,CAAC,IACzC;AACN,YAAIC,OAAM,QAAQ,OAAO;AACzB,YAAI,OAAO;AACP,UAAAA,QAAO,OAAO,OAAO;AACzB,eAAO,EAAE,OAAAD,QAAO,MAAM,SAAS,OAAO,SAAS,OAAO,CAAC,OAAOC,MAAKA,IAAG,EAAE;AAAA,MAC5E;AAEA,UAAI,aAAa,OAAO,SAAS,OAAO;AACxC,UAAI,SAAS,OAAO,SAAS,OAAO;AACpC,UAAI,eAAe;AACnB,eAAS,IAAI,GAAG,IAAI,YAAY,EAAE,GAAG;AACjC,cAAM,CAAC,QAAQ,OAAO,IAAI,MAAM,CAAC;AACjC,YAAI,YAAY,MAAM,YAAY,MAAM;AACpC,cAAI,OAAO,WAAW,KAAK,OAAO,SAAS;AACvC,yBAAa,OAAO;AAAA,QAC5B,OACK;AACD,cAAI,OAAO,SAAS,YAAY;AAC5B,kBAAM,UAAU;AAChB,oBAAQ,SAAS,OAAO,QAAQ,gBAAgB,OAAO;AAAA,UAC3D;AACA,cAAI,OAAO,WAAW;AAClB,yBAAa,OAAO;AACxB,yBAAe;AACf;AAAA,QACJ;AACA,kBAAU,OAAO,SAAS,QAAQ,SAAS;AAAA,MAC/C;AAEA,eAAS,IAAI,MAAM,SAAS,GAAG,KAAK,YAAY,EAAE,GAAG;AACjD,YAAI,MAAM,CAAC,EAAE,CAAC,EAAE,SAAS;AACrB,uBAAa,IAAI;AAAA,MACzB;AACA,UAAI,QAAQ;AACZ,UAAI,MAAM;AACV,UAAI,mBAAmB;AAEvB,eAAS,IAAI,GAAG,IAAI,cAAc,EAAE;AAChC,iBAAS,MAAM,CAAC,EAAE,CAAC,EAAE,MAAM,UAAU,IAAI;AAC7C,eAAS,IAAI,cAAc,IAAI,YAAY,EAAE,GAAG;AAC5C,YAAI,CAAC,QAAQ,OAAO,IAAI,MAAM,CAAC;AAC/B,kBAAU,OAAO,SAAS,QAAQ,SAAS;AAC3C,cAAM,OAAO,QAAQ,QAAQ,SAAS,CAAC,MAAM;AAC7C,YAAI;AACA,oBAAU,QAAQ,MAAM,GAAG,EAAE;AAEjC,YAAI,WAAW,OAAO,SAAS,YAAY;AACvC,gBAAM,MAAM,OAAO,SACb,mCACA;AACN,gBAAM,UAAU,2DAA2D,GAAG;AAC9E,kBAAQ,SAAS,QAAQ,UAAU,OAAO,IAAI,IAAI,cAAc,OAAO;AACvE,mBAAS;AAAA,QACb;AACA,YAAI,SAAS,OAAO,OAAO,eAAe;AACtC,mBAAS,MAAM,OAAO,MAAM,UAAU,IAAI;AAC1C,gBAAM;AAAA,QACV,WACS,OAAO,SAAS,cAAc,QAAQ,CAAC,MAAM,KAAM;AAExD,cAAI,QAAQ;AACR,kBAAM;AAAA,mBACD,CAAC,oBAAoB,QAAQ;AAClC,kBAAM;AACV,mBAAS,MAAM,OAAO,MAAM,UAAU,IAAI;AAC1C,gBAAM;AACN,6BAAmB;AAAA,QACvB,WACS,YAAY,IAAI;AAErB,cAAI,QAAQ;AACR,qBAAS;AAAA;AAET,kBAAM;AAAA,QACd,OACK;AACD,mBAAS,MAAM;AACf,gBAAM;AACN,6BAAmB;AAAA,QACvB;AAAA,MACJ;AACA,cAAQ,OAAO,OAAO;AAAA,QAClB,KAAK;AACD;AAAA,QACJ,KAAK;AACD,mBAAS,IAAI,YAAY,IAAI,MAAM,QAAQ,EAAE;AACzC,qBAAS,OAAO,MAAM,CAAC,EAAE,CAAC,EAAE,MAAM,UAAU;AAChD,cAAI,MAAM,MAAM,SAAS,CAAC,MAAM;AAC5B,qBAAS;AACb;AAAA,QACJ;AACI,mBAAS;AAAA,MACjB;AACA,YAAM,MAAM,QAAQ,OAAO,SAAS,OAAO,OAAO;AAClD,aAAO,EAAE,OAAO,MAAM,SAAS,OAAO,SAAS,OAAO,CAAC,OAAO,KAAK,GAAG,EAAE;AAAA,IAC5E;AAnHS;AAoHT,aAAS,uBAAuB,EAAE,QAAQ,MAAM,GAAG,QAAQ,SAAS;AAEhE,UAAI,MAAM,CAAC,EAAE,SAAS,uBAAuB;AACzC,gBAAQ,MAAM,CAAC,GAAG,cAAc,+BAA+B;AAC/D,eAAO;AAAA,MACX;AACA,YAAM,EAAE,OAAO,IAAI,MAAM,CAAC;AAC1B,YAAM,OAAO,OAAO,CAAC;AACrB,UAAI,SAAS;AACb,UAAI,QAAQ;AACZ,UAAI,QAAQ;AACZ,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACpC,cAAM,KAAK,OAAO,CAAC;AACnB,YAAI,CAAC,UAAU,OAAO,OAAO,OAAO;AAChC,kBAAQ;AAAA,aACP;AACD,gBAAM,IAAI,OAAO,EAAE;AACnB,cAAI,CAAC,UAAU;AACX,qBAAS;AAAA,mBACJ,UAAU;AACf,oBAAQ,SAAS;AAAA,QACzB;AAAA,MACJ;AACA,UAAI,UAAU;AACV,gBAAQ,OAAO,oBAAoB,kDAAkD,MAAM,EAAE;AACjG,UAAI,WAAW;AACf,UAAI,UAAU;AACd,UAAI,SAAS,OAAO;AACpB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACnC,cAAM,QAAQ,MAAM,CAAC;AACrB,gBAAQ,MAAM,MAAM;AAAA,UAChB,KAAK;AACD,uBAAW;AAAA,UAEf,KAAK;AACD,sBAAU,MAAM,OAAO;AACvB;AAAA,UACJ,KAAK;AACD,gBAAI,UAAU,CAAC,UAAU;AACrB,oBAAM,UAAU;AAChB,sBAAQ,OAAO,gBAAgB,OAAO;AAAA,YAC1C;AACA,sBAAU,MAAM,OAAO;AACvB,sBAAU,MAAM,OAAO,UAAU,CAAC;AAClC;AAAA,UACJ,KAAK;AACD,oBAAQ,OAAO,oBAAoB,MAAM,OAAO;AAChD,sBAAU,MAAM,OAAO;AACvB;AAAA,UAEJ,SAAS;AACL,kBAAM,UAAU,4CAA4C,MAAM,IAAI;AACtE,oBAAQ,OAAO,oBAAoB,OAAO;AAC1C,kBAAM,KAAK,MAAM;AACjB,gBAAI,MAAM,OAAO,OAAO;AACpB,wBAAU,GAAG;AAAA,UACrB;AAAA,QACJ;AAAA,MACJ;AACA,aAAO,EAAE,MAAM,QAAQ,OAAO,SAAS,OAAO;AAAA,IAClD;AA5DS;AA8DT,aAAS,WAAW,QAAQ;AACxB,YAAM,QAAQ,OAAO,MAAM,QAAQ;AACnC,YAAM,QAAQ,MAAM,CAAC;AACrB,YAAM,IAAI,MAAM,MAAM,OAAO;AAC7B,YAAM,QAAQ,IAAI,CAAC,IACb,CAAC,EAAE,CAAC,GAAG,MAAM,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,IAC/B,CAAC,IAAI,KAAK;AAChB,YAAM,QAAQ,CAAC,KAAK;AACpB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,cAAM,KAAK,CAAC,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC,CAAC,CAAC;AACvC,aAAO;AAAA,IACX;AAXS;AAaT,IAAAF,SAAQ,qBAAqB;AAAA;AAAA;;;ACnM7B;AAAA,2IAAAG,UAAA;AAAA;AAEA,QAAI,SAAS;AACb,QAAI,aAAa;AAEjB,aAAS,kBAAkB,QAAQ,QAAQ,SAAS;AAChD,YAAM,EAAE,QAAQ,MAAM,QAAQ,IAAI,IAAI;AACtC,UAAI;AACJ,UAAI;AACJ,YAAM,WAAW,wBAAC,KAAK,MAAM,QAAQ,QAAQ,SAAS,KAAK,MAAM,GAAG,GAAnD;AACjB,cAAQ,MAAM;AAAA,QACV,KAAK;AACD,kBAAQ,OAAO,OAAO;AACtB,kBAAQ,WAAW,QAAQ,QAAQ;AACnC;AAAA,QACJ,KAAK;AACD,kBAAQ,OAAO,OAAO;AACtB,kBAAQ,kBAAkB,QAAQ,QAAQ;AAC1C;AAAA,QACJ,KAAK;AACD,kBAAQ,OAAO,OAAO;AACtB,kBAAQ,kBAAkB,QAAQ,QAAQ;AAC1C;AAAA,QAEJ;AACI,kBAAQ,QAAQ,oBAAoB,4CAA4C,IAAI,EAAE;AACtF,iBAAO;AAAA,YACH,OAAO;AAAA,YACP,MAAM;AAAA,YACN,SAAS;AAAA,YACT,OAAO,CAAC,QAAQ,SAAS,OAAO,QAAQ,SAAS,OAAO,MAAM;AAAA,UAClE;AAAA,MACR;AACA,YAAM,WAAW,SAAS,OAAO;AACjC,YAAM,KAAK,WAAW,WAAW,KAAK,UAAU,QAAQ,OAAO;AAC/D,aAAO;AAAA,QACH;AAAA,QACA,MAAM;AAAA,QACN,SAAS,GAAG;AAAA,QACZ,OAAO,CAAC,QAAQ,UAAU,GAAG,MAAM;AAAA,MACvC;AAAA,IACJ;AApCS;AAqCT,aAAS,WAAW,QAAQ,SAAS;AACjC,UAAI,UAAU;AACd,cAAQ,OAAO,CAAC,GAAG;AAAA,QAEf,KAAK;AACD,oBAAU;AACV;AAAA,QACJ,KAAK;AACD,oBAAU;AACV;AAAA,QACJ,KAAK;AACD,oBAAU;AACV;AAAA,QACJ,KAAK;AAAA,QACL,KAAK,KAAK;AACN,oBAAU,0BAA0B,OAAO,CAAC,CAAC;AAC7C;AAAA,QACJ;AAAA,QACA,KAAK;AAAA,QACL,KAAK,KAAK;AACN,oBAAU,sBAAsB,OAAO,CAAC,CAAC;AACzC;AAAA,QACJ;AAAA,MACJ;AACA,UAAI;AACA,gBAAQ,GAAG,oBAAoB,iCAAiC,OAAO,EAAE;AAC7E,aAAO,UAAU,MAAM;AAAA,IAC3B;AA3BS;AA4BT,aAAS,kBAAkB,QAAQ,SAAS;AACxC,UAAI,OAAO,OAAO,SAAS,CAAC,MAAM,OAAO,OAAO,WAAW;AACvD,gBAAQ,OAAO,QAAQ,gBAAgB,wBAAwB;AACnE,aAAO,UAAU,OAAO,MAAM,GAAG,EAAE,CAAC,EAAE,QAAQ,OAAO,GAAG;AAAA,IAC5D;AAJS;AAKT,aAAS,UAAU,QAAQ;AAQvB,UAAI,OAAO;AACX,UAAI;AACA,gBAAQ,IAAI,OAAO,4BAA8B,IAAI;AACrD,eAAO,IAAI,OAAO,sCAAyC,IAAI;AAAA,MACnE,SACO,GAAG;AACN,gBAAQ;AACR,eAAO;AAAA,MACX;AACA,UAAI,QAAQ,MAAM,KAAK,MAAM;AAC7B,UAAI,CAAC;AACD,eAAO;AACX,UAAI,MAAM,MAAM,CAAC;AACjB,UAAI,MAAM;AACV,UAAI,MAAM,MAAM;AAChB,WAAK,YAAY;AACjB,aAAQ,QAAQ,KAAK,KAAK,MAAM,GAAI;AAChC,YAAI,MAAM,CAAC,MAAM,IAAI;AACjB,cAAI,QAAQ;AACR,mBAAO;AAAA;AAEP,kBAAM;AAAA,QACd,OACK;AACD,iBAAO,MAAM,MAAM,CAAC;AACpB,gBAAM;AAAA,QACV;AACA,cAAM,KAAK;AAAA,MACf;AACA,YAAM,OAAO;AACb,WAAK,YAAY;AACjB,cAAQ,KAAK,KAAK,MAAM;AACxB,aAAO,MAAM,OAAO,QAAQ,CAAC,KAAK;AAAA,IACtC;AAzCS;AA0CT,aAAS,kBAAkB,QAAQ,SAAS;AACxC,UAAI,MAAM;AACV,eAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,EAAE,GAAG;AACxC,cAAM,KAAK,OAAO,CAAC;AACnB,YAAI,OAAO,QAAQ,OAAO,IAAI,CAAC,MAAM;AACjC;AACJ,YAAI,OAAO,MAAM;AACb,gBAAM,EAAE,MAAM,OAAO,IAAI,YAAY,QAAQ,CAAC;AAC9C,iBAAO;AACP,cAAI;AAAA,QACR,WACS,OAAO,MAAM;AAClB,cAAI,OAAO,OAAO,EAAE,CAAC;AACrB,gBAAM,KAAK,YAAY,IAAI;AAC3B,cAAI;AACA,mBAAO;AAAA,mBACF,SAAS,MAAM;AAEpB,mBAAO,OAAO,IAAI,CAAC;AACnB,mBAAO,SAAS,OAAO,SAAS;AAC5B,qBAAO,OAAO,EAAE,IAAI,CAAC;AAAA,UAC7B,WACS,SAAS,QAAQ,OAAO,IAAI,CAAC,MAAM,MAAM;AAE9C,mBAAO,OAAO,EAAE,IAAI,CAAC;AACrB,mBAAO,SAAS,OAAO,SAAS;AAC5B,qBAAO,OAAO,EAAE,IAAI,CAAC;AAAA,UAC7B,WACS,SAAS,OAAO,SAAS,OAAO,SAAS,KAAK;AACnD,kBAAM,SAAS,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,IAAI;AACxC,mBAAO,cAAc,QAAQ,IAAI,GAAG,QAAQ,OAAO;AACnD,iBAAK;AAAA,UACT,OACK;AACD,kBAAM,MAAM,OAAO,OAAO,IAAI,GAAG,CAAC;AAClC,oBAAQ,IAAI,GAAG,iBAAiB,2BAA2B,GAAG,EAAE;AAChE,mBAAO;AAAA,UACX;AAAA,QACJ,WACS,OAAO,OAAO,OAAO,KAAM;AAEhC,gBAAM,UAAU;AAChB,cAAI,OAAO,OAAO,IAAI,CAAC;AACvB,iBAAO,SAAS,OAAO,SAAS;AAC5B,mBAAO,OAAO,EAAE,IAAI,CAAC;AACzB,cAAI,SAAS,QAAQ,EAAE,SAAS,QAAQ,OAAO,IAAI,CAAC,MAAM;AACtD,mBAAO,IAAI,UAAU,OAAO,MAAM,SAAS,IAAI,CAAC,IAAI;AAAA,QAC5D,OACK;AACD,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,UAAI,OAAO,OAAO,SAAS,CAAC,MAAM,OAAO,OAAO,WAAW;AACvD,gBAAQ,OAAO,QAAQ,gBAAgB,wBAAwB;AACnE,aAAO;AAAA,IACX;AAvDS;AA4DT,aAAS,YAAY,QAAQ,QAAQ;AACjC,UAAI,OAAO;AACX,UAAI,KAAK,OAAO,SAAS,CAAC;AAC1B,aAAO,OAAO,OAAO,OAAO,OAAQ,OAAO,QAAQ,OAAO,MAAM;AAC5D,YAAI,OAAO,QAAQ,OAAO,SAAS,CAAC,MAAM;AACtC;AACJ,YAAI,OAAO;AACP,kBAAQ;AACZ,kBAAU;AACV,aAAK,OAAO,SAAS,CAAC;AAAA,MAC1B;AACA,UAAI,CAAC;AACD,eAAO;AACX,aAAO,EAAE,MAAM,OAAO;AAAA,IAC1B;AAdS;AAeT,QAAM,cAAc;AAAA,MAChB,KAAK;AAAA,MACL,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,MAAM;AAAA,MACN,KAAM;AAAA,IACV;AACA,aAAS,cAAc,QAAQ,QAAQ,QAAQ,SAAS;AACpD,YAAM,KAAK,OAAO,OAAO,QAAQ,MAAM;AACvC,YAAM,KAAK,GAAG,WAAW,UAAU,iBAAiB,KAAK,EAAE;AAC3D,YAAM,OAAO,KAAK,SAAS,IAAI,EAAE,IAAI;AACrC,UAAI,MAAM,IAAI,GAAG;AACb,cAAM,MAAM,OAAO,OAAO,SAAS,GAAG,SAAS,CAAC;AAChD,gBAAQ,SAAS,GAAG,iBAAiB,2BAA2B,GAAG,EAAE;AACrE,eAAO;AAAA,MACX;AACA,aAAO,OAAO,cAAc,IAAI;AAAA,IACpC;AAVS;AAYT,IAAAA,SAAQ,oBAAoB;AAAA;AAAA;;;AChO5B;AAAA,sIAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,qBAAqB;AACzB,QAAI,oBAAoB;AAExB,aAAS,cAAc,KAAK,OAAO,UAAU,SAAS;AAClD,YAAM,EAAE,OAAO,MAAM,SAAS,MAAM,IAAI,MAAM,SAAS,iBACjD,mBAAmB,mBAAmB,OAAO,IAAI,QAAQ,QAAQ,OAAO,IACxE,kBAAkB,kBAAkB,OAAO,IAAI,QAAQ,QAAQ,OAAO;AAC5E,YAAM,UAAU,WACV,IAAI,WAAW,QAAQ,SAAS,QAAQ,SAAO,QAAQ,UAAU,sBAAsB,GAAG,CAAC,IAC3F;AACN,YAAM,MAAM,YAAY,UAClB,oBAAoB,IAAI,QAAQ,OAAO,SAAS,UAAU,OAAO,IACjE,MAAM,SAAS,WACX,oBAAoB,KAAK,OAAO,OAAO,OAAO,IAC9C,IAAI,OAAO,SAAS,MAAM;AACpC,UAAI;AACJ,UAAI;AACA,cAAM,MAAM,IAAI,QAAQ,OAAO,SAAO,QAAQ,YAAY,OAAO,sBAAsB,GAAG,GAAG,IAAI,OAAO;AACxG,iBAAS,SAAS,SAAS,GAAG,IAAI,MAAM,IAAI,OAAO,OAAO,GAAG;AAAA,MACjE,SACO,OAAO;AACV,cAAM,MAAM,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AACjE,gBAAQ,YAAY,OAAO,sBAAsB,GAAG;AACpD,iBAAS,IAAI,OAAO,OAAO,KAAK;AAAA,MACpC;AACA,aAAO,QAAQ;AACf,aAAO,SAAS;AAChB,UAAI;AACA,eAAO,OAAO;AAClB,UAAI;AACA,eAAO,MAAM;AACjB,UAAI,IAAI;AACJ,eAAO,SAAS,IAAI;AACxB,UAAI;AACA,eAAO,UAAU;AACrB,aAAO;AAAA,IACX;AAjCS;AAkCT,aAAS,oBAAoB,QAAQ,OAAO,SAAS,UAAU,SAAS;AACpE,UAAI,YAAY;AACZ,eAAO,OAAO,SAAS,MAAM;AACjC,YAAM,gBAAgB,CAAC;AACvB,iBAAW,OAAO,OAAO,MAAM;AAC3B,YAAI,CAAC,IAAI,cAAc,IAAI,QAAQ,SAAS;AACxC,cAAI,IAAI,WAAW,IAAI;AACnB,0BAAc,KAAK,GAAG;AAAA;AAEtB,mBAAO;AAAA,QACf;AAAA,MACJ;AACA,iBAAW,OAAO;AACd,YAAI,IAAI,MAAM,KAAK,KAAK;AACpB,iBAAO;AACf,YAAM,KAAK,OAAO,UAAU,OAAO;AACnC,UAAI,MAAM,CAAC,GAAG,YAAY;AAGtB,eAAO,KAAK,KAAK,OAAO,OAAO,CAAC,GAAG,IAAI,EAAE,SAAS,OAAO,MAAM,OAAU,CAAC,CAAC;AAC3E,eAAO;AAAA,MACX;AACA,cAAQ,UAAU,sBAAsB,mBAAmB,OAAO,IAAI,YAAY,uBAAuB;AACzG,aAAO,OAAO,SAAS,MAAM;AAAA,IACjC;AAxBS;AAyBT,aAAS,oBAAoB,EAAE,YAAY,OAAO,GAAG,OAAO,OAAO,SAAS;AACxE,YAAM,MAAM,OAAO,KAAK,KAAK,CAAAC,SAAOA,KAAI,WAAWA,KAAI,MAAM,KAAK,KAAK,CAAC,KAAK,OAAO,SAAS,MAAM;AACnG,UAAI,OAAO,QAAQ;AACf,cAAM,SAAS,OAAO,OAAO,KAAK,CAAAA,SAAOA,KAAI,WAAWA,KAAI,MAAM,KAAK,KAAK,CAAC,KACzE,OAAO,SAAS,MAAM;AAC1B,YAAI,IAAI,QAAQ,OAAO,KAAK;AACxB,gBAAM,KAAK,WAAW,UAAU,IAAI,GAAG;AACvC,gBAAM,KAAK,WAAW,UAAU,OAAO,GAAG;AAC1C,gBAAM,MAAM,iCAAiC,EAAE,OAAO,EAAE;AACxD,kBAAQ,OAAO,sBAAsB,KAAK,IAAI;AAAA,QAClD;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAbS;AAeT,IAAAD,SAAQ,gBAAgB;AAAA;AAAA;;;ACjFxB;AAAA,kJAAAE,UAAA;AAAA;AAEA,aAAS,oBAAoB,QAAQ,QAAQ,KAAK;AAC9C,UAAI,QAAQ;AACR,YAAI,QAAQ;AACR,gBAAM,OAAO;AACjB,iBAAS,IAAI,MAAM,GAAG,KAAK,GAAG,EAAE,GAAG;AAC/B,cAAI,KAAK,OAAO,CAAC;AACjB,kBAAQ,GAAG,MAAM;AAAA,YACb,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACD,wBAAU,GAAG,OAAO;AACpB;AAAA,UACR;AAGA,eAAK,OAAO,EAAE,CAAC;AACf,iBAAO,IAAI,SAAS,SAAS;AACzB,sBAAU,GAAG,OAAO;AACpB,iBAAK,OAAO,EAAE,CAAC;AAAA,UACnB;AACA;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAxBS;AA0BT,IAAAA,SAAQ,sBAAsB;AAAA;AAAA;;;AC5B9B;AAAA,oIAAAC,UAAA;AAAA;AAEA,QAAI,QAAQ;AACZ,QAAI,oBAAoB;AACxB,QAAI,gBAAgB;AACpB,QAAI,aAAa;AACjB,QAAI,0BAA0B;AAE9B,QAAM,KAAK,EAAE,aAAa,iBAAiB;AAC3C,aAAS,YAAY,KAAK,OAAO,OAAO,SAAS;AAC7C,YAAM,EAAE,aAAa,SAAS,QAAQ,IAAI,IAAI;AAC9C,UAAI;AACJ,UAAI,aAAa;AACjB,cAAQ,MAAM,MAAM;AAAA,QAChB,KAAK;AACD,iBAAO,aAAa,KAAK,OAAO,OAAO;AACvC,cAAI,UAAU;AACV,oBAAQ,OAAO,eAAe,+CAA+C;AACjF;AAAA,QACJ,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,iBAAO,cAAc,cAAc,KAAK,OAAO,KAAK,OAAO;AAC3D,cAAI;AACA,iBAAK,SAAS,OAAO,OAAO,UAAU,CAAC;AAC3C;AAAA,QACJ,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,iBAAO,kBAAkB,kBAAkB,IAAI,KAAK,OAAO,KAAK,OAAO;AACvE,cAAI;AACA,iBAAK,SAAS,OAAO,OAAO,UAAU,CAAC;AAC3C;AAAA,QACJ,SAAS;AACL,gBAAM,UAAU,MAAM,SAAS,UACzB,MAAM,UACN,4BAA4B,MAAM,IAAI;AAC5C,kBAAQ,OAAO,oBAAoB,OAAO;AAC1C,iBAAO,iBAAiB,KAAK,MAAM,QAAQ,QAAW,MAAM,OAAO,OAAO;AAC1E,uBAAa;AAAA,QACjB;AAAA,MACJ;AACA,UAAI,UAAU,KAAK,WAAW;AAC1B,gBAAQ,QAAQ,aAAa,kCAAkC;AACnE,UAAI;AACA,aAAK,cAAc;AACvB,UAAI,SAAS;AACT,YAAI,MAAM,SAAS,YAAY,MAAM,WAAW;AAC5C,eAAK,UAAU;AAAA;AAEf,eAAK,gBAAgB;AAAA,MAC7B;AAEA,UAAI,IAAI,QAAQ,oBAAoB;AAChC,aAAK,WAAW;AACpB,aAAO;AAAA,IACX;AAhDS;AAiDT,aAAS,iBAAiB,KAAK,QAAQ,QAAQ,KAAK,EAAE,aAAa,SAAS,QAAQ,KAAK,IAAI,GAAG,SAAS;AACrG,YAAM,QAAQ;AAAA,QACV,MAAM;AAAA,QACN,QAAQ,wBAAwB,oBAAoB,QAAQ,QAAQ,GAAG;AAAA,QACvE,QAAQ;AAAA,QACR,QAAQ;AAAA,MACZ;AACA,YAAM,OAAO,cAAc,cAAc,KAAK,OAAO,KAAK,OAAO;AACjE,UAAI,QAAQ;AACR,aAAK,SAAS,OAAO,OAAO,UAAU,CAAC;AACvC,YAAI,KAAK,WAAW;AAChB,kBAAQ,QAAQ,aAAa,kCAAkC;AAAA,MACvE;AACA,UAAI;AACA,aAAK,cAAc;AACvB,UAAI,SAAS;AACT,aAAK,UAAU;AACf,aAAK,MAAM,CAAC,IAAI;AAAA,MACpB;AACA,aAAO;AAAA,IACX;AApBS;AAqBT,aAAS,aAAa,EAAE,QAAQ,GAAG,EAAE,QAAQ,QAAQ,IAAI,GAAG,SAAS;AACjE,YAAM,QAAQ,IAAI,MAAM,MAAM,OAAO,UAAU,CAAC,CAAC;AACjD,UAAI,MAAM,WAAW;AACjB,gBAAQ,QAAQ,aAAa,iCAAiC;AAClE,UAAI,MAAM,OAAO,SAAS,GAAG;AACzB,gBAAQ,SAAS,OAAO,SAAS,GAAG,aAAa,kCAAkC,IAAI;AAC3F,YAAM,WAAW,SAAS,OAAO;AACjC,YAAM,KAAK,WAAW,WAAW,KAAK,UAAU,QAAQ,QAAQ,OAAO;AACvE,YAAM,QAAQ,CAAC,QAAQ,UAAU,GAAG,MAAM;AAC1C,UAAI,GAAG;AACH,cAAM,UAAU,GAAG;AACvB,aAAO;AAAA,IACX;AAZS;AAcT,IAAAA,SAAQ,mBAAmB;AAC3B,IAAAA,SAAQ,cAAc;AAAA;AAAA;;;AC9FtB;AAAA,mIAAAC,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,cAAc;AAClB,QAAI,aAAa;AACjB,QAAI,eAAe;AAEnB,aAAS,WAAW,SAAS,YAAY,EAAE,QAAQ,OAAO,OAAO,IAAI,GAAG,SAAS;AAC7E,YAAM,OAAO,OAAO,OAAO,EAAE,aAAa,WAAW,GAAG,OAAO;AAC/D,YAAM,MAAM,IAAI,SAAS,SAAS,QAAW,IAAI;AACjD,YAAM,MAAM;AAAA,QACR,QAAQ;AAAA,QACR,YAAY,IAAI;AAAA,QAChB,SAAS,IAAI;AAAA,QACb,QAAQ,IAAI;AAAA,MAChB;AACA,YAAM,QAAQ,aAAa,aAAa,OAAO;AAAA,QAC3C,WAAW;AAAA,QACX,MAAM,SAAS,MAAM,CAAC;AAAA,QACtB;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,MACpB,CAAC;AACD,UAAI,MAAM,OAAO;AACb,YAAI,WAAW,WAAW;AAC1B,YAAI,UACC,MAAM,SAAS,eAAe,MAAM,SAAS,gBAC9C,CAAC,MAAM;AACP,kBAAQ,MAAM,KAAK,gBAAgB,uEAAuE;AAAA,MAClH;AAEA,UAAI,WAAW,QACT,YAAY,YAAY,KAAK,OAAO,OAAO,OAAO,IAClD,YAAY,iBAAiB,KAAK,MAAM,KAAK,OAAO,MAAM,OAAO,OAAO;AAC9E,YAAM,aAAa,IAAI,SAAS,MAAM,CAAC;AACvC,YAAM,KAAK,WAAW,WAAW,KAAK,YAAY,OAAO,OAAO;AAChE,UAAI,GAAG;AACH,YAAI,UAAU,GAAG;AACrB,UAAI,QAAQ,CAAC,QAAQ,YAAY,GAAG,MAAM;AAC1C,aAAO;AAAA,IACX;AAjCS;AAmCT,IAAAA,SAAQ,aAAa;AAAA;AAAA;;;AC1CrB;AAAA,gIAAAC,UAAA;AAAA;AAEA,QAAI,aAAa;AACjB,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,WAAW;AACf,QAAI,aAAa;AACjB,QAAI,aAAa;AAEjB,aAAS,YAAY,KAAK;AACtB,UAAI,OAAO,QAAQ;AACf,eAAO,CAAC,KAAK,MAAM,CAAC;AACxB,UAAI,MAAM,QAAQ,GAAG;AACjB,eAAO,IAAI,WAAW,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;AACnD,YAAM,EAAE,QAAQ,OAAO,IAAI;AAC3B,aAAO,CAAC,QAAQ,UAAU,OAAO,WAAW,WAAW,OAAO,SAAS,EAAE;AAAA,IAC7E;AAPS;AAQT,aAAS,aAAa,SAAS;AAC3B,UAAI,UAAU;AACd,UAAI,YAAY;AAChB,UAAI,iBAAiB;AACrB,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACrC,cAAM,SAAS,QAAQ,CAAC;AACxB,gBAAQ,OAAO,CAAC,GAAG;AAAA,UACf,KAAK;AACD,wBACK,YAAY,KAAK,KAAK,iBAAiB,SAAS,SAC5C,OAAO,UAAU,CAAC,KAAK;AAChC,wBAAY;AACZ,6BAAiB;AACjB;AAAA,UACJ,KAAK;AACD,gBAAI,QAAQ,IAAI,CAAC,IAAI,CAAC,MAAM;AACxB,mBAAK;AACT,wBAAY;AACZ;AAAA,UACJ;AAEI,gBAAI,CAAC;AACD,+BAAiB;AACrB,wBAAY;AAAA,QACpB;AAAA,MACJ;AACA,aAAO,EAAE,SAAS,eAAe;AAAA,IACrC;AA3BS;AAuCT,QAAM,WAAN,MAAe;AAAA,MAxDf,OAwDe;AAAA;AAAA;AAAA,MACX,YAAY,UAAU,CAAC,GAAG;AACtB,aAAK,MAAM;AACX,aAAK,eAAe;AACpB,aAAK,UAAU,CAAC;AAChB,aAAK,SAAS,CAAC;AACf,aAAK,WAAW,CAAC;AACjB,aAAK,UAAU,CAAC,QAAQ,MAAM,SAAS,YAAY;AAC/C,gBAAM,MAAM,YAAY,MAAM;AAC9B,cAAI;AACA,iBAAK,SAAS,KAAK,IAAI,OAAO,YAAY,KAAK,MAAM,OAAO,CAAC;AAAA;AAE7D,iBAAK,OAAO,KAAK,IAAI,OAAO,eAAe,KAAK,MAAM,OAAO,CAAC;AAAA,QACtE;AAEA,aAAK,aAAa,IAAI,WAAW,WAAW,EAAE,SAAS,QAAQ,WAAW,MAAM,CAAC;AACjF,aAAK,UAAU;AAAA,MACnB;AAAA,MACA,SAAS,KAAK,UAAU;AACpB,cAAM,EAAE,SAAS,eAAe,IAAI,aAAa,KAAK,OAAO;AAE7D,YAAI,SAAS;AACT,gBAAM,KAAK,IAAI;AACf,cAAI,UAAU;AACV,gBAAI,UAAU,IAAI,UAAU,GAAG,IAAI,OAAO;AAAA,EAAK,OAAO,KAAK;AAAA,UAC/D,WACS,kBAAkB,IAAI,WAAW,YAAY,CAAC,IAAI;AACvD,gBAAI,gBAAgB;AAAA,UACxB,WACS,SAAS,aAAa,EAAE,KAAK,CAAC,GAAG,QAAQ,GAAG,MAAM,SAAS,GAAG;AACnE,gBAAI,KAAK,GAAG,MAAM,CAAC;AACnB,gBAAI,SAAS,OAAO,EAAE;AAClB,mBAAK,GAAG;AACZ,kBAAM,KAAK,GAAG;AACd,eAAG,gBAAgB,KAAK,GAAG,OAAO;AAAA,EAAK,EAAE,KAAK;AAAA,UAClD,OACK;AACD,kBAAM,KAAK,GAAG;AACd,eAAG,gBAAgB,KAAK,GAAG,OAAO;AAAA,EAAK,EAAE,KAAK;AAAA,UAClD;AAAA,QACJ;AACA,YAAI,UAAU;AACV,gBAAM,UAAU,KAAK,MAAM,IAAI,QAAQ,KAAK,MAAM;AAClD,gBAAM,UAAU,KAAK,MAAM,IAAI,UAAU,KAAK,QAAQ;AAAA,QAC1D,OACK;AACD,cAAI,SAAS,KAAK;AAClB,cAAI,WAAW,KAAK;AAAA,QACxB;AACA,aAAK,UAAU,CAAC;AAChB,aAAK,SAAS,CAAC;AACf,aAAK,WAAW,CAAC;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,aAAa;AACT,eAAO;AAAA,UACH,SAAS,aAAa,KAAK,OAAO,EAAE;AAAA,UACpC,YAAY,KAAK;AAAA,UACjB,QAAQ,KAAK;AAAA,UACb,UAAU,KAAK;AAAA,QACnB;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,CAAC,QAAQ,QAAQ,WAAW,OAAO,YAAY,IAAI;AAC/C,mBAAW,SAAS;AAChB,iBAAO,KAAK,KAAK,KAAK;AAC1B,eAAO,KAAK,IAAI,UAAU,SAAS;AAAA,MACvC;AAAA;AAAA,MAEA,CAAC,KAAK,OAAO;AACT,YAAI,QAAQ,IAAI;AACZ,kBAAQ,IAAI,OAAO,EAAE,OAAO,KAAK,CAAC;AACtC,gBAAQ,MAAM,MAAM;AAAA,UAChB,KAAK;AACD,iBAAK,WAAW,IAAI,MAAM,QAAQ,CAAC,QAAQ,SAAS,YAAY;AAC5D,oBAAM,MAAM,YAAY,KAAK;AAC7B,kBAAI,CAAC,KAAK;AACV,mBAAK,QAAQ,KAAK,iBAAiB,SAAS,OAAO;AAAA,YACvD,CAAC;AACD,iBAAK,QAAQ,KAAK,MAAM,MAAM;AAC9B,iBAAK,eAAe;AACpB;AAAA,UACJ,KAAK,YAAY;AACb,kBAAM,MAAM,WAAW,WAAW,KAAK,SAAS,KAAK,YAAY,OAAO,KAAK,OAAO;AACpF,gBAAI,KAAK,gBAAgB,CAAC,IAAI,WAAW;AACrC,mBAAK,QAAQ,OAAO,gBAAgB,iDAAiD;AACzF,iBAAK,SAAS,KAAK,KAAK;AACxB,gBAAI,KAAK;AACL,oBAAM,KAAK;AACf,iBAAK,MAAM;AACX,iBAAK,eAAe;AACpB;AAAA,UACJ;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AACD;AAAA,UACJ,KAAK;AAAA,UACL,KAAK;AACD,iBAAK,QAAQ,KAAK,MAAM,MAAM;AAC9B;AAAA,UACJ,KAAK,SAAS;AACV,kBAAM,MAAM,MAAM,SACZ,GAAG,MAAM,OAAO,KAAK,KAAK,UAAU,MAAM,MAAM,CAAC,KACjD,MAAM;AACZ,kBAAM,QAAQ,IAAI,OAAO,eAAe,YAAY,KAAK,GAAG,oBAAoB,GAAG;AACnF,gBAAI,KAAK,gBAAgB,CAAC,KAAK;AAC3B,mBAAK,OAAO,KAAK,KAAK;AAAA;AAEtB,mBAAK,IAAI,OAAO,KAAK,KAAK;AAC9B;AAAA,UACJ;AAAA,UACA,KAAK,WAAW;AACZ,gBAAI,CAAC,KAAK,KAAK;AACX,oBAAM,MAAM;AACZ,mBAAK,OAAO,KAAK,IAAI,OAAO,eAAe,YAAY,KAAK,GAAG,oBAAoB,GAAG,CAAC;AACvF;AAAA,YACJ;AACA,iBAAK,IAAI,WAAW,SAAS;AAC7B,kBAAM,MAAM,WAAW,WAAW,MAAM,KAAK,MAAM,SAAS,MAAM,OAAO,QAAQ,KAAK,IAAI,QAAQ,QAAQ,KAAK,OAAO;AACtH,iBAAK,SAAS,KAAK,KAAK,IAAI;AAC5B,gBAAI,IAAI,SAAS;AACb,oBAAM,KAAK,KAAK,IAAI;AACpB,mBAAK,IAAI,UAAU,KAAK,GAAG,EAAE;AAAA,EAAK,IAAI,OAAO,KAAK,IAAI;AAAA,YAC1D;AACA,iBAAK,IAAI,MAAM,CAAC,IAAI,IAAI;AACxB;AAAA,UACJ;AAAA,UACA;AACI,iBAAK,OAAO,KAAK,IAAI,OAAO,eAAe,YAAY,KAAK,GAAG,oBAAoB,qBAAqB,MAAM,IAAI,EAAE,CAAC;AAAA,QAC7H;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,CAAC,IAAI,WAAW,OAAO,YAAY,IAAI;AACnC,YAAI,KAAK,KAAK;AACV,eAAK,SAAS,KAAK,KAAK,IAAI;AAC5B,gBAAM,KAAK;AACX,eAAK,MAAM;AAAA,QACf,WACS,UAAU;AACf,gBAAM,OAAO,OAAO,OAAO,EAAE,aAAa,KAAK,WAAW,GAAG,KAAK,OAAO;AACzE,gBAAM,MAAM,IAAI,SAAS,SAAS,QAAW,IAAI;AACjD,cAAI,KAAK;AACL,iBAAK,QAAQ,WAAW,gBAAgB,uCAAuC;AACnF,cAAI,QAAQ,CAAC,GAAG,WAAW,SAAS;AACpC,eAAK,SAAS,KAAK,KAAK;AACxB,gBAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAEA,IAAAA,SAAQ,WAAW;AAAA;AAAA;;;AC5NnB;AAAA,gIAAAC,UAAA;AAAA;AAEA,QAAI,qBAAqB;AACzB,QAAI,oBAAoB;AACxB,QAAI,SAAS;AACb,QAAI,kBAAkB;AAEtB,aAAS,gBAAgB,OAAO,SAAS,MAAM,SAAS;AACpD,UAAI,OAAO;AACP,cAAM,WAAW,wBAAC,KAAK,MAAM,YAAY;AACrC,gBAAM,SAAS,OAAO,QAAQ,WAAW,MAAM,MAAM,QAAQ,GAAG,IAAI,IAAI,CAAC,IAAI,IAAI;AACjF,cAAI;AACA,oBAAQ,QAAQ,MAAM,OAAO;AAAA;AAE7B,kBAAM,IAAI,OAAO,eAAe,CAAC,QAAQ,SAAS,CAAC,GAAG,MAAM,OAAO;AAAA,QAC3E,GANiB;AAOjB,gBAAQ,MAAM,MAAM;AAAA,UAChB,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD,mBAAO,kBAAkB,kBAAkB,OAAO,QAAQ,QAAQ;AAAA,UACtE,KAAK;AACD,mBAAO,mBAAmB,mBAAmB,OAAO,QAAQ,QAAQ;AAAA,QAC5E;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAnBS;AAkCT,aAAS,kBAAkB,OAAO,SAAS;AACvC,YAAM,EAAE,cAAc,OAAO,QAAQ,SAAS,OAAO,SAAS,IAAI,OAAO,QAAQ,IAAI;AACrF,YAAM,SAAS,gBAAgB,gBAAgB,EAAE,MAAM,MAAM,GAAG;AAAA,QAC5D;AAAA,QACA,QAAQ,SAAS,IAAI,IAAI,OAAO,MAAM,IAAI;AAAA,QAC1C;AAAA,QACA,SAAS,EAAE,YAAY,MAAM,WAAW,GAAG;AAAA,MAC/C,CAAC;AACD,YAAM,MAAM,QAAQ,OAAO;AAAA,QACvB,EAAE,MAAM,WAAW,QAAQ,IAAI,QAAQ,QAAQ,KAAK;AAAA,MACxD;AACA,cAAQ,OAAO,CAAC,GAAG;AAAA,QACf,KAAK;AAAA,QACL,KAAK,KAAK;AACN,gBAAM,KAAK,OAAO,QAAQ,IAAI;AAC9B,gBAAM,OAAO,OAAO,UAAU,GAAG,EAAE;AACnC,gBAAM,OAAO,OAAO,UAAU,KAAK,CAAC,IAAI;AACxC,gBAAM,QAAQ;AAAA,YACV,EAAE,MAAM,uBAAuB,QAAQ,QAAQ,QAAQ,KAAK;AAAA,UAChE;AACA,cAAI,CAAC,mBAAmB,OAAO,GAAG;AAC9B,kBAAM,KAAK,EAAE,MAAM,WAAW,QAAQ,IAAI,QAAQ,QAAQ,KAAK,CAAC;AACpE,iBAAO,EAAE,MAAM,gBAAgB,QAAQ,QAAQ,OAAO,QAAQ,KAAK;AAAA,QACvE;AAAA,QACA,KAAK;AACD,iBAAO,EAAE,MAAM,wBAAwB,QAAQ,QAAQ,QAAQ,IAAI;AAAA,QACvE,KAAK;AACD,iBAAO,EAAE,MAAM,wBAAwB,QAAQ,QAAQ,QAAQ,IAAI;AAAA,QACvE;AACI,iBAAO,EAAE,MAAM,UAAU,QAAQ,QAAQ,QAAQ,IAAI;AAAA,MAC7D;AAAA,IACJ;AA/BS;AAgDT,aAAS,eAAe,OAAO,OAAO,UAAU,CAAC,GAAG;AAChD,UAAI,EAAE,WAAW,OAAO,cAAc,OAAO,SAAS,OAAO,KAAK,IAAI;AACtE,UAAI,SAAS,YAAY,QAAQ,MAAM,SAAS;AAChD,UAAI,YAAY,OAAO,WAAW;AAC9B,kBAAU;AACd,UAAI,CAAC;AACD,gBAAQ,MAAM,MAAM;AAAA,UAChB,KAAK;AACD,mBAAO;AACP;AAAA,UACJ,KAAK;AACD,mBAAO;AACP;AAAA,UACJ,KAAK,gBAAgB;AACjB,kBAAM,SAAS,MAAM,MAAM,CAAC;AAC5B,gBAAI,OAAO,SAAS;AAChB,oBAAM,IAAI,MAAM,6BAA6B;AACjD,mBAAO,OAAO,OAAO,CAAC,MAAM,MAAM,iBAAiB;AACnD;AAAA,UACJ;AAAA,UACA;AACI,mBAAO;AAAA,QACf;AACJ,YAAM,SAAS,gBAAgB,gBAAgB,EAAE,MAAM,MAAM,GAAG;AAAA,QAC5D,aAAa,eAAe,WAAW;AAAA,QACvC,QAAQ,WAAW,QAAQ,SAAS,IAAI,IAAI,OAAO,MAAM,IAAI;AAAA,QAC7D;AAAA,QACA,SAAS,EAAE,YAAY,MAAM,WAAW,GAAG;AAAA,MAC/C,CAAC;AACD,cAAQ,OAAO,CAAC,GAAG;AAAA,QACf,KAAK;AAAA,QACL,KAAK;AACD,8BAAoB,OAAO,MAAM;AACjC;AAAA,QACJ,KAAK;AACD,6BAAmB,OAAO,QAAQ,sBAAsB;AACxD;AAAA,QACJ,KAAK;AACD,6BAAmB,OAAO,QAAQ,sBAAsB;AACxD;AAAA,QACJ;AACI,6BAAmB,OAAO,QAAQ,QAAQ;AAAA,MAClD;AAAA,IACJ;AA3CS;AA4CT,aAAS,oBAAoB,OAAO,QAAQ;AACxC,YAAM,KAAK,OAAO,QAAQ,IAAI;AAC9B,YAAM,OAAO,OAAO,UAAU,GAAG,EAAE;AACnC,YAAM,OAAO,OAAO,UAAU,KAAK,CAAC,IAAI;AACxC,UAAI,MAAM,SAAS,gBAAgB;AAC/B,cAAM,SAAS,MAAM,MAAM,CAAC;AAC5B,YAAI,OAAO,SAAS;AAChB,gBAAM,IAAI,MAAM,6BAA6B;AACjD,eAAO,SAAS;AAChB,cAAM,SAAS;AAAA,MACnB,OACK;AACD,cAAM,EAAE,OAAO,IAAI;AACnB,cAAM,SAAS,YAAY,QAAQ,MAAM,SAAS;AAClD,cAAM,QAAQ;AAAA,UACV,EAAE,MAAM,uBAAuB,QAAQ,QAAQ,QAAQ,KAAK;AAAA,QAChE;AACA,YAAI,CAAC,mBAAmB,OAAO,SAAS,QAAQ,MAAM,MAAM,MAAS;AACjE,gBAAM,KAAK,EAAE,MAAM,WAAW,QAAQ,IAAI,QAAQ,QAAQ,KAAK,CAAC;AACpE,mBAAW,OAAO,OAAO,KAAK,KAAK;AAC/B,cAAI,QAAQ,UAAU,QAAQ;AAC1B,mBAAO,MAAM,GAAG;AACxB,eAAO,OAAO,OAAO,EAAE,MAAM,gBAAgB,QAAQ,OAAO,QAAQ,KAAK,CAAC;AAAA,MAC9E;AAAA,IACJ;AAxBS;AA0BT,aAAS,mBAAmB,OAAO,KAAK;AACpC,UAAI;AACA,mBAAW,MAAM;AACb,kBAAQ,GAAG,MAAM;AAAA,YACb,KAAK;AAAA,YACL,KAAK;AACD,oBAAM,KAAK,EAAE;AACb;AAAA,YACJ,KAAK;AACD,oBAAM,KAAK,EAAE;AACb,qBAAO;AAAA,UACf;AACR,aAAO;AAAA,IACX;AAbS;AAcT,aAAS,mBAAmB,OAAO,QAAQ,MAAM;AAC7C,cAAQ,MAAM,MAAM;AAAA,QAChB,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,gBAAM,OAAO;AACb,gBAAM,SAAS;AACf;AAAA,QACJ,KAAK,gBAAgB;AACjB,gBAAM,MAAM,MAAM,MAAM,MAAM,CAAC;AAC/B,cAAI,KAAK,OAAO;AAChB,cAAI,MAAM,MAAM,CAAC,EAAE,SAAS;AACxB,kBAAM,MAAM,MAAM,CAAC,EAAE,OAAO;AAChC,qBAAW,OAAO;AACd,gBAAI,UAAU;AAClB,iBAAO,MAAM;AACb,iBAAO,OAAO,OAAO,EAAE,MAAM,QAAQ,IAAI,CAAC;AAC1C;AAAA,QACJ;AAAA,QACA,KAAK;AAAA,QACL,KAAK,aAAa;AACd,gBAAM,SAAS,MAAM,SAAS,OAAO;AACrC,gBAAM,KAAK,EAAE,MAAM,WAAW,QAAQ,QAAQ,MAAM,QAAQ,QAAQ,KAAK;AACzE,iBAAO,MAAM;AACb,iBAAO,OAAO,OAAO,EAAE,MAAM,QAAQ,KAAK,CAAC,EAAE,EAAE,CAAC;AAChD;AAAA,QACJ;AAAA,QACA,SAAS;AACL,gBAAM,SAAS,YAAY,QAAQ,MAAM,SAAS;AAClD,gBAAM,MAAM,SAAS,SAAS,MAAM,QAAQ,MAAM,GAAG,IAC/C,MAAM,IAAI,OAAO,QAAM,GAAG,SAAS,WACjC,GAAG,SAAS,aACZ,GAAG,SAAS,SAAS,IACvB,CAAC;AACP,qBAAW,OAAO,OAAO,KAAK,KAAK;AAC/B,gBAAI,QAAQ,UAAU,QAAQ;AAC1B,qBAAO,MAAM,GAAG;AACxB,iBAAO,OAAO,OAAO,EAAE,MAAM,QAAQ,QAAQ,IAAI,CAAC;AAAA,QACtD;AAAA,MACJ;AAAA,IACJ;AAxCS;AA0CT,IAAAA,SAAQ,oBAAoB;AAC5B,IAAAA,SAAQ,kBAAkB;AAC1B,IAAAA,SAAQ,iBAAiB;AAAA;AAAA;;;ACzNzB;AAAA,mIAAAC,UAAA;AAAA;AAQA,QAAM,YAAY,wBAAC,QAAQ,UAAU,MAAM,eAAe,GAAG,IAAI,cAAc,GAAG,GAAhE;AAClB,aAAS,eAAe,OAAO;AAC3B,cAAQ,MAAM,MAAM;AAAA,QAChB,KAAK,gBAAgB;AACjB,cAAI,MAAM;AACV,qBAAW,OAAO,MAAM;AACpB,mBAAO,eAAe,GAAG;AAC7B,iBAAO,MAAM,MAAM;AAAA,QACvB;AAAA,QACA,KAAK;AAAA,QACL,KAAK,aAAa;AACd,cAAI,MAAM;AACV,qBAAW,QAAQ,MAAM;AACrB,mBAAO,cAAc,IAAI;AAC7B,iBAAO;AAAA,QACX;AAAA,QACA,KAAK,mBAAmB;AACpB,cAAI,MAAM,MAAM,MAAM;AACtB,qBAAW,QAAQ,MAAM;AACrB,mBAAO,cAAc,IAAI;AAC7B,qBAAW,MAAM,MAAM;AACnB,mBAAO,GAAG;AACd,iBAAO;AAAA,QACX;AAAA,QACA,KAAK,YAAY;AACb,cAAI,MAAM,cAAc,KAAK;AAC7B,cAAI,MAAM;AACN,uBAAW,MAAM,MAAM;AACnB,qBAAO,GAAG;AAClB,iBAAO;AAAA,QACX;AAAA,QACA,SAAS;AACL,cAAI,MAAM,MAAM;AAChB,cAAI,SAAS,SAAS,MAAM;AACxB,uBAAW,MAAM,MAAM;AACnB,qBAAO,GAAG;AAClB,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAtCS;AAuCT,aAAS,cAAc,EAAE,OAAO,KAAK,KAAK,MAAM,GAAG;AAC/C,UAAI,MAAM;AACV,iBAAW,MAAM;AACb,eAAO,GAAG;AACd,UAAI;AACA,eAAO,eAAe,GAAG;AAC7B,UAAI;AACA,mBAAW,MAAM;AACb,iBAAO,GAAG;AAClB,UAAI;AACA,eAAO,eAAe,KAAK;AAC/B,aAAO;AAAA,IACX;AAZS;AAcT,IAAAA,SAAQ,YAAY;AAAA;AAAA;;;AC9DpB;AAAA,+HAAAC,UAAA;AAAA;AAEA,QAAM,QAAQ,OAAO,aAAa;AAClC,QAAM,OAAO,OAAO,eAAe;AACnC,QAAM,SAAS,OAAO,aAAa;AA6BnC,aAAS,MAAM,KAAK,SAAS;AACzB,UAAI,UAAU,OAAO,IAAI,SAAS;AAC9B,cAAM,EAAE,OAAO,IAAI,OAAO,OAAO,IAAI,MAAM;AAC/C,aAAO,OAAO,OAAO,CAAC,CAAC,GAAG,KAAK,OAAO;AAAA,IAC1C;AAJS;AAST,UAAM,QAAQ;AAEd,UAAM,OAAO;AAEb,UAAM,SAAS;AAEf,UAAM,aAAa,CAAC,KAAK,SAAS;AAC9B,UAAI,OAAO;AACX,iBAAW,CAAC,OAAO,KAAK,KAAK,MAAM;AAC/B,cAAM,MAAM,OAAO,KAAK;AACxB,YAAI,OAAO,WAAW,KAAK;AACvB,iBAAO,IAAI,MAAM,KAAK;AAAA,QAC1B;AAEI,iBAAO;AAAA,MACf;AACA,aAAO;AAAA,IACX;AAMA,UAAM,mBAAmB,CAAC,KAAK,SAAS;AACpC,YAAM,SAAS,MAAM,WAAW,KAAK,KAAK,MAAM,GAAG,EAAE,CAAC;AACtD,YAAM,QAAQ,KAAK,KAAK,SAAS,CAAC,EAAE,CAAC;AACrC,YAAM,OAAO,SAAS,KAAK;AAC3B,UAAI,QAAQ,WAAW;AACnB,eAAO;AACX,YAAM,IAAI,MAAM,6BAA6B;AAAA,IACjD;AACA,aAAS,OAAO,MAAM,MAAM,SAAS;AACjC,UAAI,OAAO,QAAQ,MAAM,IAAI;AAC7B,UAAI,OAAO,SAAS;AAChB,eAAO;AACX,iBAAW,SAAS,CAAC,OAAO,OAAO,GAAG;AAClC,cAAM,QAAQ,KAAK,KAAK;AACxB,YAAI,SAAS,WAAW,OAAO;AAC3B,mBAAS,IAAI,GAAG,IAAI,MAAM,MAAM,QAAQ,EAAE,GAAG;AACzC,kBAAM,KAAK,OAAO,OAAO,OAAO,KAAK,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC,GAAG,OAAO;AACnF,gBAAI,OAAO,OAAO;AACd,kBAAI,KAAK;AAAA,qBACJ,OAAO;AACZ,qBAAO;AAAA,qBACF,OAAO,QAAQ;AACpB,oBAAM,MAAM,OAAO,GAAG,CAAC;AACvB,mBAAK;AAAA,YACT;AAAA,UACJ;AACA,cAAI,OAAO,SAAS,cAAc,UAAU;AACxC,mBAAO,KAAK,MAAM,IAAI;AAAA,QAC9B;AAAA,MACJ;AACA,aAAO,OAAO,SAAS,aAAa,KAAK,MAAM,IAAI,IAAI;AAAA,IAC3D;AAvBS;AAyBT,IAAAA,SAAQ,QAAQ;AAAA;AAAA;;;AClGhB;AAAA,yHAAAC,UAAA;AAAA;AAEA,QAAI,YAAY;AAChB,QAAI,eAAe;AACnB,QAAI,WAAW;AAGf,QAAM,MAAM;AAEZ,QAAM,WAAW;AAEjB,QAAM,WAAW;AAEjB,QAAM,SAAS;AAEf,QAAM,eAAe,wBAAC,UAAU,CAAC,CAAC,SAAS,WAAW,OAAjC;AAErB,QAAM,WAAW,wBAAC,UAAU,CAAC,CAAC,UACzB,MAAM,SAAS,YACZ,MAAM,SAAS,0BACf,MAAM,SAAS,0BACf,MAAM,SAAS,iBAJN;AAOjB,aAAS,YAAY,OAAO;AACxB,cAAQ,OAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX;AACI,iBAAO,KAAK,UAAU,KAAK;AAAA,MACnC;AAAA,IACJ;AAbS;AAeT,aAAS,UAAU,QAAQ;AACvB,cAAQ,QAAQ;AAAA,QACZ,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,MACf;AACA,cAAQ,OAAO,CAAC,GAAG;AAAA,QACf,KAAK;AAAA,QACL,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AACD,iBAAO;AAAA,QACX,KAAK;AAAA,QACL,KAAK;AACD,iBAAO;AAAA,MACf;AACA,aAAO;AAAA,IACX;AA1DS;AA4DT,IAAAA,SAAQ,oBAAoB,UAAU;AACtC,IAAAA,SAAQ,kBAAkB,UAAU;AACpC,IAAAA,SAAQ,iBAAiB,UAAU;AACnC,IAAAA,SAAQ,YAAY,aAAa;AACjC,IAAAA,SAAQ,QAAQ,SAAS;AACzB,IAAAA,SAAQ,MAAM;AACd,IAAAA,SAAQ,WAAW;AACnB,IAAAA,SAAQ,WAAW;AACnB,IAAAA,SAAQ,SAAS;AACjB,IAAAA,SAAQ,eAAe;AACvB,IAAAA,SAAQ,WAAW;AACnB,IAAAA,SAAQ,cAAc;AACtB,IAAAA,SAAQ,YAAY;AAAA;AAAA;;;AC/GpB;AAAA,2HAAAC,UAAA;AAAA;AAEA,QAAI,MAAM;AAqEV,aAAS,QAAQ,IAAI;AACjB,cAAQ,IAAI;AAAA,QACR,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,iBAAO;AAAA,QACX;AACI,iBAAO;AAAA,MACf;AAAA,IACJ;AAXS;AAYT,QAAM,YAAY,yBAAyB,MAAM,EAAE;AACnD,QAAM,WAAW,oFAAoF,MAAM,EAAE;AAC7G,QAAM,yBAAyB,QAAQ,MAAM,EAAE;AAC/C,QAAM,qBAAqB,cAAe,MAAM,EAAE;AAClD,QAAM,kBAAkB,wBAAC,OAAO,CAAC,MAAM,mBAAmB,SAAS,EAAE,GAA7C;AAgBxB,QAAM,QAAN,MAAY;AAAA,MAvGZ,OAuGY;AAAA;AAAA;AAAA,MACR,cAAc;AAKV,aAAK,QAAQ;AAMb,aAAK,oBAAoB;AAMzB,aAAK,kBAAkB;AAEvB,aAAK,SAAS;AAKd,aAAK,UAAU;AAEf,aAAK,YAAY;AAKjB,aAAK,aAAa;AAElB,aAAK,cAAc;AAEnB,aAAK,aAAa;AAElB,aAAK,OAAO;AAEZ,aAAK,MAAM;AAAA,MACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,CAAC,IAAI,QAAQ,aAAa,OAAO;AAC7B,YAAI,QAAQ;AACR,eAAK,SAAS,KAAK,SAAS,KAAK,SAAS,SAAS;AACnD,eAAK,aAAa;AAAA,QACtB;AACA,aAAK,QAAQ,CAAC;AACd,YAAI,OAAO,KAAK,QAAQ;AACxB,eAAO,SAAS,cAAc,KAAK,SAAS,CAAC;AACzC,iBAAO,OAAO,KAAK,UAAU,IAAI;AAAA,MACzC;AAAA,MACA,YAAY;AACR,YAAI,IAAI,KAAK;AACb,YAAI,KAAK,KAAK,OAAO,CAAC;AACtB,eAAO,OAAO,OAAO,OAAO;AACxB,eAAK,KAAK,OAAO,EAAE,CAAC;AACxB,YAAI,CAAC,MAAM,OAAO,OAAO,OAAO;AAC5B,iBAAO;AACX,YAAI,OAAO;AACP,iBAAO,KAAK,OAAO,IAAI,CAAC,MAAM;AAClC,eAAO;AAAA,MACX;AAAA,MACA,OAAO,GAAG;AACN,eAAO,KAAK,OAAO,KAAK,MAAM,CAAC;AAAA,MACnC;AAAA,MACA,eAAe,QAAQ;AACnB,YAAI,KAAK,KAAK,OAAO,MAAM;AAC3B,YAAI,KAAK,aAAa,GAAG;AACrB,cAAI,SAAS;AACb,iBAAO,OAAO;AACV,iBAAK,KAAK,OAAO,EAAE,SAAS,MAAM;AACtC,cAAI,OAAO,MAAM;AACb,kBAAM,OAAO,KAAK,OAAO,SAAS,SAAS,CAAC;AAC5C,gBAAI,SAAS,QAAS,CAAC,QAAQ,CAAC,KAAK;AACjC,qBAAO,SAAS,SAAS;AAAA,UACjC;AACA,iBAAO,OAAO,QAAQ,UAAU,KAAK,cAAe,CAAC,MAAM,CAAC,KAAK,QAC3D,SAAS,SACT;AAAA,QACV;AACA,YAAI,OAAO,OAAO,OAAO,KAAK;AAC1B,gBAAM,KAAK,KAAK,OAAO,OAAO,QAAQ,CAAC;AACvC,eAAK,OAAO,SAAS,OAAO,UAAU,QAAQ,KAAK,OAAO,SAAS,CAAC,CAAC;AACjE,mBAAO;AAAA,QACf;AACA,eAAO;AAAA,MACX;AAAA,MACA,UAAU;AACN,YAAI,MAAM,KAAK;AACf,YAAI,OAAO,QAAQ,YAAa,QAAQ,MAAM,MAAM,KAAK,KAAM;AAC3D,gBAAM,KAAK,OAAO,QAAQ,MAAM,KAAK,GAAG;AACxC,eAAK,aAAa;AAAA,QACtB;AACA,YAAI,QAAQ;AACR,iBAAO,KAAK,QAAQ,KAAK,OAAO,UAAU,KAAK,GAAG,IAAI;AAC1D,YAAI,KAAK,OAAO,MAAM,CAAC,MAAM;AACzB,iBAAO;AACX,eAAO,KAAK,OAAO,UAAU,KAAK,KAAK,GAAG;AAAA,MAC9C;AAAA,MACA,SAAS,GAAG;AACR,eAAO,KAAK,MAAM,KAAK,KAAK,OAAO;AAAA,MACvC;AAAA,MACA,QAAQ,OAAO;AACX,aAAK,SAAS,KAAK,OAAO,UAAU,KAAK,GAAG;AAC5C,aAAK,MAAM;AACX,aAAK,aAAa;AAClB,aAAK,OAAO;AACZ,eAAO;AAAA,MACX;AAAA,MACA,KAAK,GAAG;AACJ,eAAO,KAAK,OAAO,OAAO,KAAK,KAAK,CAAC;AAAA,MACzC;AAAA,MACA,CAAC,UAAU,MAAM;AACb,gBAAQ,MAAM;AAAA,UACV,KAAK;AACD,mBAAO,OAAO,KAAK,YAAY;AAAA,UACnC,KAAK;AACD,mBAAO,OAAO,KAAK,eAAe;AAAA,UACtC,KAAK;AACD,mBAAO,OAAO,KAAK,gBAAgB;AAAA,UACvC,KAAK;AACD,mBAAO,OAAO,KAAK,cAAc;AAAA,UACrC,KAAK;AACD,mBAAO,OAAO,KAAK,oBAAoB;AAAA,UAC3C,KAAK;AACD,mBAAO,OAAO,KAAK,kBAAkB;AAAA,UACzC,KAAK;AACD,mBAAO,OAAO,KAAK,iBAAiB;AAAA,UACxC,KAAK;AACD,mBAAO,OAAO,KAAK,iBAAiB;AAAA,QAC5C;AAAA,MACJ;AAAA,MACA,CAAC,cAAc;AACX,YAAI,OAAO,KAAK,QAAQ;AACxB,YAAI,SAAS;AACT,iBAAO,KAAK,QAAQ,QAAQ;AAChC,YAAI,KAAK,CAAC,MAAM,IAAI,KAAK;AACrB,iBAAO,KAAK,UAAU,CAAC;AACvB,iBAAO,KAAK,UAAU,CAAC;AAAA,QAC3B;AACA,YAAI,KAAK,CAAC,MAAM,KAAK;AACjB,cAAI,SAAS,KAAK;AAClB,gBAAM,KAAK,KAAK,QAAQ,GAAG;AAC3B,cAAI,OAAO,IAAI;AACX,kBAAM,KAAK,KAAK,KAAK,CAAC;AACtB,gBAAI,OAAO,OAAO,OAAO;AACrB,uBAAS,KAAK;AAAA,UACtB;AACA,iBAAO,MAAM;AACT,kBAAM,KAAK,KAAK,SAAS,CAAC;AAC1B,gBAAI,OAAO,OAAO,OAAO;AACrB,wBAAU;AAAA;AAEV;AAAA,UACR;AACA,gBAAM,KAAK,OAAO,KAAK,UAAU,MAAM,MAAM,OAAO,KAAK,WAAW,IAAI;AACxE,iBAAO,KAAK,UAAU,KAAK,SAAS,CAAC;AACrC,eAAK,YAAY;AACjB,iBAAO;AAAA,QACX;AACA,YAAI,KAAK,UAAU,GAAG;AAClB,gBAAM,KAAK,OAAO,KAAK,WAAW,IAAI;AACtC,iBAAO,KAAK,UAAU,KAAK,SAAS,EAAE;AACtC,iBAAO,KAAK,YAAY;AACxB,iBAAO;AAAA,QACX;AACA,cAAM,IAAI;AACV,eAAO,OAAO,KAAK,eAAe;AAAA,MACtC;AAAA,MACA,CAAC,iBAAiB;AACd,cAAM,KAAK,KAAK,OAAO,CAAC;AACxB,YAAI,CAAC,MAAM,CAAC,KAAK;AACb,iBAAO,KAAK,QAAQ,YAAY;AACpC,YAAI,OAAO,OAAO,OAAO,KAAK;AAC1B,cAAI,CAAC,KAAK,SAAS,CAAC,KAAK,SAAS,CAAC;AAC/B,mBAAO,KAAK,QAAQ,YAAY;AACpC,gBAAM,IAAI,KAAK,KAAK,CAAC;AACrB,cAAI,MAAM,SAAS,QAAQ,KAAK,OAAO,CAAC,CAAC,GAAG;AACxC,mBAAO,KAAK,UAAU,CAAC;AACvB,iBAAK,cAAc;AACnB,iBAAK,aAAa;AAClB,mBAAO;AAAA,UACX,WACS,MAAM,SAAS,QAAQ,KAAK,OAAO,CAAC,CAAC,GAAG;AAC7C,mBAAO,KAAK,UAAU,CAAC;AACvB,mBAAO;AAAA,UACX;AAAA,QACJ;AACA,aAAK,cAAc,OAAO,KAAK,WAAW,KAAK;AAC/C,YAAI,KAAK,aAAa,KAAK,eAAe,CAAC,QAAQ,KAAK,OAAO,CAAC,CAAC;AAC7D,eAAK,aAAa,KAAK;AAC3B,eAAO,OAAO,KAAK,gBAAgB;AAAA,MACvC;AAAA,MACA,CAAC,kBAAkB;AACf,cAAM,CAAC,KAAK,GAAG,IAAI,KAAK,KAAK,CAAC;AAC9B,YAAI,CAAC,OAAO,CAAC,KAAK;AACd,iBAAO,KAAK,QAAQ,aAAa;AACrC,aAAK,QAAQ,OAAO,QAAQ,OAAO,QAAQ,QAAQ,QAAQ,GAAG,GAAG;AAC7D,gBAAM,KAAK,OAAO,KAAK,UAAU,CAAC,MAAM,OAAO,KAAK,WAAW,IAAI;AACnE,eAAK,aAAa,KAAK,cAAc;AACrC,eAAK,eAAe;AACpB,iBAAO,OAAO,KAAK,gBAAgB;AAAA,QACvC;AACA,eAAO;AAAA,MACX;AAAA,MACA,CAAC,gBAAgB;AACb,eAAO,KAAK,WAAW,IAAI;AAC3B,cAAM,OAAO,KAAK,QAAQ;AAC1B,YAAI,SAAS;AACT,iBAAO,KAAK,QAAQ,KAAK;AAC7B,YAAI,IAAI,OAAO,KAAK,eAAe;AACnC,gBAAQ,KAAK,CAAC,GAAG;AAAA,UACb,KAAK;AACD,mBAAO,KAAK,UAAU,KAAK,SAAS,CAAC;AAAA,UAEzC,KAAK;AACD,mBAAO,KAAK,YAAY;AACxB,mBAAO,OAAO,KAAK,eAAe;AAAA,UACtC,KAAK;AAAA,UACL,KAAK;AACD,mBAAO,KAAK,UAAU,CAAC;AACvB,iBAAK,UAAU;AACf,iBAAK,YAAY;AACjB,mBAAO;AAAA,UACX,KAAK;AAAA,UACL,KAAK;AAED,mBAAO,KAAK,UAAU,CAAC;AACvB,mBAAO;AAAA,UACX,KAAK;AACD,mBAAO,KAAK,UAAU,eAAe;AACrC,mBAAO;AAAA,UACX,KAAK;AAAA,UACL,KAAK;AACD,mBAAO,OAAO,KAAK,kBAAkB;AAAA,UACzC,KAAK;AAAA,UACL,KAAK;AACD,iBAAK,OAAO,KAAK,uBAAuB;AACxC,iBAAK,OAAO,KAAK,WAAW,IAAI;AAChC,mBAAO,KAAK,UAAU,KAAK,SAAS,CAAC;AACrC,mBAAO,KAAK,YAAY;AACxB,mBAAO,OAAO,KAAK,iBAAiB;AAAA,UACxC;AACI,mBAAO,OAAO,KAAK,iBAAiB;AAAA,QAC5C;AAAA,MACJ;AAAA,MACA,CAAC,sBAAsB;AACnB,YAAI,IAAI;AACR,YAAI,SAAS;AACb,WAAG;AACC,eAAK,OAAO,KAAK,YAAY;AAC7B,cAAI,KAAK,GAAG;AACR,iBAAK,OAAO,KAAK,WAAW,KAAK;AACjC,iBAAK,cAAc,SAAS;AAAA,UAChC,OACK;AACD,iBAAK;AAAA,UACT;AACA,gBAAM,OAAO,KAAK,WAAW,IAAI;AAAA,QACrC,SAAS,KAAK,KAAK;AACnB,cAAM,OAAO,KAAK,QAAQ;AAC1B,YAAI,SAAS;AACT,iBAAO,KAAK,QAAQ,MAAM;AAC9B,YAAK,WAAW,MAAM,SAAS,KAAK,cAAc,KAAK,CAAC,MAAM,OACzD,WAAW,MACP,KAAK,WAAW,KAAK,KAAK,KAAK,WAAW,KAAK,MAChD,QAAQ,KAAK,CAAC,CAAC,GAAI;AAIvB,gBAAM,kBAAkB,WAAW,KAAK,aAAa,KACjD,KAAK,cAAc,MAClB,KAAK,CAAC,MAAM,OAAO,KAAK,CAAC,MAAM;AACpC,cAAI,CAAC,iBAAiB;AAElB,iBAAK,YAAY;AACjB,kBAAM,IAAI;AACV,mBAAO,OAAO,KAAK,eAAe;AAAA,UACtC;AAAA,QACJ;AACA,YAAI,IAAI;AACR,eAAO,KAAK,CAAC,MAAM,KAAK;AACpB,eAAK,OAAO,KAAK,UAAU,CAAC;AAC5B,eAAK,OAAO,KAAK,WAAW,IAAI;AAChC,eAAK,UAAU;AAAA,QACnB;AACA,aAAK,OAAO,KAAK,eAAe;AAChC,gBAAQ,KAAK,CAAC,GAAG;AAAA,UACb,KAAK;AACD,mBAAO;AAAA,UACX,KAAK;AACD,mBAAO,KAAK,UAAU,KAAK,SAAS,CAAC;AACrC,mBAAO;AAAA,UACX,KAAK;AAAA,UACL,KAAK;AACD,mBAAO,KAAK,UAAU,CAAC;AACvB,iBAAK,UAAU;AACf,iBAAK,aAAa;AAClB,mBAAO;AAAA,UACX,KAAK;AAAA,UACL,KAAK;AACD,mBAAO,KAAK,UAAU,CAAC;AACvB,iBAAK,UAAU;AACf,iBAAK,aAAa;AAClB,mBAAO,KAAK,YAAY,SAAS;AAAA,UACrC,KAAK;AACD,mBAAO,KAAK,UAAU,eAAe;AACrC,mBAAO;AAAA,UACX,KAAK;AAAA,UACL,KAAK;AACD,iBAAK,UAAU;AACf,mBAAO,OAAO,KAAK,kBAAkB;AAAA,UACzC,KAAK,KAAK;AACN,kBAAM,OAAO,KAAK,OAAO,CAAC;AAC1B,gBAAI,KAAK,WAAW,QAAQ,IAAI,KAAK,SAAS,KAAK;AAC/C,mBAAK,UAAU;AACf,qBAAO,KAAK,UAAU,CAAC;AACvB,qBAAO,KAAK,WAAW,IAAI;AAC3B,qBAAO;AAAA,YACX;AAAA,UACJ;AAAA,UAEA;AACI,iBAAK,UAAU;AACf,mBAAO,OAAO,KAAK,iBAAiB;AAAA,QAC5C;AAAA,MACJ;AAAA,MACA,CAAC,oBAAoB;AACjB,cAAM,QAAQ,KAAK,OAAO,CAAC;AAC3B,YAAI,MAAM,KAAK,OAAO,QAAQ,OAAO,KAAK,MAAM,CAAC;AACjD,YAAI,UAAU,KAAK;AACf,iBAAO,QAAQ,MAAM,KAAK,OAAO,MAAM,CAAC,MAAM;AAC1C,kBAAM,KAAK,OAAO,QAAQ,KAAK,MAAM,CAAC;AAAA,QAC9C,OACK;AAED,iBAAO,QAAQ,IAAI;AACf,gBAAI,IAAI;AACR,mBAAO,KAAK,OAAO,MAAM,IAAI,CAAC,MAAM;AAChC,mBAAK;AACT,gBAAI,IAAI,MAAM;AACV;AACJ,kBAAM,KAAK,OAAO,QAAQ,KAAK,MAAM,CAAC;AAAA,UAC1C;AAAA,QACJ;AAEA,cAAM,KAAK,KAAK,OAAO,UAAU,GAAG,GAAG;AACvC,YAAI,KAAK,GAAG,QAAQ,MAAM,KAAK,GAAG;AAClC,YAAI,OAAO,IAAI;AACX,iBAAO,OAAO,IAAI;AACd,kBAAM,KAAK,KAAK,eAAe,KAAK,CAAC;AACrC,gBAAI,OAAO;AACP;AACJ,iBAAK,GAAG,QAAQ,MAAM,EAAE;AAAA,UAC5B;AACA,cAAI,OAAO,IAAI;AAEX,kBAAM,MAAM,GAAG,KAAK,CAAC,MAAM,OAAO,IAAI;AAAA,UAC1C;AAAA,QACJ;AACA,YAAI,QAAQ,IAAI;AACZ,cAAI,CAAC,KAAK;AACN,mBAAO,KAAK,QAAQ,eAAe;AACvC,gBAAM,KAAK,OAAO;AAAA,QACtB;AACA,eAAO,KAAK,YAAY,MAAM,GAAG,KAAK;AACtC,eAAO,KAAK,YAAY,SAAS;AAAA,MACrC;AAAA,MACA,CAAC,yBAAyB;AACtB,aAAK,oBAAoB;AACzB,aAAK,kBAAkB;AACvB,YAAI,IAAI,KAAK;AACb,eAAO,MAAM;AACT,gBAAM,KAAK,KAAK,OAAO,EAAE,CAAC;AAC1B,cAAI,OAAO;AACP,iBAAK,kBAAkB;AAAA,mBAClB,KAAK,OAAO,MAAM;AACvB,iBAAK,oBAAoB,OAAO,EAAE,IAAI;AAAA,mBACjC,OAAO;AACZ;AAAA,QACR;AACA,eAAO,OAAO,KAAK,UAAU,QAAM,QAAQ,EAAE,KAAK,OAAO,GAAG;AAAA,MAChE;AAAA,MACA,CAAC,mBAAmB;AAChB,YAAI,KAAK,KAAK,MAAM;AACpB,YAAI,SAAS;AACb,YAAI;AACJ;AAAM,mBAAS,IAAI,KAAK,KAAM,KAAK,KAAK,OAAO,CAAC,GAAI,EAAE,GAAG;AACrD,oBAAQ,IAAI;AAAA,cACR,KAAK;AACD,0BAAU;AACV;AAAA,cACJ,KAAK;AACD,qBAAK;AACL,yBAAS;AACT;AAAA,cACJ,KAAK,MAAM;AACP,sBAAM,OAAO,KAAK,OAAO,IAAI,CAAC;AAC9B,oBAAI,CAAC,QAAQ,CAAC,KAAK;AACf,yBAAO,KAAK,QAAQ,cAAc;AACtC,oBAAI,SAAS;AACT;AAAA,cACR;AAAA,cACA;AACI,sBAAM;AAAA,YACd;AAAA,UACJ;AACA,YAAI,CAAC,MAAM,CAAC,KAAK;AACb,iBAAO,KAAK,QAAQ,cAAc;AACtC,YAAI,UAAU,KAAK,YAAY;AAC3B,cAAI,KAAK,sBAAsB;AAC3B,iBAAK,aAAa;AAAA;AAElB,iBAAK,cAAc,KAAK;AAC5B,aAAG;AACC,kBAAM,KAAK,KAAK,eAAe,KAAK,CAAC;AACrC,gBAAI,OAAO;AACP;AACJ,iBAAK,KAAK,OAAO,QAAQ,MAAM,EAAE;AAAA,UACrC,SAAS,OAAO;AAChB,cAAI,OAAO,IAAI;AACX,gBAAI,CAAC,KAAK;AACN,qBAAO,KAAK,QAAQ,cAAc;AACtC,iBAAK,KAAK,OAAO;AAAA,UACrB;AAAA,QACJ;AACA,YAAI,CAAC,KAAK,iBAAiB;AACvB,aAAG;AACC,gBAAI,IAAI,KAAK;AACb,gBAAIC,MAAK,KAAK,OAAO,CAAC;AACtB,gBAAIA,QAAO;AACP,cAAAA,MAAK,KAAK,OAAO,EAAE,CAAC;AACxB,kBAAM,WAAW;AACjB,mBAAOA,QAAO,OAAOA,QAAO;AACxB,cAAAA,MAAK,KAAK,OAAO,EAAE,CAAC;AACxB,gBAAIA,QAAO,QAAQ,KAAK,KAAK,OAAO,IAAI,IAAI,SAAS;AACjD,mBAAK;AAAA;AAEL;AAAA,UACR,SAAS;AAAA,QACb;AACA,cAAM,IAAI;AACV,eAAO,KAAK,YAAY,KAAK,GAAG,IAAI;AACpC,eAAO,OAAO,KAAK,eAAe;AAAA,MACtC;AAAA,MACA,CAAC,mBAAmB;AAChB,cAAM,SAAS,KAAK,YAAY;AAChC,YAAI,MAAM,KAAK,MAAM;AACrB,YAAI,IAAI,KAAK,MAAM;AACnB,YAAI;AACJ,eAAQ,KAAK,KAAK,OAAO,EAAE,CAAC,GAAI;AAC5B,cAAI,OAAO,KAAK;AACZ,kBAAM,OAAO,KAAK,OAAO,IAAI,CAAC;AAC9B,gBAAI,QAAQ,IAAI,KAAM,UAAU,SAAS;AACrC;AACJ,kBAAM;AAAA,UACV,WACS,QAAQ,EAAE,GAAG;AAClB,gBAAI,OAAO,KAAK,OAAO,IAAI,CAAC;AAC5B,gBAAI,OAAO,MAAM;AACb,kBAAI,SAAS,MAAM;AACf,qBAAK;AACL,qBAAK;AACL,uBAAO,KAAK,OAAO,IAAI,CAAC;AAAA,cAC5B;AAEI,sBAAM;AAAA,YACd;AACA,gBAAI,SAAS,OAAQ,UAAU,uBAAuB,SAAS,IAAI;AAC/D;AACJ,gBAAI,OAAO,MAAM;AACb,oBAAM,KAAK,KAAK,eAAe,IAAI,CAAC;AACpC,kBAAI,OAAO;AACP;AACJ,kBAAI,KAAK,IAAI,GAAG,KAAK,CAAC;AAAA,YAC1B;AAAA,UACJ,OACK;AACD,gBAAI,UAAU,uBAAuB,SAAS,EAAE;AAC5C;AACJ,kBAAM;AAAA,UACV;AAAA,QACJ;AACA,YAAI,CAAC,MAAM,CAAC,KAAK;AACb,iBAAO,KAAK,QAAQ,cAAc;AACtC,cAAM,IAAI;AACV,eAAO,KAAK,YAAY,MAAM,GAAG,IAAI;AACrC,eAAO,SAAS,SAAS;AAAA,MAC7B;AAAA,MACA,CAAC,UAAU,GAAG;AACV,YAAI,IAAI,GAAG;AACP,gBAAM,KAAK,OAAO,OAAO,KAAK,KAAK,CAAC;AACpC,eAAK,OAAO;AACZ,iBAAO;AAAA,QACX;AACA,eAAO;AAAA,MACX;AAAA,MACA,CAAC,YAAY,GAAG,YAAY;AACxB,cAAM,IAAI,KAAK,OAAO,MAAM,KAAK,KAAK,CAAC;AACvC,YAAI,GAAG;AACH,gBAAM;AACN,eAAK,OAAO,EAAE;AACd,iBAAO,EAAE;AAAA,QACb,WACS;AACL,gBAAM;AACV,eAAO;AAAA,MACX;AAAA,MACA,CAAC,iBAAiB;AACd,gBAAQ,KAAK,OAAO,CAAC,GAAG;AAAA,UACpB,KAAK;AACD,oBAAS,OAAO,KAAK,QAAQ,MACxB,OAAO,KAAK,WAAW,IAAI,MAC3B,OAAO,KAAK,eAAe;AAAA,UACpC,KAAK;AACD,oBAAS,OAAO,KAAK,UAAU,eAAe,MACzC,OAAO,KAAK,WAAW,IAAI,MAC3B,OAAO,KAAK,eAAe;AAAA,UACpC,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK,KAAK;AACN,kBAAM,SAAS,KAAK,YAAY;AAChC,kBAAM,MAAM,KAAK,OAAO,CAAC;AACzB,gBAAI,QAAQ,GAAG,KAAM,UAAU,uBAAuB,SAAS,GAAG,GAAI;AAClE,kBAAI,CAAC;AACD,qBAAK,aAAa,KAAK,cAAc;AAAA,uBAChC,KAAK;AACV,qBAAK,UAAU;AACnB,sBAAS,OAAO,KAAK,UAAU,CAAC,MAC3B,OAAO,KAAK,WAAW,IAAI,MAC3B,OAAO,KAAK,eAAe;AAAA,YACpC;AAAA,UACJ;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AAAA,MACA,CAAC,UAAU;AACP,YAAI,KAAK,OAAO,CAAC,MAAM,KAAK;AACxB,cAAI,IAAI,KAAK,MAAM;AACnB,cAAI,KAAK,KAAK,OAAO,CAAC;AACtB,iBAAO,CAAC,QAAQ,EAAE,KAAK,OAAO;AAC1B,iBAAK,KAAK,OAAO,EAAE,CAAC;AACxB,iBAAO,OAAO,KAAK,YAAY,OAAO,MAAM,IAAI,IAAI,GAAG,KAAK;AAAA,QAChE,OACK;AACD,cAAI,IAAI,KAAK,MAAM;AACnB,cAAI,KAAK,KAAK,OAAO,CAAC;AACtB,iBAAO,IAAI;AACP,gBAAI,SAAS,SAAS,EAAE;AACpB,mBAAK,KAAK,OAAO,EAAE,CAAC;AAAA,qBACf,OAAO,OACZ,UAAU,SAAS,KAAK,OAAO,IAAI,CAAC,CAAC,KACrC,UAAU,SAAS,KAAK,OAAO,IAAI,CAAC,CAAC,GAAG;AACxC,mBAAK,KAAK,OAAQ,KAAK,CAAE;AAAA,YAC7B;AAEI;AAAA,UACR;AACA,iBAAO,OAAO,KAAK,YAAY,GAAG,KAAK;AAAA,QAC3C;AAAA,MACJ;AAAA,MACA,CAAC,cAAc;AACX,cAAM,KAAK,KAAK,OAAO,KAAK,GAAG;AAC/B,YAAI,OAAO;AACP,iBAAO,OAAO,KAAK,UAAU,CAAC;AAAA,iBACzB,OAAO,QAAQ,KAAK,OAAO,CAAC,MAAM;AACvC,iBAAO,OAAO,KAAK,UAAU,CAAC;AAAA;AAE9B,iBAAO;AAAA,MACf;AAAA,MACA,CAAC,WAAW,WAAW;AACnB,YAAI,IAAI,KAAK,MAAM;AACnB,YAAI;AACJ,WAAG;AACC,eAAK,KAAK,OAAO,EAAE,CAAC;AAAA,QACxB,SAAS,OAAO,OAAQ,aAAa,OAAO;AAC5C,cAAM,IAAI,IAAI,KAAK;AACnB,YAAI,IAAI,GAAG;AACP,gBAAM,KAAK,OAAO,OAAO,KAAK,KAAK,CAAC;AACpC,eAAK,MAAM;AAAA,QACf;AACA,eAAO;AAAA,MACX;AAAA,MACA,CAAC,UAAU,MAAM;AACb,YAAI,IAAI,KAAK;AACb,YAAI,KAAK,KAAK,OAAO,CAAC;AACtB,eAAO,CAAC,KAAK,EAAE;AACX,eAAK,KAAK,OAAO,EAAE,CAAC;AACxB,eAAO,OAAO,KAAK,YAAY,GAAG,KAAK;AAAA,MAC3C;AAAA,IACJ;AAEA,IAAAD,SAAQ,QAAQ;AAAA;AAAA;;;AC9rBhB;AAAA,kIAAAE,UAAA;AAAA;AAOA,QAAM,cAAN,MAAkB;AAAA,MAPlB,OAOkB;AAAA;AAAA;AAAA,MACd,cAAc;AACV,aAAK,aAAa,CAAC;AAKnB,aAAK,aAAa,CAAC,WAAW,KAAK,WAAW,KAAK,MAAM;AAMzD,aAAK,UAAU,CAAC,WAAW;AACvB,cAAI,MAAM;AACV,cAAI,OAAO,KAAK,WAAW;AAC3B,iBAAO,MAAM,MAAM;AACf,kBAAM,MAAO,MAAM,QAAS;AAC5B,gBAAI,KAAK,WAAW,GAAG,IAAI;AACvB,oBAAM,MAAM;AAAA;AAEZ,qBAAO;AAAA,UACf;AACA,cAAI,KAAK,WAAW,GAAG,MAAM;AACzB,mBAAO,EAAE,MAAM,MAAM,GAAG,KAAK,EAAE;AACnC,cAAI,QAAQ;AACR,mBAAO,EAAE,MAAM,GAAG,KAAK,OAAO;AAClC,gBAAM,QAAQ,KAAK,WAAW,MAAM,CAAC;AACrC,iBAAO,EAAE,MAAM,KAAK,KAAK,SAAS,QAAQ,EAAE;AAAA,QAChD;AAAA,MACJ;AAAA,IACJ;AAEA,IAAAA,SAAQ,cAAc;AAAA;AAAA;;;ACxCtB,IAAAC,kBAAA;AAAA,4HAAAC,UAAA;AAAA;AAEA,QAAI,MAAM;AACV,QAAI,QAAQ;AAEZ,aAAS,cAAc,MAAM,MAAM;AAC/B,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,EAAE;AAC/B,YAAI,KAAK,CAAC,EAAE,SAAS;AACjB,iBAAO;AACf,aAAO;AAAA,IACX;AALS;AAMT,aAAS,kBAAkB,MAAM;AAC7B,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,EAAE,GAAG;AAClC,gBAAQ,KAAK,CAAC,EAAE,MAAM;AAAA,UAClB,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD;AAAA,UACJ;AACI,mBAAO;AAAA,QACf;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAZS;AAaT,aAAS,YAAY,OAAO;AACxB,cAAQ,OAAO,MAAM;AAAA,QACjB,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACD,iBAAO;AAAA,QACX;AACI,iBAAO;AAAA,MACf;AAAA,IACJ;AAXS;AAYT,aAAS,aAAa,QAAQ;AAC1B,cAAQ,OAAO,MAAM;AAAA,QACjB,KAAK;AACD,iBAAO,OAAO;AAAA,QAClB,KAAK,aAAa;AACd,gBAAM,KAAK,OAAO,MAAM,OAAO,MAAM,SAAS,CAAC;AAC/C,iBAAO,GAAG,OAAO,GAAG;AAAA,QACxB;AAAA,QACA,KAAK;AACD,iBAAO,OAAO,MAAM,OAAO,MAAM,SAAS,CAAC,EAAE;AAAA,QAEjD;AACI,iBAAO,CAAC;AAAA,MAChB;AAAA,IACJ;AAdS;AAgBT,aAAS,sBAAsB,MAAM;AACjC,UAAI,KAAK,WAAW;AAChB,eAAO,CAAC;AACZ,UAAI,IAAI,KAAK;AACb;AAAM,eAAO,EAAE,KAAK,GAAG;AACnB,kBAAQ,KAAK,CAAC,EAAE,MAAM;AAAA,YAClB,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACD,oBAAM;AAAA,UACd;AAAA,QACJ;AACA,aAAO,KAAK,EAAE,CAAC,GAAG,SAAS,SAAS;AAAA,MAEpC;AACA,aAAO,KAAK,OAAO,GAAG,KAAK,MAAM;AAAA,IACrC;AAlBS;AAmBT,aAAS,gBAAgB,IAAI;AACzB,UAAI,GAAG,MAAM,SAAS,kBAAkB;AACpC,mBAAW,MAAM,GAAG,OAAO;AACvB,cAAI,GAAG,OACH,CAAC,GAAG,SACJ,CAAC,cAAc,GAAG,OAAO,kBAAkB,KAC3C,CAAC,cAAc,GAAG,KAAK,eAAe,GAAG;AACzC,gBAAI,GAAG;AACH,iBAAG,QAAQ,GAAG;AAClB,mBAAO,GAAG;AACV,gBAAI,YAAY,GAAG,KAAK,GAAG;AACvB,kBAAI,GAAG,MAAM;AACT,sBAAM,UAAU,KAAK,MAAM,GAAG,MAAM,KAAK,GAAG,GAAG;AAAA;AAE/C,mBAAG,MAAM,MAAM,GAAG;AAAA,YAC1B;AAEI,oBAAM,UAAU,KAAK,MAAM,GAAG,OAAO,GAAG,GAAG;AAC/C,mBAAO,GAAG;AAAA,UACd;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAtBS;AAkDT,QAAM,SAAN,MAAa;AAAA,MAzHb,OAyHa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKT,YAAY,WAAW;AAEnB,aAAK,YAAY;AAEjB,aAAK,WAAW;AAEhB,aAAK,SAAS;AAEd,aAAK,SAAS;AAEd,aAAK,YAAY;AAEjB,aAAK,QAAQ,CAAC;AAEd,aAAK,SAAS;AAEd,aAAK,OAAO;AAEZ,aAAK,QAAQ,IAAI,MAAM,MAAM;AAC7B,aAAK,YAAY;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASA,CAAC,MAAM,QAAQ,aAAa,OAAO;AAC/B,YAAI,KAAK,aAAa,KAAK,WAAW;AAClC,eAAK,UAAU,CAAC;AACpB,mBAAW,UAAU,KAAK,MAAM,IAAI,QAAQ,UAAU;AAClD,iBAAO,KAAK,KAAK,MAAM;AAC3B,YAAI,CAAC;AACD,iBAAO,KAAK,IAAI;AAAA,MACxB;AAAA;AAAA;AAAA;AAAA,MAIA,CAAC,KAAK,QAAQ;AACV,aAAK,SAAS;AACd,YAAI,QAAQ,IAAI;AACZ,kBAAQ,IAAI,KAAK,IAAI,YAAY,MAAM,CAAC;AAC5C,YAAI,KAAK,UAAU;AACf,eAAK,WAAW;AAChB,iBAAO,KAAK,KAAK;AACjB,eAAK,UAAU,OAAO;AACtB;AAAA,QACJ;AACA,cAAM,OAAO,IAAI,UAAU,MAAM;AACjC,YAAI,CAAC,MAAM;AACP,gBAAM,UAAU,qBAAqB,MAAM;AAC3C,iBAAO,KAAK,IAAI,EAAE,MAAM,SAAS,QAAQ,KAAK,QAAQ,SAAS,OAAO,CAAC;AACvE,eAAK,UAAU,OAAO;AAAA,QAC1B,WACS,SAAS,UAAU;AACxB,eAAK,YAAY;AACjB,eAAK,WAAW;AAChB,eAAK,OAAO;AAAA,QAChB,OACK;AACD,eAAK,OAAO;AACZ,iBAAO,KAAK,KAAK;AACjB,kBAAQ,MAAM;AAAA,YACV,KAAK;AACD,mBAAK,YAAY;AACjB,mBAAK,SAAS;AACd,kBAAI,KAAK;AACL,qBAAK,UAAU,KAAK,SAAS,OAAO,MAAM;AAC9C;AAAA,YACJ,KAAK;AACD,kBAAI,KAAK,aAAa,OAAO,CAAC,MAAM;AAChC,qBAAK,UAAU,OAAO;AAC1B;AAAA,YACJ,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACD,kBAAI,KAAK;AACL,qBAAK,UAAU,OAAO;AAC1B;AAAA,YACJ,KAAK;AAAA,YACL,KAAK;AACD;AAAA,YACJ;AACI,mBAAK,YAAY;AAAA,UACzB;AACA,eAAK,UAAU,OAAO;AAAA,QAC1B;AAAA,MACJ;AAAA;AAAA,MAEA,CAAC,MAAM;AACH,eAAO,KAAK,MAAM,SAAS;AACvB,iBAAO,KAAK,IAAI;AAAA,MACxB;AAAA,MACA,IAAI,cAAc;AACd,cAAM,KAAK;AAAA,UACP,MAAM,KAAK;AAAA,UACX,QAAQ,KAAK;AAAA,UACb,QAAQ,KAAK;AAAA,UACb,QAAQ,KAAK;AAAA,QACjB;AACA,eAAO;AAAA,MACX;AAAA,MACA,CAAC,OAAO;AACJ,cAAM,MAAM,KAAK,KAAK,CAAC;AACvB,YAAI,KAAK,SAAS,cAAc,CAAC,OAAO,IAAI,SAAS,YAAY;AAC7D,iBAAO,KAAK,MAAM,SAAS;AACvB,mBAAO,KAAK,IAAI;AACpB,eAAK,MAAM,KAAK;AAAA,YACZ,MAAM;AAAA,YACN,QAAQ,KAAK;AAAA,YACb,QAAQ,KAAK;AAAA,UACjB,CAAC;AACD;AAAA,QACJ;AACA,YAAI,CAAC;AACD,iBAAO,OAAO,KAAK,OAAO;AAC9B,gBAAQ,IAAI,MAAM;AAAA,UACd,KAAK;AACD,mBAAO,OAAO,KAAK,SAAS,GAAG;AAAA,UACnC,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD,mBAAO,OAAO,KAAK,OAAO,GAAG;AAAA,UACjC,KAAK;AACD,mBAAO,OAAO,KAAK,YAAY,GAAG;AAAA,UACtC,KAAK;AACD,mBAAO,OAAO,KAAK,SAAS,GAAG;AAAA,UACnC,KAAK;AACD,mBAAO,OAAO,KAAK,cAAc,GAAG;AAAA,UACxC,KAAK;AACD,mBAAO,OAAO,KAAK,eAAe,GAAG;AAAA,UACzC,KAAK;AACD,mBAAO,OAAO,KAAK,YAAY,GAAG;AAAA,QAC1C;AAEA,eAAO,KAAK,IAAI;AAAA,MACpB;AAAA,MACA,KAAK,GAAG;AACJ,eAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA,MAC3C;AAAA,MACA,CAAC,IAAI,OAAO;AACR,cAAM,QAAQ,SAAS,KAAK,MAAM,IAAI;AAEtC,YAAI,CAAC,OAAO;AACR,gBAAM,UAAU;AAChB,gBAAM,EAAE,MAAM,SAAS,QAAQ,KAAK,QAAQ,QAAQ,IAAI,QAAQ;AAAA,QACpE,WACS,KAAK,MAAM,WAAW,GAAG;AAC9B,gBAAM;AAAA,QACV,OACK;AACD,gBAAM,MAAM,KAAK,KAAK,CAAC;AACvB,cAAI,MAAM,SAAS,gBAAgB;AAE/B,kBAAM,SAAS,YAAY,MAAM,IAAI,SAAS;AAAA,UAClD,WACS,MAAM,SAAS,qBAAqB,IAAI,SAAS,YAAY;AAElE,kBAAM,SAAS;AAAA,UACnB;AACA,cAAI,MAAM,SAAS;AACf,4BAAgB,KAAK;AACzB,kBAAQ,IAAI,MAAM;AAAA,YACd,KAAK;AACD,kBAAI,QAAQ;AACZ;AAAA,YACJ,KAAK;AACD,kBAAI,MAAM,KAAK,KAAK;AACpB;AAAA,YACJ,KAAK,aAAa;AACd,oBAAM,KAAK,IAAI,MAAM,IAAI,MAAM,SAAS,CAAC;AACzC,kBAAI,GAAG,OAAO;AACV,oBAAI,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,KAAK,OAAO,KAAK,CAAC,EAAE,CAAC;AACjD,qBAAK,YAAY;AACjB;AAAA,cACJ,WACS,GAAG,KAAK;AACb,mBAAG,QAAQ;AAAA,cACf,OACK;AACD,uBAAO,OAAO,IAAI,EAAE,KAAK,OAAO,KAAK,CAAC,EAAE,CAAC;AACzC,qBAAK,YAAY,CAAC,cAAc,GAAG,OAAO,kBAAkB;AAC5D;AAAA,cACJ;AACA;AAAA,YACJ;AAAA,YACA,KAAK,aAAa;AACd,oBAAM,KAAK,IAAI,MAAM,IAAI,MAAM,SAAS,CAAC;AACzC,kBAAI,GAAG;AACH,oBAAI,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,OAAO,MAAM,CAAC;AAAA;AAE1C,mBAAG,QAAQ;AACf;AAAA,YACJ;AAAA,YACA,KAAK,mBAAmB;AACpB,oBAAM,KAAK,IAAI,MAAM,IAAI,MAAM,SAAS,CAAC;AACzC,kBAAI,CAAC,MAAM,GAAG;AACV,oBAAI,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,KAAK,OAAO,KAAK,CAAC,EAAE,CAAC;AAAA,uBAC5C,GAAG;AACR,mBAAG,QAAQ;AAAA;AAEX,uBAAO,OAAO,IAAI,EAAE,KAAK,OAAO,KAAK,CAAC,EAAE,CAAC;AAC7C;AAAA,YACJ;AAAA,YAEA;AACI,qBAAO,KAAK,IAAI;AAChB,qBAAO,KAAK,IAAI,KAAK;AAAA,UAC7B;AACA,eAAK,IAAI,SAAS,cACd,IAAI,SAAS,eACb,IAAI,SAAS,iBACZ,MAAM,SAAS,eAAe,MAAM,SAAS,cAAc;AAC5D,kBAAM,OAAO,MAAM,MAAM,MAAM,MAAM,SAAS,CAAC;AAC/C,gBAAI,QACA,CAAC,KAAK,OACN,CAAC,KAAK,SACN,KAAK,MAAM,SAAS,KACpB,kBAAkB,KAAK,KAAK,MAAM,OACjC,MAAM,WAAW,KACd,KAAK,MAAM,MAAM,QAAM,GAAG,SAAS,aAAa,GAAG,SAAS,MAAM,MAAM,IAAI;AAChF,kBAAI,IAAI,SAAS;AACb,oBAAI,MAAM,KAAK;AAAA;AAEf,oBAAI,MAAM,KAAK,EAAE,OAAO,KAAK,MAAM,CAAC;AACxC,oBAAM,MAAM,OAAO,IAAI,CAAC;AAAA,YAC5B;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,CAAC,SAAS;AACN,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AACD,kBAAM,EAAE,MAAM,aAAa,QAAQ,KAAK,QAAQ,QAAQ,KAAK,OAAO;AACpE;AAAA,UACJ,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD,kBAAM,KAAK;AACX;AAAA,UACJ,KAAK;AAAA,UACL,KAAK,aAAa;AACd,kBAAM,MAAM;AAAA,cACR,MAAM;AAAA,cACN,QAAQ,KAAK;AAAA,cACb,OAAO,CAAC;AAAA,YACZ;AACA,gBAAI,KAAK,SAAS;AACd,kBAAI,MAAM,KAAK,KAAK,WAAW;AACnC,iBAAK,MAAM,KAAK,GAAG;AACnB;AAAA,UACJ;AAAA,QACJ;AACA,cAAM;AAAA,UACF,MAAM;AAAA,UACN,QAAQ,KAAK;AAAA,UACb,SAAS,cAAc,KAAK,IAAI;AAAA,UAChC,QAAQ,KAAK;AAAA,QACjB;AAAA,MACJ;AAAA,MACA,CAAC,SAAS,KAAK;AACX,YAAI,IAAI;AACJ,iBAAO,OAAO,KAAK,QAAQ,GAAG;AAClC,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK,aAAa;AACd,gBAAI,kBAAkB,IAAI,KAAK,MAAM,IAAI;AACrC,qBAAO,KAAK,IAAI;AAChB,qBAAO,KAAK,KAAK;AAAA,YACrB;AAEI,kBAAI,MAAM,KAAK,KAAK,WAAW;AACnC;AAAA,UACJ;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD,gBAAI,MAAM,KAAK,KAAK,WAAW;AAC/B;AAAA,QACR;AACA,cAAM,KAAK,KAAK,gBAAgB,GAAG;AACnC,YAAI;AACA,eAAK,MAAM,KAAK,EAAE;AAAA,aACjB;AACD,gBAAM;AAAA,YACF,MAAM;AAAA,YACN,QAAQ,KAAK;AAAA,YACb,SAAS,cAAc,KAAK,IAAI;AAAA,YAChC,QAAQ,KAAK;AAAA,UACjB;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,CAAC,OAAO,QAAQ;AACZ,YAAI,KAAK,SAAS,iBAAiB;AAC/B,gBAAM,OAAO,aAAa,KAAK,KAAK,CAAC,CAAC;AACtC,gBAAM,QAAQ,sBAAsB,IAAI;AACxC,cAAI;AACJ,cAAI,OAAO,KAAK;AACZ,kBAAM,OAAO;AACb,gBAAI,KAAK,KAAK,WAAW;AACzB,mBAAO,OAAO;AAAA,UAClB;AAEI,kBAAM,CAAC,KAAK,WAAW;AAC3B,gBAAM,MAAM;AAAA,YACR,MAAM;AAAA,YACN,QAAQ,OAAO;AAAA,YACf,QAAQ,OAAO;AAAA,YACf,OAAO,CAAC,EAAE,OAAO,KAAK,QAAQ,IAAI,CAAC;AAAA,UACvC;AACA,eAAK,YAAY;AACjB,eAAK,MAAM,KAAK,MAAM,SAAS,CAAC,IAAI;AAAA,QACxC;AAEI,iBAAO,KAAK,QAAQ,MAAM;AAAA,MAClC;AAAA,MACA,CAAC,YAAY,QAAQ;AACjB,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD,mBAAO,MAAM,KAAK,KAAK,WAAW;AAClC;AAAA,UACJ,KAAK;AACD,mBAAO,SAAS,KAAK;AAErB,iBAAK,YAAY;AACjB,iBAAK,SAAS;AACd,gBAAI,KAAK,WAAW;AAChB,kBAAI,KAAK,KAAK,OAAO,QAAQ,IAAI,IAAI;AACrC,qBAAO,OAAO,GAAG;AACb,qBAAK,UAAU,KAAK,SAAS,EAAE;AAC/B,qBAAK,KAAK,OAAO,QAAQ,MAAM,EAAE,IAAI;AAAA,cACzC;AAAA,YACJ;AACA,mBAAO,KAAK,IAAI;AAChB;AAAA,UAEJ;AACI,mBAAO,KAAK,IAAI;AAChB,mBAAO,KAAK,KAAK;AAAA,QACzB;AAAA,MACJ;AAAA,MACA,CAAC,SAAS,KAAK;AACX,cAAM,KAAK,IAAI,MAAM,IAAI,MAAM,SAAS,CAAC;AAEzC,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AACD,iBAAK,YAAY;AACjB,gBAAI,GAAG,OAAO;AACV,oBAAM,MAAM,SAAS,GAAG,QAAQ,GAAG,MAAM,MAAM;AAC/C,oBAAM,OAAO,MAAM,QAAQ,GAAG,IAAI,IAAI,IAAI,SAAS,CAAC,IAAI;AACxD,kBAAI,MAAM,SAAS;AACf,qBAAK,KAAK,KAAK,WAAW;AAAA;AAE1B,oBAAI,MAAM,KAAK,EAAE,OAAO,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,YACpD,WACS,GAAG,KAAK;AACb,iBAAG,IAAI,KAAK,KAAK,WAAW;AAAA,YAChC,OACK;AACD,iBAAG,MAAM,KAAK,KAAK,WAAW;AAAA,YAClC;AACA;AAAA,UACJ,KAAK;AAAA,UACL,KAAK;AACD,gBAAI,GAAG,OAAO;AACV,kBAAI,MAAM,KAAK,EAAE,OAAO,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,YAChD,WACS,GAAG,KAAK;AACb,iBAAG,IAAI,KAAK,KAAK,WAAW;AAAA,YAChC,OACK;AACD,kBAAI,KAAK,kBAAkB,GAAG,OAAO,IAAI,MAAM,GAAG;AAC9C,sBAAM,OAAO,IAAI,MAAM,IAAI,MAAM,SAAS,CAAC;AAC3C,sBAAM,MAAM,MAAM,OAAO;AACzB,oBAAI,MAAM,QAAQ,GAAG,GAAG;AACpB,wBAAM,UAAU,KAAK,MAAM,KAAK,GAAG,KAAK;AACxC,sBAAI,KAAK,KAAK,WAAW;AACzB,sBAAI,MAAM,IAAI;AACd;AAAA,gBACJ;AAAA,cACJ;AACA,iBAAG,MAAM,KAAK,KAAK,WAAW;AAAA,YAClC;AACA;AAAA,QACR;AACA,YAAI,KAAK,UAAU,IAAI,QAAQ;AAC3B,gBAAM,aAAa,CAAC,KAAK,aAAa,KAAK,WAAW,IAAI,UAAU,GAAG;AAEvE,cAAI,QAAQ,CAAC;AACb,cAAI,cAAc,GAAG,OAAO,CAAC,GAAG,OAAO;AACnC,kBAAM,KAAK,CAAC;AACZ,qBAAS,IAAI,GAAG,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AACpC,oBAAM,KAAK,GAAG,IAAI,CAAC;AACnB,sBAAQ,GAAG,MAAM;AAAA,gBACb,KAAK;AACD,qBAAG,KAAK,CAAC;AACT;AAAA,gBACJ,KAAK;AACD;AAAA,gBACJ,KAAK;AACD,sBAAI,GAAG,SAAS,IAAI;AAChB,uBAAG,SAAS;AAChB;AAAA,gBACJ;AACI,qBAAG,SAAS;AAAA,cACpB;AAAA,YACJ;AACA,gBAAI,GAAG,UAAU;AACb,sBAAQ,GAAG,IAAI,OAAO,GAAG,CAAC,CAAC;AAAA,UACnC;AACA,kBAAQ,KAAK,MAAM;AAAA,YACf,KAAK;AAAA,YACL,KAAK;AACD,kBAAI,cAAc,GAAG,OAAO;AACxB,sBAAM,KAAK,KAAK,WAAW;AAC3B,oBAAI,MAAM,KAAK,EAAE,MAAM,CAAC;AACxB,qBAAK,YAAY;AAAA,cACrB,WACS,GAAG,KAAK;AACb,mBAAG,IAAI,KAAK,KAAK,WAAW;AAAA,cAChC,OACK;AACD,mBAAG,MAAM,KAAK,KAAK,WAAW;AAAA,cAClC;AACA;AAAA,YACJ,KAAK;AACD,kBAAI,CAAC,GAAG,OAAO,CAAC,cAAc,GAAG,OAAO,kBAAkB,GAAG;AACzD,mBAAG,MAAM,KAAK,KAAK,WAAW;AAAA,cAClC,WACS,cAAc,GAAG,OAAO;AAC7B,sBAAM,KAAK,KAAK,WAAW;AAC3B,oBAAI,MAAM,KAAK,EAAE,MAAM,CAAC;AAAA,cAC5B,OACK;AACD,qBAAK,MAAM,KAAK;AAAA,kBACZ,MAAM;AAAA,kBACN,QAAQ,KAAK;AAAA,kBACb,QAAQ,KAAK;AAAA,kBACb,OAAO,CAAC,EAAE,OAAO,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,gBACzC,CAAC;AAAA,cACL;AACA,mBAAK,YAAY;AACjB;AAAA,YACJ,KAAK;AACD,kBAAI,cAAc,GAAG,OAAO,kBAAkB,GAAG;AAC7C,oBAAI,CAAC,GAAG,KAAK;AACT,sBAAI,cAAc,GAAG,OAAO,SAAS,GAAG;AACpC,2BAAO,OAAO,IAAI,EAAE,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,kBAC5D,OACK;AACD,0BAAMC,SAAQ,sBAAsB,GAAG,KAAK;AAC5C,yBAAK,MAAM,KAAK;AAAA,sBACZ,MAAM;AAAA,sBACN,QAAQ,KAAK;AAAA,sBACb,QAAQ,KAAK;AAAA,sBACb,OAAO,CAAC,EAAE,OAAAA,QAAO,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,oBACzD,CAAC;AAAA,kBACL;AAAA,gBACJ,WACS,GAAG,OAAO;AACf,sBAAI,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,gBACpE,WACS,cAAc,GAAG,KAAK,eAAe,GAAG;AAC7C,uBAAK,MAAM,KAAK;AAAA,oBACZ,MAAM;AAAA,oBACN,QAAQ,KAAK;AAAA,oBACb,QAAQ,KAAK;AAAA,oBACb,OAAO,CAAC,EAAE,OAAO,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,kBACzD,CAAC;AAAA,gBACL,WACS,YAAY,GAAG,GAAG,KACvB,CAAC,cAAc,GAAG,KAAK,SAAS,GAAG;AACnC,wBAAMA,SAAQ,sBAAsB,GAAG,KAAK;AAC5C,wBAAM,MAAM,GAAG;AACf,wBAAM,MAAM,GAAG;AACf,sBAAI,KAAK,KAAK,WAAW;AAEzB,yBAAO,GAAG,KAAK,OAAO,GAAG;AACzB,uBAAK,MAAM,KAAK;AAAA,oBACZ,MAAM;AAAA,oBACN,QAAQ,KAAK;AAAA,oBACb,QAAQ,KAAK;AAAA,oBACb,OAAO,CAAC,EAAE,OAAAA,QAAO,KAAK,IAAI,CAAC;AAAA,kBAC/B,CAAC;AAAA,gBACL,WACS,MAAM,SAAS,GAAG;AAEvB,qBAAG,MAAM,GAAG,IAAI,OAAO,OAAO,KAAK,WAAW;AAAA,gBAClD,OACK;AACD,qBAAG,IAAI,KAAK,KAAK,WAAW;AAAA,gBAChC;AAAA,cACJ,OACK;AACD,oBAAI,CAAC,GAAG,KAAK;AACT,yBAAO,OAAO,IAAI,EAAE,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,gBAC5D,WACS,GAAG,SAAS,YAAY;AAC7B,sBAAI,MAAM,KAAK,EAAE,OAAO,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,gBAChE,WACS,cAAc,GAAG,KAAK,eAAe,GAAG;AAC7C,uBAAK,MAAM,KAAK;AAAA,oBACZ,MAAM;AAAA,oBACN,QAAQ,KAAK;AAAA,oBACb,QAAQ,KAAK;AAAA,oBACb,OAAO,CAAC,EAAE,OAAO,CAAC,GAAG,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,kBAC7D,CAAC;AAAA,gBACL,OACK;AACD,qBAAG,IAAI,KAAK,KAAK,WAAW;AAAA,gBAChC;AAAA,cACJ;AACA,mBAAK,YAAY;AACjB;AAAA,YACJ,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK,wBAAwB;AACzB,oBAAM,KAAK,KAAK,WAAW,KAAK,IAAI;AACpC,kBAAI,cAAc,GAAG,OAAO;AACxB,oBAAI,MAAM,KAAK,EAAE,OAAO,KAAK,IAAI,KAAK,CAAC,EAAE,CAAC;AAC1C,qBAAK,YAAY;AAAA,cACrB,WACS,GAAG,KAAK;AACb,qBAAK,MAAM,KAAK,EAAE;AAAA,cACtB,OACK;AACD,uBAAO,OAAO,IAAI,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,CAAC;AACtC,qBAAK,YAAY;AAAA,cACrB;AACA;AAAA,YACJ;AAAA,YACA,SAAS;AACL,oBAAM,KAAK,KAAK,gBAAgB,GAAG;AACnC,kBAAI,IAAI;AACJ,oBAAI,cACA,GAAG,SAAS,eACZ,cAAc,GAAG,OAAO,kBAAkB,GAAG;AAC7C,sBAAI,MAAM,KAAK,EAAE,MAAM,CAAC;AAAA,gBAC5B;AACA,qBAAK,MAAM,KAAK,EAAE;AAClB;AAAA,cACJ;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AACA,eAAO,KAAK,IAAI;AAChB,eAAO,KAAK,KAAK;AAAA,MACrB;AAAA,MACA,CAAC,cAAc,KAAK;AAChB,cAAM,KAAK,IAAI,MAAM,IAAI,MAAM,SAAS,CAAC;AACzC,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AACD,gBAAI,GAAG,OAAO;AACV,oBAAM,MAAM,SAAS,GAAG,QAAQ,GAAG,MAAM,MAAM;AAC/C,oBAAM,OAAO,MAAM,QAAQ,GAAG,IAAI,IAAI,IAAI,SAAS,CAAC,IAAI;AACxD,kBAAI,MAAM,SAAS;AACf,qBAAK,KAAK,KAAK,WAAW;AAAA;AAE1B,oBAAI,MAAM,KAAK,EAAE,OAAO,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,YACpD;AAEI,iBAAG,MAAM,KAAK,KAAK,WAAW;AAClC;AAAA,UACJ,KAAK;AAAA,UACL,KAAK;AACD,gBAAI,GAAG;AACH,kBAAI,MAAM,KAAK,EAAE,OAAO,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,iBAC3C;AACD,kBAAI,KAAK,kBAAkB,GAAG,OAAO,IAAI,MAAM,GAAG;AAC9C,sBAAM,OAAO,IAAI,MAAM,IAAI,MAAM,SAAS,CAAC;AAC3C,sBAAM,MAAM,MAAM,OAAO;AACzB,oBAAI,MAAM,QAAQ,GAAG,GAAG;AACpB,wBAAM,UAAU,KAAK,MAAM,KAAK,GAAG,KAAK;AACxC,sBAAI,KAAK,KAAK,WAAW;AACzB,sBAAI,MAAM,IAAI;AACd;AAAA,gBACJ;AAAA,cACJ;AACA,iBAAG,MAAM,KAAK,KAAK,WAAW;AAAA,YAClC;AACA;AAAA,UACJ,KAAK;AAAA,UACL,KAAK;AACD,gBAAI,GAAG,SAAS,KAAK,UAAU,IAAI;AAC/B;AACJ,eAAG,MAAM,KAAK,KAAK,WAAW;AAC9B;AAAA,UACJ,KAAK;AACD,gBAAI,KAAK,WAAW,IAAI;AACpB;AACJ,gBAAI,GAAG,SAAS,cAAc,GAAG,OAAO,cAAc;AAClD,kBAAI,MAAM,KAAK,EAAE,OAAO,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA;AAE5C,iBAAG,MAAM,KAAK,KAAK,WAAW;AAClC;AAAA,QACR;AACA,YAAI,KAAK,SAAS,IAAI,QAAQ;AAC1B,gBAAM,KAAK,KAAK,gBAAgB,GAAG;AACnC,cAAI,IAAI;AACJ,iBAAK,MAAM,KAAK,EAAE;AAClB;AAAA,UACJ;AAAA,QACJ;AACA,eAAO,KAAK,IAAI;AAChB,eAAO,KAAK,KAAK;AAAA,MACrB;AAAA,MACA,CAAC,eAAe,IAAI;AAChB,cAAM,KAAK,GAAG,MAAM,GAAG,MAAM,SAAS,CAAC;AACvC,YAAI,KAAK,SAAS,kBAAkB;AAChC,cAAI;AACJ,aAAG;AACC,mBAAO,KAAK,IAAI;AAChB,kBAAM,KAAK,KAAK,CAAC;AAAA,UACrB,SAAS,OAAO,IAAI,SAAS;AAAA,QACjC,WACS,GAAG,IAAI,WAAW,GAAG;AAC1B,kBAAQ,KAAK,MAAM;AAAA,YACf,KAAK;AAAA,YACL,KAAK;AACD,kBAAI,CAAC,MAAM,GAAG;AACV,mBAAG,MAAM,KAAK,EAAE,OAAO,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA;AAE3C,mBAAG,MAAM,KAAK,KAAK,WAAW;AAClC;AAAA,YACJ,KAAK;AACD,kBAAI,CAAC,MAAM,GAAG;AACV,mBAAG,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,uBAC1D,GAAG;AACR,mBAAG,IAAI,KAAK,KAAK,WAAW;AAAA;AAE5B,uBAAO,OAAO,IAAI,EAAE,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAC5D;AAAA,YACJ,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACD,kBAAI,CAAC,MAAM,GAAG;AACV,mBAAG,MAAM,KAAK,EAAE,OAAO,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,uBACtC,GAAG;AACR,mBAAG,IAAI,KAAK,KAAK,WAAW;AAAA;AAE5B,mBAAG,MAAM,KAAK,KAAK,WAAW;AAClC;AAAA,YACJ,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK,wBAAwB;AACzB,oBAAM,KAAK,KAAK,WAAW,KAAK,IAAI;AACpC,kBAAI,CAAC,MAAM,GAAG;AACV,mBAAG,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,KAAK,IAAI,KAAK,CAAC,EAAE,CAAC;AAAA,uBACxC,GAAG;AACR,qBAAK,MAAM,KAAK,EAAE;AAAA;AAElB,uBAAO,OAAO,IAAI,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,CAAC;AAC1C;AAAA,YACJ;AAAA,YACA,KAAK;AAAA,YACL,KAAK;AACD,iBAAG,IAAI,KAAK,KAAK,WAAW;AAC5B;AAAA,UACR;AACA,gBAAM,KAAK,KAAK,gBAAgB,EAAE;AAElC,cAAI;AACA,iBAAK,MAAM,KAAK,EAAE;AAAA,eACjB;AACD,mBAAO,KAAK,IAAI;AAChB,mBAAO,KAAK,KAAK;AAAA,UACrB;AAAA,QACJ,OACK;AACD,gBAAM,SAAS,KAAK,KAAK,CAAC;AAC1B,cAAI,OAAO,SAAS,gBACd,KAAK,SAAS,mBAAmB,OAAO,WAAW,GAAG,UACnD,KAAK,SAAS,aACX,CAAC,OAAO,MAAM,OAAO,MAAM,SAAS,CAAC,EAAE,MAAO;AACtD,mBAAO,KAAK,IAAI;AAChB,mBAAO,KAAK,KAAK;AAAA,UACrB,WACS,KAAK,SAAS,mBACnB,OAAO,SAAS,mBAAmB;AACnC,kBAAM,OAAO,aAAa,MAAM;AAChC,kBAAM,QAAQ,sBAAsB,IAAI;AACxC,4BAAgB,EAAE;AAClB,kBAAM,MAAM,GAAG,IAAI,OAAO,GAAG,GAAG,IAAI,MAAM;AAC1C,gBAAI,KAAK,KAAK,WAAW;AACzB,kBAAM,MAAM;AAAA,cACR,MAAM;AAAA,cACN,QAAQ,GAAG;AAAA,cACX,QAAQ,GAAG;AAAA,cACX,OAAO,CAAC,EAAE,OAAO,KAAK,IAAI,IAAI,CAAC;AAAA,YACnC;AACA,iBAAK,YAAY;AACjB,iBAAK,MAAM,KAAK,MAAM,SAAS,CAAC,IAAI;AAAA,UACxC,OACK;AACD,mBAAO,KAAK,QAAQ,EAAE;AAAA,UAC1B;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,WAAW,MAAM;AACb,YAAI,KAAK,WAAW;AAChB,cAAI,KAAK,KAAK,OAAO,QAAQ,IAAI,IAAI;AACrC,iBAAO,OAAO,GAAG;AACb,iBAAK,UAAU,KAAK,SAAS,EAAE;AAC/B,iBAAK,KAAK,OAAO,QAAQ,MAAM,EAAE,IAAI;AAAA,UACzC;AAAA,QACJ;AACA,eAAO;AAAA,UACH;AAAA,UACA,QAAQ,KAAK;AAAA,UACb,QAAQ,KAAK;AAAA,UACb,QAAQ,KAAK;AAAA,QACjB;AAAA,MACJ;AAAA,MACA,gBAAgB,QAAQ;AACpB,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD,mBAAO,KAAK,WAAW,KAAK,IAAI;AAAA,UACpC,KAAK;AACD,mBAAO;AAAA,cACH,MAAM;AAAA,cACN,QAAQ,KAAK;AAAA,cACb,QAAQ,KAAK;AAAA,cACb,OAAO,CAAC,KAAK,WAAW;AAAA,cACxB,QAAQ;AAAA,YACZ;AAAA,UACJ,KAAK;AAAA,UACL,KAAK;AACD,mBAAO;AAAA,cACH,MAAM;AAAA,cACN,QAAQ,KAAK;AAAA,cACb,QAAQ,KAAK;AAAA,cACb,OAAO,KAAK;AAAA,cACZ,OAAO,CAAC;AAAA,cACR,KAAK,CAAC;AAAA,YACV;AAAA,UACJ,KAAK;AACD,mBAAO;AAAA,cACH,MAAM;AAAA,cACN,QAAQ,KAAK;AAAA,cACb,QAAQ,KAAK;AAAA,cACb,OAAO,CAAC,EAAE,OAAO,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,YACzC;AAAA,UACJ,KAAK,oBAAoB;AACrB,iBAAK,YAAY;AACjB,kBAAM,OAAO,aAAa,MAAM;AAChC,kBAAM,QAAQ,sBAAsB,IAAI;AACxC,kBAAM,KAAK,KAAK,WAAW;AAC3B,mBAAO;AAAA,cACH,MAAM;AAAA,cACN,QAAQ,KAAK;AAAA,cACb,QAAQ,KAAK;AAAA,cACb,OAAO,CAAC,EAAE,MAAM,CAAC;AAAA,YACrB;AAAA,UACJ;AAAA,UACA,KAAK,iBAAiB;AAClB,iBAAK,YAAY;AACjB,kBAAM,OAAO,aAAa,MAAM;AAChC,kBAAM,QAAQ,sBAAsB,IAAI;AACxC,mBAAO;AAAA,cACH,MAAM;AAAA,cACN,QAAQ,KAAK;AAAA,cACb,QAAQ,KAAK;AAAA,cACb,OAAO,CAAC,EAAE,OAAO,KAAK,MAAM,KAAK,CAAC,KAAK,WAAW,EAAE,CAAC;AAAA,YACzD;AAAA,UACJ;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AAAA,MACA,kBAAkB,OAAO,QAAQ;AAC7B,YAAI,KAAK,SAAS;AACd,iBAAO;AACX,YAAI,KAAK,UAAU;AACf,iBAAO;AACX,eAAO,MAAM,MAAM,QAAM,GAAG,SAAS,aAAa,GAAG,SAAS,OAAO;AAAA,MACzE;AAAA,MACA,CAAC,YAAY,QAAQ;AACjB,YAAI,KAAK,SAAS,YAAY;AAC1B,cAAI,OAAO;AACP,mBAAO,IAAI,KAAK,KAAK,WAAW;AAAA;AAEhC,mBAAO,MAAM,CAAC,KAAK,WAAW;AAClC,cAAI,KAAK,SAAS;AACd,mBAAO,KAAK,IAAI;AAAA,QACxB;AAAA,MACJ;AAAA,MACA,CAAC,QAAQ,OAAO;AACZ,gBAAQ,KAAK,MAAM;AAAA,UACf,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACD,mBAAO,KAAK,IAAI;AAChB,mBAAO,KAAK,KAAK;AACjB;AAAA,UACJ,KAAK;AACD,iBAAK,YAAY;AAAA,UAErB,KAAK;AAAA,UACL,KAAK;AAAA,UACL;AAEI,gBAAI,MAAM;AACN,oBAAM,IAAI,KAAK,KAAK,WAAW;AAAA;AAE/B,oBAAM,MAAM,CAAC,KAAK,WAAW;AACjC,gBAAI,KAAK,SAAS;AACd,qBAAO,KAAK,IAAI;AAAA,QAC5B;AAAA,MACJ;AAAA,IACJ;AAEA,IAAAD,SAAQ,SAAS;AAAA;AAAA;;;ACz7BjB;AAAA,0HAAAE,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,MAAM;AACV,QAAI,cAAc;AAClB,QAAI,SAAS;AAEb,aAAS,aAAa,SAAS;AAC3B,YAAM,eAAe,QAAQ,iBAAiB;AAC9C,YAAM,gBAAgB,QAAQ,eAAgB,gBAAgB,IAAI,YAAY,YAAY,KAAM;AAChG,aAAO,EAAE,aAAa,eAAe,aAAa;AAAA,IACtD;AAJS;AAcT,aAAS,kBAAkB,QAAQ,UAAU,CAAC,GAAG;AAC7C,YAAM,EAAE,aAAAC,cAAa,aAAa,IAAI,aAAa,OAAO;AAC1D,YAAM,WAAW,IAAI,OAAO,OAAOA,cAAa,UAAU;AAC1D,YAAM,aAAa,IAAI,SAAS,SAAS,OAAO;AAChD,YAAM,OAAO,MAAM,KAAK,WAAW,QAAQ,SAAS,MAAM,MAAM,CAAC,CAAC;AAClE,UAAI,gBAAgBA;AAChB,mBAAW,OAAO,MAAM;AACpB,cAAI,OAAO,QAAQ,OAAO,cAAc,QAAQA,YAAW,CAAC;AAC5D,cAAI,SAAS,QAAQ,OAAO,cAAc,QAAQA,YAAW,CAAC;AAAA,QAClE;AACJ,UAAI,KAAK,SAAS;AACd,eAAO;AACX,aAAO,OAAO,OAAO,CAAC,GAAG,EAAE,OAAO,KAAK,GAAG,WAAW,WAAW,CAAC;AAAA,IACrE;AAbS;AAeT,aAAS,cAAc,QAAQ,UAAU,CAAC,GAAG;AACzC,YAAM,EAAE,aAAAA,cAAa,aAAa,IAAI,aAAa,OAAO;AAC1D,YAAM,WAAW,IAAI,OAAO,OAAOA,cAAa,UAAU;AAC1D,YAAM,aAAa,IAAI,SAAS,SAAS,OAAO;AAEhD,UAAI,MAAM;AACV,iBAAW,QAAQ,WAAW,QAAQ,SAAS,MAAM,MAAM,GAAG,MAAM,OAAO,MAAM,GAAG;AAChF,YAAI,CAAC;AACD,gBAAM;AAAA,iBACD,IAAI,QAAQ,aAAa,UAAU;AACxC,cAAI,OAAO,KAAK,IAAI,OAAO,eAAe,KAAK,MAAM,MAAM,GAAG,CAAC,GAAG,iBAAiB,yEAAyE,CAAC;AAC7J;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,gBAAgBA,cAAa;AAC7B,YAAI,OAAO,QAAQ,OAAO,cAAc,QAAQA,YAAW,CAAC;AAC5D,YAAI,SAAS,QAAQ,OAAO,cAAc,QAAQA,YAAW,CAAC;AAAA,MAClE;AACA,aAAO;AAAA,IACX;AAnBS;AAoBT,aAAS,MAAM,KAAK,SAAS,SAAS;AAClC,UAAI,WAAW;AACf,UAAI,OAAO,YAAY,YAAY;AAC/B,mBAAW;AAAA,MACf,WACS,YAAY,UAAa,WAAW,OAAO,YAAY,UAAU;AACtE,kBAAU;AAAA,MACd;AACA,YAAM,MAAM,cAAc,KAAK,OAAO;AACtC,UAAI,CAAC;AACD,eAAO;AACX,UAAI,SAAS,QAAQ,aAAW,IAAI,KAAK,IAAI,QAAQ,UAAU,OAAO,CAAC;AACvE,UAAI,IAAI,OAAO,SAAS,GAAG;AACvB,YAAI,IAAI,QAAQ,aAAa;AACzB,gBAAM,IAAI,OAAO,CAAC;AAAA;AAElB,cAAI,SAAS,CAAC;AAAA,MACtB;AACA,aAAO,IAAI,KAAK,OAAO,OAAO,EAAE,SAAS,SAAS,GAAG,OAAO,CAAC;AAAA,IACjE;AAnBS;AAoBT,aAAS,UAAU,OAAO,UAAU,SAAS;AACzC,UAAI,YAAY;AAChB,UAAI,OAAO,aAAa,cAAc,MAAM,QAAQ,QAAQ,GAAG;AAC3D,oBAAY;AAAA,MAChB,WACS,YAAY,UAAa,UAAU;AACxC,kBAAU;AAAA,MACd;AACA,UAAI,OAAO,YAAY;AACnB,kBAAU,QAAQ;AACtB,UAAI,OAAO,YAAY,UAAU;AAC7B,cAAM,SAAS,KAAK,MAAM,OAAO;AACjC,kBAAU,SAAS,IAAI,SAAY,SAAS,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,OAAO;AAAA,MAC7E;AACA,UAAI,UAAU,QAAW;AACrB,cAAM,EAAE,cAAc,IAAI,WAAW,YAAY,CAAC;AAClD,YAAI,CAAC;AACD,iBAAO;AAAA,MACf;AACA,aAAO,IAAI,SAAS,SAAS,OAAO,WAAW,OAAO,EAAE,SAAS,OAAO;AAAA,IAC5E;AApBS;AAsBT,IAAAD,SAAQ,QAAQ;AAChB,IAAAA,SAAQ,oBAAoB;AAC5B,IAAAA,SAAQ,gBAAgB;AACxB,IAAAA,SAAQ,YAAY;AAAA;AAAA;;;ACvGpB;AAAA,qHAAAE,UAAA;AAAA;AAEA,QAAI,WAAW;AACf,QAAI,WAAW;AACf,QAAI,SAAS;AACb,QAAI,SAAS;AACb,QAAI,QAAQ;AACZ,QAAI,WAAW;AACf,QAAI,OAAO;AACX,QAAI,SAAS;AACb,QAAI,UAAU;AACd,QAAI,UAAU;AACd,QAAI,MAAM;AACV,QAAI,QAAQ;AACZ,QAAI,cAAc;AAClB,QAAI,SAAS;AACb,QAAI,YAAY;AAChB,QAAI,QAAQ;AAIZ,IAAAA,SAAQ,WAAW,SAAS;AAC5B,IAAAA,SAAQ,WAAW,SAAS;AAC5B,IAAAA,SAAQ,SAAS,OAAO;AACxB,IAAAA,SAAQ,YAAY,OAAO;AAC3B,IAAAA,SAAQ,iBAAiB,OAAO;AAChC,IAAAA,SAAQ,cAAc,OAAO;AAC7B,IAAAA,SAAQ,QAAQ,MAAM;AACtB,IAAAA,SAAQ,UAAU,SAAS;AAC3B,IAAAA,SAAQ,eAAe,SAAS;AAChC,IAAAA,SAAQ,aAAa,SAAS;AAC9B,IAAAA,SAAQ,QAAQ,SAAS;AACzB,IAAAA,SAAQ,SAAS,SAAS;AAC1B,IAAAA,SAAQ,SAAS,SAAS;AAC1B,IAAAA,SAAQ,WAAW,SAAS;AAC5B,IAAAA,SAAQ,QAAQ,SAAS;AACzB,IAAAA,SAAQ,OAAO,KAAK;AACpB,IAAAA,SAAQ,SAAS,OAAO;AACxB,IAAAA,SAAQ,UAAU,QAAQ;AAC1B,IAAAA,SAAQ,UAAU,QAAQ;AAC1B,IAAAA,SAAQ,MAAM;AACd,IAAAA,SAAQ,QAAQ,MAAM;AACtB,IAAAA,SAAQ,cAAc,YAAY;AAClC,IAAAA,SAAQ,SAAS,OAAO;AACxB,IAAAA,SAAQ,QAAQ,UAAU;AAC1B,IAAAA,SAAQ,oBAAoB,UAAU;AACtC,IAAAA,SAAQ,gBAAgB,UAAU;AAClC,IAAAA,SAAQ,YAAY,UAAU;AAC9B,IAAAA,SAAQ,QAAQ,MAAM;AACtB,IAAAA,SAAQ,aAAa,MAAM;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjD3B,QAAA,OAAA,QAAA,IAAA;AACA,QAAA,OAAA,aAAA,QAAA,MAAA,CAAA;AACA,QAAA,OAAA,aAAA,cAAA;AACA,QAAA,OAAA,aAAA,cAAA;AAiBA,aAAgB,4BAA4B,QAAc;AACxD,YAAM,SAAc,CAAA;AAEpB,YAAM,aAAa,OAAO,MAAM,GAAG;AACnC,iBAAW,QAAQ,CAAC,MAAK;AACvB,cAAM,CAAC,WAAW,KAAK,IAAI,EAAE,MAAM,GAAG;AACtC,cAAM,YAAY,UAAU,MAAM,GAAG;AACrC,YAAI,aAAa;AAEjB,kBAAU,QAAQ,CAAC,MAAM,UAAS;AAEhC,cAAI,UAAU,UAAU,SAAS,GAAG;AAClC,uBAAW,IAAI,IAAI;UACrB,OAAO;AAEL,gBAAI,CAAC,WAAW,IAAI;AAAG,yBAAW,IAAI,IAAI,CAAA;AAC1C,yBAAa,WAAW,IAAI;UAC9B;QACF,CAAC;MACH,CAAC;AAED,aAAO;IACT;AAtBgB;AAAhB,IAAAC,SAAA,8BAAA;AA8BA,aAAgB,wBAAwB,QAAW;AACjD,YAAM,SAAS,oBAAI,IAAG;AAEtB,UAAI,OAAO,YAAY;AACrB,mBAAW,OAAO,OAAO,KAAK,OAAO,UAAU,GAAG;AAChD,iBAAO,IAAI,GAAG;QAChB;MACF;AAEA,aAAO;IACT;AAVgB;AAAhB,IAAAA,SAAA,0BAAA;AAYA,aAAgB,yBACd,QACA,YAAe;AAEf,YAAM,WAAgB,CAAA;AAEtB,iBAAW,SAAS,QAAQ;AAC1B,YAAI,WAAW,eAAe,KAAK,GAAG;AACpC,mBAAS,KAAK,IAAI,WAAW,KAAK;QACpC;MACF;AAEA,aAAO;IACT;AAbgB;AAAhB,IAAAA,SAAA,2BAAA;AAsCA,aAAgB,6BAA0B;AACxC,YAAM,YAAY,4BAA4B,QAAQ,IAAI,eAAe,EAAE;AAE3E,UACE,QAAQ,IAAI,qBAAqB,UACjC,QAAQ,IAAI,qBAAqB,IACjC;AACA,eAAO;MACT;AAEA,YAAM,OAAO,KAAK,WAAW,QAAQ,IAAI,gBAAgB,IACrD,QAAQ,IAAI,mBACZ,KAAK,KAAK,QAAQ,IAAG,GAAI,QAAQ,IAAI,gBAAgB;AACzD,UAAI,EAAC,GAAA,KAAA,YAAW,IAAI,GAAG;AACrB,eAAO;MACT;AACA,YAAM,QAAO,GAAA,KAAA,cAAa,MAAM,OAAO;AAEvC,YAAM,gBAAgB,KAAK,QAAQ,IAAI;AACvC,YAAM,cAAc,MAAK;AACvB,gBAAQ,eAAe;UACrB,KAAK;UACL,KAAK;AACH,mBAAO,KAAK,MAAM,IAAI;UACxB,KAAK;AACH,mBAAO,KAAK,MAAM,IAAI;UACxB,KAAK;AACH,mBAAO,KAAK,MAAM,IAAI;UACxB;AACE,kBAAM,IAAI,MACR,+BAA+B,aAAa,mCAAmC;QAErF;MACF,GAAE;AACF,aAAO,EAAE,GAAG,YAAY,GAAG,UAAS;IACtC;AAnCgB;AAAhB,IAAAA,SAAA,6BAAA;AA2CA,aAAgB,uBAAuB,KAAW;AAChD,YAAM,SAAmB,CAAA;AAEzB,UAAI,EAAC,GAAA,KAAA,YAAW,GAAG,GAAG;AACpB,eAAO;MACT;AAEA,YAAM,SAAQ,GAAA,KAAA,aAAY,GAAG;AAC7B,iBAAW,QAAQ,OAAO;AACxB,YAAI,SAAS,kBAAkB,KAAK,SAAS,eAAe,GAAG;AAC7D,iBAAO,KAAK,KAAK,KAAK,KAAK,IAAI,CAAC;QAClC;MACF;AAEA,aAAO;IACT;AAfgB;AAAhB,IAAAA,SAAA,yBAAA;;;;;;;;;;;;;AC1IA,QAAA,SAAA;AAOA,QAAaC,SAAb,MAAkB;aAAA;;;;;;MAIT,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;MAEA,cAAA;MAAuB;;;;;MAMvB,IAAW,SAAM;AACf,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;MAQO,GAAG,OAAa;AACrB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,MAAM,OAAa;AACxB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;MAQO,OAAO,KAAU;AACtB;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;MAUO,SAAS,eAAiB;AAC/B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,UAAO;AACZ,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,QAAQ,eAAiB;AAC9B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,KAAK,WAAkB;AAC5B;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;MAUO,YAAY,eAAiB;AAClC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;MAWO,MAAM,OAAgB,KAAY;AACvC;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;AAjIF,IAAAC,SAAA,QAAAD;;;AAyIA,QAAa,WAAb,MAAqB;aAAA;;;;;;MAIZ,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;MAEA,cAAA;MAAuB;;;;;MAMvB,IAAW,SAAM;AACf,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;MAQO,GAAG,OAAa;AACrB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;MAQO,OAAO,KAAa;AACzB;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;MAUO,SAAS,eAAiB;AAC/B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,OAAI;AACT,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,QAAQ,eAAiB;AAC9B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,KAAK,WAAkB;AAC5B;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;MAUO,YAAY,eAAiB;AAClC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,QAAQ,QAAY;AACzB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;MAMO,MAAG;AACR,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;;MAWO,MAAM,OAAa;AACxB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;MAWO,IAAI,OAAe,OAAS;AACjC;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;MAWO,OAAO,OAAe,OAAS;AACpC;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,YAAY,OAAS;AAC1B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;MAWO,MAAM,OAAgB,KAAY;AACvC;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;AAjMF,IAAAC,SAAA,WAAA;;;;;;;;;;;;;;;;;ACrJA,QAAA,QAAA,gBAAA,aAAA;AAEA,QAAA,SAAA;AACA,QAAA,SAAA;AAQA,QAAa,aAAb,MAAa,YAAU;aAAA;;;;;;MAId,OAAO,gBAAgB,QAAY;AACxC,eAAO,OAAA,eAAe,QACpB,YACA,GAAG,KAAK,IAAI,sBAAsB,KAAK,UAAU,MAAM,CAAC,GAAG;MAE/D;;;;;;MAOO,OAAO,kBAAkB,QAAY;AAC1C,eAAO,IAAI,YAAW,MAAM;MAC9B;MAMA,YAAY,QAAY;AACtB,aAAK,aAAa;AAClB,aAAK,YAAY,IAAI,MAAA,QAAI,EAAE,WAAW,MAAM,iBAAiB,KAAI,CAAE;MACrE;;;;;;;MAQO,SAAS,KAAW,SAA+B;AACxD,YAAI,SAAS,QAAQ;AACnB;QACF;AACA,cAAM,YAAY,KAAK,UAAU,QAAQ,KAAK,UAAU;AACxD,cAAM,QAAQ,UAAU,GAAG;AAC3B,YAAI,CAAC,OAAO;AACV,gBAAM,WAAW,KAAK,WAAW,IAAI,QAAQ,KAAK,EAAE;AACpD,gBAAM,IAAI,MACR,mBAAmB,QAAQ;IAAQ,UAAU,QACzC,IACA,CAAC,UAAe,WAAW,MAAM,eAAe,MAAM,MAAM,OAAO,EAEpE,KAAK,MAAM,CAAC,EAAE;QAErB;MACF;;;;;;MAOO,QAAK;AACV,eAAO,KAAK,UAAU,KAAK,UAAU;MACvC;;MAGO,UAAU,KAAW,iBAAuC;AACjE,aAAK,SAAS,KAAK,eAAe;AAClC,cAAM,UAAS,GAAA,OAAA,yBAAwB,KAAK,UAAU;AAEtD,cAAM,sBAAqB,GAAA,OAAA,0BAAyB,QAAQ,GAAG;AAC/D,eAAO;MACT;;MAGO,aAAa,KAAS;AAC3B,YAAI;AACF,iBAAO,KAAK,UAAU,GAAG;QAC3B,QAAQ;AACN,iBAAO;QACT;MACF;;MAGO,cAAc,MAAwB;AAC3C,YAAI;AACF,iBAAO,KAAK,UAAU,KAAK,MAAM,IAAK,CAAC;QACzC,QAAQ;AACN,iBAAO;QACT;MACF;;MAGO,kBAAe;AACpB,eAAO,YAAW,gBAAgB,KAAK,UAAU;MACnD;;AA5FF,IAAAC,SAAA,aAAA;;;;;;;;;;;;;;ACVA,QAAA,gBAAA;AACA,QAAA,SAAA;AAMA,QAAaC,WAAb,MAAoB;aAAA;;;;;;;;;MAOX,OAAO,SAAS,MAAY,SAA+B;AAChE,cAAM,SAAS,cAAA,WAAW,kBAAkB;UAC1C,KAAK;UACL,MAAM;SACA;AACR,eAAO,SAAS,MAAM,OAAO;AAC7B,eAAO;MACT;;;;MAKO,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;MAEA,cAAA;MAAuB;;AAvBzB,IAAAC,SAAA,UAAAD;;;;;;;;;;;;;;ACRA,QAAA,eAAA;AACA,QAAA,WAAA;AACA,QAAA,WAAA;AAYa,IAAAE,SAAA,4BAA4B;AAOzC,QAAM,iCAAiC;AAKvC,QAAM,+BAA+B;AASrC,aAAgB,qBACd,MACA,YACA,MAAY;AAEZ,UACE,OAAO,MAAM,oBAAoB,cACjC,MAAM,aAAa,SAAS,UAC5B;AACA,eAAO;MACT,OAAO;AACL,eAAO;UACL,iBAAiB,MAAM,YAAY,UAAU,MAAM,IAAI;;MAE3D;IACF;AAfgB;AAAhB,IAAAA,SAAA,uBAAA;AAiBA,aAAgB,WAAW,KAAQ;AAEjC,UAAI,OAAO,MAAM;AACf,eAAO,KAAK,UAAU,GAAG;MAC3B;AAEA,YAAM,iBAAgB,GAAA,SAAA,kBAAiB,GAAG;AAC1C,UAAI,eAAe;AACjB,eAAO,cAAc,KAAK,GAAG;MAC/B;AAIA,UAAI,OAAO,KAAK,oBAAoB,YAAY;AAC9C,eAAO,IAAI,gBAAe;MAC5B;AAEA,cAAQ,OAAO,KAAK;QAClB,KAAK;QACL,KAAK;QACL,KAAK;AACH,iBAAO,KAAK,UAAU,GAAG;QAE3B,KAAK;AACH,cAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,mBAAO,IAAI,IAAI,IAAI,CAAC,MAAM,WAAW,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC;UACpD;AAEA,cAAI,eAAe,KAAK;AACtB,mBAAO,WAAW,WAAW,MAAM,KAAK,GAAG,CAAC,CAAC;UAC/C;AAEA,cAAI,eAAe,KAAK;AACtB,mBAAO,WAAW,WAAW,MAAM,KAAK,GAAG,CAAC,CAAC;UAC/C;AAIA,cAAI,OAAQ,IAAkB,gBAAgB,YAAY;AACxD,mBAAQ,IAAkB,YAAW;UACvC;AAGA,cAAI,IAAI,YAAY,SAAS,UAAU;AACrC,kBAAM,QAAQ,CAAA;AACd,kBAAM,KAAK,GAAG;AACd,uBAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,GAAG,GAAG;AACxC,oBAAM,KAAK,IAAK,EAAE,QAAQ,MAAM,KAAK,CAAC,MAAO,WAAW,CAAC,CAAC,GAAG;YAC/D;AACA,kBAAM,KAAK,GAAG;AACd,mBAAO,MAAM,KAAK,EAAE;UACtB;AAEA;MACJ;AAEA,YAAM,IAAI,MAAM,iCAAiC,KAAK,aAAa,IAAI,EAAE;IAC3E;AAzDgB;AAAhB,IAAAA,SAAA,aAAA;AAmEA,aAAgB,cACd,UAA6B,CAAA,GAC7B,UAA6B,CAAA,GAAE;AAE/B,YAAM,SAA4B,CAAA;AAClC,iBAAW,CAAC,IAAI,IAAI,KAAK,OAAO,QAAQ,OAAO,GAAG;AAChD,eAAO,EAAE,IAAI,oBAAI,IAAG;AACpB,mBAAW,CAAC,KAAK,OAAO,KAAK,MAAM;AACjC,iBAAO,EAAE,EAAE,IAAI,KAAK,IAAI,IAAI,OAAO,CAAC;QACtC;MACF;AAEA,iBAAW,CAAC,IAAI,IAAI,KAAK,OAAO,QAAQ,OAAO,GAAG;AAChD,cAAM,aAAa,OAAO,EAAE,KAAK,oBAAI,IAAG;AACxC,mBAAW,CAAC,KAAK,OAAO,KAAK,MAAM;AACjC,gBAAM,gBAAgB,WAAW,IAAI,GAAG,KAAK,oBAAI,IAAG;AACpD,qBAAW,OAAO,SAAS;AACzB,0BAAc,IAAI,GAAG;UACvB;AACA,qBAAW,IAAI,KAAK,aAAa;QACnC;AACA,eAAO,EAAE,IAAI;MACf;AAEA,aAAO;IACT;AAzBgB;AAAhB,IAAAA,SAAA,gBAAA;AA6CA,aAAS,YAAY,MAAa;AAChC,YAAM,SAA4B,CAAA;AAClC,iBAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,IAAI,GAAG;AAC9C,eAAO,EAAE,IAAI,oBAAI,IAAG;AACpB,mBAAW,CAAC,KAAK,OAAO,KAAK,OAAO;AAClC,cAAI,CAAC,OAAO,EAAE,EAAE,IAAI,GAAG,GAAG;AACxB,mBAAO,EAAE,EAAE,IAAI,KAAK,oBAAI,IAAG,CAAE;UAC/B;AACA,gBAAM,SAAS,OAAO,EAAE,EAAE,IAAI,GAAG;AACjC,qBAAW,OAAO,SAAS;AACzB,mBAAO,IAAI,GAAG;UAChB;QACF;MACF;AACA,aAAO;IACT;AAfS;AAqDT,aAAgB,aACd,YACA,YAAyB;AAEzB,UAAI,WAAW,SAASA,SAAA,yBAAyB,GAAG;AAClD,cAAM,IAAI,MACR,iBAAiBA,SAAA,yBAAyB,sDAAsD;MAEpG;AAEA,YAAM,WAAW,oBAAI,IAAG;AACxB,YAAM,QAAQ,IAAI,MAA4B,CAAC,YAAY,CAAC,GAAG,UAAU,CAAC,CAAC;AAC3E,YAAM,cAAc,oBAAI,IAAG;AAE3B,aAAO,MAAM,SAAS,GAAG;AAEvB,YAAI,CAAC,KAAK,GAAG,IAA0B,MAAM,MAAK;AAElD,YAAI,SAAS;AACb,YAAI,CAAC,SAAS,IAAI,GAAG,GAAG;AACtB,mBAAS,IAAI,KAAK,oBAAI,IAAG,CAAE;AAC3B,mBAAS;QACX;AAEA,YAAI,cAAc,SAAS,IAAI,GAAG;AAGlC,cAAM,IAAI,OAAO,CAAC,OAAO,CAAC,YAAY,IAAI,EAAE,CAAC;AAG7C,YAAI,IAAI,WAAW,KAAK,CAAC,QAAQ;AAC/B;QACF;AAGA,mBAAW,MAAM,KAAK;AACpB,sBAAY,IAAI,EAAE;QACpB;AAOA,YAAI;AACJ,YAAI,YAAY,IAAI,GAAG,GAAG;AACxB,mBAAS,YAAY,IAAI,GAAG;QAC9B,WAAW,OAAO,QAAQ,YAAY,IAAI,aAAa,QAAW;AAChE,mBAAS,YAAY,IAAI,YAAY,CAAA,CAAE;AACvC,sBAAY,IAAI,KAAK,MAAM;QAC7B,WACE,OAAO,QAAQ,cACf,OAAO,IAAI,iBAAiB,QAC5B;AACA,mBAAS,YAAY,IAAI,gBAAgB,CAAA,CAAE;AAC3C,sBAAY,IAAI,KAAK,MAAM;QAC7B,OAAO;AAYL,cAAI,mBAAkC,CAAA;AACtC,cAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,+BAAmB;UACrB,WAAW,eAAe,KAAK;AAC7B,+BAAmB;UACrB,WAAW,eAAe,KAAK;AAC7B,+BAAmB,IAAI,OAAM;UAC/B,WAAW,OAAO,QAAQ,YAAY,IAAI,YAAY,SAAS,UAAU;AACvE,+BAAmB,OAAO,OAAO,GAAG;UACtC;AAEA,qBAAW,QAAQ,kBAAkB;AACnC,gBAAI,CAAC,SAAS,IAAI,IAAI,GAAG;AACvB,kBAAI,WAAqB,CAAA;AAEzB,kBAAI,wBAAwB,IAAI,GAAG;AACjC,yBAAS,KAAK,8BAA8B;cAC9C;AACA,oBAAM,KAAK,CAAC,MAAM,QAAQ,CAAC;YAC7B;UACF;AACA;QACF;AAEA,mBAAW,MAAM,CAAC,GAAG,KAAKA,SAAA,yBAAyB,GAAG;AACpD,gBAAM,UAAU,OAAO,EAAE;AAIzB,cAAI,OAAOA,SAAA,6BAA6B,CAAC,SAAS;AAChD;UACF;AAEA,cAAI,CAAC,SAAS;AACZ,gBAAI,aAAA,UAAU,YAAY,GAAG,GAAG;AAC9B,oBAAM,IAAI,SAAA,oBACR,YAAY,IAAI,KAAK,IAAI,wCAAwC,EAAE;mCACnE,EAAE,UAAU,IAAI,YAAY,MAAM,WAAW,GAAE,CAAE;YAErD,OAAO;AACL,oBAAM,IAAI,MACR,qBAAqB,EAAE,yBAAyB,GAAG,KAAK,IAAI,YAAY,IAAI,GAAG;YAEnF;UACF;AAEA,qBAAW,CAAC,QAAQ,MAAM,KAAK,QAAQ,QAAO,GAAI;AAChD,gBAAI,OAAO,IAAIA,SAAA,yBAAyB,GAAG;AACzC,oBAAM,IAAI,MACR,iBAAiBA,SAAA,yBAAyB,sDAAsD;YAEpG;AACA,kBAAM,KAAK,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,CAAC;UAClC;QACF;MACF;AAEA,aAAO;IACT;AA9HgB;AAAhB,IAAAA,SAAA,eAAA;AAmIA,aAAS,wBAAwB,MAAS;AACxC,aACE,OAAO,SAAS,YAChB,OAAO,KAAK,gBAAgB,cAC5B,OAAO,KAAK,YAAY,SAAS,YACjC,KAAK,YAAY,KAAK,WAAW,4BAA4B,KAC7D,KAAK,aAAa,UAClB,KAAK,SAAS,8BAA8B,MAAM;IAEtD;AATS;AAqCT,QAAa,UAAb,MAAoB;aAAA;;;;;;;;;;MAQX,OAAO,KACZ,KACA,MACA,KAAkB;AAGlB,cAAM,QAAQ,aAAa,KAAK,GAAG;AAGnC,mBAAW,CAAC,WAAW,SAAS,KAAK,OAAO;AAC1C,gBAAM,UAAS,GAAA,SAAA,kBAAiB,SAAS;AACzC,cAAI,QAAQ;AACV,mBAAO,YAAY,MAAM,SAAS;AAClC;UACF;AAEA,cACE,OAAO,cAAc,YACrB,OAAO,UAAU,WAAW,YAC5B;AACA,sBAAU,OAAO,MAAM,CAAC,GAAG,SAAS,CAAC;AACrC;UACF;AAEA,cACE,OAAO,cAAc,cACrB,OAAO,UAAU,eAAe,YAChC;AACA,sBAAU,WAAW,MAAM,CAAC,GAAG,SAAS,CAAC;AACzC;UACF;QAIF;MACF;;AA3CF,IAAAA,SAAA,UAAA;;;;;;;;;;;;AC5XA,QAAA,eAAA;AAAS,WAAA,eAAAC,UAAA,aAAA,EAAA,YAAA,MAAA,KAAA,WAAA;AAAA,aAAA,aAAA;IAAS,EAAA,CAAA;AAGL,IAAAA,SAAA,kBAAiC,OAAO,wBAAwB;AAMhE,IAAAA,SAAA,gBAAgB,OAAO,4BAA4B;;;;;;;;;;ACdhE,QAAA,kBAAA,QAAA,eAAA;AACA,QAAA,OAAA,QAAA,IAAA;AACA,QAAA,SAAA,QAAA,MAAA;AAEA,QAAM,eAAc,GAAA,OAAA,WAAU,gBAAA,IAAI;AAClC,QAAM,mBAAkB,GAAA,OAAA,WAAU,gBAAA,QAAQ;AAE1C,aAAgB,aAAa,MAAY;AACvC,aAAO,KAAK,OAAM,GAAA,KAAA,cAAa,MAAM,OAAO,CAAC;IAC/C;AAFgB;AAAhB,IAAAC,SAAA,eAAA;AAOA,aAAgB,WAAW,MAAY;AACrC,UAAI,QAAQ,aAAa,SAAS;AAChC,eACE,KAEG,QAAQ,QAAQ,GAAG;MAE1B,OAAO;AACL,eAAO;MACT;IACF;AAVgB;AAAhB,IAAAA,SAAA,aAAA;AAeO,mBAAe,WACpB,KACA,MACA,SAAyB;AAEzB,YAAM,EAAE,OAAM,IAAK,MAAM,gBAAgB,KAAK,MAAM,OAAO;AAC3D,aAAO;IACT;AAPsB;AAAtB,IAAAA,SAAA,aAAA;AAaO,mBAAe,MACpB,KACA,MACA,SAAqB;AAErB,YAAM,EAAE,OAAM,IAAK,MAAM,YAAY,MAAM,MAAM,KAAK,KAAK,GAAG,GAAG,OAAO;AACxE,aAAO;IACT;AAPsB;AAAtB,IAAAA,SAAA,QAAA;AASA,aAAgB,OAAO,GAAS;AAC9B,UAAI,WAAW,CAAC;AAChB,aAAO,EAAE,WAAW,IAAI,KAAK,EAAE,WAAW,KAAK,KAAK,EAAE,WAAW,GAAG;IACtE;AAHgB;AAAhB,IAAAA,SAAA,SAAA;;;;;;;;;;;;ACnDA,QAAA,SAAA,QAAA,MAAA;AACA,QAAA,YAAA;AACA,QAAA,UAAA;AAOA,QAAA,SAAA;AAGA,QAAI,eAAe;AAEnB,aAAgB,YAAS;AACvB,aAAO;IACT;AAFgB;AAAhB,IAAAC,SAAA,YAAA;AAwBA,QAAa,iBAAb,MAA2B;aAAA;;;;;;MAIlB,OAAO,IACZ,SACA,UACA,aACA,MAAc;AAEd,cAAM,cAAc;AACpB,cAAM,gBAAe,GAAA,OAAA,UAAS,QAAQ,EAAE,MAAM,GAAG,EAAE,CAAC,IAAI;AACxD,eAAO,kBAAiB,GAAA,OAAA,YACtB,GAAG,WAAW,IAAI,YAAY,EAAE,CACjC,OAAO,WAAW,IAAI,KAAK,KAAK,IAAI,CAAC;MACxC;;;;MAKO,OAAO,QAAQ,UAAkB,aAAmB;AACzD,eAAO,aAAY,GAAA,OAAA,YAAW,QAAQ,CAAC,MAAM,WAAW;MAC1D;MAEA,cAAA;MAAuB;;AAxBzB,IAAAA,SAAA,iBAAA;;;AAmDA,aAAgB,KACd,UAAiB;AAEjB,aAAO,IAAI,OAAM,EAAG,KAAK,QAAQ;IACnC;AAJgB;AAAhB,IAAAA,SAAA,OAAA;AAeA,aAAgB,SACd,IAAsE;AAEtE,aAAO,IAAI,OAAM,EAAG,SAAS,EAAE;IACjC;AAJgB;AAAhB,IAAAA,SAAA,WAAA;AASA,aAAgB,eAId,cAKA,OAAsC;AAEtC,YAAM,WAAgC,CAAA;AACtC,YAAM,YAAsC,CAAA;AAG5C,iBAAW,kBAAkB,SAAS,CAAA,GAAI;AACxC,YAAI,eAAe,UAAU,QAAW;AACtC,gBAAM,IAAI,MAAM,2CAA2C;QAC7D;AAEA,iBAAS,eAAe,KAAK,IAAI,eAAe;AAChD,YAAI,eAAe,KAAK;AACtB,oBAAU,eAAe,KAAK,IAAI,eAAe;QACnD;MACF;AAEA,aACE,KAAK,QAAQ,EACV,MAAM,SAAS,EAEf,SAAS,YAAmB;IAEnC;AAhCgB;AAAhB,IAAAA,SAAA,iBAAA;AAqCA,QAAM,SAAN,MAAM,QAAM;aAAA;;;MAIV,YACU,QAAwB,CAAA,GACxB,SAAmC,CAAA,GAAE;AADrC,aAAA,QAAA;AACA,aAAA,SAAA;MACP;;;;;;;;;;;;;;;;;;;;;;;;;;MA2BI,KAAuC,UAAmB;AAC/D,eAAO,IAAI,QAIT;UACE,GAAG,KAAK;UACR,GAAG;WAEL,KAAK,MAAM;MAEf;;;;;;;;;;;;;;;;;;;;MAqBO,MAIL,QAAe;AACf,eAAO,IAAI,QACT,KAAK,OACL;UACE,GAAG,KAAK;UACR,GAAG;SACJ;MAEL;;;;;;;;;;;MAYO,SACL,IAW0B;AAO1B,cAAM,WAAoB,EAAE,QAAQ,CAAA,EAAE;AACtC,mBAAW,CAAC,KAAK,GAAG,KAAK,OAAO,QAAQ,KAAK,KAAK,GAAG;AACnD,gBAAM,WACJ,KAAK,OAAO,GAAG,KACf,OAAO,KAAM,IAAwB,YAAY,CAAA,CAAE,EAAE;YACnD,CAAC,MAAM,MAAM,UAAA;;;AAGjB,mBAAS,OAAO,KAAK,CAAC,KAAK,QAAQ,CAAC;QACtC;AAEA,eAAO;UACL,KAAK,UAAS;UACd,aAAa,MAAK;AAEhB,kBAAM,qBAAqB,GAAG,SAAQ;AAEtC,mBAAO;kBAEG,kBAAkB;;IAEhC,OAAO,QAAQ,KAAK,KAAK,EACxB,IAAI,CAAC,CAAC,MAAM,QAAQ,MAAM,GAAG,IAAI,MAAK,GAAA,UAAA,YAAW,QAAQ,CAAC,EAAE,EAC5D,KAAK,KAAK,CAAC;;;;;;;;;UASV;UACA;;UAEA,CAAC,QAAA,eAAe,GAAG,MAAK;AACtB,kBAAM,IAAI,MACR,oEAAoE;UAExE;;MAEJ;;;;;;;;;;;;;AC3SF,QAAA,aAAA;AACA,QAAA,SAAA;AA4CA,QAAa,WAAb,MAAa,UAAQ;aAAA;;;;;;MAIZ,OAAO,kBAAe;AAC3B,eAAO,WAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;;;;;;MAMO,OAAO,SAAM;AAClB,eAAO,IAAI,UAAQ;MACrB;;;;;;MAOO,OAAO,YAAS;AACrB,cAAM,OAAO,oBAAI,KAAI;AACrB,aAAK,QAAQ,KAAK,QAAO,IAAK,KAAK,kBAAiB,IAAK,KAAK,GAAI;AAElE,eAAO,IAAI,UAAS,MAAM,KAAK,kBAAiB,CAAE;MACpD;;;;;;;MAQO,OAAO,QAAQ,KAAW;AAC/B,eAAO,IAAI,UAAS,IAAI,KAAK,GAAG,CAAC;MACnC;;;;;;;MAQO,OAAO,SAAS,MAAU;AAC/B,eAAO,KAAK,QAAQ,KAAK,YAAW,CAAE;MACxC;;;;;;;MAQO,OAAO,eAAe,GAAqB;AAChD,cAAM,OAAO,IAAI,KACf,KAAK,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,CAAC;AAG9D,eAAO,IAAI,UAAS,MAAM,EAAE,EAAE;MAChC;MAOA,YAAoB,OAAa,oBAAI,KAAI,GAAI,iBAAiB,GAAC;AAF9C,aAAA,kBAA0B;AAGzC,aAAK,QAAQ;AACb,aAAK,kBAAkB;MACzB;;MAGO,cAAW;AAChB,eAAO,cAAa,GAAA,OAAA,YAClB,UAAU,CACX,wBAAwB,KAAK,MAAK,CAAE;MACvC;;;;;;MAOA,IAAW,YAAS;AAClB,eAAO,KAAK,cAAc;MAC5B;;;;;;MAOA,IAAW,cAAW;AAKpB,eAAO,KAAK,MAAM,QAAO,IAAK,KAAK,kBAAkB,KAAK;MAC5D;;;;;;MAOA,IAAW,QAAK;AACd,eAAO,KAAK,MAAM,YAAW;MAC/B;;;;;;MAOA,IAAW,MAAG;AACZ,eAAO,KAAK,MAAM,cAAa;MACjC;;;;;;MAOA,IAAW,MAAG;AACZ,eAAO,KAAK,MAAM,cAAa;MACjC;;;;;;MAOA,IAAW,KAAE;AACX,eAAO,KAAK,MAAM,mBAAkB;MACtC;;;;;;MAOA,IAAW,aAAU;AACnB,eAAO,KAAK,MAAM,WAAU;MAC9B;;;;;;MAOA,IAAW,YAAS;AAClB,eAAO,KAAK,MAAM,UAAS;MAC7B;;;;;;MAOA,IAAW,QAAK;AACd,eAAO,KAAK,MAAM,YAAW;MAC/B;;;;;;MAOA,IAAW,OAAI;AACb,eAAO,KAAK,MAAM,eAAc;MAClC;;;;;;MAOA,IAAW,WAAQ;AACjB,eAAO,KAAK;MACd;;;;;;MAOO,QAAK;AACV,eAAO,IAAI,UAAS,IAAI,KAAK,KAAK,WAAW,CAAC;MAChD;;;;;;MAOO,QAAK;AACV,eAAO,IAAI,KAAK,KAAK,WAAW,EAAE,YAAW;MAC/C;;AAtMF,IAAAC,SAAA,WAAA;;;;;;;;;;;;;;AC7CA,QAAA,SAAA;AACA,QAAA,SAAA;AAMA,QAAa,WAAb,MAAa,UAAQ;aAAA;;;;;;MAIZ,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;;;;;;;MAQO,OAAO,UAAU,QAAc;AACpC,eAAO,IAAI,UAAS,SAAS,KAAK,KAAK,KAAK,GAAG;MACjD;;;;;;;MAQO,OAAO,WAAW,QAAc;AACrC,eAAO,IAAI,UAAU,SAAS,KAAK,KAAK,KAAK,MAAO,EAAE;MACxD;;;;;;;MAQO,OAAO,SAAS,QAAc;AACnC,eAAO,IAAI,UAAS,SAAS,KAAK,KAAK,EAAE;MAC3C;;;;;;;MAQO,OAAO,UAAU,QAAc;AACpC,eAAO,IAAI,UAAS,SAAS,KAAK,EAAE;MACtC;;;;;;;MAQO,OAAO,YAAY,QAAc;AACtC,eAAO,IAAI,UAAS,SAAS,EAAE;MACjC;;;;;;;MAQO,OAAO,YAAY,QAAc;AACtC,eAAO,IAAI,UAAS,MAAM;MAC5B;;;;;;;MAQO,OAAO,iBAAiB,QAAc;AAC3C,eAAO,IAAI,UAAS,SAAS,GAAI;MACnC;MASA,YAAoB,SAAe;AACjC,aAAK,UAAU;MACjB;;;;;;MAOA,IAAW,eAAY;AACrB,eAAO,KAAK,UAAU;MACxB;;;;;;MAOA,IAAW,UAAO;AAChB,eAAO,KAAK,UAAU;MACxB;;;;;;MAOA,IAAW,QAAK;AACd,eAAO,KAAK,UAAU;MACxB;;;;;;MAOA,IAAW,OAAI;AACb,eAAO,KAAK,QAAQ;MACtB;;;;;;MAOA,IAAW,SAAM;AACf,eAAO,KAAK,QAAQ;MACtB;;;;;;MAOA,IAAW,QAAK;AACd,eAAO,KAAK,OAAO;MACrB;;MAGO,cAAW;AAChB,eAAO,mBAAkB,GAAA,OAAA,YAAW,UAAU,CAAC,gBAC7C,KAAK,OACP;MACF;;AApJF,IAAAC,SAAA,WAAA;;;;;;;;;;;;;;ACDA,QAAa,KAAb,MAAe;aAAA;;;;AAAf,IAAAC,SAAA,KAAA;;;;;;;;;;;;;;;ACPA,QAAA,SAAA;AA+BA,QAAa,OAAb,MAAiB;aAAA;;;;;;MAIR,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;;;;;;;;;MAUO,OAAO,KAAK,MAAoB;AACrC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,OAAO,MAAU;AAC7B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;MAQO,OAAO,QAAQ,MAAU;AAC9B,eAAO,OAAO,QAAQ,IAAI,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,OAAO,EAAE,KAAK,MAAK,EAAG;MACpE;;;;;;;;;MAUO,OAAO,OAAO,MAAe,KAAW;AAC7C;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,UACZ,MACA,SAA8B;AAE9B;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,SAAS,MAAa;AAClC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,YAAY,MAAU;AAClC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,MAAM,KAAW;AAC7B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,SAAS,KAAY;AACjC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;MACA,cAAA;MAAuB;;;;;;;;;MAShB,IAAI,KAAW;AACpB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;MAWO,IAAI,KAAW;AACpB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;MAWO,MAAM,OAAa;AACxB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,KAAW;AACvB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,SAAS,OAAa;AAC3B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,QAAK;AACV,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,WAAQ;AACb,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,QAAK;AACV,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,WAAQ;AACb,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,SAAM;AACX,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,YAAS;AACd,cAAM,IAAI,MAAM,OAAO;MACzB;;AAlQF,IAAAC,SAAA,OAAA;;;AAwQA,QAAa,UAAb,MAAoB;aAAA;;;;;;MAIX,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;MAEA,cAAA;MAAuB;;;;;;;;;;MAWhB,IAAI,KAAW;AACpB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;MAWO,MAAM,OAAa;AACxB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,IAAI,KAAa,OAAc;AACpC;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,MAAM,OAAe,OAAc;AACxC;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,KAAW;AACvB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,SAAS,OAAa;AAC3B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,QAAK;AACV,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,WAAQ;AACb,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,QAAK;AACV,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,WAAQ;AACb,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,SAAM;AACX,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,YAAS;AACd,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAWO,OAAO,KAAW;AACvB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,IAAI,KAAW;AACpB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;AAtLF,IAAAA,SAAA,UAAA;;;;;;;;;;;;;;;ACjSA,QAAA,SAAA;AAmBA,QAAaC,OAAb,MAAgB;aAAA;;;;;;MAIP,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;MAEA,cAAA;MAAuB;;;;;;;;;MAUhB,OAAI;AACT,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;;;MAaO,IAAI,KAAW;AACpB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,KAAW;AACvB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,IAAI,KAAW;AACpB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,UAAO;AACZ,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,OAAI;AACT,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,SAAM;AACX,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,UAAO;AACZ,cAAM,IAAI,MAAM,OAAO;MACzB;;AA1GF,IAAAC,SAAA,MAAAD;;;AAkHA,QAAa,SAAb,MAAmB;aAAA;;;;;;MAIV,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;MAEA,cAAA;MAAuB;;;;;;;;;MAUhB,OAAI;AACT,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;MAOO,QAAK;AACV,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,OAAI;AACT,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,KAAW;AACvB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;;;MAaO,IAAI,KAAW;AACpB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,OAAO,KAAW;AACvB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,IAAI,KAAW;AACpB;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;;MAWO,IAAI,KAAa,OAAS;AAC/B;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,OAAI;AACT,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,SAAM;AACX,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,UAAO;AACZ,cAAM,IAAI,MAAM,OAAO;MACzB;;AA/IF,IAAAC,SAAA,SAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3IA,QAAA,KAAA,aAAA,QAAA,IAAA,CAAA;AACA,QAAA,OAAA,aAAA,QAAA,MAAA,CAAA;AAGA,QAAM,qBAAqB,OAAO,IAAI,gCAAgC;AAEzD,IAAAC,SAAA,wBAAwB;AAKrC,QAAa,cAAb,MAAa,aAAW;aAAA;;;;;;MAIf,OAAO,GAAG,WAAqB;AACpC,YAAI,cAAe,UAAU,KAAK,KAAa,kBAAkB;AAEjE,YAAI,CAAC,aAAa;AAChB,wBAAc,IAAI,aAAW;AAC5B,oBAAU,KAAK,KAAa,kBAAkB,IAAI;QACrD;AAEA,eAAO;MACT;MAGA,cAAA;AADiB,aAAA,eAA6B,CAAA;MACvB;;;;;MAMhB,IAAI,OAAyB;AAClC,cAAM,aAAa;AAGnB,YACE,KAAK,aAAa,KAChB,CAAC,MACC,EAAE,WAAW,WAAW,UACxB,EAAE,aAAa,WAAW,YAC1B,EAAE,WAAW,WAAW,UACxB,EAAE,aAAa,WAAW,YAC1B,EAAE,SAAS,WAAW,IAAI,GAE9B;AACA;QACF;AAEA,aAAK,aAAa,KAAK,UAAU;MACnC;;;;MAKO,MAAM,QAAc;AACzB,cAAM,cAAc,KAAK,aAAa,IAAI,CAAC,OAAO;UAChD,QAAQ,EAAE,OAAO,KAAK;UACtB,UAAU,EAAE;UACZ,QAAQ,EAAE,OAAO,KAAK;UACtB,UAAU,EAAE;UACZ,MAAM,EAAE;UACR;AAEF,cAAM,OAAO;UACX,SAAS;UACT;;AAGF,WAAG,cACD,KAAK,KAAK,QAAQA,SAAA,qBAAqB,GACvC,KAAK,UAAU,MAAM,QAAW,CAAC,GACjC,EAAE,UAAU,OAAM,CAAE;MAExB;;AAhEF,IAAAA,SAAA,cAAA;;;;;;;;;;;;;;ACXA,QAAA,eAAA;AAQA,QAAA,gBAAA;AAGA,QAAM,cAAc,OAAO,IAAI,wBAAwB;AAC1C,IAAAC,SAAA,aAAa,OAAO,IAAI,4BAA4B;AACjE,QAAM,cAAc,OAAO,IAAI,6BAA6B;AAE/C,IAAAA,SAAA,wBAAwB;AACxB,IAAAA,SAAA,oBAAoB;AAKjC,QAAa,OAAb,MAAa,MAAI;aAAA;;;;;;;;MAMR,OAAO,UAAU,iBAAoB;AAC1C,wBAAgB,WAAW,IAAI;MACjC;;;;MAKO,OAAO,GAAG,WAAqB;AACpC,YAAI,OAAQ,UAAkB,WAAW;AAEzC,YAAI,CAAC,MAAM;AACT,iBAAO,IAAI,MAAK,SAAS;AACxB,oBAAkB,WAAW,IAAI;QACpC;AAEA,eAAO;MACT;MA6DA,YAAqC,WAAqB;AAArB,aAAA,YAAA;AACnC,aAAK,kBAAkB,UAAU;AACjC,aAAK,eAAe,cAAA,YAAY,GAAG,SAAS;MAC9C;;;;;MAMO,cAAc,OAAyB;AAC5C,aAAK,aAAa,IAAI;UACpB,QAAQ,MAAM,UAAU,KAAK;UAC7B,GAAG;SACJ;MACH;;;;;;;;MAUA,IAAW,QAAK;AACd,eAAO,KAAK,gBAAgB;MAC9B;;;;;;MAOA,IAAW,KAAE;AACX,eAAO,KAAK,gBAAgB;MAC9B;;;;;;MAOA,IAAW,OAAI;AACb,eAAO,KAAK,gBAAgB;MAC9B;;;;;;;;;;;;;;;;MAiBA,IAAW,OAAI;AACb,eAAO,KAAK,gBAAgB;MAC9B;;;;;;;MAQO,aAAa,IAAU;AAC5B,eAAO,KAAK,gBAAgB,aAAa,EAAE;MAC7C;;;;;;;;;MAUO,UAAU,IAAU;AACzB,eAAO,KAAK,gBAAgB,UAAU,EAAE;MAC1C;;;;;;;;;MAUA,IAAW,eAAY;AACrB,eAAO,KAAK,gBAAgB;MAC9B;;;;;;;;;;;MAYA,IAAW,aAAa,OAA6B;AACnD,aAAK,gBAAgB,eAAe;MACtC;;;;MAKA,IAAW,WAAQ;AACjB,eAAO,KAAK,gBAAgB;MAC9B;;;;MAKO,QACL,QAAwB,aAAA,eAAe,UAAQ;AAE/C,eAAO,KAAK,gBAAgB,QAAQ,KAAK;MAC3C;;;;;;;;MASO,WAAW,KAAa,OAAU;AACvC,aAAK,gBAAgB,WAAW,KAAK,KAAK;MAC5C;;;;;;;;;MAUO,WAAW,KAAW;AAC3B,eAAO,KAAK,gBAAgB,WAAW,GAAG;MAC5C;;;;;;;;;MAUO,cAAc,KAAW;AAC9B,eAAO,KAAK,gBAAgB,cAAc,GAAG;MAC/C;;;;;MAMA,IAAW,WAAQ;AACjB,eAAO,KAAK,gBAAgB;MAC9B;;;;;;;;;;;MAYO,YACL,MACA,MACA,UAA2B,CAAA,GAAE;AAE7B,aAAK,gBAAgB,YAAY,MAAM,MAAM,OAAO;MACtD;;;;;;;;MASA,IAAW,SAAM;AACf,eAAO,KAAK,gBAAgB;MAC9B;;;;;;;;MASA,IAAW,OAAI;AACb,YAAI,CAAC,KAAK,OAAO;AACf,eAAK,QAAQ,KAAK,SAAS,KAAK,SAAS;QAC3C;AAEA,eAAO,KAAK;MACd;;;;;;;;MASA,IAAW,MAAG;AACZ,YAAI,CAAC,KAAK,MAAM;AACd,eAAK,OAAO,KAAK,QAAQ,KAAK,SAAS;QACzC;AAEA,eAAO,KAAK;MACd;;;;;MAMA,IAAW,SAAM;AACf,eAAO,KAAK,gBAAgB;MAC9B;;;;;;MAOO,iBAAiB,MAAmB;AACzC,aAAK,gBAAgB,cAAc,GAAG,IAAI;MAC5C;;;;MAKA,IAAW,eAAY;AACrB,eAAO,KAAK,gBAAgB;MAC9B;;;;;;;MAQO,eAAe,WAAiB;AACrC,eAAO,KAAK,gBAAgB,eAAe,SAAS;MACtD;;;;;;;;;MAUO,cAAc,YAAuB;AAC1C,aAAK,gBAAgB,cAAc,UAAU;MAC/C;;;;;;;;;;MAWO,WAAQ;AACb,eAAO,KAAK,gBAAgB,SAAQ;MACtC;;;;;MAMO,OAAI;AACT,aAAK,gBAAgB,KAAI;MAC3B;;;;MAKQ,QAAQ,OAAiB;AAC/B,YAAI,MAAM,KAAK,GAAG;AAChB,iBAAO;QACT;AAEA,YAAI,CAAC,MAAM,KAAK,OAAO;AACrB,gBAAM,IAAI,MAAM,sBAAsB;QACxC;AAEA,eAAO,KAAK,QAAQ,MAAM,KAAK,KAAK;MACtC;MAEQ,SAAS,OAAiB;AAChC,YAAI,OAAO,KAAK,GAAG;AACjB,iBAAO;QACT;AAEA,YAAI,CAAC,MAAM,KAAK,OAAO;AACrB,gBAAM,IAAI,MAAM,4BAA4B;QAC9C;AAEA,eAAO,KAAK,SAAS,MAAM,KAAK,KAAK;MACvC;;AAtZF,IAAAA,SAAA,OAAA;;;AAoeA,aAAS,MAAM,GAAM;AACnB,aAAO,KAAK,EAAEA,SAAA,UAAU;IAC1B;AAFS;AAIT,aAAS,OAAO,GAAM;AACpB,aAAO,KAAK,EAAE,eAAe,EAAE,YAAY,WAAW;IACxD;AAFS;;;;;;;;;;;;AC5fT,QAAA,gBAAA;AACA,QAAA,SAAA;AAMA,QAAaC,UAAb,MAAmB;aAAA;;;;;;;;;MAOV,OAAO,SAAS,MAAY,SAA+B;AAChE,cAAM,SAAS,cAAA,WAAW,kBAAkB;UAC1C,KAAK;UACL,MAAM;SACA;AACR,eAAO,SAAS,MAAM,OAAO;AAC7B,eAAO;MACT;;;;;;;;;MAUO,OAAO,QAAQ,KAAW;AAC/B;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;MAKO,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;MAEA,cAAA;MAAuB;;AApCzB,IAAAC,SAAA,SAAAD;;;;;;;;;;;;;;ACPA,QAAA,SAAA;AACA,QAAA,SAAA;AAMA,QAAa,QAAb,MAAa,OAAK;aAAA;;;;;;MAIT,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;;;;;;MAOO,OAAO,QAAQ,SAAe;AACnC,eAAO,IAAI,OAAM,OAAO;MAC1B;;;;;MASA,YAAoB,SAAe;AACjC,aAAK,SAAS,IAAI,OAAO,OAAO;MAClC;;MAGO,cAAW;AAChB,eAAO,mBAAkB,GAAA,OAAA,YAAW,UAAU,CAAC,aAAa,KAAK,MAAM;MACzE;;;;;;MAOO,KAAK,MAAY;AACtB,eAAO,KAAK,OAAO,KAAK,IAAI;MAC9B;;;;;;MAOO,KAAK,MAAY;AACtB,cAAM,SAAS,KAAK,MAAM,KAAK,MAAM;AACrC,eAAO,SAAS,OAAO,CAAC,IAAI;MAC9B;;;;;;MAOO,UAAU,MAAY;AAC3B,cAAM,SAAS,KAAK,OAAO,KAAK,IAAI;AACpC,eAAO,SAAS,CAAC,OAAO,OAAO,OAAO,QAAQ,OAAO,CAAC,EAAE,MAAM,IAAI;MACpE;;;;;;MAOO,aAAa,MAAY;AAC9B,cAAM,SAAS,KAAK,MAAM,KAAK,MAAM;AACrC,YAAI,QAAQ;AACV,iBAAO,CAAC,OAAO,CAAC,GAAG,GAAG,OAAO,MAAM,CAAC,CAAC;QACvC;AACA,eAAO;MACT;;;;;;MAOO,kBAAkB,MAAY;AACnC,cAAM,SAAS,KAAK,OAAO,KAAK,IAAI;AACpC,YAAI,CAAC,QAAQ;AACX,iBAAO;QACT;AAGA,cAAM,UAAU,CAAC,CAAC,OAAO,OAAO,OAAO,QAAQ,OAAO,CAAC,EAAE,MAAM,CAAC;AAGhE,eAAO,MAAM,CAAC,EAAE,QAAQ,CAAC,aAAY;AACnC,gBAAM,QAAQ,KAAK,QAAQ,UAAU,QAAQ,QAAQ,SAAS,CAAC,EAAE,CAAC,CAAC;AACnE,gBAAM,MAAM,QAAQ,SAAS;AAC7B,kBAAQ,KAAK,CAAC,OAAO,GAAG,CAAC;QAC3B,CAAC;AAED,eAAO;MACT;;;;;;;MAQO,QAAQ,MAAY;AACzB,cAAM,cAAc,KAAK,eAAc;AACvC,eAAO,CAAC,GAAG,KAAK,SAAS,WAAW,CAAC,EAAE,IAAI,CAAC,UAAU,MAAM,CAAC,CAAC;MAChE;;;;;;;MAQO,aAAa,MAAY;AAC9B,cAAM,UAAsB,CAAA;AAC5B,cAAM,cAAc,KAAK,eAAc;AAEvC,mBAAW,SAAS,KAAK,SAAS,WAAW,GAAG;AAC9C,cAAI,MAAM,UAAU,QAAW;AAC7B,oBAAQ,KAAK,CAAC,MAAM,OAAO,MAAM,QAAQ,MAAM,CAAC,EAAE,MAAM,CAAC;UAC3D;QACF;AAEA,eAAO;MACT;;;;;;;MAQO,WAAW,MAAc,aAAmB;AACjD,cAAM,cAAc,KAAK,eAAc;AACvC,eAAO,KAAK,QAAQ,aAAa,WAAW;MAC9C;;;;;MAMQ,iBAAc;AACpB,eAAO,KAAK,OAAO,SAAS,KAAK,SAAS,IAAI,OAAO,KAAK,QAAQ,GAAG;MACvE;;AAlJF,IAAAE,SAAA,QAAA;;;;;;;;;;;;;;;ACRA,QAAA,eAAA;AACA,QAAA,SAAA;AACA,QAAA,WAAA;AACA,QAAA,QAAA;AAiGA,aAAS,WAAW,GAAM;AACxB,aAAO,KAAK,QAAQ,OAAO,EAAE,aAAa;IAC5C;AAFS;AA0BT,QAAsB,WAAtB,cAAuC,aAAA,UAAS;aAAA;;;;;;;;;;;MASvC,OAAO,WAAW,MAAqB,KAAa;AACzD;AACA;MACF;;;;;;;MAQO,OAAO,WAAW,KAAc;AACrC,eAAO,IAAI,YAAW;MACxB;;;;;;;;;;;;;;;;;;MAmBU,OAAO,gBACf,KACA,OACA,OACG,OAAY;AAEf,eAAO,OAAA,IAAI,GAAG,KAAK,EAAE,YAAY,KAAK,OAAO,IAAI,GAAG,KAAK;MAC3D;;;;;;;MAQO,cAAW;AAChB,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;;;MAWO,OAAO,MAAqB,KAAa;AAC9C;AACA;MACF;;;;;;;;;MAUO,iBAAc;AACnB,YAAI,WAAW,IAAI,KAAK,EAAE,gBAAgB,iBAAiB;AACzD,oCAA0B,MAAM,KAAK,QAAQ;QAC/C;MACF;;AAtFF,IAAAC,SAAA,WAAA;;;AAyFA,aAAS,0BACP,WACA,UACA,QAAe;AAEf,iBAAW,CAAC,IAAI,WAAW,KAAK,OAAO,QAAQ,QAAQ,GAAG;AACxD,mBAAW,CAAC,KAAK,MAAM,KAAK,aAAa;AACvC,cAAI,aAAA,UAAU,YAAY,GAAG,KAAK,EAAE,eAAe,iBAAiB;AAElE,uBAAW,SAAS,QAAQ;AAC1B,oBAAA,KAAK,GAAG,SAAS,EAAE,cAAc;gBAC/B,QAAQ;gBACR,UAAU,UAAU;gBACpB,QAAQ;gBACR,UAAU;gBACV,MAAM;eACP;YACH;UACF,WAAW,WAAW,GAAG,GAAG;AAE1B,sCAA0B,WAAW,IAAI,UAAU,UAAU,EAAE;UACjE;QACF;MACF;IACF;AAxBS;AAgCT,QAAsB,iBAAtB,cAA6C,SAAQ;aAAA;;;MACnD,YAAY,OAAkB,WAAmB,IAAE;AACjD,cAAM,KAAK,OAAA,IAAI,GAAG,KAAK,EAAE,OAAO,OAAO,WAAW,GAAG,QAAQ,MAAM,EAAE;AACrE,cAAM,OAAO,EAAE;MACjB;;AAJF,IAAAA,SAAA,iBAAA;;;;;;;;;;;;;;;ACjPA,QAAA,SAAA;AAOA,QAAaC,OAAb,MAAgB;aAAA;;;;;;MAIP,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;MAEA,cAAA;MAAuB;;;;;MAMvB,IAAW,OAAI;AACb,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;MAOO,IAAI,OAAS;AAClB;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;MASO,UAAO;AACZ,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,UAAO;AACZ,cAAM,IAAI,MAAM,OAAO;MACzB;;AAhDF,IAAAC,SAAA,MAAAD;;;AAwDA,QAAa,SAAb,MAAmB;aAAA;;;;;;MAIV,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;MAEA,cAAA;MAAuB;;;;;MAMvB,IAAW,OAAI;AACb,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;MAOO,IAAI,OAAS;AAClB;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;MAKO,QAAK;AACV,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;MASO,OAAI;AACT,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;MAOO,OAAO,OAAS;AACrB;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;MAOO,IAAI,OAAS;AAClB;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;MASO,UAAO;AACZ,cAAM,IAAI,MAAM,OAAO;MACzB;;AA3EF,IAAAC,SAAA,SAAA;;;;;;;;;;;;;;AChEA,QAAA,gBAAA;AACA,QAAA,SAAA;AAMA,QAAaC,UAAb,MAAmB;aAAA;;;;;;MAIV,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;;;;;;;MAQO,OAAO,SAAS,MAAY,SAA+B;AAChE,cAAM,SAAS,cAAA,WAAW,kBAAkB;UAC1C,KAAK;UACL,MAAM;SACA;AACR,eAAO,SAAS,MAAM,OAAO;AAC7B,eAAO;MACT;MAEA,cAAA;MAAuB;;;;MAKvB,IAAW,SAAM;AACf,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;MAUO,GAAG,OAAa;AACrB;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;MAQO,OAAO,MAAY;AACxB;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;MAUO,SAAS,cAAoB;AAClC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;;MAUO,SAAS,cAAoB;AAClC;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;MAUO,QAAQ,cAAoB;AACjC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;;MASO,YAAS;AACd,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;;MAQO,MAAM,WAAiB;AAC5B;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;MAUO,WAAW,cAAoB;AACpC;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;MASO,UAAU,YAAoB,UAAiB;AACpD;AACA;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;;MAWO,QAAQ,cAAsB,eAAqB;AACxD;AACA;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;;;MAWO,WAAW,cAAsB,eAAqB;AAC3D;AACA;AACA,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;MAOO,OAAI;AACT,cAAM,IAAI,MAAM,UAAU;MAC5B;;;;;;;;MASO,YAAS;AACd,cAAM,IAAI,MAAM,OAAO;MACzB;;AA/LF,IAAAC,SAAA,SAAAD;;;;;;;;;;;;;;ACVA,QAAA,gBAAA;AACA,QAAA,SAAA;AAOA,QAAa,SAAb,MAAmB;aAAA;;;;;;MAIV,OAAO,kBAAe;AAC3B,eAAO,OAAA,eAAe,QAAQ,YAAY,KAAK,IAAI;MACrD;;;;;;MAOO,OAAO,SAAS,MAAY,SAA+B;AAChE;AACA;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;MAOO,OAAO,YAAY,MAAU;AAClC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;MAOO,OAAO,UAAU,MAAY;AAClC;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;MAOO,OAAO,aAAa,MAAwB;AACjD;AACA,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;MAMO,OAAO,SAAM;AAClB,cAAM,IAAI,MAAM,OAAO;MACzB;;;;;;MAOO,OAAO,kBAAkB,QAAY;AAC1C,eAAO,IAAI,cAAA,WAAW,MAAM;MAC9B;MAEA,cAAA;MAAuB;;AAlEzB,IAAAE,SAAA,SAAA;;;;;;;;;;;;;;ACRA,QAAA,cAAA;AACA,QAAA,SAAA;AACA,QAAA,QAAA;AAKa,IAAAC,SAAA,YAAW,GAAA,YAAA,YAAW,UAAU;AAsB7C,QAAa,OAAb,cAA0B,MAAA,SAAQ;aAAA;;;MAQhC,YACE,OACA,IACA,UACA,QAAmB,CAAA,GAAE;AAErB,cAAM,OAAO,EAAE;AAEf,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B,aAAK,MAAM,OAAA,IAAI,GAAG,IAAI,GAAG,aAAa,iBACpC,MACA,WACA,UACA,KAAK;AAEP,YAAI,CAAC,KAAK,KAAK;AACb,gBAAA,KAAK,GAAG,IAAI,EAAE,SAAS;QACzB;MACF;;MAGA,IAAW,WAAQ;AACjB,eAAO,CAAA;MACT;;MAGO,cAAW;AAChB,cAAM,IAAI,MAAM,eAAe;MACjC;;AAtCF,IAAAA,SAAA,OAAA;;;;;;;;;;;;;;AC5BA,QAAA,cAAA;AACA,QAAA,WAAA;AACA,QAAA,UAAA;AACA,QAAA,QAAA;AAMa,IAAAC,SAAA,WAAU,GAAA,YAAA,YAAW,WAAW;AA2I7C,QAAa,MAAb,MAAa,aAAY,MAAA,SAAQ;aAAA;;;;;;;;MAMxB,OAAO,kBAAkB,MAAY;AAC1C,eAAO,KAAK,QAAQ,wBAAwB,OAAO;MACrD;;;;;;MAOO,OAAO,kBACZ,aAA4B;AAE5B,YAAI,eAAe,QAAW;AAC5B;QACF;AAEA,cAAM,EACJ,cAAc,KACd,eAAe,CAAA,GACf,eAAe,CAAA,GACf,gBAAgB,CAAA,GAChB,mBAAmB,OACnB,SAAS,MAAA,SAAS,YAAY,CAAC,EAAC,IAC9B;AAEJ,cAAM,iBAA6C;UACjD,+BAA+B,eAAe;UAC9C,iCAAiC,cAAc,KAAK,GAAG,KAAK;UAC5D,oCAAoC,mBAAmB,SAAS;;AAGlE,cAAM,iBAA6C;UACjD,+BAA+B,eAAe;UAC9C,gCAAgC,aAAa,KAAK,GAAG,KAAK;UAC1D,gCAAgC,aAAa,KAAK,GAAG,KAAK;UAC1D,0BAA0B,OAAO,QAAQ,SAAQ;;AAGnD,eAAO;UACL,iBAAiB;UACjB,iBAAiB;;MAErB;;;;MAKA,IAAW,MAAG;AACZ,eAAO,KAAK,UAAU;MACxB;;;;;;MAOA,IAAc,YAAS;AACrB,cAAM,IAAI,SAAA,oBAAmB;MAC/B;MA+BA,YAAY,OAAkB,IAAY,QAAkB,CAAA,GAAE;AAC5D,YAAI,eAAe,MAAK;AACtB,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,SAAS,OAAO,IAAI,KAAK;QAC3D;AAEA,cAAM,OAAO,EAAE;AAjCT,aAAA,UAAe;UACrB,OAAO,CAAA;;AAGD,aAAA,oBAAoC;UAC1C,aAAa;UACb,cAAc;YACZ,WAAW;YACX,WAAW;YACX,WAAW;YACX,WAAW;YACX,WAAW;YACX,WAAW;;UAEb,cAAc,CAAC,gBAAgB,iBAAiB,kBAAkB;UAClE,eAAe,CAAA;UACf,kBAAkB;UAClB,QAAQ,MAAA,SAAS,YAAY,CAAC;;AAkB9B,aAAK,cAAc,MAAM,OAAO,KAAK,MAAM,MAAM,WAAW,IAAI;AAEhE,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;MAC9B;;;;;;;;MASO,IACL,MACA,UACA,OAAqB;AAErB;AACA;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;MASO,KACL,MACA,UACA,OAAsB;AAEtB;AACA;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;MASO,IACL,MACA,UACA,OAAqB;AAErB;AACA;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;MASO,OACL,MACA,UACA,OAAwB;AAExB;AACA;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;MASO,MACL,MACA,UACA,OAAuB;AAEvB;AACA;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;MASO,QACL,MACA,UACA,OAAyB;AAEzB;AACA;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;MASO,KACL,MACA,UACA,OAAsB;AAEtB;AACA;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;MASO,QACL,MACA,UACA,OAAyB;AAEzB;AACA;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;MAQU,cAAc,MAAY;AAClC,YACE,CAAC,+DAA+D,KAAK,IAAI,GACzE;AACA,gBAAM,IAAI,MACR,gBAAgB,IAAI,0HAA0H;QAElJ;MACF;;;;;;;MAQU,MAAM,OAAsB;AACpC,eAAO;UACL,GAAG,KAAK;UACR,GAAG;;MAEP;;;;;;;;MAUU,kBAAkB,OAAe,OAAa;AACtD,cAAM,SAAS,MAAM,MAAM,GAAG;AAC9B,cAAM,SAAS,MAAM,MAAM,GAAG;AAE9B,YAAI,UAAU,OAAO,SAAS,OAAO,SAAS,SAAS;AAEvD,iBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,gBAAM,QAAQ,OAAO,CAAC;AACtB,gBAAM,QAAQ,OAAO,CAAC;AACtB,eACG,CAAC,MAAM,MAAM,QAAQ,KAAK,CAAC,MAAM,MAAM,QAAQ,MAChD,MAAM,CAAC,MAAM,MAAM,CAAC,GACpB;AACA,mBAAO;UACT;AAEA,cACE,MAAM,MAAM,QAAQ,KACpB,MAAM,MAAM,QAAQ,KACpB,MAAM,CAAC,MAAM,MAAM,CAAC,GACpB;AACA,mBAAO;UACT;QACF;AAEA,eAAO;MACT;;;;;;;;MASU,mBAAmB,OAAe,OAAa;AACvD,cAAM,SAAS,MAAM,MAAM,GAAG;AAC9B,cAAM,SAAS,MAAM,MAAM,GAAG;AAE9B,YAAI,OAAO,WAAW,OAAO,QAAQ;AACnC,iBAAO;QACT;AAEA,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,gBAAM,QAAQ,OAAO,CAAC;AACtB,gBAAM,QAAQ,OAAO,CAAC;AAEtB,cAAI,UAAU,SAAS,CAAC,MAAM,MAAM,QAAQ,KAAK,CAAC,MAAM,MAAM,QAAQ,GAAG;AACvE,mBAAO;UACT;QACF;AAEA,eAAO;MACT;;;;;;;;MASU,mBACR,MACA,QAAc;AAEd,cAAM,gBAAgB,OAAO,KAAK,KAAK,QAAQ,KAAK;AAEpD,eAAO,cAAc,KACnB,CAAC,iBACC,CAAC,CAAC,KAAK,QAAQ,MAAM,YAAY,EAAE,OAAO,YAAW,CAAE,KACvD,KAAK,mBAAmB,cAAc,IAAI,CAAC;MAEjD;;;;;;;MAQQ,iBAAiB,MAAY;AACnC,cAAM,gBAAgB,OAAO,KAAK,KAAK,QAAQ,KAAK;AAEpD,eAAO,cAAc,KAAK,CAAC,iBACzB,KAAK,kBAAkB,cAAc,IAAI,CAAC;MAE9C;;;;;;MAOQ,mBAAmB,aAA4B;AACrD,cAAM,cAAkC,CAAA;AACxC,YAAI,aAAa;AACf,gBAAM,mBAAmB;YACvB,QAAQ;cACN,MAAM;;;AAGV,sBAAY,6BAA6B,IAAI;AAC7C,sBAAY,8BAA8B,IAAI;AAC9C,sBAAY,8BAA8B,IAAI;AAC9C,sBAAY,wBAAwB,IAAI;QAC1C;AACA,eAAO;MACT;;;;;;;;;MAUO,WACL,MACA,QACA,kBACA,aAA4B;AAE5B,YAAI,KAAK,QAAQ,MAAM,IAAI,IAAI,OAAO,YAAW,CAAE,GAAG;AACpD,gBAAM,IAAI,MACR,sBAAsB,IAAI,iBAAiB,MAAM,kBAAkB;QAEvE;AACA,cAAM,gBAAgB,KAAK,mBAAmB,MAAM,MAAM;AAC1D,YAAI,CAAC,CAAC,eAAe;AACnB,gBAAM,IAAI,MACR,sBAAsB,IAAI,iBAAiB,MAAM,kEAAkE,aAAa,GAAG;QAEvI;AACA,cAAM,cAAc,KAAK,iBAAiB,IAAI;AAC9C,YAAI,CAAC,CAAC,aAAa;AACjB,gBAAM,IAAI,MACR,sBAAsB,IAAI,iBAAiB,MAAM,wDAAwD,WAAW,0DAA0D;QAElL;AACA,cAAM,cAAc,GAAG,OAAO,YAAW,CAAE,GACzC,SAAS,MAAM,KAAK,KAAK,QAAQ,KAAK,GAAG,CAC3C;AACA,cAAM,aAAa,KAAK,MAAM,oBAAoB;AAClD,cAAM,iBAAwB,CAAA;AAC9B,YAAI,YAAY;AACd,qBAAW,QAAQ,CAAC,UAAS;AAC3B,kBAAM,YAAY,MAAM,QAAQ,KAAK,EAAE;AACvC,2BAAe,KAAK;cAClB,MAAM;cACN,IAAI;cACJ,UAAU;cACV,QAAQ;gBACN,MAAM;;aAET;UACH,CAAC;QACH;AACA,cAAM,oBAAoB,KAAK,mBAAmB,WAAW;AAC7D,cAAM,aAAa;UACjB,CAAC,OAAO,YAAW,CAAE,GAAG;YACtB;YACA,WAAW;cACT,OAAO;gBACL,aAAa;gBACb,SAAS,CAAA;gBACT,GAAI,OAAO,KAAK,iBAAiB,EAAE,SAAS,IACxC,EAAE,SAAS,kBAAiB,IAC5B,CAAA;;;YAGR,YAAY;YACZ,GAAG;;;AAGP,aAAK,QAAQ,MAAM,IAAI,IAAI;UACzB,GAAG,KAAK,QAAQ,MAAM,IAAI;UAC1B,GAAG;;MAEP;;;;MAKO,kBAAe;AAEpB,YAAI,QAAgC,CAAA;AACpC,eAAO,KAAK,KAAK,QAAQ,KAAK,EAAE,QAAQ,CAAC,QAAO;AAC9C,gBAAM,KAAI,kBAAkB,GAAG,CAAC,IAAI,KAAK,QAAQ,MAAM,GAAG;QAC5D,CAAC;AAGD,eAAO;UACL,GAAG,KAAK;UACR,SAAS;UACT;;MAEJ;;AAveF,IAAAA,SAAA,MAAA;;;AAgiBA,QAAY;AAAZ,KAAA,SAAYC,qBAAkB;AAE5B,MAAAA,oBAAA,SAAA,IAAA;IACF,GAHY,uBAAkBD,SAAA,qBAAlB,qBAAkB,CAAA,EAAA;AAQ9B,QAAY;AAAZ,KAAA,SAAYE,aAAU;AAEpB,MAAAA,YAAA,KAAA,IAAA;AAEA,MAAAA,YAAA,MAAA,IAAA;AAEA,MAAAA,YAAA,MAAA,IAAA;AAEA,MAAAA,YAAA,KAAA,IAAA;AAEA,MAAAA,YAAA,QAAA,IAAA;AAEA,MAAAA,YAAA,SAAA,IAAA;AAEA,MAAAA,YAAA,SAAA,IAAA;AAEA,MAAAA,YAAA,OAAA,IAAA;IACF,GAjBY,eAAUF,SAAA,aAAV,aAAU,CAAA,EAAA;AAqCT,IAAAA,SAAA,0BAA0B;AAoDvC,aAAgB,gBAAgB,QAAc;AAC5C,cAAQ,QAAQ;QACd,KAAK;AACH,iBAAO,WAAW;QACpB,KAAK;AACH,iBAAO,WAAW;QACpB,KAAK;AACH,iBAAO,WAAW;QACpB,KAAK;AACH,iBAAO,WAAW;QACpB,KAAK;AACH,iBAAO,WAAW;QACpB,KAAK;AACH,iBAAO,WAAW;QACpB,KAAK;AACH,iBAAO,WAAW;QACpB,KAAK;AACH,iBAAO,WAAW;QACpB;AACE,gBAAM,IAAI,MAAM,4BAA4B,MAAM,EAAE;MACxD;IACF;AArBgB;AAAhB,IAAAA,SAAA,kBAAA;AA2BA,aAAgB,wBACd,KAAkD;AAElD,YAAM,SAAiC,CAAA;AACvC,aAAO,KAAK,GAAG,EAAE,QAAQ,CAAC,QAAO;AAC/B,cAAM,QAAQ,IAAI,GAAG;AACrB,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,iBAAO,GAAG,IAAI,MAAM,KAAK,GAAG;QAC9B,WAAW,OAAO,UAAU,UAAU;AACpC,iBAAO,GAAG,IAAI;QAChB;MACF,CAAC;AACD,aAAO;IACT;AAbgB;AAAhB,IAAAA,SAAA,0BAAA;;;;;;;;;;;;AChzBA,QAAA,cAAA;AACA,QAAA,WAAA;AACA,QAAA,UAAA;AACA,QAAA,QAAA;AAEa,IAAAG,SAAA,aAAY,GAAA,YAAA,YAAW,aAAa;AAajD,QAAa,QAAb,MAAa,eAAc,MAAA,SAAQ;aAAA;;;MAIjC,YAAY,OAAkB,IAAY,QAAoB,CAAA,GAAE;AAC9D,YAAI,eAAe,QAAO;AACxB,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,WAAW,OAAO,IAAI,KAAK;QAC7D;AAEA,cAAM,OAAO,EAAE;AAEf,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B;MACF;;;;;MAMO,UACL,UACA,OAA6B;AAE7B;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;MAMO,eACL,OACA,OAAkC;AAElC;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;AAzCF,IAAAA,SAAA,QAAA;;;AA4FA,QAAY;AAAZ,KAAA,SAAYC,uBAAoB;AAE9B,MAAAA,sBAAA,SAAA,IAAA;IACF,GAHY,yBAAoBD,SAAA,uBAApB,uBAAoB,CAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjHhC,QAAA,KAAA,aAAA,QAAA,IAAA,CAAA;AACA,QAAA,SAAA,QAAA,MAAA;AAEA,QAAA,UAAA;AACA,QAAA,cAAA;AACA,QAAA,SAAA;AACA,QAAA,WAAA;AACA,QAAA,UAAA;AACA,QAAA,QAAA;AAKa,IAAAE,SAAA,cAAa,GAAA,YAAA,YAAW,cAAc;AAmBnD,QAAa,SAAb,MAAa,gBAAe,MAAA,SAAQ;aAAA;;;MAMlC,YAAY,OAAkB,IAAY,QAAqB,CAAA,GAAE;AAC/D,YAAI,eAAe,SAAQ;AACzB,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,YAAY,OAAO,IAAI,KAAK;QAC9D;AAEA,cAAM,OAAO,EAAE;AATE,aAAA,UAAU,oBAAI,IAAG;AAWlC,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;MAC9B;;;;;;;;MASO,UAAU,KAAa,MAAY;AACxC;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;;MAUO,QACL,KACA,MACA,WAA2B,SAAO;AAElC,cAAM,MAAM,OAAA,IAAI,GAAG,IAAI;AAEvB,cAAM,OAAO,GAAG,cACd,GAAA,OAAA,YAAW,IAAI,IAAI,QAAO,GAAA,OAAA,SAAQ,IAAI,eAAe,IAAI,GACzD,EAAE,SAAkB,CAAE;AAGxB,aAAK,UAAU,KAAK,IAAI;MAC1B;;;;;;MAOU,YAAY,YAA2B;AAC/C,cAAM,QAAQ,IAAI,QAAA,MAAM,MAAM,UAAU;AACxC,aAAK,KAAK,cAAc,KAAK;AAC7B,eAAO;MACT;;;;;MAMU,SAAS,YAA2B;AAC5C,YAAI,CAAC,KAAK,QAAQ,IAAI,UAAU,GAAG;AACjC,eAAK,QAAQ,IAAI,YAAY,KAAK,YAAY,UAAU,CAAC;QAC3D;AACA,eAAO,KAAK,QAAQ,IAAI,UAAU;MACpC;;;;;;MAOU,mBACR,WACA,UAA6B;AAE7B;AACA;AACA,cAAM,IAAI,MAAM,yBAAyB;MAC3C;;;;;;;MAQQ,kBACN,YACA,UACA,MAA4B;AAE5B;AACA,YAAI,WAAW,SAAS,gBAAgB,MAAM,GAAG;AAC/C,gBAAM,QAAQ,KAAK,SAAS,gBAAgB,MAAM,EAAE,UAClD,KAAK,mBAAmB,gBAAgB,QAAQ,QAAQ,CAAC;AAE3D,qBAAW,MAAM;YACf,sBAAsB;YACtB,sBAAsB;aACrB;AACD,kBAAA,KAAK,GAAG,IAAI,EAAE,cAAc;cAC1B,QAAQ;cACR,UAAU;cACV,QAAQ;cACR,UAAU,QAAA,qBAAqB;cAC/B,MAAM,gBAAgB;aACvB;UACH;QACF;AACA,YAAI,WAAW,SAAS,gBAAgB,MAAM,GAAG;AAC/C,gBAAM,QAAQ,KAAK,SAAS,gBAAgB,MAAM,EAAE,UAClD,KAAK,mBAAmB,gBAAgB,QAAQ,QAAQ,CAAC;AAE3D,qBAAW,MAAM;YACf,sBAAsB;YACtB,sBAAsB;aACrB;AACD,kBAAA,KAAK,GAAG,IAAI,EAAE,cAAc;cAC1B,QAAQ;cACR,UAAU;cACV,QAAQ;cACR,UAAU,QAAA,qBAAqB;cAC/B,MAAM,gBAAgB;aACvB;UACH;QACF;AACA,YAAI,WAAW,SAAS,gBAAgB,MAAM,GAAG;AAC/C,gBAAM,QAAQ,KAAK,SAAS,gBAAgB,MAAM,EAAE,UAClD,KAAK,mBAAmB,gBAAgB,QAAQ,QAAQ,CAAC;AAE3D,qBAAW,MAAM;YACf,sBAAsB;YACtB,sBAAsB;aACrB;AACD,kBAAA,KAAK,GAAG,IAAI,EAAE,cAAc;cAC1B,QAAQ;cACR,UAAU;cACV,QAAQ;cACR,UAAU,QAAA,qBAAqB;cAC/B,MAAM,gBAAgB;aACvB;UACH;QACF;MACF;;;;MAKO,SAAS,IAAyB,MAA4B;AACnE,YAAI,MAAM;AACR,kBAAQ,KAAK,8CAA8C;QAC7D;AACA,aAAK,kBAAkB,CAAC,gBAAgB,MAAM,GAAG,IAAI,IAAI;MAC3D;;;;MAKO,SAAS,IAAyB,MAA4B;AACnE,YAAI,MAAM;AACR,kBAAQ,KAAK,8CAA8C;QAC7D;AACA,aAAK,kBAAkB,CAAC,gBAAgB,MAAM,GAAG,IAAI,IAAI;MAC3D;;;;MAKO,SAAS,IAAyB,MAA4B;AACnE,YAAI,MAAM;AACR,kBAAQ,KAAK,8CAA8C;QAC7D;AACA,aAAK,kBAAkB,CAAC,gBAAgB,MAAM,GAAG,IAAI,IAAI;MAC3D;;;;MAKO,QAAQ,IAAyB,MAA2B;AACjE,YAAI,MAAM;AACR,kBAAQ,KAAK,6CAA6C;QAC5D;AACA,aAAK,kBACH,CAAC,gBAAgB,QAAQ,gBAAgB,QAAQ,gBAAgB,MAAM,GACvE,IACA,IAAI;MAER;;AApMF,IAAAA,SAAA,SAAA;;;AAsQA,QAAY;AAAZ,KAAA,SAAYC,wBAAqB;AAI/B,MAAAA,uBAAA,UAAA,IAAA;AAIA,MAAAA,uBAAA,QAAA,IAAA;IACF,GATY,0BAAqBD,SAAA,wBAArB,wBAAqB,CAAA,EAAA;AAoOjC,QAAY;AAAZ,KAAA,SAAYE,kBAAe;AAIzB,MAAAA,iBAAA,QAAA,IAAA;AAIA,MAAAA,iBAAA,QAAA,IAAA;AAIA,MAAAA,iBAAA,QAAA,IAAA;IACF,GAbY,oBAAeF,SAAA,kBAAf,kBAAe,CAAA,EAAA;AAmB3B,QAAY;AAAZ,KAAA,SAAYG,wBAAqB;AAE/B,MAAAA,uBAAA,KAAA,IAAA;AAEA,MAAAA,uBAAA,KAAA,IAAA;AAEA,MAAAA,uBAAA,MAAA,IAAA;AAEA,MAAAA,uBAAA,QAAA,IAAA;AAEA,MAAAA,uBAAA,UAAA,IAAA;AAEA,MAAAA,uBAAA,UAAA,IAAA;AAEA,MAAAA,uBAAA,YAAA,IAAA;AAEA,MAAAA,uBAAA,QAAA,IAAA;AAEA,MAAAA,uBAAA,SAAA,IAAA;AAEA,MAAAA,uBAAA,cAAA,IAAA;AAEA,MAAAA,uBAAA,YAAA,IAAA;AAEA,MAAAA,uBAAA,YAAA,IAAA;AAEA,MAAAA,uBAAA,UAAA,IAAA;AAEA,MAAAA,uBAAA,MAAA,IAAA;AAEA,MAAAA,uBAAA,QAAA,IAAA;IACF,GA/BY,0BAAqBH,SAAA,wBAArB,wBAAqB,CAAA,EAAA;;;;;;;;;;;;AC5hBjC,QAAA,cAAA;AACA,QAAA,UAAA;AACA,QAAA,QAAA;AAKa,IAAAI,SAAA,eAAc,GAAA,YAAA,YAAW,eAAe;AAkBrD,QAAa,UAAb,MAAa,iBAAgB,MAAA,SAAQ;aAAA;;;MASnC,YAAY,OAAkB,IAAY,QAAsB,CAAA,GAAE;AAChE,YAAI,eAAe,UAAS;AAC1B,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,aAAa,OAAO,IAAI,KAAK;QAC/D;AAEA,cAAM,OAAO,EAAE;AAEf,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B,aAAK,UAAU,MAAM,WAAW;MAClC;;AApBF,IAAAA,SAAA,UAAA;;;AAoEA,QAAY;AAAZ,KAAA,SAAYC,yBAAsB;AAEhC,MAAAA,wBAAA,KAAA,IAAA;AAEA,MAAAA,wBAAA,KAAA,IAAA;AAEA,MAAAA,wBAAA,MAAA,IAAA;AAEA,MAAAA,wBAAA,KAAA,IAAA;IACF,GATY,2BAAsBD,SAAA,yBAAtB,yBAAsB,CAAA,EAAA;;;;;;;;;;;;AC7FlC,QAAA,cAAA;AACA,QAAA,QAAA;AAKa,IAAAE,SAAA,cAAa,GAAA,YAAA,YAAW,cAAc;AAkBnD,QAAa,SAAb,MAAa,gBAAe,MAAA,SAAQ;aAAA;;;MAIlC,YAAY,OAAkB,IAAY,OAAkB;AAC1D,YAAI,eAAe,SAAQ;AACzB,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,YAAY,OAAO,IAAI,KAAK;QAC9D;AAEA,cAAM,OAAO,EAAE;AAEf,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B,aAAK,UAAU,MAAM;MACvB;;;;MAKA,IAAW,aAAU;AACnB,eAAO,KAAK;MACd;;AAtBF,IAAAA,SAAA,SAAA;;;;;;;;;;;;;;ACxBA,QAAA,cAAA;AACA,QAAA,QAAA;AAKa,IAAAC,SAAA,gBAAe,GAAA,YAAA,YAAW,gBAAgB;AAyBvD,QAAa,WAAb,MAAa,kBAAiB,MAAA,SAAQ;aAAA;;;;;;;MAcpC,YACE,OACA,IACA,KACA,OAAqB;AAErB,YAAI,eAAe,WAAU;AAC3B,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,cAAc,OAAO,IAAI,KAAK,KAAK;QACrE;AAEA,cAAM,OAAO,EAAE;AAEf,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc,OAAO,SAAS;AAE5C,aAAK,OAAO;AACZ,aAAK,SAAS,OAAO;AACrB,aAAK,kBAAkB,OAAO;MAChC;;;;MAKA,IAAW,MAAG;AACZ,eAAO,KAAK;MACd;;;;MAKA,IAAc,QAAK;AACjB,eAAO,KAAK;MACd;;;;MAKA,IAAc,iBAAc;AAC1B,eAAO,KAAK;MACd;;AArDF,IAAAA,SAAA,WAAA;;;;;;;;;;;;AC9BA,QAAY;AAAZ,KAAA,SAAYC,kBAAe;AACzB,MAAAA,iBAAA,WAAA,IAAA;AACA,MAAAA,iBAAA,WAAA,IAAA;IACF,GAHY,oBAAeC,SAAA,kBAAf,kBAAe,CAAA,EAAA;AA0D3B,QAAa,gBAAb,MAA0B;aAAA;;;MACjB,OAAO,aAAa,UAAqB,OAAkB;AAChE,cAAM,MAAM,MAAM,OAAO;AACzB,cAAM,SAAS,MAAM;AAErB,YAAI,UAAU,SAAS,GAAG;AACxB,gBAAM,IAAI,MAAM,2BAA2B;QAC7C;AAEA,YAAI,OAAO,SAAS,KAAK;AAEzB,eAAO,oBAAoB,MAAM,MAAM,IAAI;AAE3C,YAAI,MAAM,QAAQ;AAChB,iBAAO,GAAG,MAAM,MAAM,GAAG,IAAI;QAC/B;AAEA,YAAI,cAAc,MAAM,eAAe;AACvC,YAAI,OAAO,cAAc,MAAM,SAAS,KAAK,KAAK,UAAU,GAAG,CAAC,IAAI;AACpE,YAAI,SAAS,MAAM,UAAU;AAE7B,eAAO,KAAK,QAAQ,MAAM,iBAAiB,GAAG;AAM9C,YAAI,QAAQ;AACV,iBAAO,KAAK,UAAU,GAAG,SAAS,KAAK,SAAS,OAAO,MAAM;QAC/D;AAEA,eAAO,GAAG,IAAI,GAAG,IAAI,GAAG,MAAM;AAI9B,eAAO,oBAAoB,MAAM,MAAM,IAAI;AAE3C,eAAO;MACT;;AAtCF,IAAAA,SAAA,gBAAA;AAyCA,aAAS,oBAAoB,MAAc,iBAAiC;AAC1E,UAAI,oBAAoB,gBAAgB,WAAW;AACjD,eAAO,KAAK,kBAAiB;MAC/B;AACA,UAAI,oBAAoB,gBAAgB,WAAW;AACjD,eAAO,KAAK,kBAAiB;MAC/B;AACA,aAAO;IACT;AARS;;;;;;;;;;;;ACrGT,QAAA,OAAA,QAAA,IAAA;AACA,QAAA,SAAA,QAAA,MAAA;AAEA,QAAA,cAAA;AACA,QAAA,SAAA;AACA,QAAA,UAAA;AACA,QAAA,mBAAA;AACA,QAAA,QAAA;AAKa,IAAAC,SAAA,gBAAe,GAAA,YAAA,YAAW,gBAAgB;AA4CvD,QAAaC,YAAb,MAAa,kBAAiB,MAAA,SAAQ;aAAA;;;MAcpC,YACE,OACA,IACA,SACA,QAAuB,CAAA,GAAE;AAEzB,YAAI,eAAe,WAAU;AAC3B,iBAAO,MAAA,SAAS,gBAAgBD,SAAA,cAAc,OAAO,IAAI,SAAS,KAAK;QACzE;AAEA,cAAM,OAAO,EAAE;AArBA,aAAA,OAA+B,CAAA;AAuB9C,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B,mBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,OAAO,CAAA,CAAE,GAAG;AAC1D,eAAK,eAAe,KAAK,KAAK;QAChC;AAEA,aAAK,UAAU;AACf,cAAM,YAAY,iBAAA,cAAc,aAAa,MAAM;;UAEjD,iBAAiB;UACjB,MAAM,iBAAA,gBAAgB;UACtB,KAAK;SACN;AAED,cAAM,UAAU,OAAA,IAAI,GAAG,IAAI,EAAE;AAC7B,SAAA,GAAA,KAAA,WAAU,SAAS,EAAE,WAAW,KAAI,CAAE;AACtC,cAAM,cAAa,GAAA,OAAA,MAAK,SAAS,GAAG,SAAS,MAAM;AACnD,aAAK,aAAa;AAElB,YAAI,QAAQ,IAAI,aAAa;AAC3B,eAAK,eAAe,eAAe,QAAQ,IAAI,WAAW;QAC5D;AAEA,YAAI,MAAM,gBAAgB,UAAa,MAAM,eAAe,GAAG;AAC7D,gBAAM,IAAI,MACR,iEAAiE;QAErE;MACF;;MAGO,iBAAc;AACnB,cAAM,eAAc;AAIpB,cAAM,QAAQ,KAAK,cAAc,KAAK,OAAO;AAC7C,SAAA,GAAA,KAAA,eAAc,KAAK,YAAY,MAAM,KAAK,IAAI,CAAC;AAI/C,eAAA,QAAQ,KAAK,KAAK,SAAS,MAAM,CAAC,QAAQ,CAAC;MAC7C;;;;;;MAOU,cAAc,SAAyB;AAC/C,cAAM,iBAAiB,QAAQ,YAAW;AAC1C,cAAM,QAAQ,IAAI,MAAK;AACvB,cAAM,SAAS;AAEf,cAAM,KAAK,eAAe;AAC1B,cAAM,KAAK,OAAO,MAAM,eAAe;AACvC,cAAM,KAAK,2CAA2C;AACtD,cAAM,KAAK,KAAK,MAAM,MAAM,MAAM,QAAQ,cAAc,IAAI;AAC5D,cAAM,KAAK,kBAAkB,MAAM,iBAAiB;AACpD,cAAM,KAAK,IAAI;AAEf,eAAO;MACT;;;;MAKO,eAAe,MAAc,OAAa;AAC/C,YAAI,KAAK,KAAK,IAAI,MAAM,UAAa,KAAK,KAAK,IAAI,MAAM,OAAO;AAC9D,gBAAM,IAAI,MACR,yBAAyB,IAAI,uCAAuC;QAExE;AACA,aAAK,KAAK,IAAI,IAAI;MACpB;;;;MAKA,IAAW,MAAG;AACZ,eAAO,EAAE,GAAG,KAAK,KAAI;MACvB;;AA5GF,IAAAA,SAAA,WAAAC;;;AA6JA,QAAY;AAAZ,KAAA,SAAYC,0BAAuB;AAEjC,MAAAA,yBAAA,QAAA,IAAA;AAEA,MAAAA,yBAAA,cAAA,IAAA;IACF,GALY,4BAAuBF,SAAA,0BAAvB,0BAAuB,CAAA,EAAA;;;;;;;;;;;;ACnNnC,QAAA,cAAA;AACA,QAAA,UAAA;AACA,QAAA,QAAA;AAKa,IAAAG,SAAA,iBAAgB,GAAA,YAAA,YAAW,gBAAgB;AAyBxD,QAAa,WAAb,MAAa,kBAAiB,MAAA,SAAQ;aAAA;;;MAIpC,YACE,OACA,IACA,SACA,QAAuB,CAAA,GAAE;AAEzB,YAAI,eAAe,WAAU;AAC3B,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,eAAe,OAAO,IAAI,SAAS,KAAK;QAC1E;AAEA,cAAM,OAAO,EAAE;AAEf,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B;AACA;MACF;;AArBF,IAAAA,SAAA,WAAA;;;;;;;;;;;;;;AChCA,QAAA,cAAA;AACA,QAAA,WAAA;AACA,QAAA,UAAA;AACA,QAAA,QAAA;AAKa,IAAAC,SAAA,aAAY,GAAA,YAAA,YAAW,aAAa;AAKpC,IAAAA,SAAA,4BAA4B;AA+CzC,QAAa,QAAb,MAAa,eAAc,MAAA,SAAQ;aAAA;;;MAIjC,YAAY,OAAkB,IAAY,QAAoB,CAAA,GAAE;AAC9D,YAAI,eAAe,QAAO;AACxB,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,WAAW,OAAO,IAAI,KAAK;QAC7D;AAEA,cAAM,OAAO,EAAE;AAEf,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B;MACF;;;;;MAMO,YACL,SACA,OAA+B;AAE/B;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;AA5BF,IAAAA,SAAA,QAAA;;;AAmGA,QAAY;AAAZ,KAAA,SAAYC,uBAAoB;AAE9B,MAAAA,sBAAA,MAAA,IAAA;AAEA,MAAAA,sBAAA,OAAA,IAAA;AAEA,MAAAA,sBAAA,aAAA,IAAA;AAEA,MAAAA,sBAAA,KAAA,IAAA;IACF,GATY,yBAAoBD,SAAA,uBAApB,uBAAoB,CAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;AC/JhC,QAAM,eAAe,gCAAC,OAAa;AACjC,UAAI,QAAQ,KAAK,KAAK,GAAG;AACvB,eAAO,OAAO,KAAK;aACd;AACL,eAAO;;IAEX,GANqB;AAQrB,QAAM,aAAa,gCAAC,OAAa;AAC/B,aAAO,UAAU;IACnB,GAFmB;AAInB,QAAM,iBAAiB,gCAAC,OAAa;AACnC,aAAO,UAAU;IACnB,GAFuB;AAIvB,QAAM,YAAY,gCAAC,OAAe,OAAe,MAAY;AAC3D,aAAO,SAAS,SAAS,SAAS;IACpC,GAFkB;AAIlB,QAAM,eAAe,gCAAC,OAAe,OAAe,MAAY;AAC9D,UAAM,QAAQ,MAAM,MAAM,GAAG;AAC7B,cAAQ,MAAM,QAAQ;QACpB,KAAK;AACH,iBAAO,WAAW,KAAK,KAAK,UAAU,aAAa,KAAK,GAAG,OAAO,IAAI;QACxE,KAAK;AACG,cAAA,KAAe,MAAM,IAAI,SAAC,MAAY;AAAa,mBAAA,aAAa,IAAI;UAAjB,CAAkB,GAApE,QAAK,GAAA,CAAA,GAAE,MAAG,GAAA,CAAA;AACjB,iBAAO,SAAS,OAAO,UAAU,OAAO,OAAO,IAAI,KAAK,UAAU,KAAK,OAAO,IAAI;QACpF;AACE,iBAAO;;IAEb,GAXqB;AAarB,QAAM,cAAc,gCAAC,OAAyB;AAC5C,aAAO,UAAU,UAAc,MAAM,OAAO,OAAO,MAAM,MAAM,aAAa,KAAK,IAAI;IACvF,GAFoB;AAIpB,QAAM,mBAAmB,gCAAC,OAAe,OAAe,MAAY;AAClE,UAAI,MAAM,OAAO,YAAY,MAAM,IAAI;AACrC,eAAO;;AAGT,UAAM,OAAO,MAAM,MAAM,GAAG;AAC5B,aAAO,KAAK,MAAM,SAAC,WAAiB;AAClC,YAAM,SAAS,UAAU,MAAM,GAAG;AAElC,YAAI,UAAU,KAAI,EAAG,SAAS,GAAG,GAAG;AAClC,iBAAO;;AAIT,YAAI,OAAO,SAAS,GAAG;AACrB,iBAAO;;AAIF,YAAA,OAAe,OAAM,CAAA,GAAf,QAAS,OAAM,CAAA;AAC5B,eAAO,aAAa,MAAM,OAAO,IAAI,KAAK,YAAY,KAAK;MAC7D,CAAC;IACH,GAtByB;AAwBzB,QAAM,kBAAkB,gCAAC,SAAe;AACtC,aAAO,iBAAiB,SAAS,GAAG,EAAE;IACxC,GAFwB;AAIxB,QAAM,kBAAkB,gCAAC,SAAe;AACtC,aAAO,iBAAiB,SAAS,GAAG,EAAE;IACxC,GAFwB;AAIxB,QAAM,gBAAgB,gCAAC,OAAa;AAClC,aAAO,iBAAiB,OAAO,GAAG,EAAE;IACtC,GAFsB;AAItB,QAAM,eAAe,gCAAC,MAAc,eAAuB;AACzD,aAAQ,iBAAiB,eAAe,IAAI,KAAM,iBAAiB,MAAM,GAAG,EAAE;IAChF,GAFqB;AAIrB,QAAM,aAAwC;MAC5C,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;;AAGP,QAAM,iBAAiB,gCAAC,QAAgB,OAAe;AAErD,UAAI,OAAO,OAAO,YAAY,MAAM,IAAI;AACtC,eAAO;;AAGT,UAAI,OAAO;AACT,YAAM,iBAAiB,OAAO,YAAW,EAAG,QAAQ,aAAa,SAAC,OAAa;AAC7E,iBAAO,WAAW,KAAK,MAAM,SAAY,QAAQ,WAAW,KAAK;QACnE,CAAC;AAED,eAAO,iBAAiB,gBAAgB,GAAG,EAAE;;AAG/C,aAAO,iBAAiB,QAAQ,GAAG,EAAE;IACvC,GAfuB;AAiBvB,QAAM,gBAA2C;MAC/C,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;;AAGP,QAAM,mBAAmB,gCAAC,UAAkB,OAAiB,eAAyB,oBAA4B;AAGhH,UAAI,iBAAiB,eAAe,QAAQ,GAAG;AAC7C,eAAO;iBACE,CAAC,iBAAiB,eAAe,QAAQ,GAAG;AACrD,eAAO;;AAIT,UAAI,SAAS,OAAO,YAAY,MAAM,IAAI;AACxC,eAAO;;AAGT,UAAI,OAAO;AACT,YAAM,mBAAmB,SAAS,YAAW,EAAG,QAAQ,aAAa,SAAC,OAAa;AACjF,iBAAO,cAAc,KAAK,MAAM,SAAY,QAAQ,cAAc,KAAK;QACzE,CAAC;AAED,eAAO,iBAAiB,kBAAkB,GAAG,qBAAqB,IAAI,CAAC;;AAGzE,aAAO,iBAAiB,UAAU,GAAG,qBAAqB,IAAI,CAAC;IACjE,GAvByB;AAyBzB,QAAM,yBAAyB,gCAAC,MAAc,UAAkB,eAAuB;AACrF,aAAO,EAAE,iBAAiB,eAAe,IAAI,KAAK,eAAe,QAAQ;IAC3E,GAF+B;AAI/B,QAAM,QAAQ,gCAAC,MAAY;AACzB,aAAO,KAAK,KAAI,EAAG,MAAM,KAAK;IAChC,GAFc;AAWd,QAAM,iBAA0B;MAC9B,OAAO;MACP,SAAS;MACT,eAAe;MACf,oBAAoB;;AAGT,IAAAE,SAAA,cAAc,SAAC,MAAc,SAA0B;AAClE,gBAAO,SAAA,SAAA,CAAA,GAAQ,cAAc,GAAK,OAAO;AAEzC,UAAM,SAAS,MAAM,IAAI;AAEzB,UAAI,OAAO,UAAU,QAAQ,UAAU,IAAI,MAAM,OAAO,SAAS,GAAG;AAClE,eAAO;;AAGT,UAAM,SAAoB,CAAA;AAC1B,UAAI,OAAO,WAAW,GAAG;AACvB,YAAM,UAAU,OAAO,MAAK;AAC5B,YAAI,SAAS;AACX,iBAAO,KAAK,gBAAgB,OAAO,CAAC;;;AAMjC,UAAA,UAA0C,OAAM,CAAA,GAAvC,QAAiC,OAAM,CAAA,GAAhC,OAA0B,OAAM,CAAA,GAA1B,SAAoB,OAAM,CAAA,GAAlB,WAAY,OAAM,CAAA;AACvD,aAAO,KAAK,gBAAgB,OAAO,CAAC;AACpC,aAAO,KAAK,cAAc,KAAK,CAAC;AAChC,aAAO,KAAK,aAAa,MAAM,QAAQ,aAAa,CAAC;AACrD,aAAO,KAAK,eAAe,QAAQ,QAAQ,KAAK,CAAC;AACjD,aAAO,KAAK,iBAAiB,UAAU,QAAQ,OAAO,QAAQ,eAAe,QAAQ,kBAAkB,CAAC;AACxG,aAAO,KAAK,uBAAuB,MAAM,UAAU,QAAQ,aAAa,CAAC;AAEzE,aAAO,OAAO,MAAM,OAAO;IAC7B;;;;;;;;;;;;ACnMA,QAAA,mBAAA;AAEA,QAAA,cAAA;AACA,QAAA,WAAA;AACA,QAAA,UAAA;AACA,QAAA,QAAA;AAKa,IAAAC,SAAA,gBAAe,GAAA,YAAA,YAAW,gBAAgB;AAoCvD,QAAa,WAAb,MAAa,kBAAiB,MAAA,SAAQ;aAAA;;;MAIpC,YAAY,OAAkB,IAAY,QAAuB,CAAA,GAAE;AACjE,YAAI,eAAe,WAAU;AAC3B,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,cAAc,OAAO,IAAI,KAAK;QAChE;AAEA,cAAM,OAAO,EAAE;AAEf,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cACZ;AAEF,cAAM,EAAE,MAAM,KAAI,IAAK;AAEvB,YAAI,QAAQ,MAAM;AAChB,gBAAM,IAAI,MAAM,oDAAoD;QACtE;AACA,YAAI,CAAC,QAAQ,CAAC,MAAM;AAClB,gBAAM,IAAI,MAAM,iCAAiC;QACnD;AACA,YAAI,QAAQ,KAAK,UAAU,IAAI;AAC7B,gBAAM,IAAI,MAAM,4CAA4C;QAC9D;AAGA,YACE,QACA,EAAC,GAAA,iBAAA,aAAY,MAAM;UACjB,OAAO;UACP,oBAAoB;UACpB,eAAe;UACf,SAAS;SACV,GACD;AACA,gBAAM,IAAI,MAAM,yCAAyC;QAC3D;MACF;;;;;MAMO,OACL,UACA,OAA6B;AAE7B;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;AApDF,IAAAA,SAAA,WAAA;;;AAgFA,QAAY;AAAZ,KAAA,SAAYC,0BAAuB;AAEjC,MAAAA,yBAAA,MAAA,IAAA;IACF,GAHY,4BAAuBD,SAAA,0BAAvB,0BAAuB,CAAA,EAAA;;;;;;;;;;;;;AC9HnC,QAAA,cAAA;AACA,QAAA,UAAA;AACA,QAAA,QAAA;AAKa,IAAAE,SAAA,cAAa,GAAA,YAAA,YAAW,cAAc;AAwBnD,QAAa,SAAb,MAAa,gBAAe,MAAA,SAAQ;aAAA;;;MASlC,YAAY,OAAkB,IAAY,QAAqB,CAAA,GAAE;AAC/D,YAAI,eAAe,SAAQ;AACzB,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,YAAY,OAAO,IAAI,KAAK;QAC9D;AAEA,cAAM,OAAO,EAAE;AAVV,aAAA,EAAA,IAAkB;AAYvB,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B,aAAK,QAAQ,MAAM;MACrB;;MAGA,IAAW,OAAI;AACb,eAAO,KAAK;MACd;;AAzBF,IAAAA,SAAA,SAAA;kCAIU,QAAA;;AA6DV,QAAY;AAAZ,KAAA,SAAYC,wBAAqB;AAE/B,MAAAA,uBAAA,OAAA,IAAA;AAEA,MAAAA,uBAAA,YAAA,IAAA;IACF,GALY,0BAAqBD,SAAA,wBAArB,wBAAqB,CAAA,EAAA;;;;;;;;;;;;ACjGjC,QAAA,OAAA,QAAA,IAAA;AACA,QAAA,SAAA,QAAA,MAAA;AAGA,QAAA,cAAA;AACA,QAAA,SAAA;AACA,QAAA,UAAA;AACA,QAAA,mBAAA;AACA,QAAA,QAAA;AAKa,IAAAE,SAAA,eAAc,GAAA,YAAA,YAAW,eAAe;AA2BrD,QAAa,UAAb,MAAa,iBAAgB,MAAA,SAAQ;aAAA;;;MAgBnC,YACE,OACA,IACA,SACA,QAAsB,CAAA,GAAE;AAExB,YAAI,eAAe,UAAS;AAC1B,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,aAAa,OAAO,IAAI,SAAS,KAAK;QACxE;AAEA,cAAM,OAAO,EAAE;AAZA,aAAA,OAA+B,CAAA;AAc9C,mBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,OAAO,CAAA,CAAE,GAAG;AAC1D,eAAK,eAAe,KAAK,KAAK;QAChC;AAEA,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B,cAAM,YAAY,iBAAA,cAAc,aAAa,MAAM;UACjD,iBAAiB;;UACjB,MAAM,iBAAA,gBAAgB;UACtB,KAAK;SACN;AAED,cAAM,UAAU,OAAA,IAAI,GAAG,IAAI,EAAE;AAC7B,SAAA,GAAA,KAAA,WAAU,SAAS,EAAE,WAAW,KAAI,CAAE;AACtC,cAAM,cAAa,GAAA,OAAA,MAAK,SAAS,GAAG,SAAS,MAAM;AACnD,aAAK,aAAa;AAElB,YAAI,QAAQ,IAAI,aAAa;AAC3B,eAAK,eAAe,eAAe,QAAQ,IAAI,WAAW;QAC5D;AAEA,aAAK,UAAU;MACjB;;MAGO,iBAAc;AACnB,cAAM,eAAc;AAEpB,cAAM,iBAAiB,KAAK,QAAQ,YAAW;AAC/C,cAAM,OAAO;;;;;;+BAOc,cAAc;;;;;;;;;;;;;AAczC,SAAA,GAAA,KAAA,eAAc,KAAK,YAAY,IAAI;AAInC,eAAA,QAAQ,KAAK,KAAK,SAAS,MAAM,CAAC,QAAQ,CAAC;MAC7C;;;;MAKO,eAAe,MAAc,OAAa;AAC/C,YAAI,KAAK,KAAK,IAAI,MAAM,UAAa,KAAK,KAAK,IAAI,MAAM,OAAO;AAC9D,gBAAM,IAAI,MACR,yBAAyB,IAAI,uCAAuC;QAExE;AACA,aAAK,KAAK,IAAI,IAAI;MACpB;;;;MAKA,IAAW,MAAG;AACZ,eAAO,EAAE,GAAG,KAAK,KAAI;MACvB;;AAvGF,IAAAA,SAAA,UAAA;;;AAwMA,QAAY;AAAZ,KAAA,SAAYC,yBAAsB;AAChC,MAAAA,wBAAA,OAAA,IAAA;AACA,MAAAA,wBAAA,MAAA,IAAA;AACA,MAAAA,wBAAA,SAAA,IAAA;IACF,GAJY,2BAAsBD,SAAA,yBAAtB,yBAAsB,CAAA,EAAA;;;;;;;;;;;;AChPlC,QAAA,SAAA,QAAA,MAAA;AAGA,QAAA,cAAA;AACA,QAAA,SAAA;AACA,QAAA,WAAA;AACA,QAAA,UAAA;AACA,QAAA,QAAA;AAKa,IAAAE,SAAA,eAAc,GAAA,YAAA,YAAW,eAAe;AA0CrD,QAAa,UAAb,MAAa,iBAAgB,MAAA,SAAQ;aAAA;;;MAUnC,YAAY,OAAkB,IAAY,OAAmB;AAC3D,YAAI,eAAe,UAAS;AAC1B,iBAAO,MAAA,SAAS,gBAAgBA,SAAA,aAAa,OAAO,IAAI,KAAK;QAC/D;AAEA,cAAM,OAAO,EAAE;AAEf,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAE5B,aAAK,SAAQ,GAAA,OAAA,YAAW,MAAM,IAAI,IAC9B,MAAM,QACN,GAAA,OAAA,SAAQ,OAAA,IAAI,GAAG,KAAK,EAAE,eAAe,MAAM,IAAI;AAEnD,aAAK,UAAU,MAAM;MACvB;;;;MAKA,IAAW,OAAI;AACb,eAAO,KAAK;MACd;;;;MAKA,IAAW,MAAG;AACZ,eAAO,KAAK,UAAU;MACxB;;;;;;MAOA,IAAc,YAAS;AACrB,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;;;;;;MAQO,QAAQ,MAAc,MAAU;AACrC,YAAI,CAAC,KAAK,SAAS,OAAO,GAAG;AAC3B,gBAAM,IAAI,MACR,4CAA4C,KAAK,MAAM,GAAG,EAAE,IAAG,CAAE,IAAI;QAEzE;AACA,eAAO,KAAK,QAAQ,MAAM,KAAK,UAAU,IAAI,GAAG;UAC9C,aAAa;SACd;MACH;;;;;;;;;MAUO,QAAQ,MAAc,MAAc,SAAwB;AACjE;AACA;AACA;AACA,cAAM,IAAI,SAAA,oBAAmB;MAC/B;;AAhFF,IAAAA,SAAA,UAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDA,iBAAA,eAAAC,QAAA;AACA,iBAAA,kBAAAA,QAAA;AACA,iBAAA,mBAAAA,QAAA;AACA,iBAAA,kBAAAA,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,qBAAAA,QAAA;AACA,iBAAA,iBAAAA,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,kBAAAA,QAAA;AACA,iBAAA,mBAAAA,QAAA;AACA,iBAAA,iBAAAA,QAAA;AACA,iBAAA,mBAAAA,QAAA;;;;;;;;;;;;ACXA,QAAA,aAAA;AACA,QAAA,SAAA;AACA,QAAA,UAAA;AACA,QAAA,cAAA;AAEA,QAAA,QAAA;AAKa,IAAAC,SAAA,mBAAkB,GAAA,YAAA,YAAW,gBAAgB;AAe1D,QAAa,aAAb,MAAa,oBAAmB,WAAA,SAAQ;aAAA;;;;;;;;MAM/B,OAAO,YAAY,KAAU,MAAS;AAC3C,YAAI,IAAI,mBAAmB;AACzB,cAAI,cAAc,IAAI,YAAW,KAAK,kBAAkB;QAC1D;AAEA,YAAI,MAAM;AAGR,gBAAA,KAAK,UAAU,IAAI;AAEnB,cAAI,IAAI,mBAAmB;AACzB,gBAAI,KAAK,KAAK,MAAM;AACpB,kBAAM,QAAQ,IAAI,YAAa,UAAS;AACxC,qBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,kBAAI,KAAK,KAAK,QAAQ,CAAC;YACzB;UACF,OAAO;AACL,gBAAI,KAAK,KAAK,SAAS;UACzB;QACF;MACF;MAgBA,YAAY,OAAkB,IAAY,QAAyB,CAAA,GAAE;AACnE,YAAI,eAAe,aAAY;AAC7B,iBAAO,WAAA,SAAS,gBAAgBA,SAAA,iBAAiB,OAAO,IAAI,KAAK;QACnE;AAEA,cAAM,OAAO,EAAE;AAdT,aAAA,eAA4B,oBAAI,IAAG;AAOnC,aAAA,gBAA6B,oBAAI,IAAG;AAS1C,cAAA,KAAK,GAAG,IAAI,EAAE,SAAS;AACvB,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cACZ;AAEF;MACF;;MAGO,iBACL,OACA,IACA,UACA,OAAoB;AAGpB,cAAM,UAAU,MAAM,KAAK,KAAK,MAAM,WAAW,GAAG,GAAG,CAAC;AAExD,cAAM,WACJ,MAAM,KAAK,KACR,MAAM,cAAc,GACnB,GAAG,CAAC,EACL,QAAQ,GAAG,OAAO,KAAK,EAAE,IAC5B,MACA;AAEF,YAAI,CAAC,KAAK,aAAa,IAAI,OAAO,KAAK,CAAC,KAAK,cAAc,IAAI,QAAQ,GAAG;AACxE,eAAK,aAAa,IAAI,OAAO;AAC7B,eAAK,cAAc,IAAI,QAAQ;AAC/B,iBAAO,IAAI,QAAA,SAAS,OAAO,IAAI,UAAU,KAAK;QAChD;AAEA,eAAO;MACT;;MAGA,IAAW,WAAQ;AACjB,eAAO;UACL,CAAC,0BAA0B,UAAU,GAAG,CAAA;UACxC,CAAC,0BAA0B,QAAQ,GAAG,CAAA;;MAE1C;;;;;MAMO,YAAS;AACd,cAAM,SAAS,wBAAC,OAAuB;AACrC,iBAAO,cAAc,OAAA;QACvB,GAFe;AAGf,eAAO,KAAK,KAAK,KAAK,KAAK,QAAO,EAAG,OAAO,MAAM;MACpD;;AArGF,IAAAA,SAAA,aAAA;;;AAmNA,QAAY;AAAZ,KAAA,SAAYC,WAAQ;AAIlB,MAAAA,UAAA,SAAA,IAAA;AAKA,MAAAA,UAAA,MAAA,IAAA;AAKA,MAAAA,UAAA,SAAA,IAAA;AAKA,MAAAA,UAAA,OAAA,IAAA;IACF,GApBY,aAAQD,SAAA,WAAR,WAAQ,CAAA,EAAA;AA0BpB,QAAY;AAAZ,KAAA,SAAYE,YAAS;AAInB,MAAAA,WAAA,WAAA,IAAA;AAIA,MAAAA,WAAA,UAAA,IAAA;AAIA,MAAAA,WAAA,KAAA,IAAA;IACF,GAbY,cAASF,SAAA,YAAT,YAAS,CAAA,EAAA;AAmBrB,QAAY;AAAZ,KAAA,SAAYG,4BAAyB;AAEnC,MAAAA,2BAAA,UAAA,IAAA;AAEA,MAAAA,2BAAA,YAAA,IAAA;IACF,GALY,8BAAyBH,SAAA,4BAAzB,4BAAyB,CAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1RrC,iBAAA,iBAAAI,QAAA;AACA,iBAAA,iBAAAA,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,gBAAAA,QAAA;AACA,iBAAA,uBAAAA,QAAA;AACA,iBAAA,gBAAAA,QAAA;AACA,iBAAA,gBAAAA,QAAA;AACA,iBAAA,kBAAAA,QAAA;AACA,iBAAA,iBAAAA,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,gBAAAA,QAAA;AACA,iBAAA,mBAAAA,QAAA;AACA,iBAAA,kBAAAA,QAAA;AACA,iBAAA,gBAAAA,QAAA;AACA,iBAAA,uBAAAA,QAAA;;;;;;;;;;;;;;;AChBA,QAAA,QAAA,gBAAA,aAAA;AACA,QAAA,eAAA;AACA,QAAA,SAAA;AAKA,QAAA,QAAA;AAeA,QAAa,qBAAb,cAAwC,aAAA,UAAS;aAAA;;;MAU/C,YAAY,OAAkB,IAAU;AACtC,cAAM,OAAO,EAAE;AATT,aAAA,uBAA+C,CAAA;AAE/C,aAAA,mBAA0B,CAAA;AAGlB,aAAA,kBACd,GAAA,OAAA,4BAA0B;AAI1B,cAAA,KAAK,GAAG,IAAI,EAAE,SAAS;MACzB;;;;;;;MAQO,MAAM,MAAY;AACvB,YAAI,KAAK,qBAAqB,IAAI,MAAM,QAAW;AAEjD,eAAK,qBAAqB,IAAI,IAAI,qBAChC,KAAK,gBACL,IAAI;QAER;AAEA,eAAO,KAAK,qBAAqB,IAAI;MACvC;;;;;;;MAQO,KAAK,SAA8B;AACxC,YAAI,SAAS,QAAQ;AACnB,eAAK,UAAU,QAAQ,MAAM;AAC7B,gBAAM,UAAS,GAAA,OAAA,yBACb,QAAQ,OAAO,aACX,QAAQ,OAAO,aACf,QAAQ,MAAM;AAEpB,kBAAO,GAAA,OAAA,0BAAyB,QAAQ,KAAK,cAAc;QAC7D;AACA,eAAO,KAAK;MACd;;;;;;MAOO,UAAU,QAAW;AAE1B,cAAM,cAAc,OAAO,aAAa,OAAO,aAAa;AAC5D,YAAI,CAAC,KAAK,iBAAiB,SAAS,WAAW,GAAG;AAChD,eAAK,iBAAiB,KAAK,WAAW;QACxC;MACF;;;;;;;;;MAUO,gBAAgB,QAAa,MAAc,mBAAmB,OAAK;AACxE,aAAK,UAAU,KAAK,qBAAqB,QAAQ,MAAM,gBAAgB,CAAC;MAC1E;;;;;;;;;;;;;;MAeO,qBACL,QACA,MACA,mBAAmB,OAAK;AAExB,cAAM,QAAQ,KAAK,MAAM,GAAG;AAE5B,YAAI,MAAM,WAAW,KAAK,SAAS,IAAI;AAErC,iBAAO;QACT;AAEA,cAAM,aAAa,MAAM,CAAC;AAG1B,eAAO;UACL,MAAM;UACN,YAAY;;YAEV,CAAC,UAAU,GAAG,KAAK,qBACjB,QACA,MAAM,MAAM,CAAC,EAAE,KAAK,GAAG,GACvB,gBAAgB;;UAGpB,UAAU,mBAAmB,CAAC,UAAU,IAAI,CAAA;;MAEhD;;;;MAKO,iBAAc;AACnB,YAAI,KAAK,iBAAiB,WAAW,GAAG;AACtC;QACF;AAEA,cAAM,0BAA0B;UAC9B,OAAO,CAAC,GAAG,KAAK,gBAAgB;;AAGlC,cAAM,MAAM,IAAI,MAAA,QAAI,EAAE,WAAW,KAAI,CAAE;AACvC,cAAM,YAAY,IAAI,QAAQ,uBAAuB;AACrD,cAAM,QAAQ,UAAU,KAAK,cAAc;AAE3C,YAAI,CAAC,OAAO;AACV,gBAAM,IAAI,MACR;IAAmC,UAAU,QACzC,IAAI,CAAC,UAAe,MAAM,OAAO,EAClC,KAAK,MAAM,CAAC;;;SAGd;QAEL;MACF;;AAjJF,IAAAC,SAAA,qBAAA;;;AA2JA,aAAgB,qBACd,eACA,MAAY;AAEZ,UAAI,CAAC,eAAe;AAClB,eAAO;MACT;AAEA,YAAM,YAAY,KAAK,MAAM,GAAG;AAEhC,UAAI,UAAU,WAAW,GAAG;AAC1B,eAAO,cAAc,UAAU,CAAC,CAAC;MACnC;AAGA,YAAM,WAAW,UAAU,MAAM,CAAC,EAAE,KAAK,GAAG;AAC5C,aAAO,qBAAqB,cAAc,UAAU,CAAC,CAAC,GAAG,QAAQ;IACnE;AAjBgB;AAAhB,IAAAA,SAAA,uBAAA;;;;;ACjLA;AAAA,8GAAAC,UAAA;AAAA;AACA,WAAO,eAAeA,UAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACD5D,QAAA,OAAA,QAAA,IAAA;AACA,QAAA,SAAA,QAAA,MAAA;AACA,QAAA,YAAA,QAAA,SAAA;AACA,QAAA,KAAA,aAAA,QAAA,IAAA,CAAA;AAEA,QAAA,SAAA;AAEA,QAAA,UAAA;AASA,QAAM,oBAAoB,CAAC,UAAU,YAAY,UAAU,KAAK;AAGnD,IAAAC,SAAA,oBAAoB;AAGjC,QAAa,kBAAb,MAA4B;aAAA;;;MAI1B,YAAY,SAA+B;AAFnC,aAAA,oBAAiC,CAAA;AAGvC,aAAK,gBAAgB,QAAQ,iBAAiB,CAAA;AAC9C,aAAK,0BAAyB;AAC9B,aAAK,wBAAuB;MAC9B;;;;;;;;;;;;;;MAeQ,4BAAyB;AAC/B,cAAM,qBAAqB,QAAQ,IAAI,0BAA0B,MAAM,GAAG;AAC1E,cAAM,YAAY,QAAQ,IAAI;AAE9B,YAAI,WAAW;AACb,gBAAM,yBAAwB,GAAA,OAAA,wBAAuB,SAAS;AAC9D,cAAI,uBAAuB;AACzB,iBAAK,cAAc,KAAK,GAAG,qBAAqB;UAClD;QACF;AAEA,YAAI,oBAAoB;AACtB,6BAAmB,QAAQ,CAAC,iBAAgB;AAC1C,kBAAM,4BAA2B,GAAA,OAAA,wBAAuB,YAAY;AACpE,gBAAI,0BAA0B;AAC5B,mBAAK,cAAc,KAAK,GAAG,wBAAwB;YACrD;UACF,CAAC;QACH;MACF;MAEQ,iBAAiB,cAAoB;AAC3C,cAAM,gBAAe,GAAA,OAAA,UAAS,YAAY;AAE1C,cAAM,YAAY,kBAAkB,SAAS,YAAY;AAEzD,cAAM,aAAa,aACf,GAAA,OAAA,MAAK,WAAW,aAAa,YAAY,WAAW,KACpD,GAAA,OAAA,MAAK,YAAY;AAErB,aAAK,kBAAkB,KACrB,YACI,KAAK,oBAAoB,UAAU,IACnC,oBAAoB,UAAU,CAAC;MAEvC;;;;;;MAOQ,oBAAoB,qBAA2B;AAErD,cAAM,iBAAiB,QAAQ,mBAAmB;AAClD,YAAI,CAAC,kBAAkB,CAAC,eAAe,UAAU;AAC/C,kBAAQ,MAAM,gCAAgC,mBAAmB,EAAE;AACnE;QACF;AAEA,eAAO,IAAI,eAAe,SAAQ;MACpC;MAEQ,0BAAuB;AAC7B,aAAK,oBAAoB,CAAA;AACzB,aAAK,cAAc,QAAQ,CAAC,iBAAgB;AAC1C,eAAK,iBAAiB,YAAY;QACpC,CAAC;MACH;;;MAIO,UAAU,UAAkB;AACjC,aAAK,wBAAuB;AAC5B,YAAI,UAAU,KAAK,kBAAkB,CAAC,EAAE;AAExC,YAAI,CAAC,SAAS;AACZ,gBAAM,IAAI,MACR,uCAAuC,KAAK,cAAc,CAAC,CAAC,gEAAgE;QAEhI;AAEA,YAAI,QAAQ,aAAa,KAAK,iBAAiB;AAE/C,cAAM,MAAM,QAAS;UACnB,GAAG;UACH,YAAY,MAAM;UAClB,sBAAsB,MAAM;SAC7B;AAED,YAAI,cAAc,CAAA;AAClB,mBAAW,KAAK,IAAI,KAAK,QAAO,GAAI;AAClC,cAAK,EAAU,QAAA,aAAa,GAAG;AAC7B,kBAAM,SAAS;AACf,wBAAY,KAAK,OAAO,IAAI;UAC9B;QACF;AAEA,YAAI,YAAY,SAAS,GAAG;AAC1B,WAAA,GAAA,KAAA,gBACE,GAAA,OAAA,MAAK,IAAI,QAAQA,SAAA,iBAAiB,GAClC,KAAK,UAAU,WAAW,CAAC;QAE/B;AAEA,YAAI,YAAY,IAAI;AAEpB,cAAM,iBAAiB,QAAQ,CAAC,WAAU;AACxC,oBAAU,UAAU,MAAM;QAC5B,CAAC;AAED,eAAO;MACT;MAEO,MAAM,aAAa,SAA+B;AACvD,cAAM,QAAQ,aAAa,KAAK,iBAAiB;AACjD,YAAI,CAAC,MAAM,kBAAkB;AAC3B,gBAAM,IAAI,MACR,4EAA4E;QAEhF;AACA,cAAM,MAAM,iBAAiB,OAAO;MACtC;;AAvIF,IAAAA,SAAA,kBAAA;AAgJA,aAAgB,oBAAoB,oBAA0B;AAC5D,YAAM,WAAW,mBAAmB,WAAW,GAAG;AAElD,YAAM,kBAAkB,YACpB,GAAA,OAAA,UAAQ,GAAA,OAAA,SAAQ,kBAAkB,CAAC,KACnC,GAAA,OAAA,SAAQ,kBAAkB;AAE9B,YAAM,eAAc,GAAA,OAAA,MAAK,iBAAiB,cAAc;AAQxD,YAAM,yBAAyB,mBAAmB,SAAS,KAAK,IAC5D,qBACA,YACA,GAAA,OAAA,MAAK,aAAa,GAAG,kBAAkB,eAAe,IACtD,GAAG,kBAAkB;AAGzB,YAAM,wBAAwB,mBAAmB,SAAS,KAAK,KAC3D,GAAA,OAAA,SAAQ,kBAAkB,IAC1B;AAEJ,YAAM,kBAAiB,GAAA,OAAA,OAAK,GAAA,UAAA,KAAG,GAAI,cAAc;AACjD,YAAM,qBAAoB,GAAA,OAAA,MAAK,gBAAgB,oBAAoB,KAAK;AAExE,YAAM,kBAAkB;QACtB,GAAGC,QAAO;QACV;QACA;QACA;QACA;;AAGF,YAAM,iBAAiB,wBAAC,SAAgB;AACtC,eAAO,QAAQ,QAAQ,MAAM;UAC3B,OAAO;SACR;MACH,GAJuB;AAMvB,YAAM,kBAAkB,wBAAC,SAAgB;AAEvC,eAAO,QAAQ,eAAe,IAAI,CAAC;MACrC,GAHwB;AAKxB,sBAAgB,UAAU;AAE1B,YAAM,iBAAiB;QACrB,SAAS,CAAA;;AAEX,YAAM,UAAU,GAAG,cAAc;QAC/B,SAAS;QACT;QACA,SAAS,eAAe;QACxB,QAAQ;QACR;QACA,WAAW;OACZ;AAED,UAAI;AACF,cAAM,gBAAe,GAAA,KAAA,cAAa,wBAAwB,OAAO;AACjE,cAAM,SAAS,IAAI,GAAG,OAAO,YAAY;AACzC,eAAO,aAAa,OAAO;AAC3B,eAAO,IAAK,eAAe,QAAgB,SAAQ;MACrD,SAAS,OAAO;AACd,YAAI,QAAQ,IAAI,OAAO;AACrB,kBAAQ,MAAM,KAAK;QACrB;AACA,cAAM,OAAO,mBAAmB,SAAS,GAAG,IACxC,+CACA,2EAA2E,kBAAkB;AACjG,gBAAQ,MACN,wDAAwD,kBAAkB;;SAAc,IAAI,GAAG;MAEnG;IACF;AA9EgB;AAAhB,IAAAD,SAAA,sBAAA;AAuFA,aAAS,aAAa,mBAA8B;AAClD,UAAI,SAA6B;QAC/B,YAAY;UACV,eAAe,CAAA;UACf,gBAAgB,CAAA;UAChB,UAAU,CAAA;;QAEZ,sBAAsB,CAAA;QACtB,kBAAkB,CAAA;QAClB,kBAAkB;;AAGpB,wBAAkB,QAAQ,CAAC,aAAY;AACrC,YAAI,SAAS,YAAY;AACvB,iBAAO,iBAAiB,KAAK,SAAS,UAAU;QAClD;AAEA,YAAI,SAAS,UAAU;AACrB,iBAAO,WAAW,cAAe,KAAK,SAAS,SAAS,KAAK,QAAQ,CAAC;QACxE;AAEA,YAAI,SAAS,WAAW;AACtB,iBAAO,WAAW,eAAgB,KAAK,SAAS,UAAU,KAAK,QAAQ,CAAC;QAC1E;AAEA,YAAI,SAAS,UAAU;AACrB,iBAAO,WAAW,SAAU,KAAK,SAAS,SAAS,KAAK,QAAQ,CAAC;QACnE;AAEA,YAAI,SAAS,aAAa;AACxB,iBAAO,qBAAqB,KAAK,SAAS,YAAY,KAAK,QAAQ,CAAC;QACtE;AAEA,YAAI,SAAS,cAAc;AACzB,iBAAO,mBAAmB,SAAS,aAAa,KAAK,QAAQ;QAC/D;MACF,CAAC;AAED,aAAO;IACT;AAvCS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7PT,iBAAA,+BAAAE,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,4BAAAA,QAAA;AACA,iBAAA,iBAAAA,QAAA;;;;;;;;;;;;;ACHA,QAAA,eAAA;AACA,QAAA,WAAA;AACA,QAAA,cAAA;AACA,QAAA,aAAA;AACA,QAAA,SAAA;AAyFA,QAAsB,MAAtB,cAAkC,aAAA,UAAS;aAAA;;;;;;MAIlC,OAAO,GAAG,OAAgB;AAC/B,eAAO,OAAA,KAAK,GAAG,KAAK,EAAE;MACxB;MA4DA,YAAY,OAAkB,IAAY,OAAe;AACvD,cAAM,OAAO,EAAE;AA1DD,aAAA,EAAA,IAAe;AAqBd,aAAA,cAAsC,CAAA;AAsCrD,YAAI,CAAC,MAAM,eAAe;AACxB,gBAAM,IAAI,MAAM,+CAA+C;QACjE;AAGA,YAAI,CAAC,MAAM,eAAe;AACxB,iBAAA,KAAK,UAAU,KAAK,WAAW;QACjC;AAEA,aAAK,gBAAgB,MAAM;AAC3B,aAAK,wBAAwB,MAAM,wBAAwB,CAAA;AAC3D,aAAK,cAAc,MAAM;AACzB,aAAK,oBAAoB,MAAM,qBAAqB;MACtD;;;;;;MAOA,IAAW,UAAO;AAChB,eAAO,GAAG,KAAK,MAAM;MACvB;;;;;MAMA,IAAW,aAAU;AACnB,YAAI,CAAC,KAAK,aAAa;AACrB,eAAK,cAAc,IAAI,WAAA,mBAAmB,MAAM,oBAAoB;QACtE;AACA,eAAO,KAAK;MACd;;;;;;;;;;;MAiBO,IACL,KACA,MACA,OACA,OACG,MAAW;AAGd,cAAM,WAAW,KAAK,OAAO,KAAK,OAAO,IAAI,GAAG,IAAI;AACpD,YAAI,UAAU;AACZ,iBAAO;QACT;AAGA,eAAO,IAAI,KAAK,OAAO,IAAI,GAAG,IAAI;MACpC;;;;MAKO,YACL,KACA,OACA,OACG,MAAW;AAGd,cAAM,WAAW,KAAK,OAAO,KAAK,OAAO,IAAI,GAAG,IAAI;AACpD,YAAI,CAAC,UAAU;AACb,gBAAM,WAAW,IAAI,QAAQ,GAAG,YAAA,gBAAgB,KAAK,EAAE;AACvD,gBAAM,gBAAgB,SAAS,MAAM,GAAG;AACxC,gBAAM,IAAI,SAAA,oBACR,aAAa,GAAG,iCAAiC,KAAK,OAAO,yGAAyG,QAAQ,IAC9K,EAAE,UAAU,cAAc,cAAc,SAAS,CAAC,EAAC,CAAE;QAEzD;AAEA,eAAO;MACT;MAEO,OAAO,OAAmB,SAAiB,IAAE;AAClD,cAAM,MAAM,GAAG,MAAM,KAAK,IAAI,IAAI,MAAM;AAExC,aAAK,YAAY,GAAG,IAAI,KAAK,YAAY,GAAG,KAAK;AAEjD,eAAO,GAAG,MAAM,GAAG,KAAK,YAAY,GAAG,GAAG;MAC5C;;;;;;;;MASU,WAAW,KAAW;AAC9B;AACA,eAAO;MACT;;;;;;;;;MAUQ,OACN,KACA,OACA,OACG,MAAW;AAGd,mBAAW,YAAY,KAAK,uBAAuB;AACjD,gBAAM,WAAW,SAAS,KAAK,OAAO,IAAI,GAAG,IAAI;AACjD,cAAI,UAAU;AACZ,mBAAO;UACT;QACF;AAEA,cAAM,OAAO,KAAK,WAAW,GAAG;AAChC,YAAI,CAAC,MAAM;AACT,iBAAO;QACT;AAEA,eAAO,IAAI,KAAK,OAAO,IAAI,GAAG,IAAI;MACpC;;AA9MF,IAAAC,SAAA,MAAA;kCASmB,OAAA;;AAwMnB,aAAgB,2BAA2B,KAAQ;AACjD,iBAAW,KAAK,IAAI,KAAK,QAAO,GAAI;AAClC,YAAI,OAAQ,EAAgB,mBAAmB,YAAY;AACxD,YAAgB,eAAc;QACjC;MACF;IACF;AANgB;AAAhB,IAAAA,SAAA,6BAAA;;;;;;;;;;AC9Sa,IAAAC,SAAA,sCAAsC;;;;;;;;;;;;;ACEnD,QAAA,eAAA;AAeA,QAAa,kBAAb,MAA4B;aAAA;;;MAG1B,YAAY,MAAU;AACpB,aAAK,gBAAgB,IAAI,iBAAgB;AAEzC,cAAM,QAA0C,CAAA;AAEhD,iBAAS,UAAU,WAAqB;AACtC,gBAAM,aAAA,KAAK,GAAG,SAAS,EAAE,IAAI,IAAI,IAAI,iBAAiB,SAAS;QACjE;AAFS;AAIT,iBAAS,UAAU,WAAqB;AACtC,iBAAO,MAAM,aAAA,KAAK,GAAG,SAAS,EAAE,IAAI;QACtC;AAFS;AAKT,mBAAW,KAAK,KAAK,QAAO,GAAI;AAC9B,oBAAU,CAAC;QACb;AAEA,cAAM,OAAO,CAAA;AACb,mBAAW,SAAS,KAAK,QAAO,GAAI;AAClC,qBAAW,OAAO,MAAM,KAAK,cAAc;AACzC,iBAAK,KAAK,EAAE,QAAQ,OAAO,QAAQ,IAAG,CAAE;UAC1C;QACF;AAGA,mBAAW,OAAO,MAAM;AACtB,cAAI,CAAC,UAAU,IAAI,MAAM,GAAG;AAK1B;UACF;AAEA,gBAAM,gBAAgB,UAAU,IAAI,MAAM;AAC1C,gBAAM,gBAAgB,UAAU,IAAI,MAAM;AAE1C,wBAAc,SAAS,aAAa;QACtC;AAGA,mBAAW,KAAK,OAAO,OAAO,KAAK,GAAG;AACpC,cAAI,EAAE,QAAQ,WAAW,GAAG;AAE1B,iBAAK,cAAc,SAAS,CAAC;UAC/B;QACF;MACF;;;;;;;MAQA,IAAW,OAAI;AACb,eAAO,KAAK;MACd;;;;MAKO,WAAQ;AACb,eAAO,KAAK,cAAc,SAAQ;MACpC;;AApEF,IAAAC,SAAA,kBAAA;;;AA4EA,QAAa,mBAAb,MAA6B;aAAA;;;MAO3B,YAAY,QAAgC,QAAS;AALpC,aAAA,YACf,oBAAI,IAAG;AACQ,aAAA,WACf,oBAAI,IAAG;AAGP,aAAK,SAAS;MAChB;;;;;;MAOA,IAAW,QAAK;AACd,eAAO,KAAK;MACd;;;;MAKA,IAAW,WAAQ;AACjB,eAAO,MAAM,KAAK,KAAK,SAAS;MAClC;;;;MAKA,IAAW,UAAO;AAChB,eAAO,MAAM,KAAK,KAAK,QAAQ;MACjC;;;;MAKO,WAAQ;AACb,cAAM,QAAQ,oBAAI,IAAG;AACrB,cAAM,WAA+B,CAAA;AAErC,iBAAS,MAAM,GAAmB;AAChC,qBAAW,KAAK,EAAE,UAAU;AAC1B,kBAAM,CAAC;UACT;AACA,cAAI,CAAC,MAAM,IAAI,CAAC,GAAG;AACjB,qBAAS,KAAK,CAAC;AACf,kBAAM,IAAI,CAAC;UACb;QACF;AARS;AAUT,cAAM,IAAI;AAEV,eAAO,SAAS,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,KAAM;MAC5D;;;;;;;;;MAUO,SAAS,KAAqB;AACnC,cAAM,QAA4B,IAAI,UAAU,IAAI;AACpD,YAAI,MAAM,WAAW,GAAG;AACtB,gBAAM,KAAK,GAAG;AACd,gBAAM,IAAI,MACR,8BAA8B,MAC3B,OAAO,CAAC,MAAM,EAAE,KAAK,EACrB,IAAI,CAAC,MAAM,aAAA,KAAK,GAAG,EAAE,KAAM,EAAE,IAAI,EACjC,KAAK,MAAM,CAAC,EAAE;QAErB;AAEA,aAAK,UAAU,IAAI,GAAG;AACtB,YAAI,UAAU,IAAI;MACpB;MAEQ,UAAU,KAAqB;AACrC,aAAK,SAAS,IAAI,GAAG;MACvB;MAEQ,UAAU,KAAqB;AACrC,cAAM,QAA4B,CAAA;AAClC,cAAM,IAAI;AACV,eAAO;AAEP,iBAAS,MAAM,GAAmB;AAChC,gBAAM,KAAK,CAAC;AACZ,cAAI,QAAQ;AACZ,qBAAW,KAAK,EAAE,UAAU;AAC1B,gBAAI,MAAM,KAAK;AACb,oBAAM,KAAK,CAAC;AACZ,qBAAO;YACT;AACA,oBAAQ,MAAM,CAAC;UACjB;AACA,cAAI,CAAC,OAAO;AACV,kBAAM,IAAG;UACX;AACA,iBAAO;QACT;AAdS;MAeX;;AAxGF,IAAAA,SAAA,mBAAA;;;;;;;;;;;;;;AC3FA,QAAA,SAAA;AACA,QAAA,aAAA;AAEa,IAAAC,SAAA,0BAA0B,OAAO,IAC5C,kCAAkC;AAQpC,QAAsB,kBAAtB,cAA8C,WAAA,SAAQ;aAAA;;;;;;MAI7C,OAAO,kBAAkB,GAAa;AAC3C,eAAQ,EAAUA,SAAA,uBAAuB,MAAM;MACjD;MASA,YAAY,OAAkB,IAAU;AACtC,cAAM,OAAO,EAAE;AAEf,eAAA,KAAK,GAAG,IAAI,EAAE,SAAS;AACvB,eAAO,eAAe,MAAMA,SAAA,yBAAyB;UACnD,OAAO;UACP,YAAY;UACZ,UAAU;SACX;MACH;;AAxBF,IAAAA,SAAA,kBAAA;;;;;;;;;;;;ACDO,QAAM,iBAAiB,wBAAC,aAAyC;AACtE,aAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,SAAS,YAAY,EAAE;IAC3B,GAd8B;AAAjB,IAAAC,SAAA,iBAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACb3B,QAAA,KAAA,aAAA,QAAA,IAAA,CAAA;AACA,QAAA,OAAA,aAAA,QAAA,MAAA,CAAA;AAGA,QAAA,QAAA;AACA,QAAA,SAAA;AACA,QAAA,WAAA;AAEa,IAAAC,SAAA,iBAAiB;AA+J9B,QAAM,sBAAsB,OAAO,IAAI,WAAW;AAiBlD,aAAS,2BACP,WAAqB;AAErB,YAAM,kBACJ,OAAO,eAAe,SAAS,EAAE,YAAY,mBAAmB;AAClE,UACE,OAAO,oBAAoB,YAC3B,oBAAoB,QACpB,OAAO,gBAAgB,QAAQ,YAC/B,OAAO,gBAAgB,YAAY,UACnC;AACA,eAAO,EAAE,KAAK,gBAAgB,KAAK,SAAS,gBAAgB,QAAO;MACrE;AACA,aAAO;IACT;AAdS;AAgBT,aAAgB,eAAe,KAAU,QAAc;AACrD,YAAM,QAAQ,wBAAC,cAA4C;AACzD,cAAM,WAAW,UAAU,KAAK,SAAS,IAAI,CAAC,MAAM,MAAM,CAAC,CAAC;AAC5D,cAAM,cAAc,SACjB,OAAO,CAAC,UAAU,UAAU,MAAS,EACrC,OAAO,CAAC,KAAK,UAAU,OAAO,OAAO,KAAK,EAAE,CAAC,MAAO,EAAE,GAAG,MAAK,CAAE,GAAG,CAAA,CAAE;AAExE,cAAM,OAA0B;UAC9B,IAAI,UAAU,KAAK,MAAM;UACzB,MAAM,UAAU,KAAK;UACrB,UAAU,OAAO,KAAK,WAAW,EAAE,WAAW,IAAI,SAAY;UAC9D,eAAe,2BAA2B,SAAS;UACnD,SAAS,aAAa,SAAS;;AAGjC,eAAO;MACT,GAfc;AAiBd,YAAM,OAAsB;QAC1B,SAAS;QACT,MAAM,MAAM,IAAI,KAAK,IAAI;;AAG3B,SAAG,cACD,KAAK,KAAK,QAAQA,SAAA,cAAc,GAChC,KAAK,UAAU,MAAM,QAAW,CAAC,GACjC,EAAE,UAAU,OAAM,CAAE;IAExB;AA5BgB;AAAhB,IAAAA,SAAA,iBAAA;AA8BA,aAAS,aAAa,WAAqB;AACzC,YAAM,UAAU,MAAA,KAAK,GAAG,SAAS;AAEjC,YAAM,KAAoB,CAAA;AAE1B,iBAAW,SAAS,UAAU,KAAK,UAAU;AAC3C,YACE,OAAA,gBAAgB,kBAAkB,KAAK,KACvC,MAAM,eAAe,QACrB;AACA,aAAG,KAAK,MAAM,eAAc,CAAE;QAChC;MACF;AAEA,UACE,QAAQ,eACR,QAAQ,SACR,QAAQ,UACR,MACA,QAAQ,SACR,QAAQ,QACR,QAAQ,UACR;AACA,eAAO;UACL,OAAO,QAAQ;UACf,aAAa,QAAQ;UACrB,QAAQ,QAAQ;UAChB,cAAc,QAAQ;UACtB,IAAI,GAAG,SAAS,IAAI,KAAK;UACzB,QAAO,GAAA,SAAA,gBAAe,QAAQ,KAAK,IAAI,QAAQ,QAAQ;UACvD,MAAM,QAAQ;UACd,UAAU,QAAQ;;MAEtB;AACA;IACF;AAnCS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtOT,iBAAA,eAAAC,QAAA;AACA,iBAAA,sBAAAA,QAAA;AACA,iBAAA,uBAAAA,QAAA;AACA,iBAAA,uBAAAA,QAAA;AACA,iBAAA,oBAAAA,QAAA;AACA,iBAAA,mBAAAA,QAAA;AACA,iBAAA,gBAAAA,QAAA;;;;;;;;;;;;ACNA,QAAA,OAAA,QAAA,IAAA;AACA,QAAA,SAAA,QAAA,MAAA;AAGA,QAAA,WAAA;AACA,QAAA,SAAA;AACA,QAAA,SAAA;AACA,QAAA,mBAAA;AAEA,QAAA,QAAA;AAwDa,IAAAC,SAAA,mBAAmB;AAMhC,QAAa,WAAb,cACU,MAAA,SAAW;aAAA;;;MAYnB,YAAY,OAAkB,IAAY,SAAyB;AACjE,cAAM,OAAO,EAAE;AANA,aAAA,cAA6C,CAAA;AAC7C,aAAA,OAA+B,CAAA;AAO9C,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AACtB,cAAA,KAAK,GAAG,IAAI,EAAE,cAAc;AAC5B,cAAA,KAAK,GAAG,IAAI,EAAE,QAAQ;AAEtB,cAAM,YAAY,iBAAA,cAAc,aAAa,MAAM;UACjD,iBAAiB;;UACjB,MAAM,iBAAA,gBAAgB;UACtB,KAAK;SACN;AAED,cAAM,UAAU,OAAA,IAAI,GAAG,IAAI,EAAE;AAC7B,SAAA,GAAA,KAAA,WAAU,SAAS,EAAE,WAAW,KAAI,CAAE;AACtC,cAAM,cAAa,GAAA,OAAA,MAAK,SAAS,GAAG,SAAS,MAAM;AACnD,aAAK,aAAa;AAElB,YAAI,QAAQ,IAAI,aAAa;AAC3B,eAAK,eAAe,eAAe,QAAQ,IAAI,WAAW;QAC5D;AAEA,aAAK,UAAU;MACjB;MAEO,cAAc,UAAwB,IAAU;AACrD,aAAK,YAAY,KAAK,CAAC,UAAU,EAAE,CAAC;MACtC;;MAGA,IAAW,WAAQ;AACjB,eAAO;UACL,CAAC,wBAAwB,IAAI,GAAG,CAAA;;MAEpC;;;;;;;;;;;;MAaO,YAAY,MAAY;AAC7B,gBAAO,GAAA,SAAA,oBAAmB,MAAM,IAAI;MACtC;;MAGO,iBAAc;AACnB,cAAM,eAAc;AACpB,cAAM,eAAe;AACrB,cAAM,iBAAiB,KAAK,QAAQ,YAAW;AAC/C,cAAM,OAAO;;;;;;;;;;;;;;2BAeU,cAAc;2BACd,YAAY;;;;;;;;;;;;;8BAaT,YAAY;wCACF,YAAY;;;;;;;;;;;;;;;;;;;yBAmB3B,YAAY;;;;AAKjC,SAAA,GAAA,KAAA,eAAc,KAAK,YAAY,IAAI;AAInC,eAAA,QAAQ,KAAK,KAAK,SAAS,MAAM,CAAC,QAAQ,CAAC;MAC7C;;;;MAKO,eAAe,MAAc,OAAa;AAC/C,YAAI,KAAK,KAAK,IAAI,MAAM,UAAa,KAAK,KAAK,IAAI,MAAM,OAAO;AAC9D,gBAAM,IAAI,MACR,yBAAyB,IAAI,uCAAuC;QAExE;AACA,aAAK,KAAK,IAAI,IAAI;MACpB;MAEO,cAAW;AAChB,cAAM,SAAiC,CAAA;AACvC,mBAAW,CAAC,UAAU,SAAS,KAAK,KAAK,aAAa;AACpD,iBAAO,KAAK;YACV;YACA,iBAAgB,GAAA,SAAA,sBAAqB,QAAQ;WAC9C;QACH;AACA,cAAM,QAA2B;UAC/B,sBAAsB,KAAK;UAC3B,iBAAgB,GAAA,OAAA,UAAS,OAAA,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK,UAAU;UAC7D,oBAAoB;;AAEtB,eAAO;UACL,MAAMA,SAAA;UACN;UACA;;MAEJ;MAEO,OAAO,MAAqB,KAAa;AAC9C,SAAA,GAAA,OAAA,uBAAsB,YAAY,MAAM,MAAM,GAAG;AACjD,cAAM,OAAO,MAAM,GAAG;MACxB;;MAGO,cAAW;AAChB,gBAAO,GAAA,OAAA,uBAAsB,YAAY,IAAI;MAC/C;;AA1KF,IAAAA,SAAA,WAAA;;;AA4LA,QAAY;AAAZ,KAAA,SAAYC,0BAAuB;AACjC,MAAAA,yBAAA,MAAA,IAAA;IACF,GAFY,4BAAuBD,SAAA,0BAAvB,0BAAuB,CAAA,EAAA;AAsCnC,aAAgB,wBACd,KAAQ;AAER,aACE,OAAO,OAAO,YACd,OAAQ,IAA+B,kBAAkB;IAE7D;AAPgB;AAAhB,IAAAA,SAAA,0BAAA;AAmBA,aAAgB,oBAAoB,KAAQ;AAC1C,aACE,OAAO,OAAO,YACd,OAAQ,IAA2B,gBAAgB;IAEvD;AALgB;AAAhB,IAAAA,SAAA,sBAAA;;;;;;;;;;AC5TA,QAAA,OAAA,QAAA,IAAA;AACA,QAAA,SAAA,QAAA,MAAA;AACA,QAAA,SAAA,QAAA,MAAA;AAEA,QAAA,aAAA;AACA,QAAA,WAAA;AAQO,mBAAe,OAAO,UAAgB;AAC3C,UAAI;AACF,eAAM,GAAA,OAAA,WAAU,KAAA,MAAM;UACpB;UACA,KAAA,UAAU,OAAO,KAAA,UAAU,OAAO,KAAA,UAAU;;;AAE9C,eAAO;MACT,SAAS,IAAI;AACX,eAAO;MACT;IACF;AAVsB;AAAtB,IAAAE,SAAA,SAAA;AAYA,aAAS,eAAe,MAAc,UAAoB;AACxD,aAAO,GAAG,KACP,YAAW,EACX,QAAQ,YAAY,GAAG,CAAC,WAAW,SAAS,KAAK,KAAK,MAAM,EAAE,CAAC;IACpE;AAJS;AAMT,aAAgB,sBACd,UACA,UACA,MACA,KAAa;AAGb,UAAI,EAAC,GAAA,WAAA,yBAAwB,IAAI,GAAG;AAClC,cAAM,IAAI,MACR,qFAAqF;MAEzF;AACA,YAAM,QAAO,GAAA,OAAA,UAAS,QAAQ,EAAE,MAAM,GAAG,EAAE,CAAC;AAC5C,YAAM,MAAM,eAAe,MAAM,QAAQ;AACzC,YAAM,UAAS,GAAA,SAAA,sBAAqB,QAAQ;AAC5C,WAAK,eAAe,KAAK,MAAM;AAC/B,WAAK,KAAK,cAAc,QAAQ;AAChC,iBAAW,MAAM,KAAK;AACpB,aAAK,cAAc,UAAU,EAAE;MACjC;IACF;AApBgB;AAAhB,IAAAA,SAAA,wBAAA;AAsBA,aAAgB,sBAAsB,UAAkB,UAAkB;AACxE,YAAM,QAAO,GAAA,OAAA,UAAS,QAAQ,EAAE,MAAM,GAAG,EAAE,CAAC;AAC5C,YAAM,MAAM,eAAe,MAAM,QAAQ;AACzC,aAAO;6BACoB,GAAG;;qDAEqB,GAAG;;;;;;;;;;;;IAYxD;AAlBgB;AAAhB,IAAAA,SAAA,wBAAA;AAoBA,aAAgB,wBAAwB,UAAkB,UAAkB;AAC1E,YAAM,QAAO,GAAA,OAAA,UAAS,QAAQ,EAAE,MAAM,GAAG,EAAE,CAAC;AAC5C,YAAM,MAAM,eAAe,MAAM,QAAQ;AACzC,aAAO;6BACoB,GAAG;;qDAEqB,GAAG;;;;;;;;;;;;;;;;;;;;IAoBxD;AA1BgB;AAAhB,IAAAA,SAAA,0BAAA;AA8BA,aAAgB,gCAAgC,KAAa;AAC3D,UAAI,IAAI,UAAU,MAAM,GAAG;AAEzB,cAAM,IAAI,MAAM,0DAA0D;MAC5E;AAEA,YAAM,iBAAiB,KAAK,MAAM,IAAI,OAAO;AAE7C,YAAM,IAAI,KAAK,MAAM,iBAAiB,EAAE;AACxC,YAAM,IAAI,iBAAiB;AAE3B,YAAM,SAAS,KAAK,IAAI,KAAK,CAAC,KAAK;AACnC,YAAM,OAAO,KAAK,IAAI,KAAK,CAAC,KAAK;AAGjC,YAAM,aAAa;AACnB,YAAM,QAAQ;AACd,YAAM,YAAY;AAGlB,YAAM,aAAa,GAAG,MAAM,IAAI,IAAI,IAAI,UAAU,IAAI,KAAK,IAAI,SAAS;AACxE,aAAO;IACT;AAtBgB;AAAhB,IAAAA,SAAA,kCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvGA,QAAA,KAAA,aAAA,QAAA,IAAA,CAAA;AACA,QAAA,SAAA,QAAA,MAAA;AAGA,QAAA,SAAA;AAGA,QAAM,kBAAkB;AAExB,QAAa,iBAAb,MAA2B;aAAA;;;MAKzB,YAAmB,KAAuB,OAA0B;AAClE,aAAK,MAAM;AACX,aAAK,UAAU,MAAM,WAAW;AAChC,aAAK,UAAS,oBAAI,IAAG,GAAG,IAAI,WAAW,KAAK,OAAO;MACrD;MAEO,MAAM,UAAO;AAElB,cAAM,cAAa,GAAA,OAAA,MAAK,MAAM,KAAK,IAAI,SAAQ,GAAI,eAAe;AAClE,cAAM,mBAAmB,OAAM,GAAA,OAAA,QAAO,UAAU;AAChD,YAAI,kBAAkB;AACpB,gBAAM,iBAAiB,MAAM,GAAG,SAAS,SAAS,YAAY,OAAO;AACrE,gBAAM,SAAS,KAAK,MAAM,cAAc;AACxC,eAAK,SAAS,IAAI,IAAI,MAAM;QAC9B;MACF;MAEO,MAAM,SAAM;AAEjB,WAAG,eACD,GAAA,OAAA,MAAK,MAAM,KAAK,IAAI,SAAQ,GAAI,eAAe,GAC/C,KAAK,UAAU,MAAM,KAAK,KAAK,OAAO,QAAO,CAAE,CAAC,CAAC;MAErD;MAEO,MAAM,IACX,SAAiB,GACjB,MAAc,WAAS;AAEvB,cAAM,OAAO,KAAK,OAAO,IAAI,GAAG,KAAK,KAAK;AAC1C,aAAK,OAAO,IAAI,KAAK,OAAO,MAAM;AAClC,eAAO;MACT;MAEO,MAAM,IACX,SAAiB,GACjB,MAAc,WAAS;AAEvB,cAAM,OAAO,KAAK,OAAO,IAAI,GAAG,KAAK,KAAK;AAC1C,aAAK,OAAO,IAAI,KAAK,OAAO,MAAM;AAClC,eAAO;MACT;MAEO,MAAM,KAAK,MAAc,WAAS;AACvC,eAAO,KAAK,OAAO,IAAI,GAAG,KAAK,KAAK;MACtC;MAEO,MAAM,IAAI,OAAe,MAAc,WAAS;AACrD,aAAK,OAAO,IAAI,KAAK,KAAK;MAC5B;;AAtDF,IAAAC,SAAA,iBAAA;;;;;ACRQ,IAAI;AACJ,QAAQ,QAAQ,eAAe,UAAU;AACvC,MAAI,QAAQ;AACV,UAAM,MAAM,0BAA0B;AAAA,EACxC;AACA,QAAM,QAAQ,CAAC;AACf,QAAM,MAAM,CAAC;AACb,MAAI,WAAW,YAAY;AAC3B,MAAI,eAAe,OAAO,MAAM,UAAU,MAAM,IAAI,IAAI;AACxD,MAAI,MAAM,OAAO,SAAS,UAAU;AAClC,QAAI,CAAC;AAAO,cAAQ;AACpB,YAAQ,IAAI,QAAQ,MAAM,OAAO;AAAA,EACnC;AACA,QAAM,SAAU,OAAO,YAAY;AAC3C,UAAM,QAAQ,8BAAOC,MAAK,eAAe;AAE/B,YAAM;AAAA;AAAA,QAEN,2BAAyD;AAAA;AACzD,YAAM,UAAU,IAAI,eAAe,YAAY,EAAE,SAASA,KAAI,QAAQ,CAAC;AACvE,YAAM,QAAQ,QAAQ;AACtB,aAAO;AAAA,IACX,GARQ;AASd,UAAM,OAAO;AAAA,MACb,SAAS;AAAA,IACT;AACA,QAAI,cAAc,iCAAU,SAAS;AACnC,aAAO,MAAM,MAAM,GAAG,IAAI;AAAA,IAC5B,GAFkB;AAGlB,gBAAY,SAAS;AACrB,WAAO;AAAA,EACT,GACE;AACQ,QAAM,OAAO,EAAE,QAAQ,MAAM;AAAA,EAAC,EAAE;AAChC,QAAM,QAAS,MAAM,OAAO,OAAO,GAAG,KAAM;AAC5C,MAAI,eAAe,MAAM;AACvB,UAAM,MAAM,oDAAoD;AAAA,EAClE;AACA,WAAS;AACT,SAAO;AACT;AAEA,QAAQ,OAAO,eAAe,aAAa,MAAM;AAC/C,MAAI,CAAC,QAAQ;AACX,UAAM,MAAM,0DAA0D;AAAA,EACxE;AACA,MAAI,aAAa,UAAU;AACzB,UAAM,MAAM,sBAAsB;AAAA,EACpC;AACA,QAAM,OAAO,OAAO,QAAQ;AAC5B,MAAI,CAAC,MAAM;AACT,UAAM,MAAM,yBAAyB,WAAW,aAAa;AAAA,EAC/D;AACA,MAAI,OAAO,SAAS,YAAY;AAC9B,QAAI,KAAK,SAAS,GAAG;AACnB,YAAM,MAAM,eAAe,WAAW,qBAAqB;AAAA,IAC7D;AACA,WAAO;AAAA,EACT;AACA,SAAO,MAAM,KAAK,KAAK,QAAQ,GAAG,IAAI;AACxC;AAEA,QAAQ,OAAO,iBAAiB;AAC9B,MAAI,CAAC,QAAQ;AACX,UAAM,MAAM,0DAA0D;AAAA,EACxE;AACA,QAAM,OAAO,OAAO;AACpB,WAAS;AACX;AAER,QAAQ,GAAG,qBAAqB,CAAC,WAAW;AAC1C,UAAQ,KAAK,EAAE,MAAM,SAAS,OAAO,CAAC;AACxC,CAAC;AAED,QAAQ,GAAG,WAAW,OAAO,YAAY;AACvC,QAAM,EAAE,IAAI,KAAK,IAAI;AACrB,QAAM,QAAQ,MAAM,QAAQ,EAAE,EAAE,GAAG,IAAI;AACvC,UAAQ,KAAK,EAAE,MAAM,MAAM,MAAM,CAAC;AACpC,CAAC;","names":["exports","exports","exports","exports","exports","exports","ConstructOrder","exports","exports","exports","exports","module","exports","exports","UsedValueState","exports","exports","exports","Type","exports","exports","exports","exports","exports","DataType","exports","exports","exports","exports","_a","exports","exports","module","exports","module","exports","baseId","exports","exports","exports","exports","exports","module","merge","sets","length","slice","xl","x","join","subexp","str","typeOf","o","undefined","Object","prototype","toString","call","split","pop","shift","toLowerCase","toUpperCase","toArray","obj","Array","setInterval","assign","target","source","key","buildExps","isIRI","ALPHA$$","CR$","DIGIT$$","DQUOTE$$","HEXDIG$$","SP$$","PCT_ENCODED$","SUB_DELIMS$$","RESERVED$$","GEN_DELIMS$$","UCSCHAR$$","SCHEME$","USERINFO$","UNRESERVED$$","DEC_OCTET$","DEC_OCTET_RELAXED$","H16$","LS32$","IPV4ADDRESS$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","ZONEID$","IPV6ADDRESS$","IP_LITERAL$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","HOST$","REG_NAME$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","PATH$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","QUERY$","IPRIVATE$$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","URI_REFERENCE$","ABSOLUTE_URI$","GENERIC_REF$","RELATIVE_REF$","ABSOLUTE_REF$","SAMEDOC_REF$","AUTHORITY_REF$","RegExp","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","error","type","RangeError","map","array","fn","result","mapDomain","string","parts","replace","labels","encoded","ucs2decode","output","counter","value","charCodeAt","extra","push","ucs2encode","fromCodePoint","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","i","n","bias","basic","lastIndexOf","j","index","oldi","w","t","baseMinusT","out","splice","encode","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","qMinusT","toUnicode","test","toASCII","punycode","SCHEMES","pctEncChar","chr","c","e","pctDecChars","newStr","il","parseInt","substr","c2","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","UNRESERVED","scheme","PCT_ENCODED","NOT_SCHEME","userinfo","NOT_USERINFO","host","NOT_HOST","path","NOT_PATH","NOT_PATH_NOSCHEME","query","NOT_QUERY","fragment","NOT_FRAGMENT","_stripLeadingZeros","_normalizeIPv4","matches","IPV4ADDRESS","address","_normalizeIPv6","IPV6ADDRESS","zone","reverse","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","allZeroFields","reduce","acc","field","lastLongest","longestZeroFields","sort","a","b","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","parse","uriString","options","iri","IRI_PROTOCOL","URI_PROTOCOL","reference","port","isNaN","indexOf","schemeHandler","unicodeSupport","domainHost","_recomposeAuthority","uriTokens","_","$1","$2","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","s","Error","serialize","authority","charAt","absolutePath","resolveComponents","relative","skipNormalization","tolerant","resolve","baseURI","relativeURI","schemelessOptions","normalize","uri","equal","uriA","uriB","escapeComponent","ESCAPE","unescapeComponent","handler","secure","http","isSecure","wsComponents","resourceName","ws","O","ATEXT$$","QTEXT$$","VCHAR$$","SOME_DELIMS$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","mailtoComponents","to","unknownHeaders","headers","hfields","hfield","toAddrs","subject","body","addr","toAddr","atIdx","localPart","domain","name","URN_PARSE","urnComponents","nid","nss","urnScheme","uriComponents","UUID","uuidComponents","uuid","https","wss","mailto","urn","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","DiscrError","exports","exports","exports","module","module","exports","exports","module","node","text","expected","found","line","column","exports","module","nodes","exports","module","exports","exports","exports","exports","exports","exports","res","exports","res","exports","anchors","exports","exports","node","exports","exports","exports","i","end","exports","exports","exports","exports","exports","value","exports","exports","stringify","comment","str","exports","exports","map","exports","exports","seq","exports","exports","exports","exports","exports","exports","exports","require_schema","exports","exports","exports","pairs","exports","omap","require_bool","exports","require_float","exports","require_int","exports","n","exports","set","exports","res","require_schema","exports","exports","exports","exports","exports","res","require_errors","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","exports","value","end","exports","exports","tag","exports","exports","exports","exports","exports","exports","exports","exports","exports","ch","exports","require_parser","exports","start","exports","lineCounter","exports","exports","Array","exports","exports","Boolean","exports","exports","exports","exports","exports","exports","exports","exports","exports","Map","exports","exports","exports","Number","exports","exports","exports","Set","exports","String","exports","exports","exports","exports","ApiInflightMethods","HttpMethod","exports","TopicInflightMethods","exports","BucketSignedUrlAction","BucketEventType","BucketInflightMethods","exports","CounterInflightMethods","exports","exports","CaseConventions","exports","exports","Function","FunctionInflightMethods","exports","exports","QueueInflightMethods","exports","exports","ScheduleInflightMethods","exports","SecretInflightMethods","exports","ServiceInflightMethods","exports","exports","exports","LogLevel","TraceType","TestRunnerInflightMethods","exports","exports","exports","exports","module","exports","exports","exports","exports","exports","exports","exports","exports","exports","ResourceInflightMethods","exports","exports","ctx"]}
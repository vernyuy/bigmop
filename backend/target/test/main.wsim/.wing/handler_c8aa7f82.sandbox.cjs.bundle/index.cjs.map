{"version":3,"sources":["../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/util/equality.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/helpers.ts","../../../../../../node_modules/@winglibs/websockets/lib.w","../handler_c8aa7f82.sandbox.cjs"],"sourcesContent":["// taken from node 18 https://github.com/nodejs/node/blob/v18.x/lib/internal/util/comparisons.js\n\nimport {\n  isAnyArrayBuffer,\n  isArrayBufferView,\n  isDate,\n  isMap,\n  isRegExp,\n  isSet,\n  isNativeError,\n  isBoxedPrimitive,\n  isNumberObject,\n  isStringObject,\n  isBooleanObject,\n  isSymbolObject,\n  isFloat32Array,\n  isFloat64Array,\n} from \"util/types\";\n\nconst kNoIterator = 0;\nconst kIsArray = 1;\nconst kIsSet = 2;\nconst kIsMap = 3;\n\nexport function deepStrictEqual(val1: any, val2: any, memos?: any) {\n  // All identical values are equivalent, as determined by ===.\n  if (val1 === val2) {\n    if (val1 !== 0) return true;\n    return Object.is(val1, val2);\n  }\n\n  // Check more closely if val1 and val2 are equal.\n  if (typeof val1 !== \"object\") {\n    return typeof val1 === \"number\" && Number.isNaN(val1) && Number.isNaN(val2);\n  }\n  if (typeof val2 !== \"object\" || val1 === null || val2 === null) {\n    return false;\n  }\n  if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {\n    return false;\n  }\n\n  const val1Tag = val1.toString();\n  const val2Tag = val2.toString();\n\n  if (val1Tag !== val2Tag) {\n    return false;\n  }\n\n  if (Array.isArray(val1)) {\n    // Check for sparse arrays and general fast path\n    if (!Array.isArray(val2) || val1.length !== val2.length) {\n      return false;\n    }\n    const keys1 = getOwnNonIndexProperties(val1); // 179\n    const keys2 = getOwnNonIndexProperties(val2);\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, memos, kIsArray, keys1);\n  } else if (val1Tag === \"[object Object]\") {\n    return keyCheck(val1, val2, memos, kNoIterator);\n  } else if (isDate(val1)) {\n    if (!isDate(val2) || val1.getTime() !== val2.getTime()) {\n      return false;\n    }\n  } else if (isRegExp(val1)) {\n    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {\n      return false;\n    }\n  } else if (isNativeError(val1) || val1 instanceof Error) {\n    // Do not compare the stack as it might differ even though the error itself\n    // is otherwise identical.\n    if (\n      (!isNativeError(val2) && !(val2 instanceof Error)) ||\n      val1.message !== val2.message ||\n      val1.name !== val2.name\n    ) {\n      return false;\n    }\n  } else if (isArrayBufferView(val1)) {\n    if (!areSimilarTypedArrays(val1, val2)) {\n      return false;\n    }\n\n    if (\n      !areSimilarTypedArrays(val1, val2) &&\n      !isFloat32Array(val1) &&\n      !isFloat64Array(val1)\n    ) {\n      return false;\n    }\n    // Buffer.compare returns true, so val1.length === val2.length. If they both\n    // only contain numeric keys, we don't need to exam further than checking\n    // the symbols.\n    const keys1 = getOwnNonIndexProperties(val1);\n    const keys2 = getOwnNonIndexProperties(val2);\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, memos, kNoIterator, keys1);\n  } else if (isSet(val1)) {\n    if (!isSet(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, memos, kIsSet);\n  } else if (isMap(val1)) {\n    if (!isMap(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, memos, kIsMap);\n  } else if (isAnyArrayBuffer(val1)) {\n    if (!isAnyArrayBuffer(val2) || !areEqualArrayBuffers(val1, val2)) {\n      return false;\n    }\n  } else if (isBoxedPrimitive(val1)) {\n    if (!isEqualBoxedPrimitive(val1, val2)) {\n      return false;\n    }\n  } else if (\n    Array.isArray(val2) ||\n    isArrayBufferView(val2) ||\n    isSet(val2) ||\n    isMap(val2) ||\n    isDate(val2) ||\n    isRegExp(val2) ||\n    isAnyArrayBuffer(val2) ||\n    isBoxedPrimitive(val2) ||\n    isNativeError(val2) ||\n    val2 instanceof Error\n  ) {\n    return false;\n  }\n  return keyCheck(val1, val2, memos, kNoIterator);\n}\n\nfunction keyCheck(\n  val1: any,\n  val2: any,\n  memos: any,\n  iterationType: number,\n  aKeys?: Array<any>\n) {\n  // For all remaining Object pairs, including Array, objects and Maps,\n  // equivalence is determined by having:\n  // a) The same number of owned enumerable properties\n  // b) The same set of keys/indexes (although not necessarily the same order)\n  // c) Equivalent values for every corresponding key/index\n  // d) For Sets and Maps, equal contents\n  // Note: this accounts for both named and indexed properties on Arrays.\n  if (arguments.length === 4) {\n    aKeys = Object.keys(val1);\n    const bKeys = Object.keys(val2);\n\n    // The pair must have the same number of owned properties.\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n  }\n\n  // Cheap key test\n  let i = 0;\n  for (; i < aKeys!.length; i++) {\n    if (!val2.propertyIsEnumerable(aKeys![i])) {\n      return false;\n    }\n  }\n\n  if (arguments.length === 4) {\n    const symbolKeysA = Object.getOwnPropertySymbols(val1);\n    if (symbolKeysA.length !== 0) {\n      let count = 0;\n      for (i = 0; i < symbolKeysA.length; i++) {\n        const key = symbolKeysA[i];\n        if (val1.propertyIsEnumerable(key)) {\n          if (!val2.propertyIsEnumerable(val2, key)) {\n            return false;\n          }\n          aKeys!.push(aKeys, key);\n          count++;\n        } else if (val2.propertyIsEnumerable(val2, key)) {\n          return false;\n        }\n      }\n      const symbolKeysB = Object.getOwnPropertySymbols(val2);\n      if (\n        symbolKeysA.length !== symbolKeysB.length &&\n        getEnumerables(val2, symbolKeysB).length !== count\n      ) {\n        return false;\n      }\n    } else {\n      const symbolKeysB = Object.getOwnPropertySymbols(val2);\n      if (\n        symbolKeysB.length !== 0 &&\n        getEnumerables(val2, symbolKeysB).length !== 0\n      ) {\n        return false;\n      }\n    }\n  }\n\n  if (\n    aKeys!.length === 0 &&\n    (iterationType === kNoIterator ||\n      (iterationType === kIsArray && val1.length === 0) ||\n      val1.size === 0)\n  ) {\n    return true;\n  }\n\n  // Use memos to handle cycles.\n  if (memos === undefined) {\n    memos = {\n      val1: new Map(),\n      val2: new Map(),\n      position: 0,\n    };\n  } else {\n    // We prevent up to two map.has(x) calls by directly retrieving the value\n    // and checking for undefined. The map can only contain numbers, so it is\n    // safe to check for undefined only.\n    const val2MemoA = memos.val1.get(val1);\n    if (val2MemoA !== undefined) {\n      const val2MemoB = memos.val2.get(val2);\n      if (val2MemoB !== undefined) {\n        return val2MemoA === val2MemoB;\n      }\n    }\n    memos.position++;\n  }\n\n  memos.val1.set(val1, memos.position);\n  memos.val2.set(val2, memos.position);\n\n  const areEq = objEquiv(val1, val2, aKeys, memos, iterationType);\n\n  memos.val1.delete(val1);\n  memos.val2.delete(val2);\n\n  return areEq;\n}\n\nfunction objEquiv(\n  a: any,\n  b: any,\n  keys: any,\n  memos: any,\n  iterationType: Number\n) {\n  // Sets and maps don't have their entries accessible via normal object\n  // properties.\n  let i = 0;\n\n  if (iterationType === kIsSet) {\n    if (!setEquiv(a, b, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsMap) {\n    if (!mapEquiv(a, b, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsArray) {\n    for (; i < a.length; i++) {\n      if (a.hasOwnProperty(i)) {\n        if (!b.hasOwnProperty(i) || !deepStrictEqual(a[i], b[i], memos)) {\n          return false;\n        }\n      } else if (b.hasOwnProperty(i)) {\n        return false;\n      } else {\n        // Array is sparse.\n        const keysA = Object.keys(a);\n        for (; i < keysA.length; i++) {\n          const key = keysA[i];\n          if (\n            !b.hasOwnProperty(key) ||\n            !deepStrictEqual(a[key], b[key], memos)\n          ) {\n            return false;\n          }\n        }\n        if (keysA.length !== Object.keys(b).length) {\n          return false;\n        }\n        return true;\n      }\n    }\n  }\n\n  // The pair must have equivalent values for every corresponding key.\n  // Possibly expensive deep test:\n  for (i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (!deepStrictEqual(a[key], b[key], memos)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction setEquiv(a: any, b: any, memo: any) {\n  // This is a lazily initiated Set of entries which have to be compared\n  // pairwise.\n  let set = null;\n  for (const val of a) {\n    // Note: Checking for the objects first improves the performance for object\n    // heavy sets but it is a minor slow down for primitives. As they are fast\n    // to check this improves the worst case scenario instead.\n    if (typeof val === \"object\" && val !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n      // If the specified value doesn't exist in the second set it's a non-null\n      // object (or non strict only: a not matching primitive) we'll need to go\n      // hunting for something that's deep-(strict-)equal to it. To make this\n      // O(n log n) complexity we have to copy these values in a new set first.\n      set.add(val);\n    } else if (!b.has(val)) {\n      return false;\n    }\n  }\n\n  if (set !== null) {\n    for (const val of b) {\n      // We have to check if a primitive value is already\n      // matching and only if it's not, go hunting for it.\n      if (typeof val === \"object\" && val !== null) {\n        if (!setHasEqualElement(set, val, memo)) return false;\n      }\n    }\n    return set.size === 0;\n  }\n\n  return true;\n}\n\nfunction setHasEqualElement(set: any, val1: any, memo: any) {\n  // Go looking.\n  for (const val2 of set) {\n    if (deepStrictEqual(val1, val2, memo)) {\n      // Remove the matching element to make sure we do not check that again.\n      set.delete(val2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction mapEquiv(a: any, b: any, memo: any) {\n  let set = null;\n\n  for (const { 0: key, 1: item1 } of a) {\n    if (typeof key === \"object\" && key !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n      set.add(key);\n    } else {\n      // By directly retrieving the value we prevent another b.has(key) check in\n      // almost all possible cases.\n      const item2 = b.get(key);\n      if (\n        (item2 === undefined && !b.has(key)) ||\n        !deepStrictEqual(item1, item2, memo)\n      ) {\n        return false;\n      }\n    }\n  }\n\n  if (set !== null) {\n    for (const { 0: key, 1: item } of b) {\n      if (typeof key === \"object\" && key !== null) {\n        if (!mapHasEqualEntry(set, a, key, item, memo)) return false;\n      }\n    }\n    return set.size === 0;\n  }\n\n  return true;\n}\n\nfunction mapHasEqualEntry(\n  set: Set<any>,\n  map: Map<any, any>,\n  key1: any,\n  item1: any,\n  memo: any\n) {\n  // To be able to handle cases like:\n  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\n  // ... we need to consider *all* matching keys, not just the first we find.\n  for (const key2 of set) {\n    if (\n      deepStrictEqual(key1, key2, memo) &&\n      deepStrictEqual(item1, map.get(key2), memo)\n    ) {\n      set.delete(key2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isEqualBoxedPrimitive(val1: any, val2: any) {\n  if (isNumberObject(val1)) {\n    return isNumberObject(val2) && Object.is(val1.valueOf(), val2.valueOf());\n  }\n  if (isStringObject(val1)) {\n    return isStringObject(val2) && val1.valueOf() === val2.valueOf();\n  }\n  if (isBooleanObject(val1)) {\n    return isBooleanObject(val2) && val1.valueOf() === val2.valueOf();\n  }\n  if (isSymbolObject(val1)) {\n    return isSymbolObject(val2) && val1.valueOf() === val2.valueOf();\n  }\n  throw new Error(`Unknown boxed type ${val1}`);\n}\n\nfunction areEqualArrayBuffers(buf1: ArrayBufferLike, buf2: ArrayBufferLike) {\n  return (\n    buf1.byteLength === buf2.byteLength &&\n    Buffer.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0\n  );\n}\n\nfunction areSimilarTypedArrays(a: ArrayBufferView, b: ArrayBufferView) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  return (\n    Buffer.compare(\n      new Uint8Array(a.buffer, a.byteOffset, a.byteLength),\n      new Uint8Array(b.buffer, b.byteOffset, b.byteLength)\n    ) === 0\n  );\n}\n\nfunction isNonIndex(key: any) {\n  if (key.length === 0 || key.length > 10) return true;\n  for (var i = 0; i < key.length; i++) {\n    var code = key.charCodeAt(i);\n    if (code < 48 || code > 57) return true;\n  }\n  // The maximum size for an array is 2 ** 32 -1.\n  return key.length === 10 && key >= Math.pow(2, 32);\n}\nconst getOwnNonIndexProperties = (val1: any) => {\n  if (!val1?.getOwnPropertySymbols) {\n    return [];\n  }\n  return (\n    Object.keys(val1)\n      .filter(isNonIndex)\n      .concat(\n        val1\n          ?.getOwnPropertySymbols(val1)\n          .filter(Object.prototype.propertyIsEnumerable.bind(val1))\n      ) ?? []\n  );\n};\n\nfunction getEnumerables(val: Object, keys: Array<any>) {\n  return keys.filter((k) => val.propertyIsEnumerable(k));\n}\n\nfunction areSimilarRegExps(a: RegExp, b: RegExp) {\n  return (\n    a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex\n  );\n}\n","// Code in this file will be automatically included in all inflight code bundles,\n// so avoid importing anything heavy here.\nimport { notDeepStrictEqual } from \"node:assert\";\nimport * as path from \"node:path\";\nimport type { Construct } from \"constructs\";\nimport type { Node } from \"./std/node\";\n// since we moved from node:18 to node:20 the deepStrictEqual doesn't work as expected.\n// https://github.com/winglang/wing/issues/4444\n// therefore we're using a local version of the comparison from node 18.\nimport { deepStrictEqual } from \"./util/equality\";\n\nexport function eq(a: any, b: any): boolean {\n  try {\n    return deepStrictEqual(a, b);\n  } catch {\n    return false;\n  }\n}\n\nexport function neq(a: any, b: any): boolean {\n  try {\n    notDeepStrictEqual(a, b);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function assert(condition: any, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(\"assertion failed: \" + message);\n  }\n}\n\nexport function range(start: number, end: number, inclusive: boolean) {\n  function* iterator() {\n    let i = start;\n    let limit = inclusive ? (end < start ? end - 1 : end + 1) : end;\n    while (i < limit) yield i++;\n    while (i > limit) yield i--;\n  }\n  return iterator();\n}\n\nexport function nodeof(construct: Construct): Node {\n  // Should only be used preflight, avoid bundling\n  const Node = eval(\"require('./std/node').Node\");\n  return Node.of(construct);\n}\n\nexport function normalPath(p: string): string {\n  return p.replace(/\\\\+/g, \"/\");\n}\n\nexport function unwrap<T>(value: T): T | never {\n  if (value != null) {\n    return value;\n  }\n  throw new Error(\"Unexpected nil\");\n}\n\nexport function lookup(obj: any, index: string | number): any {\n  checkIndex(index);\n\n  if (typeof index === \"number\") {\n    index = checkArrayAccess(obj, index);\n    return obj[index];\n  }\n\n  if (typeof obj !== \"object\") {\n    throw new TypeError(\n      `Lookup failed, value is not an object (found \"${typeof obj}\")`\n    );\n  }\n\n  if (!(index in obj)) {\n    throw new RangeError(`Key \"${index}\" not found`);\n  }\n\n  return obj[index];\n}\n\nexport function assign(\n  obj: any,\n  index: string | number,\n  kind: \"=\" | \"+=\" | \"-=\",\n  value: any\n) {\n  checkIndex(index);\n\n  if (typeof index === \"number\") {\n    index = checkArrayAccess(obj, index);\n  }\n\n  if (typeof index === \"string\" && typeof obj !== \"object\") {\n    throw new TypeError(\n      `Assignment failed, value is not an object (found \\\"${typeof obj}\\\")`\n    );\n  }\n\n  switch (kind) {\n    case \"=\":\n      obj[index] = value;\n      break;\n    case \"+=\":\n      obj[index] += value;\n      break;\n    case \"-=\":\n      obj[index] -= value;\n      break;\n    default:\n      throw new Error(`Invalid assignment kind: ${kind}`);\n  }\n}\n\nfunction checkIndex(index: string | number) {\n  if (typeof index !== \"string\" && typeof index !== \"number\") {\n    throw new TypeError(\n      `Index must be a string or number (found \"${typeof index}\")`\n    );\n  }\n}\n\nfunction checkArrayAccess(obj: any, index: number): number {\n  if (!Array.isArray(obj) && !Buffer.isBuffer(obj) && typeof obj !== \"string\") {\n    throw new TypeError(\n      \"Index is a number but collection is not an array or string\"\n    );\n  }\n  if (index < 0 && index >= -obj.length) {\n    index = obj.length + index;\n  }\n  if (index < 0 || index >= obj.length) {\n    throw new RangeError(\n      `Index ${index} out of bounds for array of length ${obj.length}`\n    );\n  }\n  return index;\n}\n\nexport function createExternRequire(dirname: string) {\n  return (externPath: string) => {\n    // using eval to always avoid bundling\n    const jiti: typeof import(\"jiti\").default = eval(\"require('jiti')\");\n    const esbuild: typeof import(\"esbuild\") = eval(\"require('esbuild')\");\n\n    const newRequire = jiti(dirname, {\n      sourceMaps: true,\n      interopDefault: true,\n      transform(opts) {\n        return esbuild.transformSync(opts.source, {\n          format: \"cjs\",\n          target: \"node20\",\n          sourcemap: \"inline\",\n          loader: opts.ts ? \"ts\" : \"js\",\n        });\n      },\n    });\n    return newRequire(externPath);\n  };\n}\n\nexport function resolveDirname(\n  outdir: string,\n  relativeSourceDir: string\n): string {\n  return normalPath(path.resolve(outdir, relativeSourceDir));\n}\n","bring util;\nbring cloud;\nbring ui;\nbring \"./commons/api.w\" as api;\nbring \"./platform/awscdk.w\" as awscdk;\nbring \"./platform/tf-aws.w\" as tfaws;\nbring \"./platform/sim.w\" as sim;\n\npub class WebSocket impl api.IWebSocket {\n  inner: api.IWebSocket;\n  pub url: str;\n  \n  new(props: api.WebSocketProps) {\n    let target = util.env(\"WING_TARGET\");\n\n    if target == \"tf-aws\" {\n      let ws = new tfaws.WebSocket_tfaws(props) as props.name;\n      this.url = ws.url;\n      this.inner = ws;\n    } elif target == \"awscdk\" {\n      let ws = new awscdk.WebSocket_awscdk(props) as props.name;\n      this.url = ws.url;\n      this.inner = ws;\n    } elif target == \"sim\" {\n      let ws = new sim.WebSocket_sim(props) as props.name;\n      this.url = ws.url;\n      this.inner = ws;\n    } else {\n      throw \"unsupported target {target}\";\n    }\n\n    let inner = nodeof(this.inner);\n    inner.hidden = true;\n\n    new ui.Field(\"url\", inflight () => {\n      return this.url;\n    });\n\n    new cloud.Endpoint(this.url);\n  }\n\n  pub onConnect(handler: inflight(str): void): void {\n    this.inner.onConnect(handler);\n  }\n  pub onDisconnect(handler: inflight(str): void): void {\n    this.inner.onDisconnect(handler);\n  }\n  pub onMessage(handler: inflight(str, str): void): void {\n    this.inner.onMessage(handler);\n  }\n\n  pub inflight sendMessage(connectionId: str, message: str) {\n    this.inner.sendMessage(connectionId, message);\n  }\n}\n","\"use strict\";\nvar $handler = undefined;\nexports.handler = async function(event) {\n  $handler = $handler ?? (\n          (await (async () => {\n            const $Closure1Client = \n          require(\"/Users/pro-3ie-s/Desktop/educloud/bigmop2/backend/target/test/main.wsim/.wing/inflight.$Closure1-7.cjs\")({\n            $__parent_this_1_url: process.env[\"WING_TOKEN_WSIM_ROOT_ENV0_BROADCASTER_COUNTER_UPDATES_COUNTER_UPDATES_STATE_ATTRS_URL\"],\n          })\n        ;\n            const client = new $Closure1Client({\n            });\n            if (client.$inflight_init) { await client.$inflight_init(); }\n            return client;\n          })())\n        );\n  return await $handler.handle(event);\n};\nprocess.on(\"uncaughtException\", (reason) => {\n  process.send({ type: \"error\", reason });\n});\n\nprocess.on(\"message\", async (message) => {\n  const { fn, args } = message;\n  const value = await exports[fn](...args);\n  process.send({ type: \"ok\", value });\n});\n"],"mappings":"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","names":["exports","exports","module"]}
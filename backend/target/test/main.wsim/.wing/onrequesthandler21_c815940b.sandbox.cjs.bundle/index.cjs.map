{"version":3,"sources":["../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/util/equality.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/helpers.ts","../../../../../main.w","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/dependency.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/private/stack-trace.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/private/uniqueid.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/construct.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/lib/metadata.js","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/constructs/src/index.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/errors.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/tokens.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/lifting.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/types.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/shared/misc.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/core/inflight.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/std/datetime.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/simulator/serialization.ts","../../../../../../../../../../../usr/local/lib/node_modules/winglang/node_modules/@winglang/sdk/src/simulator/client.ts","../onrequesthandler21_c815940b.sandbox.cjs"],"sourcesContent":["// taken from node 18 https://github.com/nodejs/node/blob/v18.x/lib/internal/util/comparisons.js\n\nimport {\n  isAnyArrayBuffer,\n  isArrayBufferView,\n  isDate,\n  isMap,\n  isRegExp,\n  isSet,\n  isNativeError,\n  isBoxedPrimitive,\n  isNumberObject,\n  isStringObject,\n  isBooleanObject,\n  isSymbolObject,\n  isFloat32Array,\n  isFloat64Array,\n} from \"util/types\";\n\nconst kNoIterator = 0;\nconst kIsArray = 1;\nconst kIsSet = 2;\nconst kIsMap = 3;\n\nexport function deepStrictEqual(val1: any, val2: any, memos?: any) {\n  // All identical values are equivalent, as determined by ===.\n  if (val1 === val2) {\n    if (val1 !== 0) return true;\n    return Object.is(val1, val2);\n  }\n\n  // Check more closely if val1 and val2 are equal.\n  if (typeof val1 !== \"object\") {\n    return typeof val1 === \"number\" && Number.isNaN(val1) && Number.isNaN(val2);\n  }\n  if (typeof val2 !== \"object\" || val1 === null || val2 === null) {\n    return false;\n  }\n  if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {\n    return false;\n  }\n\n  const val1Tag = val1.toString();\n  const val2Tag = val2.toString();\n\n  if (val1Tag !== val2Tag) {\n    return false;\n  }\n\n  if (Array.isArray(val1)) {\n    // Check for sparse arrays and general fast path\n    if (!Array.isArray(val2) || val1.length !== val2.length) {\n      return false;\n    }\n    const keys1 = getOwnNonIndexProperties(val1); // 179\n    const keys2 = getOwnNonIndexProperties(val2);\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, memos, kIsArray, keys1);\n  } else if (val1Tag === \"[object Object]\") {\n    return keyCheck(val1, val2, memos, kNoIterator);\n  } else if (isDate(val1)) {\n    if (!isDate(val2) || val1.getTime() !== val2.getTime()) {\n      return false;\n    }\n  } else if (isRegExp(val1)) {\n    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {\n      return false;\n    }\n  } else if (isNativeError(val1) || val1 instanceof Error) {\n    // Do not compare the stack as it might differ even though the error itself\n    // is otherwise identical.\n    if (\n      (!isNativeError(val2) && !(val2 instanceof Error)) ||\n      val1.message !== val2.message ||\n      val1.name !== val2.name\n    ) {\n      return false;\n    }\n  } else if (isArrayBufferView(val1)) {\n    if (!areSimilarTypedArrays(val1, val2)) {\n      return false;\n    }\n\n    if (\n      !areSimilarTypedArrays(val1, val2) &&\n      !isFloat32Array(val1) &&\n      !isFloat64Array(val1)\n    ) {\n      return false;\n    }\n    // Buffer.compare returns true, so val1.length === val2.length. If they both\n    // only contain numeric keys, we don't need to exam further than checking\n    // the symbols.\n    const keys1 = getOwnNonIndexProperties(val1);\n    const keys2 = getOwnNonIndexProperties(val2);\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, memos, kNoIterator, keys1);\n  } else if (isSet(val1)) {\n    if (!isSet(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, memos, kIsSet);\n  } else if (isMap(val1)) {\n    if (!isMap(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, memos, kIsMap);\n  } else if (isAnyArrayBuffer(val1)) {\n    if (!isAnyArrayBuffer(val2) || !areEqualArrayBuffers(val1, val2)) {\n      return false;\n    }\n  } else if (isBoxedPrimitive(val1)) {\n    if (!isEqualBoxedPrimitive(val1, val2)) {\n      return false;\n    }\n  } else if (\n    Array.isArray(val2) ||\n    isArrayBufferView(val2) ||\n    isSet(val2) ||\n    isMap(val2) ||\n    isDate(val2) ||\n    isRegExp(val2) ||\n    isAnyArrayBuffer(val2) ||\n    isBoxedPrimitive(val2) ||\n    isNativeError(val2) ||\n    val2 instanceof Error\n  ) {\n    return false;\n  }\n  return keyCheck(val1, val2, memos, kNoIterator);\n}\n\nfunction keyCheck(\n  val1: any,\n  val2: any,\n  memos: any,\n  iterationType: number,\n  aKeys?: Array<any>\n) {\n  // For all remaining Object pairs, including Array, objects and Maps,\n  // equivalence is determined by having:\n  // a) The same number of owned enumerable properties\n  // b) The same set of keys/indexes (although not necessarily the same order)\n  // c) Equivalent values for every corresponding key/index\n  // d) For Sets and Maps, equal contents\n  // Note: this accounts for both named and indexed properties on Arrays.\n  if (arguments.length === 4) {\n    aKeys = Object.keys(val1);\n    const bKeys = Object.keys(val2);\n\n    // The pair must have the same number of owned properties.\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n  }\n\n  // Cheap key test\n  let i = 0;\n  for (; i < aKeys!.length; i++) {\n    if (!val2.propertyIsEnumerable(aKeys![i])) {\n      return false;\n    }\n  }\n\n  if (arguments.length === 4) {\n    const symbolKeysA = Object.getOwnPropertySymbols(val1);\n    if (symbolKeysA.length !== 0) {\n      let count = 0;\n      for (i = 0; i < symbolKeysA.length; i++) {\n        const key = symbolKeysA[i];\n        if (val1.propertyIsEnumerable(key)) {\n          if (!val2.propertyIsEnumerable(val2, key)) {\n            return false;\n          }\n          aKeys!.push(aKeys, key);\n          count++;\n        } else if (val2.propertyIsEnumerable(val2, key)) {\n          return false;\n        }\n      }\n      const symbolKeysB = Object.getOwnPropertySymbols(val2);\n      if (\n        symbolKeysA.length !== symbolKeysB.length &&\n        getEnumerables(val2, symbolKeysB).length !== count\n      ) {\n        return false;\n      }\n    } else {\n      const symbolKeysB = Object.getOwnPropertySymbols(val2);\n      if (\n        symbolKeysB.length !== 0 &&\n        getEnumerables(val2, symbolKeysB).length !== 0\n      ) {\n        return false;\n      }\n    }\n  }\n\n  if (\n    aKeys!.length === 0 &&\n    (iterationType === kNoIterator ||\n      (iterationType === kIsArray && val1.length === 0) ||\n      val1.size === 0)\n  ) {\n    return true;\n  }\n\n  // Use memos to handle cycles.\n  if (memos === undefined) {\n    memos = {\n      val1: new Map(),\n      val2: new Map(),\n      position: 0,\n    };\n  } else {\n    // We prevent up to two map.has(x) calls by directly retrieving the value\n    // and checking for undefined. The map can only contain numbers, so it is\n    // safe to check for undefined only.\n    const val2MemoA = memos.val1.get(val1);\n    if (val2MemoA !== undefined) {\n      const val2MemoB = memos.val2.get(val2);\n      if (val2MemoB !== undefined) {\n        return val2MemoA === val2MemoB;\n      }\n    }\n    memos.position++;\n  }\n\n  memos.val1.set(val1, memos.position);\n  memos.val2.set(val2, memos.position);\n\n  const areEq = objEquiv(val1, val2, aKeys, memos, iterationType);\n\n  memos.val1.delete(val1);\n  memos.val2.delete(val2);\n\n  return areEq;\n}\n\nfunction objEquiv(\n  a: any,\n  b: any,\n  keys: any,\n  memos: any,\n  iterationType: Number\n) {\n  // Sets and maps don't have their entries accessible via normal object\n  // properties.\n  let i = 0;\n\n  if (iterationType === kIsSet) {\n    if (!setEquiv(a, b, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsMap) {\n    if (!mapEquiv(a, b, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsArray) {\n    for (; i < a.length; i++) {\n      if (a.hasOwnProperty(i)) {\n        if (!b.hasOwnProperty(i) || !deepStrictEqual(a[i], b[i], memos)) {\n          return false;\n        }\n      } else if (b.hasOwnProperty(i)) {\n        return false;\n      } else {\n        // Array is sparse.\n        const keysA = Object.keys(a);\n        for (; i < keysA.length; i++) {\n          const key = keysA[i];\n          if (\n            !b.hasOwnProperty(key) ||\n            !deepStrictEqual(a[key], b[key], memos)\n          ) {\n            return false;\n          }\n        }\n        if (keysA.length !== Object.keys(b).length) {\n          return false;\n        }\n        return true;\n      }\n    }\n  }\n\n  // The pair must have equivalent values for every corresponding key.\n  // Possibly expensive deep test:\n  for (i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (!deepStrictEqual(a[key], b[key], memos)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction setEquiv(a: any, b: any, memo: any) {\n  // This is a lazily initiated Set of entries which have to be compared\n  // pairwise.\n  let set = null;\n  for (const val of a) {\n    // Note: Checking for the objects first improves the performance for object\n    // heavy sets but it is a minor slow down for primitives. As they are fast\n    // to check this improves the worst case scenario instead.\n    if (typeof val === \"object\" && val !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n      // If the specified value doesn't exist in the second set it's a non-null\n      // object (or non strict only: a not matching primitive) we'll need to go\n      // hunting for something that's deep-(strict-)equal to it. To make this\n      // O(n log n) complexity we have to copy these values in a new set first.\n      set.add(val);\n    } else if (!b.has(val)) {\n      return false;\n    }\n  }\n\n  if (set !== null) {\n    for (const val of b) {\n      // We have to check if a primitive value is already\n      // matching and only if it's not, go hunting for it.\n      if (typeof val === \"object\" && val !== null) {\n        if (!setHasEqualElement(set, val, memo)) return false;\n      }\n    }\n    return set.size === 0;\n  }\n\n  return true;\n}\n\nfunction setHasEqualElement(set: any, val1: any, memo: any) {\n  // Go looking.\n  for (const val2 of set) {\n    if (deepStrictEqual(val1, val2, memo)) {\n      // Remove the matching element to make sure we do not check that again.\n      set.delete(val2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction mapEquiv(a: any, b: any, memo: any) {\n  let set = null;\n\n  for (const { 0: key, 1: item1 } of a) {\n    if (typeof key === \"object\" && key !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n      set.add(key);\n    } else {\n      // By directly retrieving the value we prevent another b.has(key) check in\n      // almost all possible cases.\n      const item2 = b.get(key);\n      if (\n        (item2 === undefined && !b.has(key)) ||\n        !deepStrictEqual(item1, item2, memo)\n      ) {\n        return false;\n      }\n    }\n  }\n\n  if (set !== null) {\n    for (const { 0: key, 1: item } of b) {\n      if (typeof key === \"object\" && key !== null) {\n        if (!mapHasEqualEntry(set, a, key, item, memo)) return false;\n      }\n    }\n    return set.size === 0;\n  }\n\n  return true;\n}\n\nfunction mapHasEqualEntry(\n  set: Set<any>,\n  map: Map<any, any>,\n  key1: any,\n  item1: any,\n  memo: any\n) {\n  // To be able to handle cases like:\n  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\n  // ... we need to consider *all* matching keys, not just the first we find.\n  for (const key2 of set) {\n    if (\n      deepStrictEqual(key1, key2, memo) &&\n      deepStrictEqual(item1, map.get(key2), memo)\n    ) {\n      set.delete(key2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isEqualBoxedPrimitive(val1: any, val2: any) {\n  if (isNumberObject(val1)) {\n    return isNumberObject(val2) && Object.is(val1.valueOf(), val2.valueOf());\n  }\n  if (isStringObject(val1)) {\n    return isStringObject(val2) && val1.valueOf() === val2.valueOf();\n  }\n  if (isBooleanObject(val1)) {\n    return isBooleanObject(val2) && val1.valueOf() === val2.valueOf();\n  }\n  if (isSymbolObject(val1)) {\n    return isSymbolObject(val2) && val1.valueOf() === val2.valueOf();\n  }\n  throw new Error(`Unknown boxed type ${val1}`);\n}\n\nfunction areEqualArrayBuffers(buf1: ArrayBufferLike, buf2: ArrayBufferLike) {\n  return (\n    buf1.byteLength === buf2.byteLength &&\n    Buffer.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0\n  );\n}\n\nfunction areSimilarTypedArrays(a: ArrayBufferView, b: ArrayBufferView) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  return (\n    Buffer.compare(\n      new Uint8Array(a.buffer, a.byteOffset, a.byteLength),\n      new Uint8Array(b.buffer, b.byteOffset, b.byteLength)\n    ) === 0\n  );\n}\n\nfunction isNonIndex(key: any) {\n  if (key.length === 0 || key.length > 10) return true;\n  for (var i = 0; i < key.length; i++) {\n    var code = key.charCodeAt(i);\n    if (code < 48 || code > 57) return true;\n  }\n  // The maximum size for an array is 2 ** 32 -1.\n  return key.length === 10 && key >= Math.pow(2, 32);\n}\nconst getOwnNonIndexProperties = (val1: any) => {\n  if (!val1?.getOwnPropertySymbols) {\n    return [];\n  }\n  return (\n    Object.keys(val1)\n      .filter(isNonIndex)\n      .concat(\n        val1\n          ?.getOwnPropertySymbols(val1)\n          .filter(Object.prototype.propertyIsEnumerable.bind(val1))\n      ) ?? []\n  );\n};\n\nfunction getEnumerables(val: Object, keys: Array<any>) {\n  return keys.filter((k) => val.propertyIsEnumerable(k));\n}\n\nfunction areSimilarRegExps(a: RegExp, b: RegExp) {\n  return (\n    a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex\n  );\n}\n","// Code in this file will be automatically included in all inflight code bundles,\n// so avoid importing anything heavy here.\nimport { notDeepStrictEqual } from \"node:assert\";\nimport * as path from \"node:path\";\nimport type { Construct } from \"constructs\";\nimport type { Node } from \"./std/node\";\n// since we moved from node:18 to node:20 the deepStrictEqual doesn't work as expected.\n// https://github.com/winglang/wing/issues/4444\n// therefore we're using a local version of the comparison from node 18.\nimport { deepStrictEqual } from \"./util/equality\";\n\nexport function eq(a: any, b: any): boolean {\n  try {\n    return deepStrictEqual(a, b);\n  } catch {\n    return false;\n  }\n}\n\nexport function neq(a: any, b: any): boolean {\n  try {\n    notDeepStrictEqual(a, b);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function assert(condition: any, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(\"assertion failed: \" + message);\n  }\n}\n\nexport function range(start: number, end: number, inclusive: boolean) {\n  function* iterator() {\n    let i = start;\n    let limit = inclusive ? (end < start ? end - 1 : end + 1) : end;\n    while (i < limit) yield i++;\n    while (i > limit) yield i--;\n  }\n  return iterator();\n}\n\nexport function nodeof(construct: Construct): Node {\n  // Should only be used preflight, avoid bundling\n  const Node = eval(\"require('./std/node').Node\");\n  return Node.of(construct);\n}\n\nexport function normalPath(p: string): string {\n  return p.replace(/\\\\+/g, \"/\");\n}\n\nexport function unwrap<T>(value: T): T | never {\n  if (value != null) {\n    return value;\n  }\n  throw new Error(\"Unexpected nil\");\n}\n\nexport function lookup(obj: any, index: string | number): any {\n  checkIndex(index);\n\n  if (typeof index === \"number\") {\n    index = checkArrayAccess(obj, index);\n    return obj[index];\n  }\n\n  if (typeof obj !== \"object\") {\n    throw new TypeError(\n      `Lookup failed, value is not an object (found \"${typeof obj}\")`\n    );\n  }\n\n  if (!(index in obj)) {\n    throw new RangeError(`Key \"${index}\" not found`);\n  }\n\n  return obj[index];\n}\n\nexport function assign(\n  obj: any,\n  index: string | number,\n  kind: \"=\" | \"+=\" | \"-=\",\n  value: any\n) {\n  checkIndex(index);\n\n  if (typeof index === \"number\") {\n    index = checkArrayAccess(obj, index);\n  }\n\n  if (typeof index === \"string\" && typeof obj !== \"object\") {\n    throw new TypeError(\n      `Assignment failed, value is not an object (found \\\"${typeof obj}\\\")`\n    );\n  }\n\n  switch (kind) {\n    case \"=\":\n      obj[index] = value;\n      break;\n    case \"+=\":\n      obj[index] += value;\n      break;\n    case \"-=\":\n      obj[index] -= value;\n      break;\n    default:\n      throw new Error(`Invalid assignment kind: ${kind}`);\n  }\n}\n\nfunction checkIndex(index: string | number) {\n  if (typeof index !== \"string\" && typeof index !== \"number\") {\n    throw new TypeError(\n      `Index must be a string or number (found \"${typeof index}\")`\n    );\n  }\n}\n\nfunction checkArrayAccess(obj: any, index: number): number {\n  if (!Array.isArray(obj) && !Buffer.isBuffer(obj) && typeof obj !== \"string\") {\n    throw new TypeError(\n      \"Index is a number but collection is not an array or string\"\n    );\n  }\n  if (index < 0 && index >= -obj.length) {\n    index = obj.length + index;\n  }\n  if (index < 0 || index >= obj.length) {\n    throw new RangeError(\n      `Index ${index} out of bounds for array of length ${obj.length}`\n    );\n  }\n  return index;\n}\n\nexport function createExternRequire(dirname: string) {\n  return (externPath: string) => {\n    // using eval to always avoid bundling\n    const jiti: typeof import(\"jiti\").default = eval(\"require('jiti')\");\n    const esbuild: typeof import(\"esbuild\") = eval(\"require('esbuild')\");\n\n    const newRequire = jiti(dirname, {\n      sourceMaps: true,\n      interopDefault: true,\n      transform(opts) {\n        return esbuild.transformSync(opts.source, {\n          format: \"cjs\",\n          target: \"node20\",\n          sourcemap: \"inline\",\n          loader: opts.ts ? \"ts\" : \"js\",\n        });\n      },\n    });\n    return newRequire(externPath);\n  };\n}\n\nexport function resolveDirname(\n  outdir: string,\n  relativeSourceDir: string\n): string {\n  return normalPath(path.resolve(outdir, relativeSourceDir));\n}\n","bring expect;\nbring vite;\nbring http;\nbring cloud;\nbring \"./broadcaster.w\" as broadcaster;\nbring \"./product.w\" as product;\nbring \"./user.w\" as user;\nbring \"./order.w\" as order;\nbring \"./auth.w\" as basicAuth;\nbring \"./categories.w\" as category;\nbring \"./subCategories.w\" as subCategory;\nbring \"./cart.w\" as cart;\nbring \"./notification.w\" as notification;\n\nlet queue = new cloud.Queue();\n\n\n// api.get(\"/hello\", inflight (req) => {\n\n// });\n\n// let apiUrl = api.url;\n\n// test \"not authenticated\" {\n//   let response = http.get(\"{apiUrl}/hello\");\n//   expect.equal(response.status, 401);\n// }\n\n// test \"authenticated\" {\n//   let response = http.get(\"{apiUrl}/hello\", {\n//     headers: {\n//       Accept: \"application/json\",\n//       Authorization: \"Basic \" + util.base64Encode(\"admin:admin\")\n//     }\n//   });\n\n//   expect.equal(response.status, 200);\n// }\n///////\n\nclass Utils {\n  extern \"utils.js\" pub static __dirname(): str;\n}\n\nlet myBroadcaster = new broadcaster.Broadcaster() as \"Broadcaster\";\nlet api = new cloud.Api(cors: true);\nlet counter = new cloud.Counter();\nlet auth = new basicAuth.BasicAuth();\n\n\nlet productStorage = new product.ProductStorage();\nlet productApi = new product.ProductService(productStorage, api, auth, myBroadcaster);\nlet userStorage = new user.UserStorage();\nlet userService = new user.UserService(userStorage, api, auth);\nlet orderStorage = new order.OrderStorage();\nlet orderApi = new order.OrderService(orderStorage, productStorage, queue, api, auth);\nlet categoryStorage = new category.CategoryStorage();\nlet categoryApi = new category.CategoryService(categoryStorage, api, auth, myBroadcaster);\nlet subCategoryStorage = new subCategory.SubCategoryStorage();\nlet subCategoryApi = new subCategory.SubCategoryService(subCategoryStorage, productStorage, api, auth, myBroadcaster);\nlet cartStorage = new cart.CartStorage();\nlet cartApi = new cart.CartService(cartStorage, productStorage, api, auth, myBroadcaster);\nlet notificationStorage = new notification.NotificationStorage();\nlet notificationApi = new notification.NotificationService(notificationStorage, userStorage, api, auth, myBroadcaster);\n\nlet website = new vite.Vite(\n  root: \"{Utils.__dirname()}/../frontend\",\n  publicEnv: {\n    TITLE: \"Wing + Vite + React\",\n    API_URL: api.url,\n    WS_URL: myBroadcaster.url\n  }\n) as \"Vite Website\"; \n\napi.get(\"/counter\", inflight () => {\n  return {\n    body: \"{counter.peek()}\"\n  };\n});\n\napi.post(\"/counter\", inflight () => {\n  let prev = counter.inc();\n  myBroadcaster.broadcast(\"refresh\");\n  return {\n    body: \"{prev + 1}\"\n  };\n});\n\ntest \"api counter increment and get\" {\n  log(\"counter initial value: {counter.peek()}\");\n  assert(counter.peek() == 0);\n  http.post(api.url + \"/counter\");\n  let res = http.get(api.url + \"/counter\");\n  log(\"counter value after increment: {res.body}\");\n  assert(res.body == \"1\");\n}\n","import { IConstruct } from './construct';\n\n/**\n * Trait marker for classes that can be depended upon\n *\n * The presence of this interface indicates that an object has\n * an `IDependable` implementation.\n *\n * This interface can be used to take an (ordering) dependency on a set of\n * constructs. An ordering dependency implies that the resources represented by\n * those constructs are deployed before the resources depending ON them are\n * deployed.\n */\nexport interface IDependable {\n  // Empty, this interface is a trait marker\n}\n\n/**\n * A set of constructs to be used as a dependable\n *\n * This class can be used when a set of constructs which are disjoint in the\n * construct tree needs to be combined to be used as a single dependable.\n *\n * @experimental\n */\nexport class DependencyGroup implements IDependable {\n  private readonly _deps = new Array<IDependable>();\n\n  constructor(...deps: IDependable[]) {\n    const self = this;\n\n    Dependable.implement(this, {\n      get dependencyRoots() {\n        const result = new Array<IConstruct>();\n        for (const d of self._deps) {\n          result.push(...Dependable.of(d).dependencyRoots);\n        }\n        return result;\n      },\n    });\n\n    this.add(...deps);\n  }\n\n  /**\n   * Add a construct to the dependency roots\n   */\n  public add(...scopes: IDependable[]) {\n    this._deps.push(...scopes);\n  }\n}\n\nconst DEPENDABLE_SYMBOL = Symbol.for('@aws-cdk/core.DependableTrait');\n\n/**\n * Trait for IDependable\n *\n * Traits are interfaces that are privately implemented by objects. Instead of\n * showing up in the public interface of a class, they need to be queried\n * explicitly. This is used to implement certain framework features that are\n * not intended to be used by Construct consumers, and so should be hidden\n * from accidental use.\n *\n * @example\n *\n * // Usage\n * const roots = Dependable.of(construct).dependencyRoots;\n *\n * // Definition\n * Dependable.implement(construct, {\n *       dependencyRoots: [construct],\n * });\n *\n * @experimental\n */\nexport abstract class Dependable {\n  /**\n   * Turn any object into an IDependable.\n   */\n  public static implement(instance: IDependable, trait: Dependable) {\n    // I would also like to reference classes (to cut down on the list of objects\n    // we need to manage), but we can't do that either since jsii doesn't have the\n    // concept of a class reference.\n    (instance as any)[DEPENDABLE_SYMBOL] = trait;\n  }\n\n  /**\n   * Return the matching Dependable for the given class instance.\n   */\n  public static of(instance: IDependable): Dependable {\n    const ret = (instance as any)[DEPENDABLE_SYMBOL];\n    if (!ret) {\n      throw new Error(`${instance} does not implement IDependable. Use \"Dependable.implement()\" to implement`);\n    }\n    return ret;\n  }\n\n  /**\n   * Return the matching Dependable for the given class instance.\n   * @deprecated use `of`\n   */\n  public static get(instance: IDependable): Dependable {\n    return this.of(instance);\n  }\n\n  /**\n   * The set of constructs that form the root of this dependable\n   *\n   * All resources under all returned constructs are included in the ordering\n   * dependency.\n   */\n  public abstract readonly dependencyRoots: IConstruct[];\n}\n","// tslint:disable-next-line:ban-types\nexport function captureStackTrace(below?: Function): string[] {\n  below = below || captureStackTrace; // hide myself if nothing else\n  const object = { stack: '' };\n  const previousLimit = Error.stackTraceLimit;\n  try {\n    Error.stackTraceLimit = Number.MAX_SAFE_INTEGER;\n    Error.captureStackTrace(object, below);\n  } finally {\n    Error.stackTraceLimit = previousLimit;\n  }\n  if (!object.stack) {\n    return [];\n  }\n  return object.stack.split('\\n').slice(1).map(s => s.replace(/^\\s*at\\s+/, ''));\n}\n","import * as crypto from 'crypto';\n\n/**\n * Resources with this ID are complete hidden from the logical ID calculation.\n */\nconst HIDDEN_ID = 'Default';\n\n/**\n * Calculates the construct uid based on path components.\n *\n * Components named `Default` (case sensitive) are excluded from uid calculation\n * to allow tree refactorings.\n *\n * @param components path components\n */\nexport function addressOf(components: string[]) {\n  const hash = crypto.createHash('sha1');\n  for (const c of components) {\n    // skip components called \"Default\" to enable refactorings\n    if (c === HIDDEN_ID) { continue; }\n\n    hash.update(c);\n    hash.update('\\n');\n  }\n\n  // prefix with \"c8\" so to ensure it starts with non-digit.\n  return 'c8' + hash.digest('hex');\n}\n","import { Dependable, IDependable } from './dependency';\nimport { MetadataEntry } from './metadata';\nimport { captureStackTrace } from './private/stack-trace';\nimport { addressOf } from './private/uniqueid';\n\nconst CONSTRUCT_SYM = Symbol.for('constructs.Construct');\n\n/**\n * Represents a construct.\n */\nexport interface IConstruct extends IDependable {\n  /**\n   * The tree node.\n   */\n  readonly node: Node;\n}\n\n/**\n * Represents the construct node in the scope tree.\n */\nexport class Node {\n  /**\n   * Separator used to delimit construct path components.\n   */\n  public static readonly PATH_SEP = '/';\n\n  /**\n   * Returns the node associated with a construct.\n   * @param construct the construct\n   *\n   * @deprecated use `construct.node` instead\n   */\n  public static of(construct: IConstruct): Node {\n    return construct.node;\n  }\n\n  /**\n   * Returns the scope in which this construct is defined.\n   *\n   * The value is `undefined` at the root of the construct scope tree.\n   */\n  public readonly scope?: IConstruct;\n\n  /**\n   * The id of this construct within the current scope.\n   *\n   * This is a scope-unique id. To obtain an app-unique id for this construct, use `addr`.\n   */\n  public readonly id: string;\n\n  private _locked = false; // if this is \"true\", addChild will fail\n  private readonly _children: { [id: string]: IConstruct } = { };\n  private readonly _context: { [key: string]: any } = { };\n  private readonly _metadata = new Array<MetadataEntry>();\n  private readonly _dependencies = new Set<IDependable>();\n  private _defaultChild: IConstruct | undefined;\n  private readonly _validations = new Array<IValidation>();\n  private _addr?: string; // cache\n\n  public constructor(private readonly host: Construct, scope: IConstruct, id: string) {\n    id = id ?? ''; // if undefined, convert to empty string\n\n    this.id = sanitizeId(id);\n    this.scope = scope;\n\n    if (scope && !this.id) {\n      throw new Error('Only root constructs may have an empty ID');\n    }\n\n    // add to parent scope\n    scope?.node.addChild(host, this.id);\n  }\n\n  /**\n   * The full, absolute path of this construct in the tree.\n   *\n   * Components are separated by '/'.\n   */\n  public get path(): string {\n    const components = [];\n    for (const scope of this.scopes) {\n      if (scope.node.id) {\n        components.push(scope.node.id);\n      }\n    }\n    return components.join(Node.PATH_SEP);\n  }\n\n  /**\n   * Returns an opaque tree-unique address for this construct.\n   *\n   * Addresses are 42 characters hexadecimal strings. They begin with \"c8\"\n   * followed by 40 lowercase hexadecimal characters (0-9a-f).\n   *\n   * Addresses are calculated using a SHA-1 of the components of the construct\n   * path.\n   *\n   * To enable refactorings of construct trees, constructs with the ID `Default`\n   * will be excluded from the calculation. In those cases constructs in the\n   * same tree may have the same addreess.\n   *\n   * @example c83a2846e506bcc5f10682b564084bca2d275709ee\n   */\n  public get addr(): string {\n    if (!this._addr) {\n      this._addr = addressOf(this.scopes.map(c => c.node.id));\n    }\n\n    return this._addr;\n  }\n\n  /**\n   * Return a direct child by id, or undefined\n   *\n   * @param id Identifier of direct child\n   * @returns the child if found, or undefined\n   */\n  public tryFindChild(id: string): IConstruct | undefined {\n    return this._children[sanitizeId(id)];\n  }\n\n  /**\n   * Return a direct child by id\n   *\n   * Throws an error if the child is not found.\n   *\n   * @param id Identifier of direct child\n   * @returns Child with the given id.\n   */\n  public findChild(id: string): IConstruct {\n    const ret = this.tryFindChild(id);\n    if (!ret) {\n      throw new Error(`No child with id: '${id}'`);\n    }\n    return ret;\n  }\n\n  /**\n   * Returns the child construct that has the id `Default` or `Resource\"`.\n   * This is usually the construct that provides the bulk of the underlying functionality.\n   * Useful for modifications of the underlying construct that are not available at the higher levels.\n   *\n   * @throws if there is more than one child\n   * @returns a construct or undefined if there is no default child\n   */\n  public get defaultChild(): IConstruct | undefined {\n    if (this._defaultChild !== undefined) {\n      return this._defaultChild;\n    }\n\n    const resourceChild = this.tryFindChild('Resource');\n    const defaultChild = this.tryFindChild('Default');\n    if (resourceChild && defaultChild) {\n      throw new Error(`Cannot determine default child for ${this.path}. There is both a child with id \"Resource\" and id \"Default\"`);\n    }\n\n    return defaultChild || resourceChild;\n  }\n\n  /**\n   * Override the defaultChild property.\n   *\n   * This should only be used in the cases where the correct\n   * default child is not named 'Resource' or 'Default' as it\n   * should be.\n   *\n   * If you set this to undefined, the default behavior of finding\n   * the child named 'Resource' or 'Default' will be used.\n   */\n  public set defaultChild(value: IConstruct | undefined) {\n    this._defaultChild = value;\n  }\n\n  /**\n   * All direct children of this construct.\n   */\n  public get children() {\n    return Object.values(this._children);\n  }\n\n  /**\n   * Return this construct and all of its children in the given order\n   */\n  public findAll(order: ConstructOrder = ConstructOrder.PREORDER): IConstruct[] {\n    const ret = new Array<IConstruct>();\n    visit(this.host);\n    return ret;\n\n    function visit(c: IConstruct) {\n      if (order === ConstructOrder.PREORDER) {\n        ret.push(c);\n      }\n\n      for (const child of c.node.children) {\n        visit(child);\n      }\n\n      if (order === ConstructOrder.POSTORDER) {\n        ret.push(c);\n      }\n    }\n  }\n\n  /**\n   * This can be used to set contextual values.\n   * Context must be set before any children are added, since children may consult context info during construction.\n   * If the key already exists, it will be overridden.\n   * @param key The context key\n   * @param value The context value\n   */\n  public setContext(key: string, value: any) {\n    if (this.children.length > 0) {\n      const names = this.children.map(c => c.node.id);\n      throw new Error('Cannot set context after children have been added: ' + names.join(','));\n    }\n    this._context[key] = value;\n  }\n\n  /**\n   * Retrieves a value from tree context if present. Otherwise, would throw an error.\n   *\n   * Context is usually initialized at the root, but can be overridden at any point in the tree.\n   *\n   * @param key The context key\n   * @returns The context value or throws error if there is no context value for this key\n   */\n  public getContext(key: string): any {\n    const value = this._context[key];\n\n    if (value !== undefined) { return value; }\n\n    if (value === undefined && !this.scope?.node) {\n      throw new Error(`No context value present for ${key} key`);\n    }\n\n    return this.scope && this.scope.node.getContext(key);\n  }\n\n  /**\n   * Retrieves the all context of a node from tree context.\n   *\n   * Context is usually initialized at the root, but can be overridden at any point in the tree.\n   *\n   * @param defaults Any keys to override the retrieved context\n   * @returns The context object or an empty object if there is discovered context\n   */\n  public getAllContext(defaults?: object): any {\n    if (typeof defaults === 'undefined') {\n      defaults = {};\n    }\n\n    if (this.scope === undefined) { return defaults; }\n\n    const value = { ...this._context, ...defaults };\n    return this.scope && this.scope.node.getAllContext(value);\n  }\n\n  /**\n   * Retrieves a value from tree context.\n   *\n   * Context is usually initialized at the root, but can be overridden at any point in the tree.\n   *\n   * @param key The context key\n   * @returns The context value or `undefined` if there is no context value for this key.\n   */\n  public tryGetContext(key: string): any {\n    const value = this._context[key];\n    if (value !== undefined) { return value; }\n\n    return this.scope && this.scope.node.tryGetContext(key);\n  }\n\n  /**\n   * An immutable array of metadata objects associated with this construct.\n   * This can be used, for example, to implement support for deprecation notices, source mapping, etc.\n   */\n  public get metadata() {\n    return [...this._metadata];\n  }\n\n  /**\n   * Adds a metadata entry to this construct.\n   * Entries are arbitrary values and will also include a stack trace to allow tracing back to\n   * the code location for when the entry was added. It can be used, for example, to include source\n   * mapping in CloudFormation templates to improve diagnostics.\n   *\n   * @param type a string denoting the type of metadata\n   * @param data the value of the metadata (can be a Token). If null/undefined, metadata will not be added.\n   * @param options options\n   */\n  public addMetadata(type: string, data: any, options: MetadataOptions = { }): void {\n    if (data == null) {\n      return;\n    }\n\n    const shouldTrace = options.stackTrace ?? false;\n    const trace = shouldTrace ? captureStackTrace(options.traceFromFunction ?? this.addMetadata) : undefined;\n    this._metadata.push({ type, data, trace });\n  }\n\n  /**\n   * All parent scopes of this construct.\n   *\n   * @returns a list of parent scopes. The last element in the list will always\n   * be the current construct and the first element will be the root of the\n   * tree.\n   */\n  public get scopes(): IConstruct[] {\n    const ret = new Array<IConstruct>();\n\n    let curr: IConstruct | undefined = this.host;\n    while (curr) {\n      ret.unshift(curr);\n      curr = curr.node.scope;\n    }\n\n    return ret;\n  }\n\n  /**\n   * Returns the root of the construct tree.\n   * @returns The root of the construct tree.\n   */\n  public get root() {\n    return this.scopes[0];\n  }\n\n  /**\n   * Returns true if this construct or the scopes in which it is defined are\n   * locked.\n   */\n  public get locked() {\n    if (this._locked) {\n      return true;\n    }\n\n    if (this.scope && this.scope.node.locked) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Add an ordering dependency on another construct.\n   *\n   * An `IDependable`\n   */\n  public addDependency(...deps: IDependable[]) {\n    for (const d of deps) {\n      this._dependencies.add(d);\n    }\n  }\n\n  /**\n   * Return all dependencies registered on this node (non-recursive).\n   */\n  public get dependencies(): IConstruct[] {\n    const result = new Array<IConstruct>();\n    for (const dep of this._dependencies) {\n      for (const root of Dependable.of(dep).dependencyRoots) {\n        result.push(root);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Remove the child with the given name, if present.\n   *\n   * @returns Whether a child with the given name was deleted.\n   * @experimental\n   */\n  public tryRemoveChild(childName: string): boolean {\n    if (!(childName in this._children)) { return false; }\n    delete this._children[childName];\n    return true;\n  }\n\n  /**\n   * Adds a validation to this construct.\n   *\n   * When `node.validate()` is called, the `validate()` method will be called on\n   * all validations and all errors will be returned.\n   *\n   * @param validation The validation object\n   */\n  public addValidation(validation: IValidation) {\n    this._validations.push(validation);\n  }\n\n  /**\n   * Validates this construct.\n   *\n   * Invokes the `validate()` method on all validations added through\n   * `addValidation()`.\n   *\n   * @returns an array of validation error messages associated with this\n   * construct.\n   */\n  public validate(): string[] {\n    const deprecated = ['validate', 'onValidate', 'synthesize', 'onSynthesize', 'prepare', 'onPrepare'];\n    for (const method of deprecated) {\n      if (typeof((this.host as any)[method]) === 'function') {\n        throw new Error(`the construct \"${this.path}\" has a \"${method}()\" method which is no longer supported. Use \"construct.node.addValidation()\" to add validations to a construct`);\n      }\n    }\n\n    const errors = new Array<string>();\n    for (const v of this._validations) {\n      errors.push(...v.validate());\n    }\n\n    return errors;\n  }\n\n  /**\n   * Locks this construct from allowing more children to be added. After this\n   * call, no more children can be added to this construct or to any children.\n   */\n  public lock() {\n    this._locked = true;\n  }\n\n  /**\n   * Adds a child construct to this node.\n   *\n   * @param child The child construct\n   * @param childName The type name of the child construct.\n   * @returns The resolved path part name of the child\n   */\n  private addChild(child: Construct, childName: string) {\n    if (this.locked) {\n\n      // special error if root is locked\n      if (!this.path) {\n        throw new Error('Cannot add children during synthesis');\n      }\n\n      throw new Error(`Cannot add children to \"${this.path}\" during synthesis`);\n    }\n\n    if (this._children[childName]) {\n      const name = this.id ?? '';\n      const typeName = this.host.constructor.name;\n      throw new Error(`There is already a Construct with name '${childName}' in ${typeName}${name.length > 0 ? ' [' + name + ']' : ''}`);\n    }\n\n    this._children[childName] = child;\n  }\n}\n\n/**\n * Represents the building block of the construct graph.\n *\n * All constructs besides the root construct must be created within the scope of\n * another construct.\n */\nexport class Construct implements IConstruct {\n  /**\n   * Checks if `x` is a construct.\n   *\n   * Use this method instead of `instanceof` to properly detect `Construct`\n   * instances, even when the construct library is symlinked.\n   *\n   * Explanation: in JavaScript, multiple copies of the `constructs` library on\n   * disk are seen as independent, completely different libraries. As a\n   * consequence, the class `Construct` in each copy of the `constructs` library\n   * is seen as a different class, and an instance of one class will not test as\n   * `instanceof` the other class. `npm install` will not create installations\n   * like this, but users may manually symlink construct libraries together or\n   * use a monorepo tool: in those cases, multiple copies of the `constructs`\n   * library can be accidentally installed, and `instanceof` will behave\n   * unpredictably. It is safest to avoid using `instanceof`, and using\n   * this type-testing method instead.\n   *\n   * @returns true if `x` is an object created from a class which extends `Construct`.\n   * @param x Any object\n   */\n  public static isConstruct(x: any): x is Construct {\n    return x && typeof x === 'object' && x[CONSTRUCT_SYM];\n  }\n\n  /**\n   * The tree node.\n   */\n  public readonly node: Node;\n\n  /**\n   * Creates a new construct node.\n   *\n   * @param scope The scope in which to define this construct\n   * @param id The scoped construct ID. Must be unique amongst siblings. If\n   * the ID includes a path separator (`/`), then it will be replaced by double\n   * dash `--`.\n   */\n  constructor(scope: Construct, id: string) {\n    this.node = new Node(this, scope, id);\n\n    // implement IDependable privately\n    Dependable.implement(this, {\n      dependencyRoots: [this],\n    });\n  }\n\n  /**\n   * Returns a string representation of this construct.\n   */\n  public toString() {\n    return this.node.path || '<root>';\n  }\n}\n\n/**\n * Implement this interface in order for the construct to be able to validate itself.\n */\nexport interface IValidation {\n  /**\n   * Validate the current construct.\n   *\n   * This method can be implemented by derived constructs in order to perform\n   * validation logic. It is called on all constructs before synthesis.\n   *\n   * @returns An array of validation error messages, or an empty array if there the construct is valid.\n   */\n  validate(): string[];\n}\n\n/**\n * In what order to return constructs\n */\nexport enum ConstructOrder {\n  /**\n   * Depth-first, pre-order\n   */\n  PREORDER,\n\n  /**\n   * Depth-first, post-order (leaf nodes first)\n   */\n  POSTORDER\n}\n\nconst PATH_SEP_REGEX = new RegExp(`${Node.PATH_SEP}`, 'g');\n\n/**\n * Return a sanitized version of an arbitrary string, so it can be used as an ID\n */\nfunction sanitizeId(id: string) {\n  // Escape path seps as double dashes\n  return id.replace(PATH_SEP_REGEX, '--');\n}\n\n/**\n * Options for `construct.addMetadata()`.\n */\nexport interface MetadataOptions {\n  /**\n   * Include stack trace with metadata entry.\n   * @default false\n   */\n  readonly stackTrace?: boolean;\n\n  /**\n   * A JavaScript function to begin tracing from.\n   *\n   * This option is ignored unless `stackTrace` is `true`.\n   *\n   * @default addMetadata()\n   */\n  readonly traceFromFunction?: any;\n}\n\n// Mark all instances of 'Construct'\nObject.defineProperty(Construct.prototype, CONSTRUCT_SYM, {\n  value: true,\n  enumerable: false,\n  writable: false,\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0YWRhdGEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbWV0YWRhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQW4gZW50cnkgaW4gdGhlIGNvbnN0cnVjdCBtZXRhZGF0YSB0YWJsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YUVudHJ5IHtcbiAgLyoqXG4gICAqIFRoZSBtZXRhZGF0YSBlbnRyeSB0eXBlLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IGFueTtcblxuICAvKipcbiAgICogU3RhY2sgdHJhY2UgYXQgdGhlIHBvaW50IG9mIGFkZGluZyB0aGUgbWV0YWRhdGEuXG4gICAqXG4gICAqIE9ubHkgYXZhaWxhYmxlIGlmIGBhZGRNZXRhZGF0YSgpYCBpcyBjYWxsZWQgd2l0aCBgc3RhY2tUcmFjZTogdHJ1ZWAuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm8gdHJhY2UgaW5mb3JtYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHRyYWNlPzogc3RyaW5nW107XG59XG4iXX0=","export * from './construct';\nexport * from './metadata';\nexport * from './dependency';","interface NotImplementedErrorOptions {\n  issue?: string;\n  resource?: string;\n  operation?: string;\n}\n\nexport class NotImplementedError extends Error {\n  public name: string = \"NotImplementedError\";\n  public resource?: string;\n  public operation?: string;\n  constructor(message: string, options?: NotImplementedErrorOptions) {\n    super(\n      `${message}${\n        options?.issue\n          ? `\\nFor more information see: ${options.issue}.\\nContributions welcome ❤️`\n          : \"\"\n      }`\n    );\n    this.resource = options?.resource;\n    this.operation = options?.operation;\n  }\n}\n\nexport class AbstractMemberError extends Error {\n  constructor() {\n    super(\"This member is abstract and must be implemented in a subclass.\");\n  }\n}\n","import { IInflightHost } from \"../std\";\n/**\n * Represents values that can only be resolved after the app is synthesized.\n * Tokens values are captured as environment variable, and resolved through the compilation target token mechanism.\n */\nexport interface ITokenResolver {\n  /**\n   * Returns true is the given value is a token.\n   */\n  isToken(value: any): boolean;\n\n  /**\n   * \"Lifts\" a value into an inflight context.\n   */\n  lift(value: any): string;\n\n  /**\n   * Lifts the given token to the host.\n   */\n  onLiftValue(host: IInflightHost, value: any): void;\n}\n\n/**\n * Global registry of available token resolvers.\n */\nconst _resolvers: ITokenResolver[] = [];\n\n/**\n * Creates a valid environment variable name from the given token.\n */\nexport function tokenEnvName(value: string): string {\n  return `WING_TOKEN_${value\n    .replace(/([^a-zA-Z0-9]+)/g, \"_\")\n    .replace(/_+$/, \"\")\n    .replace(/^_+/, \"\")\n    .toUpperCase()}`;\n}\n\n/**\n * Globally registers a new token resolver\n */\nexport function registerTokenResolver(resolver: ITokenResolver) {\n  _resolvers.push(resolver);\n}\n\n/**\n * Find the first token resolver that considers the given value a token (or containing token(s)).\n */\nexport function getTokenResolver(value: any): ITokenResolver | undefined {\n  return _resolvers.find((r) => r.isToken(value));\n}\n","import { Construct } from \"constructs\";\nimport { NotImplementedError } from \"./errors\";\nimport { getTokenResolver } from \"./tokens\";\nimport { IInflightHost, ILiftable, IHostedLiftable } from \"../std\";\n\n/**\n * This is the name of a special operation that is used as a key\n * by the compiler in the `_liftMap` matrix to indicate that\n * some transitive object dependencies are always required no matter\n * what operations are passed to the `host`.\n *\n * As a user, this operation is hidden so it will not be\n * passed as an op to `onLift` or `onLiftType` methods.\n */\nexport const INFLIGHT_INIT_METHOD_NAME = \"$inflight_init\";\n\n/**\n * Inflight closures are liftable objects that have a single inflight\n * method called \"handle\". This method contains the inflight code\n * that will be executed by the inflight host.\n */\nconst INFLIGHT_CLOSURE_HANDLE_METHOD = \"handle\";\n\n/**\n * The prefix used to name inflight closure object types.\n */\nconst INFLIGHT_CLOSURE_TYPE_PREFIX = \"$Closure\";\n\n/**\n * Creates a liftable type from a class or enum\n * @param type The type to lift, Should be a class or enum.\n * @param moduleSpec A module specifier that the type can be imported from. e.g. \"aws-cdk-lib\"\n * @param path The dotted path to the type in the module. e.g. \"aws_s3.Bucket\" to access `require(\"aws-cdk-lib\").aws_s3.Bucket`\n * @returns A liftable type, either the same type or a wrapper\n */\nexport function toLiftableModuleType(\n  type: any,\n  moduleSpec: string,\n  path: string\n) {\n  if (\n    typeof type?._toInflightType === \"function\" ||\n    type?.constructor?.name === \"Object\"\n  ) {\n    return type;\n  } else {\n    return {\n      _toInflightType: () => `require(\"${moduleSpec}\").${path}`,\n    };\n  }\n}\n\nexport function liftObject(obj: any): string {\n  // since typeof(null) is \"object\", we cover all nullity cases (undefined and null) apriori.\n  if (obj == null) {\n    return JSON.stringify(obj);\n  }\n\n  const tokenResolver = getTokenResolver(obj);\n  if (tokenResolver) {\n    return tokenResolver.lift(obj);\n  }\n\n  // if the object is a type, and it has a \"_toInflightType\" method, we use it to serialize\n  // fyi, typeof(obj) in this case is a \"function\".\n  if (typeof obj?._toInflightType === \"function\") {\n    return obj._toInflightType();\n  }\n\n  switch (typeof obj) {\n    case \"string\":\n    case \"boolean\":\n    case \"number\":\n      return JSON.stringify(obj);\n\n    case \"object\":\n      if (Array.isArray(obj)) {\n        return `[${obj.map((o) => liftObject(o)).join(\",\")}]`;\n      }\n\n      if (obj instanceof Set) {\n        return `new Set(${liftObject(Array.from(obj))})`;\n      }\n\n      if (obj instanceof Map) {\n        return `new Map(${liftObject(Array.from(obj))})`;\n      }\n\n      // if the object is a resource (i.e. has a \"_toInflight\" method\"), we use it to serialize\n      // itself.\n      if (typeof (obj as ILiftable)._toInflight === \"function\") {\n        return (obj as ILiftable)._toInflight();\n      }\n\n      // structs are just plain objects\n      if (obj.constructor.name === \"Object\") {\n        const lines = [];\n        lines.push(\"{\");\n        for (const [k, v] of Object.entries(obj)) {\n          lines.push(`\\\"${k.replace(/\"/g, '\\\\\"')}\\\": ${liftObject(v)},`);\n        }\n        lines.push(\"}\");\n        return lines.join(\"\");\n      }\n\n      break;\n  }\n\n  throw new Error(`Unable to lift object of type ${obj?.constructor?.name}`);\n}\n\nexport type LiftMap = Record<string, Array<[any, Array<string>]>>;\nexport type LiftMapNormalized = Record<string, Map<any, Set<string>>>;\n\n/**\n * Merge two matrixes of lifting dependencies.\n *\n * See the unit tests in `lifting.test.ts` for examples.\n */\nexport function mergeLiftDeps(\n  matrix1: LiftMapNormalized = {},\n  matrix2: LiftMapNormalized = {}\n): LiftMapNormalized {\n  const result: LiftMapNormalized = {};\n  for (const [op, deps] of Object.entries(matrix1)) {\n    result[op] = new Map();\n    for (const [obj, objDeps] of deps) {\n      result[op].set(obj, new Set(objDeps));\n    }\n  }\n\n  for (const [op, deps] of Object.entries(matrix2)) {\n    const resultDeps = result[op] ?? new Map();\n    for (const [obj, objDeps] of deps) {\n      const resultObjDeps = resultDeps.get(obj) ?? new Set();\n      for (const dep of objDeps) {\n        resultObjDeps.add(dep);\n      }\n      resultDeps.set(obj, resultObjDeps);\n    }\n    result[op] = resultDeps;\n  }\n\n  return result;\n}\n\n/**\n * Converts a matrix of lifting dependencies from the format emitted by the Wing compiler\n * (using plain objects and arrays) to a denser format (using Maps and Sets),\n * deduplicating object references if needed.\n *\n * The deduplication is needed because the compiler might generate something like:\n * ```\n * [\n *   [obj1, [\"op1\"]],\n *   [obj2, [\"op2\"]],\n * ]\n * ```\n * not knowing that during preflight execution, obj1 and obj2 are the same object.\n * The deduplication will turn this into:\n * ```\n * new Map([obj1, new Set([\"op1\", \"op2\"])])\n * ```\n */\nfunction parseMatrix(data: LiftMap): LiftMapNormalized {\n  const result: LiftMapNormalized = {};\n  for (const [op, pairs] of Object.entries(data)) {\n    result[op] = new Map();\n    for (const [obj, objDeps] of pairs) {\n      if (!result[op].has(obj)) {\n        result[op].set(obj, new Set());\n      }\n      const depSet = result[op].get(obj)!;\n      for (const dep of objDeps) {\n        depSet.add(dep);\n      }\n    }\n  }\n  return result;\n}\n\n// for debugging\n// function printMatrix(data: LiftMapNormalized): string {\n//   const lines = [];\n//   for (const [op, pairs] of Object.entries(data)) {\n//     lines.push(`${op}: {`);\n//     for (const [obj, objDeps] of pairs) {\n//       if (Construct.isConstruct(obj)) {\n//         lines.push(`  ${obj.node.path}: [${[...objDeps]}]`);\n//       } else {\n//         lines.push(`  ${obj?.constructor?.name ?? obj}: [${[...objDeps]}]`);\n//       }\n//     }\n//     lines.push(\"}\");\n//   }\n//   return lines.join(\"\\n\");\n// }\n\n/**\n * Collects all of the objects that need to be lifted for a given object and set of operations, by\n * traversing the object graph.\n *\n * Internally, it keeps track of a queue of objects and corresponding operations that need to be lifted\n * by the inflight host (the explored set), and a queue of objects and operations that need to be\n * explored (the queue). Objects (any JavaScript values) can be re-added to the queue multiple times\n * if new operations are determined as needed by the inflight host.\n *\n * For example, suppose an inflight host needs to call op1 on object A and op2 on object B.\n * In addition, object B needs op3 on object A.\n * The explored set and queue after each step of the main loop is shown below:\n *\n * ```\n * explored: {} | queue: [(A, [op1]), (B, [op2])]\n * explored: {A: [op1]} | queue: [(B, [op2])]\n * explored: {A: [op1], B: [op2]} | queue: [(A, [op3])]\n * explored: {A: [op1, op3], B: [op2]} | queue: []\n */\nexport function collectLifts(\n  initialObj: any,\n  initialOps: Array<string>\n): Map<any, Set<string>> {\n  if (initialOps.includes(INFLIGHT_INIT_METHOD_NAME)) {\n    throw new Error(\n      `The operation ${INFLIGHT_INIT_METHOD_NAME} is implicit and should not be requested explicitly.`\n    );\n  }\n\n  const explored = new Map<any, Set<string>>();\n  const queue = new Array<[any, Array<string>]>([initialObj, [...initialOps]]);\n  const matrixCache = new Map<any, LiftMapNormalized>();\n\n  while (queue.length > 0) {\n    // `obj` and `ops` are the preflight object and operations requested on it\n    let [obj, ops]: [any, Array<string>] = queue.shift()!;\n\n    let newObj = false;\n    if (!explored.has(obj)) {\n      explored.set(obj, new Set());\n      newObj = true;\n    }\n\n    let existingOps = explored.get(obj)!;\n\n    // Filter out any ops that we've already processed for this object.\n    ops = ops.filter((op) => !existingOps.has(op));\n\n    // If there are no ops left and we have already seen the object, skip further processing.\n    if (ops.length === 0 && !newObj) {\n      continue;\n    }\n\n    // Add the new ops to the explored set.\n    for (const op of ops) {\n      existingOps.add(op);\n    }\n\n    // Inspect the object to see if there are any transitive dependency information.\n    // Currently there are a few ways to do this:\n    // - The compiler may generate a _liftMap property on the object\n    // - The compiler may generate a static _liftTypeMap method on a class\n\n    let matrix: LiftMapNormalized;\n    if (matrixCache.has(obj)) {\n      matrix = matrixCache.get(obj)!;\n    } else if (typeof obj === \"object\" && obj._liftMap !== undefined) {\n      matrix = parseMatrix(obj._liftMap ?? {});\n      matrixCache.set(obj, matrix);\n    } else if (\n      typeof obj === \"function\" &&\n      typeof obj._liftTypeMap !== undefined\n    ) {\n      matrix = parseMatrix(obj._liftTypeMap ?? {});\n      matrixCache.set(obj, matrix);\n    } else {\n      // If the object doesn't have any dependency information, we can skip it.\n      // In the future, we might want to do more advanced analysis to\n      // lift collections of objects with onLift methods etc.\n\n      // Before we `continue` to the next iteration, check for some basic collection types\n      // so if the user puts tokens in a collection, they'll get lifted.\n      //\n      // We can't calculate what ops to put for the collection items (for\n      // example, for cases where the items are resources) since the compiler\n      // doesn't produce that information yet.\n\n      let items_to_explore: Iterable<any> = [];\n      if (Array.isArray(obj)) {\n        items_to_explore = obj;\n      } else if (obj instanceof Set) {\n        items_to_explore = obj;\n      } else if (obj instanceof Map) {\n        items_to_explore = obj.values();\n      } else if (typeof obj === \"object\" && obj.constructor.name === \"Object\") {\n        items_to_explore = Object.values(obj);\n      }\n\n      for (const item of items_to_explore) {\n        if (!explored.has(item)) {\n          let item_ops: string[] = [];\n          // If the item is an inflight closure type then implicitly add the \"handle\" operation\n          if (isInflightClosureObject(item)) {\n            item_ops.push(INFLIGHT_CLOSURE_HANDLE_METHOD);\n          }\n          queue.push([item, item_ops]);\n        }\n      }\n      continue;\n    }\n\n    for (const op of [...ops, INFLIGHT_INIT_METHOD_NAME]) {\n      const objDeps = matrix[op];\n\n      // If the op is $inflight_init, then the operation is implicit\n      // so it's okay it's not defined in the matrix\n      if (op === INFLIGHT_INIT_METHOD_NAME && !objDeps) {\n        continue;\n      }\n\n      if (!objDeps) {\n        if (Construct.isConstruct(obj)) {\n          throw new NotImplementedError(\n            `Resource ${obj.node.path} does not support inflight operation ${op}.\\nIt might not be implemented yet.`,\n            { resource: obj.constructor.name, operation: op }\n          );\n        } else {\n          throw new Error(\n            `Unknown operation ${op} requested for object ${obj} (${obj.constructor.name})`\n          );\n        }\n      }\n\n      for (const [depObj, depOps] of objDeps.entries()) {\n        if (depOps.has(INFLIGHT_INIT_METHOD_NAME)) {\n          throw new Error(\n            `The operation ${INFLIGHT_INIT_METHOD_NAME} is implicit and should not be requested explicitly.`\n          );\n        }\n        queue.push([depObj, [...depOps]]);\n      }\n    }\n  }\n\n  return explored;\n}\n\n/**\n * Returns whether the given item is an inflight closure object.\n */\nfunction isInflightClosureObject(item: any): boolean {\n  return (\n    typeof item === \"object\" &&\n    typeof item.constructor === \"function\" &&\n    typeof item.constructor.name === \"string\" &&\n    item.constructor.name.startsWith(INFLIGHT_CLOSURE_TYPE_PREFIX) &&\n    item._liftMap !== undefined &&\n    item._liftMap[INFLIGHT_CLOSURE_HANDLE_METHOD] !== undefined\n  );\n}\n\n/**\n * Represents a type with static methods that may have other things to lift.\n */\nexport interface ILiftableType {\n  /**\n   * Compiler-generated data that describes the dependencies of this object on other\n   * objects. This is used to determine which permissions need to be granted to the\n   * inflight host.\n   * @internal\n   */\n  _liftTypeMap?: LiftMap;\n\n  /**\n   * A hook called by the Wing compiler once for each inflight host that needs to\n   * use this type inflight. The list of requested inflight methods\n   * needed by the inflight host are given by `ops`.\n   *\n   * This method is commonly used for adding permissions, environment variables, or\n   * other capabilities to the inflight host.\n   */\n  onLiftType(host: IInflightHost, ops: string[]): void;\n}\n\n/**\n * Lifting utilities.\n */\nexport class Lifting {\n  /**\n   * Perform the full lifting process on an object.\n   *\n   * Use this instead of calling `onLift` since it will also lift all of the\n   * object's dependencies, and it will ensure that the onLift methods of\n   * all objects are all called at most once.\n   */\n  public static lift(\n    obj: IHostedLiftable,\n    host: IInflightHost,\n    ops: Array<string>\n  ) {\n    // obtain all of the objects that need lifting\n    const lifts = collectLifts(obj, ops);\n\n    // call all of the onLift methods\n    for (const [liftedObj, liftedOps] of lifts) {\n      const tokens = getTokenResolver(liftedObj);\n      if (tokens) {\n        tokens.onLiftValue(host, liftedObj);\n        continue;\n      }\n\n      if (\n        typeof liftedObj === \"object\" &&\n        typeof liftedObj.onLift === \"function\"\n      ) {\n        liftedObj.onLift(host, [...liftedOps]);\n        continue;\n      }\n\n      if (\n        typeof liftedObj === \"function\" &&\n        typeof liftedObj.onLiftType === \"function\"\n      ) {\n        liftedObj.onLiftType(host, [...liftedOps]);\n        continue;\n      }\n\n      // no lift-related methods to call - it's probably a primitive\n      // so no capabilities need to be added to the inflight host\n    }\n  }\n}\n","/// This file is used to generate types within the compiler and make sure they're shared for external usage\n\nimport type { IInflight } from \"../std/resource\";\n\n// re-exporting useful types\nexport { Construct } from \"constructs\";\n\n/** Flag to signify the `inflight` side of a `preflight` object  */\nexport const INFLIGHT_SYMBOL: unique symbol = Symbol(\"@winglang/sdk.inflight\");\n\n/** This symbol is not defined in cloud/secrets.ts due to circular dependencies\n * between cloud/secrets.ts and platform/platform-manager.ts, which need to be revisited\n * in the meantime this dependency inversion is used to avoid the circular dependency\n */\nexport const SECRET_SYMBOL = Symbol(\"@winglang/sdk.cloud.Secret\");\n\n/** `preflight` representation of an `inflight`  */\nexport type Inflight<F extends AsyncFunction> = IInflight & {\n  /** Note: This is not actually callable,\n   *  this is a phantom type to ensure the type information can cross the phase boundary\n   */\n  [INFLIGHT_SYMBOL]?: F;\n};\n\n/** Extract async methods of an object and return them as discriminant types of an array */\nexport type OperationsOf<T> = (keyof Pick<\n  T,\n  {\n    [K in keyof T]: T[K] extends AsyncFunction ? K : never;\n  }[keyof T]\n>)[];\n\nexport type AnyFunction = (...args: any[]) => any;\nexport type AsyncFunction = (...args: any[]) => Promise<any>;\n\n/** An object that contains only valid data for JSON.stringify() */\nexport type Json =\n  | null\n  | string\n  | number\n  | boolean\n  | Json[]\n  | { [key: string]: Json };\n","import { ExecOptions, ExecFileOptions, exec, execFile } from \"child_process\";\nimport { readFileSync } from \"fs\";\nimport { promisify } from \"util\";\n\nconst execPromise = promisify(exec);\nconst execFilePromise = promisify(execFile);\n\nexport function readJsonSync(file: string) {\n  return JSON.parse(readFileSync(file, \"utf-8\"));\n}\n\n/**\n * Normalize windows paths to be posix-like.\n */\nexport function normalPath(path: string) {\n  if (process.platform === \"win32\") {\n    return (\n      path\n        // force posix path separator\n        .replace(/\\\\+/g, \"/\")\n    );\n  } else {\n    return path;\n  }\n}\n\n/**\n * Just a helpful wrapper around `execFile` that returns a promise.\n */\nexport async function runCommand(\n  cmd: string,\n  args: string[],\n  options?: ExecFileOptions\n): Promise<any> {\n  const { stdout } = await execFilePromise(cmd, args, options);\n  return stdout;\n}\n\n/**\n * Just a helpful wrapper around `exec` that returns a promise.\n * This will run commands through the shell, while `runCommand` doesn't.\n */\nexport async function shell(\n  cmd: string,\n  args: string[],\n  options?: ExecOptions\n): Promise<any> {\n  const { stdout } = await execPromise(cmd + \" \" + args.join(\" \"), options);\n  return stdout;\n}\n\nexport function isPath(s: string) {\n  s = normalPath(s);\n  return s.startsWith(\"./\") || s.startsWith(\"../\") || s.startsWith(\"/\");\n}\n","import { basename } from \"path\";\nimport { liftObject, LiftMap, INFLIGHT_INIT_METHOD_NAME } from \"./lifting\";\nimport {\n  AsyncFunction,\n  INFLIGHT_SYMBOL,\n  Inflight,\n  OperationsOf,\n} from \"./types\";\nimport { LiftableRecord, LiftedMap, PickNonFunctions } from \"./utility-types\";\nimport { normalPath } from \"../shared/misc\";\nimport type { IHostedLiftable, ImportInflightOptions } from \"../std/resource\";\n\nlet closureCount = 0;\n\nexport function closureId(): number {\n  return closureCount++;\n}\n\nexport type InflightBindings = Record<string, InflightBinding>;\n\n/**\n * An inflight binding.\n */\nexport interface InflightBinding {\n  /**\n   * The resource or capturable value.\n   */\n  readonly obj: any;\n\n  /**\n   * The list of operations used on the resource.\n   */\n  readonly ops?: string[];\n}\n\n/**\n * Utility class with functions about inflight clients.\n */\nexport class InflightClient {\n  /**\n   * Returns code for creating an inflight client.\n   */\n  public static for(\n    dirname: string,\n    filename: string,\n    clientClass: string,\n    args: string[]\n  ): string {\n    const inflightDir = dirname;\n    const inflightFile = basename(filename).split(\".\")[0] + \".inflight\";\n    return `new (require(\"${normalPath(\n      `${inflightDir}/${inflightFile}`\n    )}\")).${clientClass}(${args.join(\", \")})`;\n  }\n\n  /**\n   * Returns code for implementing `_toInflightType()`.\n   */\n  public static forType(filename: string, clientClass: string): string {\n    return `require(\"${normalPath(filename)}\").${clientClass}`;\n  }\n\n  private constructor() {}\n}\n\n/**\n * Prepares preflight objects for use in inflight functions.\n *\n * Conventionally, this is used by passing in a `const` object to bind it with the same name\n *\n * ```ts\n * const bucket = new cloud.Bucket(app, \"Bucket\");\n * const number = 5;\n *\n * lift({ bucket, number })\n *   .inflight(({ bucket, number }) => { ... }))\n * ```\n *\n * However, the name is not required to match the variable in the current scope.\n *\n * This is especially useful/necessary when lifting data via a reference or some other expression\n *\n * ```ts\n * const bucket = new cloud.Bucket(app, \"Bucket\");\n *\n * lift({ bkt: bucket, sum: 2 + 2, field: bucket.field })\n *   .inflight(({ bkt, sum, field }) => { ... }))\n * ```\n */\nexport function lift<TToLift extends LiftableRecord>(\n  captures: TToLift\n): Lifter<LiftedMap<TToLift>, {}> {\n  return new Lifter().lift(captures);\n}\n\n/**\n * Creates a inflight function.\n *\n * This function must not reference any variables outside of its scope.\n * If needed, use `lift` to bind variables to the scope of the function.\n *\n * Built-in NodeJS globals are available, such as `console` and `process`.\n * @wing inflight\n */\nexport function inflight<TFunction extends AsyncFunction>(\n  fn: (ctx: {}, ...args: Parameters<TFunction>) => ReturnType<TFunction>\n) {\n  return new Lifter().inflight(fn);\n}\n\n/**\n * Create an inflight function from a string.\n */\nexport function importInflight(\n  /**\n   * Raw JavaScript to use as the inflight function.\n   */\n  inflightText: string,\n\n  /**\n   * The lifts the JS needs to be able to access.\n   */\n  lifts?: ImportInflightOptions[\"lifts\"]\n) {\n  const newLifts: Record<string, any> = {};\n  const newGrants: Record<string, string[]> = {};\n\n  // convert the lifts to the correct format for the Lifter\n  for (const liftAnnotation of lifts ?? []) {\n    if (liftAnnotation.alias === undefined) {\n      throw new Error(\"The alias field is required for all lifts\");\n    }\n\n    newLifts[liftAnnotation.alias] = liftAnnotation.obj;\n    if (liftAnnotation.ops) {\n      newGrants[liftAnnotation.alias] = liftAnnotation.ops;\n    }\n  }\n\n  return (\n    lift(newLifts)\n      .grant(newGrants)\n      // cast as any because the inflight has already been pre-serialized\n      .inflight(inflightText as any)\n  );\n}\n\n/**\n * Manages the liftable objects and operations for an inflight function.\n */\nclass Lifter<\n  TLifted extends Record<string, any>,\n  TOperations extends Record<string, string[]>\n> {\n  constructor(\n    private lifts: LiftableRecord = {},\n    private grants: Record<string, string[]> = {}\n  ) {}\n\n  /**\n   * Add additional liftable objects to the scope of the inflight function.\n   * Any existing liftable objects with the same name will be overwritten.\n   *\n   * Conventionally, this is used by passing in a `const` object to bind it with the same name\n   *\n   * ```ts\n   * const bucket = new cloud.Bucket(app, \"Bucket\");\n   * const number = 5;\n   *\n   * lift({ bucket, number })\n   *   .inflight(({ bucket, number }) => { ... }))\n   * ```\n   *\n   * However, the name is not required to match the variable in the current scope.\n   *\n   * This is especially useful/necessary when lifting data via a reference or some other expression\n   *\n   * ```ts\n   * const bucket = new cloud.Bucket(app, \"Bucket\");\n   *\n   * lift({ bkt: bucket, sum: 2 + 2, field: bucket.field })\n   *   .inflight(({ bkt, sum, field }) => { ... }))\n   * ```\n   */\n  public lift<TWillLift extends LiftableRecord>(captures: TWillLift) {\n    return new Lifter<\n      Omit<TLifted, keyof TWillLift> & LiftedMap<TWillLift>,\n      TOperations\n    >(\n      {\n        ...this.lifts,\n        ...captures,\n      },\n      this.grants\n    );\n  }\n\n  /**\n   * Grant permissions for lifted resources.\n   *\n   * By default, all all possible methods are granted to lifted resources.\n   * This function restricts those:\n   *\n   * ```ts\n   * const bucket = new cloud.Bucket(app, \"Bucket\");\n   *\n   * lift({ bucket })\n   *   .grant({ bucket: [\"get\"] })\n   *   .inflight(({ bucket }) => {\n   *     await bucket.get(\"key\");\n   *     await bucket.set(\"key\", \"value\"); // Error: set is not granted\n   *   });\n   * ```\n   *\n   * fields are always accessible, even if not granted.\n   */\n  public grant<\n    TNewOps extends Partial<{\n      [K in keyof TLifted]: OperationsOf<TLifted[K]>;\n    }>\n  >(grants: TNewOps) {\n    return new Lifter<TLifted, Omit<TOperations, keyof TNewOps> & TNewOps>(\n      this.lifts,\n      {\n        ...this.grants,\n        ...grants,\n      }\n    );\n  }\n\n  /**\n   * Create an inflight function with the available lifted data.\n   *\n   * This function must not reference any variables outside of its scope.\n   * If needed, use `lift` again to bind variables to the scope of the function.\n   * Bound variables will be available as properties on the `ctx` object passed as the first argument to the function.\n   *\n   * Built-in NodeJS globals are available, such as `console` and `process`.\n   * @wing inflight\n   */\n  public inflight<TFunction extends AsyncFunction>(\n    fn: (\n      /** All lifted data available in this inflight */\n      ctx: // Get all the lifted types which were not explicitly granted\n      Omit<TLifted, keyof TOperations> & {\n        // For each of the granted types, get the lifted type with only the granted operations available (and any fields as well)\n        [K in keyof TOperations &\n          keyof TLifted]: TOperations[K] extends (infer TGrantedOps extends keyof TLifted[K])[]\n          ? PickNonFunctions<TLifted[K]> & Pick<TLifted[K], TGrantedOps>\n          : TLifted[K];\n      },\n      ...args: Parameters<TFunction>\n    ) => ReturnType<TFunction>\n  ): Inflight<TFunction> {\n    // This is a simplified version of the Wing compiler's _liftMap generation\n    // It specifies what transitive permissions need to be added based on what\n    // inflight methods are called on an object\n    // The SDK models inflight functions as objects with a \"handle\" property,\n    // so here we annotate that \"handle\" needs all of the required permissions\n    const _liftMap: LiftMap = { handle: [] };\n    for (const [key, obj] of Object.entries(this.lifts)) {\n      const knownOps =\n        this.grants[key] ??\n        Object.keys((obj as IHostedLiftable)._liftMap ?? {}).filter(\n          (x) => x !== INFLIGHT_INIT_METHOD_NAME // filter \"$inflight_init\"\n        );\n\n      _liftMap.handle.push([obj, knownOps]);\n    }\n\n    return {\n      _id: closureId(),\n      _toInflight: () => {\n        // Extremely advanced function serialization\n        const serializedFunction = fn.toString();\n\n        return `\\\n(await (async () => {\n  const $func = ${serializedFunction}\n  const $ctx = {\n  ${Object.entries(this.lifts)\n    .map(([name, liftable]) => `${name}: ${liftObject(liftable)}`)\n    .join(\",\\n\")}\n  };\n  let newFunction = async (...args) => {\n    return $func($ctx, ...args);\n  };\n  newFunction.handle = newFunction;\n  return newFunction;\n}\n)())`;\n      },\n      _liftMap,\n      // @ts-expect-error This function's type doesn't actually match, but it will just throw anyways\n      [INFLIGHT_SYMBOL]: () => {\n        throw new Error(\n          \"This is a inflight function and can only be invoked while inflight\"\n        );\n      },\n    };\n  }\n}\n","import { ILiftable } from \"./resource\";\nimport { InflightClient } from \"../core/inflight\";\nimport { normalPath } from \"../shared/misc\";\n\n/**\n * Interface that is used for setting Datetime date\n */\nexport interface DatetimeComponents {\n  /**\n   * Year\n   */\n  readonly year: number;\n  /**\n   * Month\n   */\n  readonly month: number;\n  /**\n   * Day\n   */\n  readonly day: number;\n  /**\n   * Hours\n   */\n  readonly hour: number;\n  /**\n   * Minutes\n   */\n  readonly min: number;\n  /**\n   * Seconds\n   */\n  readonly sec: number;\n  /**\n   * Milliseconds\n   */\n  readonly ms: number;\n  /**\n   *  Timezone offset in minutes from UTC\n   */\n  readonly tz: number;\n}\n\n/**\n * Represents a local or UTC date object\n * @wingType datetime\n */\nexport class Datetime implements ILiftable {\n  /**\n   * @internal\n   */\n  public static _toInflightType(): string {\n    return InflightClient.forType(__filename, this.name);\n  }\n  /**\n   * Create a Datetime from UTC timezone\n   *\n   * @returns a new `Datetime` from current time in UTC timezone\n   */\n  public static utcNow(): Datetime {\n    return new Datetime();\n  }\n\n  /**\n   * Create a Datetime from local system timezone\n   *\n   * @returns a new `Datetime` from current time in system timezone\n   */\n  public static systemNow(): Datetime {\n    const date = new Date();\n    date.setTime(date.getTime() - date.getTimezoneOffset() * 60 * 1000);\n\n    return new Datetime(date, date.getTimezoneOffset());\n  }\n\n  /**\n   * Create a Datetime from an ISO-8601 string\n   *\n   * @returns a new `Datetime` in UTC timezone\n   * @param iso ISO-8601 string\n   */\n  public static fromIso(iso: string): Datetime {\n    return new Datetime(new Date(iso));\n  }\n\n  /**\n   * Create a Datetime from a JavaScript Date object.\n   *\n   * @param date The JavaScript Date object.\n   * @returns a new `Datetime` instance.\n   */\n  public static fromDate(date: Date): Datetime {\n    return this.fromIso(date.toISOString());\n  }\n\n  /**\n   * Create a Datetime from Datetime components\n   *\n   * @param c DatetimeComponents\n   * @returns a new `Datetime`\n   */\n  public static fromComponents(c: DatetimeComponents): Datetime {\n    const date = new Date(\n      Date.UTC(c.year, c.month, c.day, c.hour, c.min, c.sec, c.ms)\n    );\n\n    return new Datetime(date, c.tz);\n  }\n\n  /** @internal */\n  private readonly _date: Date;\n  /** @internal */\n  private readonly _timezoneOffset: number = 0;\n\n  private constructor(date: Date = new Date(), timezoneOffset = 0) {\n    this._date = date;\n    this._timezoneOffset = timezoneOffset;\n  }\n\n  /** @internal */\n  public _toInflight(): string {\n    return `(require(\"${normalPath(\n      __filename\n    )}\").Datetime.fromIso(\"${this.toIso()}\"))`;\n  }\n\n  /**\n   * Return a timestamp of non-leap year seconds since epoch\n   *\n   * @returns a number representing the current timestamp in seconds\n   */\n  public get timestamp(): number {\n    return this.timestampMs / 1000;\n  }\n\n  /**\n   * Return a timestamp of non-leap year milliseconds since epoch\n   *\n   * @returns a number representing the current timestamp in milliseconds\n   */\n  public get timestampMs(): number {\n    // since converting between timezones/ declaring a date in a timezone other than the local or UTC\n    // isn't native to js, we keep the date in a UTC time, then retrieving back the the original timestamp,\n    // this way the date components (hours, month, day, minutes, etc..) are persistent\n    // and retrieved in the same order for all of the different constructing methods and the timestamp is correct.\n    return this._date.valueOf() + this._timezoneOffset * 60 * 1000;\n  }\n\n  /**\n   * Returns the hour of the local machine time or in utc\n   *\n   * @returns a number representing the datetime's hour\n   */\n  public get hours(): number {\n    return this._date.getUTCHours();\n  }\n\n  /**\n   * Returns the minute of the local machine time or in utc\n   *\n   * @returns a number representing the datetime's minute\n   */\n  public get min(): number {\n    return this._date.getUTCMinutes();\n  }\n\n  /**\n   * Returns the seconds of the local machine time or in utc\n   *\n   * @returns a number representing the datetime's seconds\n   */\n  public get sec(): number {\n    return this._date.getUTCSeconds();\n  }\n\n  /**\n   * Returns the milliseconds of the local machine time or in utc\n   *  *\n   * @returns a number representing the datetime's milliseconds\n   */\n  public get ms(): number {\n    return this._date.getUTCMilliseconds();\n  }\n\n  /**\n   * Returns the day of month in the local machine time or in utc (1 - 31)\n   *\n   * @returns a number representing the datetime's day of month\n   */\n  public get dayOfMonth(): number {\n    return this._date.getUTCDate();\n  }\n\n  /**\n   * Returns the day in month of the local machine time or in utc (0 - 6)\n   *\n   * @returns a number representing the datetime's day of week\n   */\n  public get dayOfWeek(): number {\n    return this._date.getUTCDay();\n  }\n\n  /**\n   * Returns the month of the local machine time or in utc (0 - 11)\n   *\n   * @returns a number representing the datetime's month\n   */\n  public get month(): number {\n    return this._date.getUTCMonth();\n  }\n\n  /**\n   * Returns the year of the local machine time or in utc\n   *\n   * @returns a number representing the datetime's year\n   */\n  public get year(): number {\n    return this._date.getUTCFullYear();\n  }\n\n  /**\n   * Returns the offset in minutes from UTC\n   *\n   * @returns a number representing the datetime's offset in minutes from UTC\n   */\n  public get timezone(): number {\n    return this._timezoneOffset;\n  }\n\n  /**\n   * Returns a Datetime represents the same date in utc\n   *\n   * @returns a datetime representing the datetime's date in UTC\n   */\n  public toUtc(): Datetime {\n    return new Datetime(new Date(this.timestampMs));\n  }\n\n  /**\n   * Returns ISO-8601 string\n   *\n   * @returns a ISO-8601 string representation of the datetime\n   */\n  public toIso(): string {\n    return new Date(this.timestampMs).toISOString();\n  }\n}\n","// TODO: more robust serialization scheme\n\nimport { Datetime } from \"../std/datetime\";\n\nexport function serialize(input: any): string {\n  return JSON.stringify(input, (_key, value) => {\n    if (value instanceof Datetime) {\n      return {\n        $kind: \"datetime\",\n        day: value.dayOfMonth,\n        hour: value.hours,\n        min: value.min,\n        month: value.month,\n        sec: value.sec,\n        year: value.year,\n        ms: value.ms,\n        tz: value.timezone,\n      };\n    }\n    return value;\n  });\n}\n\nexport function deserialize(input: string): any {\n  return JSON.parse(input, (_key, value) => {\n    // assumption: Wing APIs don't distinguish between null and undefined, so we can swap them\n    if (value === null) {\n      return undefined;\n    }\n    if (value.$kind === \"datetime\") {\n      return Datetime.fromComponents({\n        day: value.day,\n        hour: value.hour,\n        min: value.min,\n        month: value.month,\n        sec: value.sec,\n        year: value.year,\n        ms: value.ms,\n        tz: value.tz,\n      });\n    }\n    return value;\n  });\n}\n","import * as http from \"http\";\nimport { deserialize } from \"./serialization\";\nimport type {\n  SimulatorServerRequest,\n  SimulatorServerResponse,\n} from \"./simulator\";\n\ninterface HttpRequestOptions extends http.RequestOptions {\n  body?: string;\n}\n\nfunction makeHttpRequest(options: HttpRequestOptions): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const req = http.request(options, (res) => {\n      let data = \"\";\n\n      res.on(\"data\", (chunk) => {\n        data += chunk;\n      });\n\n      res.on(\"end\", () => {\n        resolve(data);\n      });\n    });\n\n    req.on(\"error\", (e) => {\n      reject(e);\n    });\n\n    if (options.body !== undefined) {\n      req.write(options.body);\n    }\n\n    req.end();\n  });\n}\n\n/**\n * Creates a proxy object that forwards method calls to the simulator server.\n *\n * @param url The URL of the simulator server\n * @param handle The handle for the resource we're calling methods on or getting properties from\n * @param caller The handle of the resource that is making the calls\n * @returns A proxy object that forwards calls to the simulator server\n */\nexport function makeSimulatorClient(\n  url: string,\n  handle: string,\n  caller: string\n) {\n  let proxy: any;\n  let hasThenMethod = true; // assume that the object has a \"then\" method until proven otherwise\n\n  const get = (_target: any, method: string, _receiver: any) => {\n    if (method === \"then\" && !hasThenMethod) {\n      return undefined;\n    }\n\n    return async function (...args: any[]) {\n      const body: SimulatorServerRequest = { caller, handle, method, args };\n      const parsedUrl = new URL(url);\n      const resp = await makeHttpRequest({\n        hostname: parsedUrl.hostname,\n        port: parsedUrl.port,\n        path: \"/v1/call\",\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(body),\n      });\n\n      let parsed: SimulatorServerResponse = deserialize(resp);\n\n      if (parsed.error) {\n        // objects with \"then\" methods are special-cased by the JS runtime\n        // because they are assumed to be promises, and can be awaited. [0]\n        // however, this client don't know ahead of time what methods are on the\n        // object, so we have to assume that it has a \"then\" method until\n        // we get an error back from the server saying that it doesn't.\n        //\n        // [0]: https://stackoverflow.com/questions/55262996/does-awaiting-a-non-promise-have-any-detectable-effect\n        if (\n          method === \"then\" &&\n          parsed.error?.message?.startsWith(\n            'Method \"then\" not found on resource'\n          )\n        ) {\n          hasThenMethod = false;\n          // args[0] is the onFulfilled callback passed to the then method.\n          // we call it with the proxy object so that that `await client`\n          // returns the proxy object back, as callers might expect.\n          return args[0](proxy);\n        }\n\n        let err = new Error();\n        err.message = parsed.error?.message;\n        err.name = parsed.error?.name;\n\n        if (parsed.error?.stack) {\n          // combine the stack trace from the server with the stack trace from the client\n          err.stack = `${parsed.error.stack}\\n${err.stack}`;\n        }\n\n        throw err;\n      }\n\n      return parsed.result;\n    };\n  };\n\n  proxy = new Proxy({}, { get });\n  return proxy;\n}\n","\"use strict\";\nvar $handler = undefined;\nexports.handler = async function(event) {\n  $handler = $handler ?? ((await (async () => {\n  const $func = async (ctx, event) => {\n            if (!event) {\n                throw new Error(\"invalid API request event\");\n            }\n            let req = JSON.parse(event);\n            const response = await ctx.handler(req);\n            if (!response) {\n                return undefined;\n            }\n            else {\n                return JSON.stringify(response);\n            }\n        }\n  const $ctx = {\n  handler: \n          (await (async () => {\n            const $Closure1Client = \n          require(\"/Users/pro-3ie-s/Desktop/educloud/bigmop2/backend/target/test/main.wsim/.wing/inflight.$Closure1-17.cjs\")({\n            $counter: (function() {\n  let handle = process.env.COUNTER_HANDLE_f9685446;\n  if (!handle) {\n    throw new Error(\"Missing environment variable: COUNTER_HANDLE_f9685446\");\n  }\n  const simulatorUrl = process.env.WING_SIMULATOR_URL;\n  if (!simulatorUrl) {\n    throw new Error(\"Missing environment variable: WING_SIMULATOR_URL\");\n  }\n  const caller = process.env.WING_SIMULATOR_CALLER;\n  if (!caller) {\n    throw new Error(\"Missing environment variable: WING_SIMULATOR_CALLER\");\n  }\n  const backend = require(\"@winglang/sdk/lib/simulator/client\").makeSimulatorClient(simulatorUrl, handle, caller);\n  const client = new Proxy(backend, {\n    get: function(target, prop, receiver) {\n      return async function(...args) {\n        return backend.call(prop, args);\n      };\n    },\n  });\n  return client;\n})(),\n          })\n        ;\n            const client = new $Closure1Client({\n            });\n            if (client.$inflight_init) { await client.$inflight_init(); }\n            return client;\n          })())\n        \n  };\n  let newFunction = async (...args) => {\n    return $func($ctx, ...args);\n  };\n  newFunction.handle = newFunction;\n  return newFunction;\n}\n)()));\n  return await $handler.handle(event);\n};\nprocess.on(\"uncaughtException\", (reason) => {\n  process.send({ type: \"error\", reason });\n});\n\nprocess.on(\"message\", async (message) => {\n  const { fn, args } = message;\n  const value = await exports[fn](...args);\n  process.send({ type: \"ok\", value });\n});\n"],"mappings":"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","names":["exports","exports","module","exports","exports","exports","Node","construct","exports","ConstructOrder","exports","exports","exports","exports","exports","path","exports","exports","normalPath","path","exports","dirname","exports","exports","__importStar","exports","event","client"]}